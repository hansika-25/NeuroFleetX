import { t as __commonJS } from "./chunk-DUEDWNxO.js";

//#region node_modules/mapbox-gl/dist/mapbox-gl.js
var require_mapbox_gl = /* @__PURE__ */ __commonJS({ "node_modules/mapbox-gl/dist/mapbox-gl.js": ((exports, module) => {
	(function(global, factory) {
		typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, global.mapboxgl = factory());
	})(exports, (function() {
		var shared, worker, mapboxgl;
		function define$1(_, chunk) {
			if (!shared) shared = chunk;
			else if (!worker) worker = chunk;
			else {
				var workerBundleString = "self.onerror = function() { console.error('An error occurred while parsing the WebWorker bundle. This is most likely due to improper transpilation by Babel; please see https://docs.mapbox.com/mapbox-gl-js/guides/install/#transpiling'); }; var sharedChunk = {}; (" + shared + ")(sharedChunk); (" + worker + ")(sharedChunk); self.onerror = null;";
				var sharedChunk = {};
				shared(sharedChunk);
				mapboxgl = chunk(sharedChunk);
				if (typeof window !== "undefined" && window && window.URL && window.URL.createObjectURL) mapboxgl.workerUrl = window.URL.createObjectURL(new Blob([workerBundleString], { type: "text/javascript" }));
			}
		}
		define$1(["exports"], (function(t) {
			var e = 1e-6, r = "undefined" != typeof Float32Array ? Float32Array : Array;
			function n(t$1, e$1) {
				var r$1 = e$1[0], n$1 = e$1[1], i$1 = e$1[2], s$1 = e$1[3], o$1 = r$1 * s$1 - i$1 * n$1;
				return o$1 ? (t$1[0] = s$1 * (o$1 = 1 / o$1), t$1[1] = -n$1 * o$1, t$1[2] = -i$1 * o$1, t$1[3] = r$1 * o$1, t$1) : null;
			}
			function i() {
				var t$1 = new r(9);
				return r != Float32Array && (t$1[1] = 0, t$1[2] = 0, t$1[3] = 0, t$1[5] = 0, t$1[6] = 0, t$1[7] = 0), t$1[0] = 1, t$1[4] = 1, t$1[8] = 1, t$1;
			}
			function s(t$1, e$1) {
				var r$1 = e$1[0], n$1 = e$1[1], i$1 = e$1[2], s$1 = e$1[3], o$1 = e$1[4], a$1 = e$1[5], l$1 = e$1[6], u$1 = e$1[7], c$1 = e$1[8];
				return t$1[0] = o$1 * c$1 - a$1 * u$1, t$1[1] = i$1 * u$1 - n$1 * c$1, t$1[2] = n$1 * a$1 - i$1 * o$1, t$1[3] = a$1 * l$1 - s$1 * c$1, t$1[4] = r$1 * c$1 - i$1 * l$1, t$1[5] = i$1 * s$1 - r$1 * a$1, t$1[6] = s$1 * u$1 - o$1 * l$1, t$1[7] = n$1 * l$1 - r$1 * u$1, t$1[8] = r$1 * o$1 - n$1 * s$1, t$1;
			}
			function o(t$1, e$1, r$1) {
				var n$1 = e$1[0], i$1 = e$1[1], s$1 = e$1[2], o$1 = e$1[3], a$1 = e$1[4], l$1 = e$1[5], u$1 = e$1[6], c$1 = e$1[7], h$1 = e$1[8], p$1 = r$1[0], d$1 = r$1[1], f$1 = r$1[2], m$1 = r$1[3], y$1 = r$1[4], g$1 = r$1[5], x$1 = r$1[6], v$1 = r$1[7], b$1 = r$1[8];
				return t$1[0] = p$1 * n$1 + d$1 * o$1 + f$1 * u$1, t$1[1] = p$1 * i$1 + d$1 * a$1 + f$1 * c$1, t$1[2] = p$1 * s$1 + d$1 * l$1 + f$1 * h$1, t$1[3] = m$1 * n$1 + y$1 * o$1 + g$1 * u$1, t$1[4] = m$1 * i$1 + y$1 * a$1 + g$1 * c$1, t$1[5] = m$1 * s$1 + y$1 * l$1 + g$1 * h$1, t$1[6] = x$1 * n$1 + v$1 * o$1 + b$1 * u$1, t$1[7] = x$1 * i$1 + v$1 * a$1 + b$1 * c$1, t$1[8] = x$1 * s$1 + v$1 * l$1 + b$1 * h$1, t$1;
			}
			function a() {
				var t$1 = new r(16);
				return r != Float32Array && (t$1[1] = 0, t$1[2] = 0, t$1[3] = 0, t$1[4] = 0, t$1[6] = 0, t$1[7] = 0, t$1[8] = 0, t$1[9] = 0, t$1[11] = 0, t$1[12] = 0, t$1[13] = 0, t$1[14] = 0), t$1[0] = 1, t$1[5] = 1, t$1[10] = 1, t$1[15] = 1, t$1;
			}
			function l(t$1) {
				var e$1 = new r(16);
				return e$1[0] = t$1[0], e$1[1] = t$1[1], e$1[2] = t$1[2], e$1[3] = t$1[3], e$1[4] = t$1[4], e$1[5] = t$1[5], e$1[6] = t$1[6], e$1[7] = t$1[7], e$1[8] = t$1[8], e$1[9] = t$1[9], e$1[10] = t$1[10], e$1[11] = t$1[11], e$1[12] = t$1[12], e$1[13] = t$1[13], e$1[14] = t$1[14], e$1[15] = t$1[15], e$1;
			}
			function u(t$1) {
				return t$1[0] = 1, t$1[1] = 0, t$1[2] = 0, t$1[3] = 0, t$1[4] = 0, t$1[5] = 1, t$1[6] = 0, t$1[7] = 0, t$1[8] = 0, t$1[9] = 0, t$1[10] = 1, t$1[11] = 0, t$1[12] = 0, t$1[13] = 0, t$1[14] = 0, t$1[15] = 1, t$1;
			}
			function c(t$1, e$1) {
				var r$1 = e$1[0], n$1 = e$1[1], i$1 = e$1[2], s$1 = e$1[3], o$1 = e$1[4], a$1 = e$1[5], l$1 = e$1[6], u$1 = e$1[7], c$1 = e$1[8], h$1 = e$1[9], p$1 = e$1[10], d$1 = e$1[11], f$1 = e$1[12], m$1 = e$1[13], y$1 = e$1[14], g$1 = e$1[15], x$1 = r$1 * a$1 - n$1 * o$1, v$1 = r$1 * l$1 - i$1 * o$1, b$1 = r$1 * u$1 - s$1 * o$1, w$1 = n$1 * l$1 - i$1 * a$1, _$1 = n$1 * u$1 - s$1 * a$1, A$1 = i$1 * u$1 - s$1 * l$1, I$1 = c$1 * m$1 - h$1 * f$1, M$1 = c$1 * y$1 - p$1 * f$1, S$1 = c$1 * g$1 - d$1 * f$1, P$1 = h$1 * y$1 - p$1 * m$1, k$1 = h$1 * g$1 - d$1 * m$1, B$1 = p$1 * g$1 - d$1 * y$1, z$1 = x$1 * B$1 - v$1 * k$1 + b$1 * P$1 + w$1 * S$1 - _$1 * M$1 + A$1 * I$1;
				return z$1 ? (t$1[0] = (a$1 * B$1 - l$1 * k$1 + u$1 * P$1) * (z$1 = 1 / z$1), t$1[1] = (i$1 * k$1 - n$1 * B$1 - s$1 * P$1) * z$1, t$1[2] = (m$1 * A$1 - y$1 * _$1 + g$1 * w$1) * z$1, t$1[3] = (p$1 * _$1 - h$1 * A$1 - d$1 * w$1) * z$1, t$1[4] = (l$1 * S$1 - o$1 * B$1 - u$1 * M$1) * z$1, t$1[5] = (r$1 * B$1 - i$1 * S$1 + s$1 * M$1) * z$1, t$1[6] = (y$1 * b$1 - f$1 * A$1 - g$1 * v$1) * z$1, t$1[7] = (c$1 * A$1 - p$1 * b$1 + d$1 * v$1) * z$1, t$1[8] = (o$1 * k$1 - a$1 * S$1 + u$1 * I$1) * z$1, t$1[9] = (n$1 * S$1 - r$1 * k$1 - s$1 * I$1) * z$1, t$1[10] = (f$1 * _$1 - m$1 * b$1 + g$1 * x$1) * z$1, t$1[11] = (h$1 * b$1 - c$1 * _$1 - d$1 * x$1) * z$1, t$1[12] = (a$1 * M$1 - o$1 * P$1 - l$1 * I$1) * z$1, t$1[13] = (r$1 * P$1 - n$1 * M$1 + i$1 * I$1) * z$1, t$1[14] = (m$1 * v$1 - f$1 * w$1 - y$1 * x$1) * z$1, t$1[15] = (c$1 * w$1 - h$1 * v$1 + p$1 * x$1) * z$1, t$1) : null;
			}
			function h(t$1, e$1, r$1) {
				var n$1 = e$1[0], i$1 = e$1[1], s$1 = e$1[2], o$1 = e$1[3], a$1 = e$1[4], l$1 = e$1[5], u$1 = e$1[6], c$1 = e$1[7], h$1 = e$1[8], p$1 = e$1[9], d$1 = e$1[10], f$1 = e$1[11], m$1 = e$1[12], y$1 = e$1[13], g$1 = e$1[14], x$1 = e$1[15], v$1 = r$1[0], b$1 = r$1[1], w$1 = r$1[2], _$1 = r$1[3];
				return t$1[0] = v$1 * n$1 + b$1 * a$1 + w$1 * h$1 + _$1 * m$1, t$1[1] = v$1 * i$1 + b$1 * l$1 + w$1 * p$1 + _$1 * y$1, t$1[2] = v$1 * s$1 + b$1 * u$1 + w$1 * d$1 + _$1 * g$1, t$1[3] = v$1 * o$1 + b$1 * c$1 + w$1 * f$1 + _$1 * x$1, t$1[4] = (v$1 = r$1[4]) * n$1 + (b$1 = r$1[5]) * a$1 + (w$1 = r$1[6]) * h$1 + (_$1 = r$1[7]) * m$1, t$1[5] = v$1 * i$1 + b$1 * l$1 + w$1 * p$1 + _$1 * y$1, t$1[6] = v$1 * s$1 + b$1 * u$1 + w$1 * d$1 + _$1 * g$1, t$1[7] = v$1 * o$1 + b$1 * c$1 + w$1 * f$1 + _$1 * x$1, t$1[8] = (v$1 = r$1[8]) * n$1 + (b$1 = r$1[9]) * a$1 + (w$1 = r$1[10]) * h$1 + (_$1 = r$1[11]) * m$1, t$1[9] = v$1 * i$1 + b$1 * l$1 + w$1 * p$1 + _$1 * y$1, t$1[10] = v$1 * s$1 + b$1 * u$1 + w$1 * d$1 + _$1 * g$1, t$1[11] = v$1 * o$1 + b$1 * c$1 + w$1 * f$1 + _$1 * x$1, t$1[12] = (v$1 = r$1[12]) * n$1 + (b$1 = r$1[13]) * a$1 + (w$1 = r$1[14]) * h$1 + (_$1 = r$1[15]) * m$1, t$1[13] = v$1 * i$1 + b$1 * l$1 + w$1 * p$1 + _$1 * y$1, t$1[14] = v$1 * s$1 + b$1 * u$1 + w$1 * d$1 + _$1 * g$1, t$1[15] = v$1 * o$1 + b$1 * c$1 + w$1 * f$1 + _$1 * x$1, t$1;
			}
			function p(t$1, e$1, r$1) {
				var n$1, i$1, s$1, o$1, a$1, l$1, u$1, c$1, h$1, p$1, d$1, f$1, m$1 = r$1[0], y$1 = r$1[1], g$1 = r$1[2];
				return e$1 === t$1 ? (t$1[12] = e$1[0] * m$1 + e$1[4] * y$1 + e$1[8] * g$1 + e$1[12], t$1[13] = e$1[1] * m$1 + e$1[5] * y$1 + e$1[9] * g$1 + e$1[13], t$1[14] = e$1[2] * m$1 + e$1[6] * y$1 + e$1[10] * g$1 + e$1[14], t$1[15] = e$1[3] * m$1 + e$1[7] * y$1 + e$1[11] * g$1 + e$1[15]) : (i$1 = e$1[1], s$1 = e$1[2], o$1 = e$1[3], a$1 = e$1[4], l$1 = e$1[5], u$1 = e$1[6], c$1 = e$1[7], h$1 = e$1[8], p$1 = e$1[9], d$1 = e$1[10], f$1 = e$1[11], t$1[0] = n$1 = e$1[0], t$1[1] = i$1, t$1[2] = s$1, t$1[3] = o$1, t$1[4] = a$1, t$1[5] = l$1, t$1[6] = u$1, t$1[7] = c$1, t$1[8] = h$1, t$1[9] = p$1, t$1[10] = d$1, t$1[11] = f$1, t$1[12] = n$1 * m$1 + a$1 * y$1 + h$1 * g$1 + e$1[12], t$1[13] = i$1 * m$1 + l$1 * y$1 + p$1 * g$1 + e$1[13], t$1[14] = s$1 * m$1 + u$1 * y$1 + d$1 * g$1 + e$1[14], t$1[15] = o$1 * m$1 + c$1 * y$1 + f$1 * g$1 + e$1[15]), t$1;
			}
			function d(t$1, e$1, r$1) {
				var n$1 = r$1[0], i$1 = r$1[1], s$1 = r$1[2];
				return t$1[0] = e$1[0] * n$1, t$1[1] = e$1[1] * n$1, t$1[2] = e$1[2] * n$1, t$1[3] = e$1[3] * n$1, t$1[4] = e$1[4] * i$1, t$1[5] = e$1[5] * i$1, t$1[6] = e$1[6] * i$1, t$1[7] = e$1[7] * i$1, t$1[8] = e$1[8] * s$1, t$1[9] = e$1[9] * s$1, t$1[10] = e$1[10] * s$1, t$1[11] = e$1[11] * s$1, t$1[12] = e$1[12], t$1[13] = e$1[13], t$1[14] = e$1[14], t$1[15] = e$1[15], t$1;
			}
			function f(t$1, e$1, r$1) {
				var n$1 = Math.sin(r$1), i$1 = Math.cos(r$1), s$1 = e$1[4], o$1 = e$1[5], a$1 = e$1[6], l$1 = e$1[7], u$1 = e$1[8], c$1 = e$1[9], h$1 = e$1[10], p$1 = e$1[11];
				return e$1 !== t$1 && (t$1[0] = e$1[0], t$1[1] = e$1[1], t$1[2] = e$1[2], t$1[3] = e$1[3], t$1[12] = e$1[12], t$1[13] = e$1[13], t$1[14] = e$1[14], t$1[15] = e$1[15]), t$1[4] = s$1 * i$1 + u$1 * n$1, t$1[5] = o$1 * i$1 + c$1 * n$1, t$1[6] = a$1 * i$1 + h$1 * n$1, t$1[7] = l$1 * i$1 + p$1 * n$1, t$1[8] = u$1 * i$1 - s$1 * n$1, t$1[9] = c$1 * i$1 - o$1 * n$1, t$1[10] = h$1 * i$1 - a$1 * n$1, t$1[11] = p$1 * i$1 - l$1 * n$1, t$1;
			}
			function m(t$1, e$1, r$1) {
				var n$1 = Math.sin(r$1), i$1 = Math.cos(r$1), s$1 = e$1[0], o$1 = e$1[1], a$1 = e$1[2], l$1 = e$1[3], u$1 = e$1[8], c$1 = e$1[9], h$1 = e$1[10], p$1 = e$1[11];
				return e$1 !== t$1 && (t$1[4] = e$1[4], t$1[5] = e$1[5], t$1[6] = e$1[6], t$1[7] = e$1[7], t$1[12] = e$1[12], t$1[13] = e$1[13], t$1[14] = e$1[14], t$1[15] = e$1[15]), t$1[0] = s$1 * i$1 - u$1 * n$1, t$1[1] = o$1 * i$1 - c$1 * n$1, t$1[2] = a$1 * i$1 - h$1 * n$1, t$1[3] = l$1 * i$1 - p$1 * n$1, t$1[8] = s$1 * n$1 + u$1 * i$1, t$1[9] = o$1 * n$1 + c$1 * i$1, t$1[10] = a$1 * n$1 + h$1 * i$1, t$1[11] = l$1 * n$1 + p$1 * i$1, t$1;
			}
			function y(t$1, e$1, r$1) {
				var n$1 = Math.sin(r$1), i$1 = Math.cos(r$1), s$1 = e$1[0], o$1 = e$1[1], a$1 = e$1[2], l$1 = e$1[3], u$1 = e$1[4], c$1 = e$1[5], h$1 = e$1[6], p$1 = e$1[7];
				return e$1 !== t$1 && (t$1[8] = e$1[8], t$1[9] = e$1[9], t$1[10] = e$1[10], t$1[11] = e$1[11], t$1[12] = e$1[12], t$1[13] = e$1[13], t$1[14] = e$1[14], t$1[15] = e$1[15]), t$1[0] = s$1 * i$1 + u$1 * n$1, t$1[1] = o$1 * i$1 + c$1 * n$1, t$1[2] = a$1 * i$1 + h$1 * n$1, t$1[3] = l$1 * i$1 + p$1 * n$1, t$1[4] = u$1 * i$1 - s$1 * n$1, t$1[5] = c$1 * i$1 - o$1 * n$1, t$1[6] = h$1 * i$1 - a$1 * n$1, t$1[7] = p$1 * i$1 - l$1 * n$1, t$1;
			}
			function g(t$1, e$1) {
				return t$1[0] = e$1[0], t$1[1] = 0, t$1[2] = 0, t$1[3] = 0, t$1[4] = 0, t$1[5] = e$1[1], t$1[6] = 0, t$1[7] = 0, t$1[8] = 0, t$1[9] = 0, t$1[10] = e$1[2], t$1[11] = 0, t$1[12] = 0, t$1[13] = 0, t$1[14] = 0, t$1[15] = 1, t$1;
			}
			function x(t$1, r$1, n$1) {
				var i$1, s$1, o$1, a$1 = n$1[0], l$1 = n$1[1], u$1 = n$1[2], c$1 = Math.sqrt(a$1 * a$1 + l$1 * l$1 + u$1 * u$1);
				return c$1 < e ? null : (a$1 *= c$1 = 1 / c$1, l$1 *= c$1, u$1 *= c$1, i$1 = Math.sin(r$1), s$1 = Math.cos(r$1), t$1[0] = a$1 * a$1 * (o$1 = 1 - s$1) + s$1, t$1[1] = l$1 * a$1 * o$1 + u$1 * i$1, t$1[2] = u$1 * a$1 * o$1 - l$1 * i$1, t$1[3] = 0, t$1[4] = a$1 * l$1 * o$1 - u$1 * i$1, t$1[5] = l$1 * l$1 * o$1 + s$1, t$1[6] = u$1 * l$1 * o$1 + a$1 * i$1, t$1[7] = 0, t$1[8] = a$1 * u$1 * o$1 + l$1 * i$1, t$1[9] = l$1 * u$1 * o$1 - a$1 * i$1, t$1[10] = u$1 * u$1 * o$1 + s$1, t$1[11] = 0, t$1[12] = 0, t$1[13] = 0, t$1[14] = 0, t$1[15] = 1, t$1);
			}
			function v(t$1, e$1) {
				var r$1 = e$1[0], n$1 = e$1[1], i$1 = e$1[2], s$1 = e$1[4], o$1 = e$1[5], a$1 = e$1[6], l$1 = e$1[8], u$1 = e$1[9], c$1 = e$1[10];
				return t$1[0] = Math.sqrt(r$1 * r$1 + n$1 * n$1 + i$1 * i$1), t$1[1] = Math.sqrt(s$1 * s$1 + o$1 * o$1 + a$1 * a$1), t$1[2] = Math.sqrt(l$1 * l$1 + u$1 * u$1 + c$1 * c$1), t$1;
			}
			function b(t$1, e$1) {
				var r$1 = e$1[0], n$1 = e$1[1], i$1 = e$1[2], s$1 = e$1[3], o$1 = r$1 + r$1, a$1 = n$1 + n$1, l$1 = i$1 + i$1, u$1 = r$1 * o$1, c$1 = n$1 * o$1, h$1 = n$1 * a$1, p$1 = i$1 * o$1, d$1 = i$1 * a$1, f$1 = i$1 * l$1, m$1 = s$1 * o$1, y$1 = s$1 * a$1, g$1 = s$1 * l$1;
				return t$1[0] = 1 - h$1 - f$1, t$1[1] = c$1 + g$1, t$1[2] = p$1 - y$1, t$1[3] = 0, t$1[4] = c$1 - g$1, t$1[5] = 1 - u$1 - f$1, t$1[6] = d$1 + m$1, t$1[7] = 0, t$1[8] = p$1 + y$1, t$1[9] = d$1 - m$1, t$1[10] = 1 - u$1 - h$1, t$1[11] = 0, t$1[12] = 0, t$1[13] = 0, t$1[14] = 0, t$1[15] = 1, t$1;
			}
			var w = h;
			function _() {
				var t$1 = new r(3);
				return r != Float32Array && (t$1[0] = 0, t$1[1] = 0, t$1[2] = 0), t$1;
			}
			function A(t$1) {
				var e$1 = new r(3);
				return e$1[0] = t$1[0], e$1[1] = t$1[1], e$1[2] = t$1[2], e$1;
			}
			function I(t$1) {
				var e$1 = t$1[0], r$1 = t$1[1], n$1 = t$1[2];
				return Math.sqrt(e$1 * e$1 + r$1 * r$1 + n$1 * n$1);
			}
			function M(t$1, e$1, n$1) {
				var i$1 = new r(3);
				return i$1[0] = t$1, i$1[1] = e$1, i$1[2] = n$1, i$1;
			}
			function S(t$1, e$1, r$1, n$1) {
				return t$1[0] = e$1, t$1[1] = r$1, t$1[2] = n$1, t$1;
			}
			function P(t$1, e$1, r$1) {
				return t$1[0] = e$1[0] + r$1[0], t$1[1] = e$1[1] + r$1[1], t$1[2] = e$1[2] + r$1[2], t$1;
			}
			function k(t$1, e$1, r$1) {
				return t$1[0] = e$1[0] - r$1[0], t$1[1] = e$1[1] - r$1[1], t$1[2] = e$1[2] - r$1[2], t$1;
			}
			function B(t$1, e$1, r$1) {
				return t$1[0] = e$1[0] * r$1[0], t$1[1] = e$1[1] * r$1[1], t$1[2] = e$1[2] * r$1[2], t$1;
			}
			function z(t$1, e$1, r$1) {
				return t$1[0] = Math.min(e$1[0], r$1[0]), t$1[1] = Math.min(e$1[1], r$1[1]), t$1[2] = Math.min(e$1[2], r$1[2]), t$1;
			}
			function T(t$1, e$1, r$1) {
				return t$1[0] = Math.max(e$1[0], r$1[0]), t$1[1] = Math.max(e$1[1], r$1[1]), t$1[2] = Math.max(e$1[2], r$1[2]), t$1;
			}
			function E(t$1, e$1, r$1) {
				return t$1[0] = e$1[0] * r$1, t$1[1] = e$1[1] * r$1, t$1[2] = e$1[2] * r$1, t$1;
			}
			function V(t$1, e$1, r$1, n$1) {
				return t$1[0] = e$1[0] + r$1[0] * n$1, t$1[1] = e$1[1] + r$1[1] * n$1, t$1[2] = e$1[2] + r$1[2] * n$1, t$1;
			}
			function F(t$1, e$1) {
				var r$1 = e$1[0] - t$1[0], n$1 = e$1[1] - t$1[1], i$1 = e$1[2] - t$1[2];
				return Math.sqrt(r$1 * r$1 + n$1 * n$1 + i$1 * i$1);
			}
			function C(t$1, e$1) {
				var r$1 = e$1[0] - t$1[0], n$1 = e$1[1] - t$1[1], i$1 = e$1[2] - t$1[2];
				return r$1 * r$1 + n$1 * n$1 + i$1 * i$1;
			}
			function D(t$1) {
				var e$1 = t$1[0], r$1 = t$1[1], n$1 = t$1[2];
				return e$1 * e$1 + r$1 * r$1 + n$1 * n$1;
			}
			function R(t$1, e$1) {
				return t$1[0] = -e$1[0], t$1[1] = -e$1[1], t$1[2] = -e$1[2], t$1;
			}
			function L(t$1, e$1) {
				var r$1 = e$1[0], n$1 = e$1[1], i$1 = e$1[2], s$1 = r$1 * r$1 + n$1 * n$1 + i$1 * i$1;
				return s$1 > 0 && (s$1 = 1 / Math.sqrt(s$1)), t$1[0] = e$1[0] * s$1, t$1[1] = e$1[1] * s$1, t$1[2] = e$1[2] * s$1, t$1;
			}
			function O(t$1, e$1) {
				return t$1[0] * e$1[0] + t$1[1] * e$1[1] + t$1[2] * e$1[2];
			}
			function U(t$1, e$1, r$1) {
				var n$1 = e$1[0], i$1 = e$1[1], s$1 = e$1[2], o$1 = r$1[0], a$1 = r$1[1], l$1 = r$1[2];
				return t$1[0] = i$1 * l$1 - s$1 * a$1, t$1[1] = s$1 * o$1 - n$1 * l$1, t$1[2] = n$1 * a$1 - i$1 * o$1, t$1;
			}
			function N(t$1, e$1, r$1, n$1) {
				var i$1 = e$1[0], s$1 = e$1[1], o$1 = e$1[2];
				return t$1[0] = i$1 + n$1 * (r$1[0] - i$1), t$1[1] = s$1 + n$1 * (r$1[1] - s$1), t$1[2] = o$1 + n$1 * (r$1[2] - o$1), t$1;
			}
			function j(t$1, e$1, r$1) {
				var n$1 = e$1[0], i$1 = e$1[1], s$1 = e$1[2], o$1 = r$1[3] * n$1 + r$1[7] * i$1 + r$1[11] * s$1 + r$1[15];
				return t$1[0] = (r$1[0] * n$1 + r$1[4] * i$1 + r$1[8] * s$1 + r$1[12]) / (o$1 = o$1 || 1), t$1[1] = (r$1[1] * n$1 + r$1[5] * i$1 + r$1[9] * s$1 + r$1[13]) / o$1, t$1[2] = (r$1[2] * n$1 + r$1[6] * i$1 + r$1[10] * s$1 + r$1[14]) / o$1, t$1;
			}
			function $(t$1, e$1, r$1) {
				var n$1 = e$1[0], i$1 = e$1[1], s$1 = e$1[2];
				return t$1[0] = n$1 * r$1[0] + i$1 * r$1[3] + s$1 * r$1[6], t$1[1] = n$1 * r$1[1] + i$1 * r$1[4] + s$1 * r$1[7], t$1[2] = n$1 * r$1[2] + i$1 * r$1[5] + s$1 * r$1[8], t$1;
			}
			function G(t$1, e$1, r$1) {
				var n$1 = r$1[0], i$1 = r$1[1], s$1 = r$1[2], o$1 = r$1[3], a$1 = e$1[0], l$1 = e$1[1], u$1 = e$1[2], c$1 = i$1 * u$1 - s$1 * l$1, h$1 = s$1 * a$1 - n$1 * u$1, p$1 = n$1 * l$1 - i$1 * a$1;
				return t$1[0] = a$1 + o$1 * (c$1 += c$1) + i$1 * (p$1 += p$1) - s$1 * (h$1 += h$1), t$1[1] = l$1 + o$1 * h$1 + s$1 * c$1 - n$1 * p$1, t$1[2] = u$1 + o$1 * p$1 + n$1 * h$1 - i$1 * c$1, t$1;
			}
			function q(t$1) {
				return t$1[0] = 0, t$1[1] = 0, t$1[2] = 0, t$1;
			}
			function H(t$1, e$1) {
				return t$1[0] === e$1[0] && t$1[1] === e$1[1] && t$1[2] === e$1[2];
			}
			var X = k, Z = B, W = I;
			function Y() {
				var t$1 = new r(4);
				return r != Float32Array && (t$1[0] = 0, t$1[1] = 0, t$1[2] = 0, t$1[3] = 0), t$1;
			}
			function K(t$1, e$1, r$1) {
				return t$1[0] = e$1[0] * r$1, t$1[1] = e$1[1] * r$1, t$1[2] = e$1[2] * r$1, t$1[3] = e$1[3] * r$1, t$1;
			}
			function J(t$1, e$1) {
				var r$1 = e$1[0], n$1 = e$1[1], i$1 = e$1[2], s$1 = e$1[3], o$1 = r$1 * r$1 + n$1 * n$1 + i$1 * i$1 + s$1 * s$1;
				return o$1 > 0 && (o$1 = 1 / Math.sqrt(o$1)), t$1[0] = r$1 * o$1, t$1[1] = n$1 * o$1, t$1[2] = i$1 * o$1, t$1[3] = s$1 * o$1, t$1;
			}
			function Q(t$1, e$1, r$1) {
				var n$1 = e$1[0], i$1 = e$1[1], s$1 = e$1[2], o$1 = e$1[3];
				return t$1[0] = r$1[0] * n$1 + r$1[4] * i$1 + r$1[8] * s$1 + r$1[12] * o$1, t$1[1] = r$1[1] * n$1 + r$1[5] * i$1 + r$1[9] * s$1 + r$1[13] * o$1, t$1[2] = r$1[2] * n$1 + r$1[6] * i$1 + r$1[10] * s$1 + r$1[14] * o$1, t$1[3] = r$1[3] * n$1 + r$1[7] * i$1 + r$1[11] * s$1 + r$1[15] * o$1, t$1;
			}
			function tt() {
				var t$1 = new r(4);
				return r != Float32Array && (t$1[0] = 0, t$1[1] = 0, t$1[2] = 0), t$1[3] = 1, t$1;
			}
			function et(t$1) {
				return t$1[0] = 0, t$1[1] = 0, t$1[2] = 0, t$1[3] = 1, t$1;
			}
			function rt(t$1, e$1, r$1) {
				r$1 *= .5;
				var n$1 = e$1[0], i$1 = e$1[1], s$1 = e$1[2], o$1 = e$1[3], a$1 = Math.sin(r$1), l$1 = Math.cos(r$1);
				return t$1[0] = n$1 * l$1 + o$1 * a$1, t$1[1] = i$1 * l$1 + s$1 * a$1, t$1[2] = s$1 * l$1 - i$1 * a$1, t$1[3] = o$1 * l$1 - n$1 * a$1, t$1;
			}
			function nt(t$1, e$1, r$1) {
				r$1 *= .5;
				var n$1 = e$1[0], i$1 = e$1[1], s$1 = e$1[2], o$1 = e$1[3], a$1 = Math.sin(r$1), l$1 = Math.cos(r$1);
				return t$1[0] = n$1 * l$1 - s$1 * a$1, t$1[1] = i$1 * l$1 + o$1 * a$1, t$1[2] = s$1 * l$1 + n$1 * a$1, t$1[3] = o$1 * l$1 - i$1 * a$1, t$1;
			}
			_(), Y();
			var it, st, ot, at = J, lt = (it = _(), st = M(1, 0, 0), ot = M(0, 1, 0), function(t$1, e$1, r$1) {
				var n$1 = O(e$1, r$1);
				return n$1 < -.999999 ? (U(it, st, e$1), W(it) < 1e-6 && U(it, ot, e$1), L(it, it), function(t$2, e$2, r$2) {
					r$2 *= .5;
					var n$2 = Math.sin(r$2);
					t$2[0] = n$2 * e$2[0], t$2[1] = n$2 * e$2[1], t$2[2] = n$2 * e$2[2], t$2[3] = Math.cos(r$2);
				}(t$1, it, Math.PI), t$1) : n$1 > .999999 ? (t$1[0] = 0, t$1[1] = 0, t$1[2] = 0, t$1[3] = 1, t$1) : (U(it, e$1, r$1), t$1[0] = it[0], t$1[1] = it[1], t$1[2] = it[2], t$1[3] = 1 + n$1, at(t$1, t$1));
			});
			function ut() {
				var t$1 = new r(2);
				return r != Float32Array && (t$1[0] = 0, t$1[1] = 0), t$1;
			}
			function ct(t$1, e$1) {
				var n$1 = new r(2);
				return n$1[0] = t$1, n$1[1] = e$1, n$1;
			}
			function ht(t$1, e$1, r$1) {
				return t$1[0] = e$1, t$1[1] = r$1, t$1;
			}
			function pt(t$1, e$1, r$1) {
				return t$1[0] = e$1[0] + r$1[0], t$1[1] = e$1[1] + r$1[1], t$1;
			}
			function dt(t$1, e$1, r$1) {
				return t$1[0] = e$1[0] - r$1[0], t$1[1] = e$1[1] - r$1[1], t$1;
			}
			function ft(t$1, e$1, r$1) {
				return t$1[0] = e$1[0] * r$1, t$1[1] = e$1[1] * r$1, t$1;
			}
			function mt(t$1) {
				var e$1 = t$1[0], r$1 = t$1[1];
				return Math.sqrt(e$1 * e$1 + r$1 * r$1);
			}
			function yt(t$1, e$1) {
				var r$1 = e$1[0], n$1 = e$1[1], i$1 = r$1 * r$1 + n$1 * n$1;
				return i$1 > 0 && (i$1 = 1 / Math.sqrt(i$1)), t$1[0] = e$1[0] * i$1, t$1[1] = e$1[1] * i$1, t$1;
			}
			function gt(t$1, e$1) {
				return t$1[0] * e$1[0] + t$1[1] * e$1[1];
			}
			tt(), tt(), i();
			var xt, vt, bt = dt;
			function wt(t$1) {
				return t$1 && t$1.__esModule && Object.prototype.hasOwnProperty.call(t$1, "default") ? t$1.default : t$1;
			}
			ut();
			var At = wt(function() {
				if (vt) return xt;
				function t$1(t$2, e$1, r$1, n$1) {
					this.cx = 3 * t$2, this.bx = 3 * (r$1 - t$2) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * e$1, this.by = 3 * (n$1 - e$1) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t$2, this.p1y = e$1, this.p2x = r$1, this.p2y = n$1;
				}
				return vt = 1, xt = t$1, t$1.prototype = {
					sampleCurveX: function(t$2) {
						return ((this.ax * t$2 + this.bx) * t$2 + this.cx) * t$2;
					},
					sampleCurveY: function(t$2) {
						return ((this.ay * t$2 + this.by) * t$2 + this.cy) * t$2;
					},
					sampleCurveDerivativeX: function(t$2) {
						return (3 * this.ax * t$2 + 2 * this.bx) * t$2 + this.cx;
					},
					solveCurveX: function(t$2, e$1) {
						if (void 0 === e$1 && (e$1 = 1e-6), t$2 < 0) return 0;
						if (t$2 > 1) return 1;
						for (var r$1 = t$2, n$1 = 0; n$1 < 8; n$1++) {
							var i$1 = this.sampleCurveX(r$1) - t$2;
							if (Math.abs(i$1) < e$1) return r$1;
							var s$1 = this.sampleCurveDerivativeX(r$1);
							if (Math.abs(s$1) < 1e-6) break;
							r$1 -= i$1 / s$1;
						}
						var o$1 = 0, a$1 = 1;
						for (r$1 = t$2, n$1 = 0; n$1 < 20 && (i$1 = this.sampleCurveX(r$1), !(Math.abs(i$1 - t$2) < e$1)); n$1++) t$2 > i$1 ? o$1 = r$1 : a$1 = r$1, r$1 = .5 * (a$1 - o$1) + o$1;
						return r$1;
					},
					solve: function(t$2, e$1) {
						return this.sampleCurveY(this.solveCurveX(t$2, e$1));
					}
				}, xt;
			}());
			function It(t$1, e$1) {
				this.x = t$1, this.y = e$1;
			}
			function Mt(t$1, e$1) {
				if (Array.isArray(t$1)) {
					if (!Array.isArray(e$1) || t$1.length !== e$1.length) return !1;
					for (let r$1 = 0; r$1 < t$1.length; r$1++) if (!Mt(t$1[r$1], e$1[r$1])) return !1;
					return !0;
				}
				if ("object" == typeof t$1 && null !== t$1 && null !== e$1) {
					if ("object" != typeof e$1) return !1;
					if (Object.keys(t$1).length !== Object.keys(e$1).length) return !1;
					for (const r$1 in t$1) if (!Mt(t$1[r$1], e$1[r$1])) return !1;
					return !0;
				}
				return t$1 === e$1;
			}
			It.prototype = {
				clone() {
					return new It(this.x, this.y);
				},
				add(t$1) {
					return this.clone()._add(t$1);
				},
				sub(t$1) {
					return this.clone()._sub(t$1);
				},
				multByPoint(t$1) {
					return this.clone()._multByPoint(t$1);
				},
				divByPoint(t$1) {
					return this.clone()._divByPoint(t$1);
				},
				mult(t$1) {
					return this.clone()._mult(t$1);
				},
				div(t$1) {
					return this.clone()._div(t$1);
				},
				rotate(t$1) {
					return this.clone()._rotate(t$1);
				},
				rotateAround(t$1, e$1) {
					return this.clone()._rotateAround(t$1, e$1);
				},
				matMult(t$1) {
					return this.clone()._matMult(t$1);
				},
				unit() {
					return this.clone()._unit();
				},
				perp() {
					return this.clone()._perp();
				},
				round() {
					return this.clone()._round();
				},
				mag() {
					return Math.sqrt(this.x * this.x + this.y * this.y);
				},
				equals(t$1) {
					return this.x === t$1.x && this.y === t$1.y;
				},
				dist(t$1) {
					return Math.sqrt(this.distSqr(t$1));
				},
				distSqr(t$1) {
					const e$1 = t$1.x - this.x, r$1 = t$1.y - this.y;
					return e$1 * e$1 + r$1 * r$1;
				},
				angle() {
					return Math.atan2(this.y, this.x);
				},
				angleTo(t$1) {
					return Math.atan2(this.y - t$1.y, this.x - t$1.x);
				},
				angleWith(t$1) {
					return this.angleWithSep(t$1.x, t$1.y);
				},
				angleWithSep(t$1, e$1) {
					return Math.atan2(this.x * e$1 - this.y * t$1, this.x * t$1 + this.y * e$1);
				},
				_matMult(t$1) {
					const e$1 = t$1[2] * this.x + t$1[3] * this.y;
					return this.x = t$1[0] * this.x + t$1[1] * this.y, this.y = e$1, this;
				},
				_add(t$1) {
					return this.x += t$1.x, this.y += t$1.y, this;
				},
				_sub(t$1) {
					return this.x -= t$1.x, this.y -= t$1.y, this;
				},
				_mult(t$1) {
					return this.x *= t$1, this.y *= t$1, this;
				},
				_div(t$1) {
					return this.x /= t$1, this.y /= t$1, this;
				},
				_multByPoint(t$1) {
					return this.x *= t$1.x, this.y *= t$1.y, this;
				},
				_divByPoint(t$1) {
					return this.x /= t$1.x, this.y /= t$1.y, this;
				},
				_unit() {
					return this._div(this.mag()), this;
				},
				_perp() {
					const t$1 = this.y;
					return this.y = this.x, this.x = -t$1, this;
				},
				_rotate(t$1) {
					const e$1 = Math.cos(t$1), r$1 = Math.sin(t$1), n$1 = r$1 * this.x + e$1 * this.y;
					return this.x = e$1 * this.x - r$1 * this.y, this.y = n$1, this;
				},
				_rotateAround(t$1, e$1) {
					const r$1 = Math.cos(t$1), n$1 = Math.sin(t$1), i$1 = e$1.y + n$1 * (this.x - e$1.x) + r$1 * (this.y - e$1.y);
					return this.x = e$1.x + r$1 * (this.x - e$1.x) - n$1 * (this.y - e$1.y), this.y = i$1, this;
				},
				_round() {
					return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
				},
				constructor: It
			}, It.convert = function(t$1) {
				if (t$1 instanceof It) return t$1;
				if (Array.isArray(t$1)) return new It(+t$1[0], +t$1[1]);
				if (void 0 !== t$1.x && void 0 !== t$1.y) return new It(+t$1.x, +t$1.y);
				throw new Error("Expected [x, y] or {x, y} point format");
			};
			const St = Math.PI / 180, Pt = 180 / Math.PI;
			function kt(t$1) {
				return t$1 * St;
			}
			function Bt(t$1) {
				return t$1 * Pt;
			}
			const zt = [
				[0, 0],
				[1, 0],
				[1, 1],
				[0, 1]
			];
			function Tt(t$1) {
				if (t$1 <= 0) return 0;
				if (t$1 >= 1) return 1;
				const e$1 = t$1 * t$1, r$1 = e$1 * t$1;
				return 4 * (t$1 < .5 ? r$1 : 3 * (t$1 - e$1) + r$1 - .75);
			}
			function Et(t$1, e$1, r$1, n$1) {
				const i$1 = new At(t$1, e$1, r$1, n$1);
				return function(t$2) {
					return i$1.solve(t$2);
				};
			}
			const Vt = Et(.25, .1, .25, 1);
			function Ft(t$1, e$1, r$1) {
				return Math.min(r$1, Math.max(e$1, t$1));
			}
			function Ct(t$1, e$1, r$1) {
				return (r$1 = Ft((r$1 - t$1) / (e$1 - t$1), 0, 1)) * r$1 * (3 - 2 * r$1);
			}
			function Dt(t$1, e$1, r$1) {
				const n$1 = r$1 - e$1, i$1 = ((t$1 - e$1) % n$1 + n$1) % n$1 + e$1;
				return i$1 === e$1 ? r$1 : i$1;
			}
			function Rt(t$1, e$1, r$1) {
				if (!t$1.length) return r$1(null, []);
				let n$1 = t$1.length;
				const i$1 = new Array(t$1.length);
				let s$1 = null;
				t$1.forEach(((t$2, o$1) => {
					e$1(t$2, ((t$3, e$2) => {
						t$3 && (s$1 = t$3), i$1[o$1] = e$2, 0 == --n$1 && r$1(s$1, i$1);
					}));
				}));
			}
			let Lt = 1;
			function Ot() {
				return Lt++;
			}
			function Ut(t$1) {
				return t$1 <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log2(t$1)));
			}
			function Nt(t$1, e$1) {
				t$1.forEach(((t$2) => {
					e$1[t$2] && (e$1[t$2] = e$1[t$2].bind(e$1));
				}));
			}
			function jt(t$1, e$1, r$1) {
				const n$1 = {};
				for (const r$2 in t$1) n$1[r$2] = e$1.call(this, t$1[r$2], r$2, t$1);
				return n$1;
			}
			function $t(t$1, e$1, r$1) {
				const n$1 = {};
				for (const r$2 in t$1) e$1.call(this, t$1[r$2], r$2, t$1) && (n$1[r$2] = t$1[r$2]);
				return n$1;
			}
			function Gt(t$1) {
				return Array.isArray(t$1) ? t$1.map(Gt) : "object" == typeof t$1 && t$1 ? jt(t$1, Gt) : t$1;
			}
			function qt(t$1, e$1) {
				for (let r$1 = 0; r$1 < t$1.length; r$1++) if (e$1.indexOf(t$1[r$1]) >= 0) return !0;
				return !1;
			}
			const Ht = {};
			function Xt(t$1) {
				Ht[t$1] || ("undefined" != typeof console && console.warn(t$1), Ht[t$1] = !0);
			}
			function Zt(t$1, e$1, r$1) {
				return (r$1.y - t$1.y) * (e$1.x - t$1.x) > (e$1.y - t$1.y) * (r$1.x - t$1.x);
			}
			function Wt(t$1) {
				let e$1 = 0;
				for (let r$1, n$1, i$1 = 0, s$1 = t$1.length, o$1 = s$1 - 1; i$1 < s$1; o$1 = i$1++) r$1 = t$1[i$1], n$1 = t$1[o$1], e$1 += (n$1.x - r$1.x) * (r$1.y + n$1.y);
				return e$1;
			}
			function Yt([t$1, e$1, r$1]) {
				const n$1 = kt(e$1 + 90), i$1 = kt(r$1);
				return {
					x: t$1 * Math.cos(n$1) * Math.sin(i$1),
					y: t$1 * Math.sin(n$1) * Math.sin(i$1),
					z: t$1 * Math.cos(i$1),
					azimuthal: e$1,
					polar: r$1
				};
			}
			function Kt(t$1) {
				return ("undefined" != typeof self || void 0 !== t$1) && "undefined" != typeof WorkerGlobalScope && (void 0 !== t$1 ? t$1 : self) instanceof WorkerGlobalScope;
			}
			function Jt(t$1) {
				const e$1 = {};
				if (t$1.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, ((t$2, r$1, n$1, i$1) => {
					const s$1 = n$1 || i$1;
					return e$1[r$1] = !s$1 || s$1.toLowerCase(), "";
				})), e$1["max-age"]) {
					const t$2 = parseInt(e$1["max-age"], 10);
					isNaN(t$2) ? delete e$1["max-age"] : e$1["max-age"] = t$2;
				}
				return e$1;
			}
			let Qt = null;
			function te(t$1, e$1) {
				return [
					t$1[4 * e$1],
					t$1[4 * e$1 + 1],
					t$1[4 * e$1 + 2],
					t$1[4 * e$1 + 3]
				];
			}
			function ee(t$1, e$1, r$1, n$1) {
				for (; e$1 < r$1;) {
					const i$1 = e$1 + r$1 >> 1;
					t$1[i$1] < n$1 ? e$1 = i$1 + 1 : r$1 = i$1;
				}
				return e$1;
			}
			function re(t$1, e$1, r$1, n$1) {
				for (; e$1 < r$1;) {
					const i$1 = e$1 + r$1 >> 1;
					t$1[i$1] <= n$1 ? e$1 = i$1 + 1 : r$1 = i$1;
				}
				return e$1;
			}
			function ne(t$1) {
				return t$1 > 0 ? 1 / (1.001 - t$1) : 1 + t$1;
			}
			function ie(t$1) {
				return t$1 > 0 ? 1 - 1 / (1.001 - t$1) : -t$1;
			}
			function se(t$1, e$1, r$1) {
				return (t$1 - e$1.min) * (r$1.max - r$1.min) / (e$1.max - e$1.min) + r$1.min;
			}
			const oe = {
				API_URL: "https://api.mapbox.com",
				get API_URL_REGEX() {
					return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/|\?|$)/i;
				},
				get API_TILEJSON_REGEX() {
					return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/v[0-9]*\/.*\.json.*$)/i;
				},
				get API_SPRITE_REGEX() {
					return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/styles\/v[0-9]*\/)(.*\/sprite.*\..*$)/i;
				},
				get API_FONTS_REGEX() {
					return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/fonts\/v[0-9]*\/)(.*\.pbf.*$)/i;
				},
				get API_STYLE_REGEX() {
					return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/styles\/v[0-9]*\/)(.*$)/i;
				},
				get API_CDN_URL_REGEX() {
					return /^((https?:)?\/\/)?api\.mapbox\.c(n|om)(\/mapbox-gl-js\/)(.*$)/i;
				},
				get EVENTS_URL() {
					if (!oe.API_URL) return null;
					try {
						const t$1 = new URL(oe.API_URL);
						return "api.mapbox.cn" === t$1.hostname ? "https://events.mapbox.cn/events/v2" : "api.mapbox.com" === t$1.hostname ? "https://events.mapbox.com/events/v2" : null;
					} catch (t$1) {
						return null;
					}
				},
				SESSION_PATH: "/map-sessions/v1",
				FEEDBACK_URL: "https://apps.mapbox.com/feedback",
				TILE_URL_VERSION: "v4",
				RASTER_URL_PREFIX: "raster/v1",
				RASTERARRAYS_URL_PREFIX: "rasterarrays/v1",
				REQUIRE_ACCESS_TOKEN: !0,
				ACCESS_TOKEN: null,
				DEFAULT_STYLE: "mapbox://styles/mapbox/standard",
				MAX_PARALLEL_IMAGE_REQUESTS: 16,
				DRACO_URL: "https://api.mapbox.com/mapbox-gl-js/draco_decoder_gltf_v1.5.6.wasm",
				MESHOPT_URL: "https://api.mapbox.com/mapbox-gl-js/meshopt_base_v0.20.wasm",
				MESHOPT_SIMD_URL: "https://api.mapbox.com/mapbox-gl-js/meshopt_simd_v0.20.wasm",
				BUILDING_GEN_URL: "https://api.mapbox.com/mapbox-gl-js/building-gen/building_gen_v1.2.4.wasm",
				GLYPHS_URL: "mapbox://fonts/mapbox/{fontstack}/{range}.pbf",
				TILES3D_URL_PREFIX: "3dtiles/v1"
			};
			function ae(t$1) {
				return oe.API_URL_REGEX.test(t$1);
			}
			function le(t$1) {
				return oe.API_SPRITE_REGEX.test(t$1);
			}
			let ue, ce, he, pe, de, fe;
			function me() {
				return ue ??= self.OffscreenCanvas && new OffscreenCanvas(1, 1).getContext("2d") && "function" == typeof self.createImageBitmap, ue;
			}
			const ye = {
				now: () => void 0 !== pe ? pe : performance.now(),
				setNow(t$1) {
					pe = t$1;
				},
				restoreNow() {
					pe = void 0;
				},
				frame(t$1) {
					const e$1 = requestAnimationFrame(t$1);
					return { cancel: () => cancelAnimationFrame(e$1) };
				},
				getImageData(t$1, e$1 = 0) {
					const { width: r$1, height: n$1 } = t$1;
					de || (de = document.createElement("canvas"));
					const i$1 = de.getContext("2d", { willReadFrequently: !0 });
					if (!i$1) throw new Error("failed to create canvas 2d context");
					return (r$1 > de.width || n$1 > de.height) && (de.width = r$1, de.height = n$1), i$1.clearRect(-e$1, -e$1, r$1 + 2 * e$1, n$1 + 2 * e$1), i$1.drawImage(t$1, 0, 0, r$1, n$1), i$1.getImageData(-e$1, -e$1, r$1 + 2 * e$1, n$1 + 2 * e$1);
				},
				resolveURL: (t$1) => (ce || (ce = document.createElement("a")), ce.href = t$1, ce.href),
				get devicePixelRatio() {
					return window.devicePixelRatio;
				},
				get prefersReducedMotion() {
					return !!window.matchMedia && (he ??= window.matchMedia("(prefers-reduced-motion: reduce)"), he.matches);
				},
				hasCanvasFingerprintNoise() {
					if (void 0 !== fe) return fe;
					if (!me()) return fe = !1, !1;
					const t$1 = new OffscreenCanvas(85, 1), e$1 = t$1.getContext("2d", { willReadFrequently: !0 });
					let r$1 = 0;
					for (let n$2 = 0; n$2 < t$1.width; ++n$2) e$1.fillStyle = `rgba(${r$1++},${r$1++},${r$1++}, 255)`, e$1.fillRect(n$2, 0, 1, 1);
					const n$1 = e$1.getImageData(0, 0, t$1.width, t$1.height);
					r$1 = 0;
					for (let t$2 = 0; t$2 < n$1.data.length; ++t$2) if (t$2 % 4 != 3 && r$1++ !== n$1.data[t$2]) return fe = !0, !0;
					return fe = !1, !1;
				}
			};
			function ge(t$1, e$1) {
				const r$1 = t$1.indexOf("?");
				if (r$1 < 0) return `${t$1}?${new URLSearchParams(e$1).toString()}`;
				const n$1 = new URLSearchParams(t$1.slice(r$1));
				for (const t$2 in e$1) n$1.set(t$2, e$1[t$2]);
				return `${t$1.slice(0, r$1)}?${n$1.toString()}`;
			}
			function xe(t$1, e$1 = { persistentParams: [] }) {
				const r$1 = t$1.indexOf("?");
				if (r$1 < 0) return t$1;
				const n$1 = new URLSearchParams(), i$1 = new URLSearchParams(t$1.slice(r$1));
				for (const t$2 of e$1.persistentParams) {
					const e$2 = i$1.get(t$2);
					e$2 && n$1.set(t$2, e$2);
				}
				const s$1 = n$1.toString();
				return `${t$1.slice(0, r$1)}${s$1.length > 0 ? `?${s$1}` : ""}`;
			}
			const ve = "mapbox-tiles";
			let be = 500, we = 50;
			const _e = [
				"language",
				"worldview",
				"jobid"
			];
			let Ae, Ie;
			function Me() {
				try {
					return caches;
				} catch (t$1) {}
			}
			function Se() {
				const t$1 = Me();
				t$1 && null == Ae && (Ae = t$1.open(ve));
			}
			let Pe = Infinity;
			const ke = {
				supported: !1,
				testSupport: function(t$1) {
					!Te && ze && (Ee ? Fe(t$1) : Be = t$1);
				}
			};
			let Be, ze, Te = !1, Ee = !1;
			const Ve = "undefined" != typeof self ? self : {};
			function Fe(t$1) {
				const e$1 = t$1.createTexture();
				t$1.bindTexture(t$1.TEXTURE_2D, e$1);
				try {
					if (t$1.texImage2D(t$1.TEXTURE_2D, 0, t$1.RGBA, t$1.RGBA, t$1.UNSIGNED_BYTE, ze), t$1.isContextLost()) return;
					ke.supported = !0;
				} catch (t$2) {}
				t$1.deleteTexture(e$1), Te = !0;
			}
			Ve.document && (ze = Ve.document.createElement("img"), ze.onload = function() {
				Be && Fe(Be), Be = null, Ee = !0;
			}, ze.onerror = function() {
				Te = !0, Be = null;
			}, ze.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA=");
			const Ce = {
				Unknown: "Unknown",
				Style: "Style",
				Source: "Source",
				Tile: "Tile",
				Glyphs: "Glyphs",
				SpriteImage: "SpriteImage",
				SpriteJSON: "SpriteJSON",
				Iconset: "Iconset",
				Image: "Image",
				Model: "Model"
			};
			"function" == typeof Object.freeze && Object.freeze(Ce);
			class De extends Error {
				constructor(t$1, e$1, r$1) {
					401 === e$1 && ae(r$1) && (t$1 += ": you may have provided an invalid Mapbox access token. See https://docs.mapbox.com/api/overview/#access-tokens-and-token-scopes"), super(t$1), this.status = e$1, this.url = r$1;
				}
				toString() {
					return `${this.name}: ${this.message} (${this.status}): ${this.url}`;
				}
			}
			const Re = Kt() ? () => self.worker.referrer : () => ("blob:" === location.protocol ? parent : self).location.href;
			const Le = function(t$1, e$1) {
				if (!(/^file:/.test(r$1 = t$1.url) || /^file:/.test(Re()) && !/^\w+:/.test(r$1))) {
					if (self.fetch && self.Request && self.AbortController && Request.prototype.hasOwnProperty("signal")) return function(t$2, e$2) {
						const r$2 = new AbortController(), n$1 = new Request(t$2.url, {
							method: t$2.method || "GET",
							body: t$2.body,
							credentials: t$2.credentials,
							headers: t$2.headers,
							referrer: Re(),
							referrerPolicy: t$2.referrerPolicy,
							signal: r$2.signal
						});
						let i$1 = !1, s$1 = !1;
						const o$1 = (a$1 = n$1.url).indexOf("sku=") > 0 && ae(a$1);
						var a$1;
						"json" === t$2.type && n$1.headers.set("Accept", "application/json");
						const l$1 = (r$3, i$2, a$2) => {
							if (s$1) return;
							if (r$3 && "SecurityError" !== r$3.message && Xt(r$3.toString()), i$2 && a$2) return u$1(i$2);
							const l$2 = Date.now();
							fetch(n$1).then(((r$4) => {
								if (r$4.ok) return u$1(r$4, o$1 ? r$4.clone() : null, l$2);
								return e$2(new De(r$4.statusText, r$4.status, t$2.url));
							})).catch(((r$4) => {
								"AbortError" !== r$4.name && e$2(/* @__PURE__ */ new Error(`${r$4.message} ${t$2.url}`));
							}));
						}, u$1 = (r$3, o$2, a$2) => {
							("arrayBuffer" === t$2.type ? r$3.arrayBuffer() : "json" === t$2.type ? r$3.json() : r$3.text()).then(((t$3) => {
								s$1 || (o$2 && a$2 && function(t$4, e$3, r$4) {
									if (Se(), null == Ae) return;
									const n$2 = Jt(e$3.headers.get("Cache-Control") || "");
									if (n$2["no-store"]) return;
									const i$2 = {
										status: e$3.status,
										statusText: e$3.statusText,
										headers: new Headers()
									};
									e$3.headers.forEach(((t$5, e$4) => i$2.headers.set(e$4, t$5))), n$2["max-age"] && i$2.headers.set("Expires", new Date(r$4 + 1e3 * n$2["max-age"]).toUTCString());
									const s$2 = i$2.headers.get("Expires");
									if (!s$2) return;
									if (new Date(s$2).getTime() - r$4 < 42e4) return;
									let o$3 = xe(t$4.url, { persistentParams: _e });
									if (206 === e$3.status) {
										const e$4 = t$4.headers.get("Range");
										if (!e$4) return;
										i$2.status = 200, o$3 = ge(o$3, { range: e$4 });
									}
									(function(t$5, e$4) {
										if (void 0 === Ie) try {
											new Response(new ReadableStream()), Ie = !0;
										} catch (t$6) {
											Ie = !1;
										}
										Ie ? e$4(t$5.body) : t$5.blob().then(e$4).catch(((t$6) => Xt(t$6.message)));
									})(e$3, ((t$5) => {
										const r$5 = new Response(200 !== (n$3 = e$3.status) && 404 !== n$3 && [
											101,
											103,
											204,
											205,
											304
										].includes(n$3) ? null : t$5, i$2);
										var n$3;
										Se(), Ae?.then(((t$6) => t$6.put(o$3, r$5))).catch(((t$6) => Xt(t$6.message)));
									}));
								}(n$1, o$2, a$2), i$1 = !0, e$2(null, t$3, r$3.headers));
							})).catch(((t$3) => {
								s$1 || e$2(new Error(t$3.message));
							}));
						};
						return o$1 ? function(t$3, e$3) {
							if (Se(), null == Ae) return e$3(null);
							Ae.then(((r$3) => {
								let n$2 = xe(t$3.url, { persistentParams: _e });
								const i$2 = t$3.headers.get("Range");
								i$2 && (n$2 = ge(n$2, { range: i$2 })), r$3.match(n$2).then(((t$4) => {
									const i$3 = function(t$5) {
										if (!t$5) return !1;
										const e$4 = new Date(t$5.headers.get("Expires") || 0), r$4 = Jt(t$5.headers.get("Cache-Control") || "");
										return Number(e$4) > Date.now() && !r$4["no-cache"];
									}(t$4);
									r$3.delete(n$2).catch(e$3), i$3 && r$3.put(n$2, t$4.clone()).catch(e$3), e$3(null, t$4, i$3);
								})).catch(e$3);
							})).catch(e$3);
						}(n$1, l$1) : l$1(null, null), { cancel: () => {
							s$1 = !0, i$1 || r$2.abort();
						} };
					}(t$1, e$1);
					if (Kt(self) && self.worker.actor) return self.worker.actor.send("getResource", t$1, e$1, void 0, !0);
				}
				var r$1;
				return function(t$2, e$2) {
					const r$2 = new XMLHttpRequest();
					r$2.open(t$2.method || "GET", t$2.url, !0), "arrayBuffer" === t$2.type && (r$2.responseType = "arraybuffer");
					for (const e$3 in t$2.headers) r$2.setRequestHeader(e$3, t$2.headers[e$3]);
					return "json" === t$2.type && (r$2.responseType = "text", r$2.setRequestHeader("Accept", "application/json")), r$2.withCredentials = "include" === t$2.credentials, r$2.onerror = () => {
						e$2(new Error(r$2.statusText));
					}, r$2.onload = () => {
						if ((r$2.status >= 200 && r$2.status < 300 || 0 === r$2.status) && null !== r$2.response) {
							let n$1 = r$2.response;
							if ("json" === t$2.type) try {
								n$1 = JSON.parse(r$2.response);
							} catch (t$3) {
								return e$2(t$3);
							}
							const i$1 = new Headers();
							r$2.getAllResponseHeaders().trim().split(/[\r\n]+/).forEach(((t$3) => {
								const e$3 = t$3.split(": "), r$3 = e$3.shift(), n$2 = e$3.join(": ");
								i$1.append(r$3, n$2);
							})), e$2(null, n$1, i$1);
						} else e$2(new De(r$2.statusText, r$2.status, t$2.url));
					}, r$2.send(t$2.body), { cancel: () => r$2.abort() };
				}(t$1, e$1);
			}, Oe = function(t$1, e$1) {
				return Le(Object.assign(t$1, { type: "arrayBuffer" }), e$1);
			};
			function Ue(t$1) {
				const e$1 = document.createElement("a");
				return e$1.href = t$1, e$1.protocol === location.protocol && e$1.host === location.host;
			}
			const Ne = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
			let je, $e;
			je = [], $e = 0;
			const Ge = function(t$1, e$1) {
				if (ke.supported && (t$1.headers || (t$1.headers = {}), t$1.headers.accept = "image/webp,*/*"), $e >= oe.MAX_PARALLEL_IMAGE_REQUESTS) {
					const r$2 = {
						requestParameters: t$1,
						callback: e$1,
						cancelled: !1,
						cancel() {
							this.cancelled = !0;
						}
					};
					return je.push(r$2), r$2;
				}
				$e++;
				let r$1 = !1;
				const n$1 = () => {
					if (!r$1) for (r$1 = !0, $e--; je.length && $e < oe.MAX_PARALLEL_IMAGE_REQUESTS;) {
						const t$2 = je.shift(), { requestParameters: e$2, callback: r$2, cancelled: n$2 } = t$2;
						n$2 || (t$2.cancel = Ge(e$2, r$2).cancel);
					}
				}, i$1 = Oe(t$1, ((t$2, r$2, i$2) => {
					n$1(), t$2 ? e$1(t$2) : r$2 && (self.createImageBitmap ? function(t$3, e$2) {
						const r$3 = new Blob([new Uint8Array(t$3)], { type: "image/png" });
						createImageBitmap(r$3).then(((t$4) => {
							e$2(null, t$4);
						})).catch(((t$4) => {
							e$2(/* @__PURE__ */ new Error(`Could not load image because of ${t$4.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`));
						}));
					}(r$2, ((t$3, r$3) => e$1(t$3, r$3, i$2))) : function(t$3, e$2) {
						const r$3 = new Image();
						r$3.onload = () => {
							e$2(null, r$3), URL.revokeObjectURL(r$3.src), r$3.onload = null, requestAnimationFrame((() => {
								r$3.src = Ne;
							}));
						}, r$3.onerror = () => e$2(/* @__PURE__ */ new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
						const n$2 = new Blob([new Uint8Array(t$3)], { type: "image/png" });
						r$3.src = t$3.byteLength ? URL.createObjectURL(n$2) : Ne;
					}(r$2, ((t$3, r$3) => e$1(t$3, r$3, i$2))));
				}));
				return { cancel: () => {
					i$1.cancel(), n$1();
				} };
			};
			var qe, He, Xe, Ze = { exports: {} }, We = { exports: {} }, Ye = { exports: {} }, Je = wt(function() {
				if (Xe) return Ze.exports;
				Xe = 1;
				var t$1 = (qe || (qe = 1, We.exports = function(t$2, e$2) {
					var r$1, n$1, i$1, s$1, o$1, a$1, l$1, u$1;
					for (n$1 = t$2.length - (r$1 = 3 & t$2.length), i$1 = e$2, o$1 = 3432918353, a$1 = 461845907, u$1 = 0; u$1 < n$1;) l$1 = 255 & t$2.charCodeAt(u$1) | (255 & t$2.charCodeAt(++u$1)) << 8 | (255 & t$2.charCodeAt(++u$1)) << 16 | (255 & t$2.charCodeAt(++u$1)) << 24, ++u$1, i$1 = 27492 + (65535 & (s$1 = 5 * (65535 & (i$1 = (i$1 ^= l$1 = (65535 & (l$1 = (l$1 = (65535 & l$1) * o$1 + (((l$1 >>> 16) * o$1 & 65535) << 16) & 4294967295) << 15 | l$1 >>> 17)) * a$1 + (((l$1 >>> 16) * a$1 & 65535) << 16) & 4294967295) << 13 | i$1 >>> 19)) + ((5 * (i$1 >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (s$1 >>> 16) & 65535) << 16);
					switch (l$1 = 0, r$1) {
						case 3: l$1 ^= (255 & t$2.charCodeAt(u$1 + 2)) << 16;
						case 2: l$1 ^= (255 & t$2.charCodeAt(u$1 + 1)) << 8;
						case 1: i$1 ^= l$1 = (65535 & (l$1 = (l$1 = (65535 & (l$1 ^= 255 & t$2.charCodeAt(u$1))) * o$1 + (((l$1 >>> 16) * o$1 & 65535) << 16) & 4294967295) << 15 | l$1 >>> 17)) * a$1 + (((l$1 >>> 16) * a$1 & 65535) << 16) & 4294967295;
					}
					return i$1 ^= t$2.length, i$1 = 2246822507 * (65535 & (i$1 ^= i$1 >>> 16)) + ((2246822507 * (i$1 >>> 16) & 65535) << 16) & 4294967295, i$1 = 3266489909 * (65535 & (i$1 ^= i$1 >>> 13)) + ((3266489909 * (i$1 >>> 16) & 65535) << 16) & 4294967295, (i$1 ^= i$1 >>> 16) >>> 0;
				}), We.exports), e$1 = (He || (He = 1, Ye.exports = function(t$2, e$2) {
					for (var r$1, n$1 = t$2.length, i$1 = e$2 ^ n$1, s$1 = 0; n$1 >= 4;) r$1 = 1540483477 * (65535 & (r$1 = 255 & t$2.charCodeAt(s$1) | (255 & t$2.charCodeAt(++s$1)) << 8 | (255 & t$2.charCodeAt(++s$1)) << 16 | (255 & t$2.charCodeAt(++s$1)) << 24)) + ((1540483477 * (r$1 >>> 16) & 65535) << 16), i$1 = 1540483477 * (65535 & i$1) + ((1540483477 * (i$1 >>> 16) & 65535) << 16) ^ (r$1 = 1540483477 * (65535 & (r$1 ^= r$1 >>> 24)) + ((1540483477 * (r$1 >>> 16) & 65535) << 16)), n$1 -= 4, ++s$1;
					switch (n$1) {
						case 3: i$1 ^= (255 & t$2.charCodeAt(s$1 + 2)) << 16;
						case 2: i$1 ^= (255 & t$2.charCodeAt(s$1 + 1)) << 8;
						case 1: i$1 = 1540483477 * (65535 & (i$1 ^= 255 & t$2.charCodeAt(s$1))) + ((1540483477 * (i$1 >>> 16) & 65535) << 16);
					}
					return i$1 = 1540483477 * (65535 & (i$1 ^= i$1 >>> 13)) + ((1540483477 * (i$1 >>> 16) & 65535) << 16), (i$1 ^= i$1 >>> 15) >>> 0;
				}), Ye.exports);
				return Ze.exports = t$1, Ze.exports.murmur3 = t$1, Ze.exports.murmur2 = e$1, Ze.exports;
			}());
			class Qe {
				constructor(t$1, ...e$1) {
					Object.assign(this, e$1[0] || {}), this.type = t$1;
				}
			}
			class tr extends Qe {
				constructor(t$1, e$1 = {}) {
					super("error", Object.assign({ error: t$1 }, e$1));
				}
			}
			function er(t$1, e$1, r$1) {
				r$1[t$1] && -1 !== r$1[t$1].indexOf(e$1) || (r$1[t$1] = r$1[t$1] || [], r$1[t$1].push(e$1));
			}
			function rr(t$1, e$1, r$1) {
				if (r$1 && r$1[t$1]) {
					const n$1 = r$1[t$1].indexOf(e$1);
					-1 !== n$1 && r$1[t$1].splice(n$1, 1);
				}
			}
			class nr {
				on(t$1, e$1) {
					return this._listeners = this._listeners || {}, er(t$1, e$1, this._listeners), this;
				}
				off(t$1, e$1) {
					return rr(t$1, e$1, this._listeners), rr(t$1, e$1, this._oneTimeListeners), this;
				}
				once(t$1, e$1) {
					return e$1 ? (this._oneTimeListeners = this._oneTimeListeners || {}, er(t$1, e$1, this._oneTimeListeners), this) : new Promise(((e$2) => {
						this.once(t$1, e$2);
					}));
				}
				fire(t$1, e$1) {
					const r$1 = "string" == typeof t$1 ? new Qe(t$1, e$1) : t$1, n$1 = r$1.type;
					if (this.listens(n$1)) {
						r$1.target = this;
						const t$2 = this._listeners && this._listeners[n$1] ? this._listeners[n$1].slice() : [];
						for (const e$3 of t$2) e$3.call(this, r$1);
						const e$2 = this._oneTimeListeners && this._oneTimeListeners[n$1] ? this._oneTimeListeners[n$1].slice() : [];
						for (const t$3 of e$2) rr(n$1, t$3, this._oneTimeListeners), t$3.call(this, r$1);
						const i$1 = this._eventedParent;
						if (i$1) {
							const t$3 = "function" == typeof this._eventedParentData ? this._eventedParentData() : this._eventedParentData;
							Object.assign(r$1, t$3), i$1.fire(r$1);
						}
					} else r$1 instanceof tr && console.error(r$1.error);
					return this;
				}
				listens(t$1) {
					return !!(this._listeners && this._listeners[t$1] && this._listeners[t$1].length > 0 || this._oneTimeListeners && this._oneTimeListeners[t$1] && this._oneTimeListeners[t$1].length > 0 || this._eventedParent && this._eventedParent.listens(t$1));
				}
				setEventedParent(t$1, e$1) {
					return this._eventedParent = t$1, this._eventedParentData = e$1, this;
				}
			}
			class ir {
				constructor(t$1) {
					"string" == typeof t$1 ? this.name = t$1 : (this.name = t$1.name, this.iconsetId = t$1.iconsetId);
				}
				static from(t$1) {
					return new ir(t$1);
				}
				static toString(t$1) {
					return t$1.iconsetId ? `${t$1.name}${t$1.iconsetId}` : t$1.name;
				}
				static parse(t$1) {
					const [e$1, r$1] = t$1.split("");
					return new ir({
						name: e$1,
						iconsetId: r$1
					});
				}
				static isEqual(t$1, e$1) {
					return t$1.name === e$1.name && t$1.iconsetId === e$1.iconsetId;
				}
				toString() {
					return ir.toString(this);
				}
				serialize() {
					return {
						name: this.name,
						iconsetId: this.iconsetId
					};
				}
			}
			var sr, or = {}, ar = function() {
				if (sr) return or;
				sr = 1;
				var t$1 = {
					transparent: [
						0,
						0,
						0,
						0
					],
					aliceblue: [
						240,
						248,
						255,
						1
					],
					antiquewhite: [
						250,
						235,
						215,
						1
					],
					aqua: [
						0,
						255,
						255,
						1
					],
					aquamarine: [
						127,
						255,
						212,
						1
					],
					azure: [
						240,
						255,
						255,
						1
					],
					beige: [
						245,
						245,
						220,
						1
					],
					bisque: [
						255,
						228,
						196,
						1
					],
					black: [
						0,
						0,
						0,
						1
					],
					blanchedalmond: [
						255,
						235,
						205,
						1
					],
					blue: [
						0,
						0,
						255,
						1
					],
					blueviolet: [
						138,
						43,
						226,
						1
					],
					brown: [
						165,
						42,
						42,
						1
					],
					burlywood: [
						222,
						184,
						135,
						1
					],
					cadetblue: [
						95,
						158,
						160,
						1
					],
					chartreuse: [
						127,
						255,
						0,
						1
					],
					chocolate: [
						210,
						105,
						30,
						1
					],
					coral: [
						255,
						127,
						80,
						1
					],
					cornflowerblue: [
						100,
						149,
						237,
						1
					],
					cornsilk: [
						255,
						248,
						220,
						1
					],
					crimson: [
						220,
						20,
						60,
						1
					],
					cyan: [
						0,
						255,
						255,
						1
					],
					darkblue: [
						0,
						0,
						139,
						1
					],
					darkcyan: [
						0,
						139,
						139,
						1
					],
					darkgoldenrod: [
						184,
						134,
						11,
						1
					],
					darkgray: [
						169,
						169,
						169,
						1
					],
					darkgreen: [
						0,
						100,
						0,
						1
					],
					darkgrey: [
						169,
						169,
						169,
						1
					],
					darkkhaki: [
						189,
						183,
						107,
						1
					],
					darkmagenta: [
						139,
						0,
						139,
						1
					],
					darkolivegreen: [
						85,
						107,
						47,
						1
					],
					darkorange: [
						255,
						140,
						0,
						1
					],
					darkorchid: [
						153,
						50,
						204,
						1
					],
					darkred: [
						139,
						0,
						0,
						1
					],
					darksalmon: [
						233,
						150,
						122,
						1
					],
					darkseagreen: [
						143,
						188,
						143,
						1
					],
					darkslateblue: [
						72,
						61,
						139,
						1
					],
					darkslategray: [
						47,
						79,
						79,
						1
					],
					darkslategrey: [
						47,
						79,
						79,
						1
					],
					darkturquoise: [
						0,
						206,
						209,
						1
					],
					darkviolet: [
						148,
						0,
						211,
						1
					],
					deeppink: [
						255,
						20,
						147,
						1
					],
					deepskyblue: [
						0,
						191,
						255,
						1
					],
					dimgray: [
						105,
						105,
						105,
						1
					],
					dimgrey: [
						105,
						105,
						105,
						1
					],
					dodgerblue: [
						30,
						144,
						255,
						1
					],
					firebrick: [
						178,
						34,
						34,
						1
					],
					floralwhite: [
						255,
						250,
						240,
						1
					],
					forestgreen: [
						34,
						139,
						34,
						1
					],
					fuchsia: [
						255,
						0,
						255,
						1
					],
					gainsboro: [
						220,
						220,
						220,
						1
					],
					ghostwhite: [
						248,
						248,
						255,
						1
					],
					gold: [
						255,
						215,
						0,
						1
					],
					goldenrod: [
						218,
						165,
						32,
						1
					],
					gray: [
						128,
						128,
						128,
						1
					],
					green: [
						0,
						128,
						0,
						1
					],
					greenyellow: [
						173,
						255,
						47,
						1
					],
					grey: [
						128,
						128,
						128,
						1
					],
					honeydew: [
						240,
						255,
						240,
						1
					],
					hotpink: [
						255,
						105,
						180,
						1
					],
					indianred: [
						205,
						92,
						92,
						1
					],
					indigo: [
						75,
						0,
						130,
						1
					],
					ivory: [
						255,
						255,
						240,
						1
					],
					khaki: [
						240,
						230,
						140,
						1
					],
					lavender: [
						230,
						230,
						250,
						1
					],
					lavenderblush: [
						255,
						240,
						245,
						1
					],
					lawngreen: [
						124,
						252,
						0,
						1
					],
					lemonchiffon: [
						255,
						250,
						205,
						1
					],
					lightblue: [
						173,
						216,
						230,
						1
					],
					lightcoral: [
						240,
						128,
						128,
						1
					],
					lightcyan: [
						224,
						255,
						255,
						1
					],
					lightgoldenrodyellow: [
						250,
						250,
						210,
						1
					],
					lightgray: [
						211,
						211,
						211,
						1
					],
					lightgreen: [
						144,
						238,
						144,
						1
					],
					lightgrey: [
						211,
						211,
						211,
						1
					],
					lightpink: [
						255,
						182,
						193,
						1
					],
					lightsalmon: [
						255,
						160,
						122,
						1
					],
					lightseagreen: [
						32,
						178,
						170,
						1
					],
					lightskyblue: [
						135,
						206,
						250,
						1
					],
					lightslategray: [
						119,
						136,
						153,
						1
					],
					lightslategrey: [
						119,
						136,
						153,
						1
					],
					lightsteelblue: [
						176,
						196,
						222,
						1
					],
					lightyellow: [
						255,
						255,
						224,
						1
					],
					lime: [
						0,
						255,
						0,
						1
					],
					limegreen: [
						50,
						205,
						50,
						1
					],
					linen: [
						250,
						240,
						230,
						1
					],
					magenta: [
						255,
						0,
						255,
						1
					],
					maroon: [
						128,
						0,
						0,
						1
					],
					mediumaquamarine: [
						102,
						205,
						170,
						1
					],
					mediumblue: [
						0,
						0,
						205,
						1
					],
					mediumorchid: [
						186,
						85,
						211,
						1
					],
					mediumpurple: [
						147,
						112,
						219,
						1
					],
					mediumseagreen: [
						60,
						179,
						113,
						1
					],
					mediumslateblue: [
						123,
						104,
						238,
						1
					],
					mediumspringgreen: [
						0,
						250,
						154,
						1
					],
					mediumturquoise: [
						72,
						209,
						204,
						1
					],
					mediumvioletred: [
						199,
						21,
						133,
						1
					],
					midnightblue: [
						25,
						25,
						112,
						1
					],
					mintcream: [
						245,
						255,
						250,
						1
					],
					mistyrose: [
						255,
						228,
						225,
						1
					],
					moccasin: [
						255,
						228,
						181,
						1
					],
					navajowhite: [
						255,
						222,
						173,
						1
					],
					navy: [
						0,
						0,
						128,
						1
					],
					oldlace: [
						253,
						245,
						230,
						1
					],
					olive: [
						128,
						128,
						0,
						1
					],
					olivedrab: [
						107,
						142,
						35,
						1
					],
					orange: [
						255,
						165,
						0,
						1
					],
					orangered: [
						255,
						69,
						0,
						1
					],
					orchid: [
						218,
						112,
						214,
						1
					],
					palegoldenrod: [
						238,
						232,
						170,
						1
					],
					palegreen: [
						152,
						251,
						152,
						1
					],
					paleturquoise: [
						175,
						238,
						238,
						1
					],
					palevioletred: [
						219,
						112,
						147,
						1
					],
					papayawhip: [
						255,
						239,
						213,
						1
					],
					peachpuff: [
						255,
						218,
						185,
						1
					],
					peru: [
						205,
						133,
						63,
						1
					],
					pink: [
						255,
						192,
						203,
						1
					],
					plum: [
						221,
						160,
						221,
						1
					],
					powderblue: [
						176,
						224,
						230,
						1
					],
					purple: [
						128,
						0,
						128,
						1
					],
					rebeccapurple: [
						102,
						51,
						153,
						1
					],
					red: [
						255,
						0,
						0,
						1
					],
					rosybrown: [
						188,
						143,
						143,
						1
					],
					royalblue: [
						65,
						105,
						225,
						1
					],
					saddlebrown: [
						139,
						69,
						19,
						1
					],
					salmon: [
						250,
						128,
						114,
						1
					],
					sandybrown: [
						244,
						164,
						96,
						1
					],
					seagreen: [
						46,
						139,
						87,
						1
					],
					seashell: [
						255,
						245,
						238,
						1
					],
					sienna: [
						160,
						82,
						45,
						1
					],
					silver: [
						192,
						192,
						192,
						1
					],
					skyblue: [
						135,
						206,
						235,
						1
					],
					slateblue: [
						106,
						90,
						205,
						1
					],
					slategray: [
						112,
						128,
						144,
						1
					],
					slategrey: [
						112,
						128,
						144,
						1
					],
					snow: [
						255,
						250,
						250,
						1
					],
					springgreen: [
						0,
						255,
						127,
						1
					],
					steelblue: [
						70,
						130,
						180,
						1
					],
					tan: [
						210,
						180,
						140,
						1
					],
					teal: [
						0,
						128,
						128,
						1
					],
					thistle: [
						216,
						191,
						216,
						1
					],
					tomato: [
						255,
						99,
						71,
						1
					],
					turquoise: [
						64,
						224,
						208,
						1
					],
					violet: [
						238,
						130,
						238,
						1
					],
					wheat: [
						245,
						222,
						179,
						1
					],
					white: [
						255,
						255,
						255,
						1
					],
					whitesmoke: [
						245,
						245,
						245,
						1
					],
					yellow: [
						255,
						255,
						0,
						1
					],
					yellowgreen: [
						154,
						205,
						50,
						1
					]
				};
				function e$1(t$2) {
					return (t$2 = Math.round(t$2)) < 0 ? 0 : t$2 > 255 ? 255 : t$2;
				}
				function r$1(t$2) {
					return e$1("%" === t$2[t$2.length - 1] ? parseFloat(t$2) / 100 * 255 : parseInt(t$2));
				}
				function n$1(t$2) {
					return (e$2 = "%" === t$2[t$2.length - 1] ? parseFloat(t$2) / 100 : parseFloat(t$2)) < 0 ? 0 : e$2 > 1 ? 1 : e$2;
					var e$2;
				}
				function i$1(t$2, e$2, r$2) {
					return r$2 < 0 ? r$2 += 1 : r$2 > 1 && (r$2 -= 1), 6 * r$2 < 1 ? t$2 + (e$2 - t$2) * r$2 * 6 : 2 * r$2 < 1 ? e$2 : 3 * r$2 < 2 ? t$2 + (e$2 - t$2) * (2 / 3 - r$2) * 6 : t$2;
				}
				try {
					or.parseCSSColor = function(s$1) {
						var o$1, a$1 = s$1.replace(/ /g, "").toLowerCase();
						if (a$1 in t$1) return t$1[a$1].slice();
						if ("#" === a$1[0]) return 4 === a$1.length ? (o$1 = parseInt(a$1.substr(1), 16)) >= 0 && o$1 <= 4095 ? [
							(3840 & o$1) >> 4 | (3840 & o$1) >> 8,
							240 & o$1 | (240 & o$1) >> 4,
							15 & o$1 | (15 & o$1) << 4,
							1
						] : null : 7 === a$1.length && (o$1 = parseInt(a$1.substr(1), 16)) >= 0 && o$1 <= 16777215 ? [
							(16711680 & o$1) >> 16,
							(65280 & o$1) >> 8,
							255 & o$1,
							1
						] : null;
						var l$1 = a$1.indexOf("("), u$1 = a$1.indexOf(")");
						if (-1 !== l$1 && u$1 + 1 === a$1.length) {
							var c$1 = a$1.substr(0, l$1), h$1 = a$1.substr(l$1 + 1, u$1 - (l$1 + 1)).split(","), p$1 = 1;
							switch (c$1) {
								case "rgba":
									if (4 !== h$1.length) return null;
									p$1 = n$1(h$1.pop());
								case "rgb": return 3 !== h$1.length ? null : [
									r$1(h$1[0]),
									r$1(h$1[1]),
									r$1(h$1[2]),
									p$1
								];
								case "hsla":
									if (4 !== h$1.length) return null;
									p$1 = n$1(h$1.pop());
								case "hsl":
									if (3 !== h$1.length) return null;
									var d$1 = (parseFloat(h$1[0]) % 360 + 360) % 360 / 360, f$1 = n$1(h$1[1]), m$1 = n$1(h$1[2]), y$1 = m$1 <= .5 ? m$1 * (f$1 + 1) : m$1 + f$1 - m$1 * f$1, g$1 = 2 * m$1 - y$1;
									return [
										e$1(255 * i$1(g$1, y$1, d$1 + 1 / 3)),
										e$1(255 * i$1(g$1, y$1, d$1)),
										e$1(255 * i$1(g$1, y$1, d$1 - 1 / 3)),
										p$1
									];
								default: return null;
							}
						}
						return null;
					};
				} catch (t$2) {}
				return or;
			}();
			class lr {
				constructor(t$1, e$1, r$1, n$1 = 1) {
					this.r = t$1, this.g = e$1, this.b = r$1, this.a = n$1;
				}
				static parse(t$1) {
					if (!t$1) return;
					if (t$1 instanceof lr) return t$1;
					if ("string" != typeof t$1) return;
					const e$1 = ar.parseCSSColor(t$1);
					return e$1 ? new lr(e$1[0] / 255, e$1[1] / 255, e$1[2] / 255, e$1[3]) : void 0;
				}
				toString() {
					const [t$1, e$1, r$1, n$1] = [
						this.r,
						this.g,
						this.b,
						this.a
					];
					return `rgba(${Math.round(255 * t$1)},${Math.round(255 * e$1)},${Math.round(255 * r$1)},${n$1})`;
				}
				toNonPremultipliedRenderColor(t$1) {
					const { r: e$1, g: r$1, b: n$1, a: i$1 } = this;
					return new cr(t$1, e$1, r$1, n$1, i$1);
				}
				toPremultipliedRenderColor(t$1) {
					const { r: e$1, g: r$1, b: n$1, a: i$1 } = this;
					return new hr(t$1, e$1 * i$1, r$1 * i$1, n$1 * i$1, i$1);
				}
				clone() {
					return new lr(this.r, this.g, this.b, this.a);
				}
			}
			class ur {
				constructor(t$1, e$1, r$1, n$1, i$1, s$1 = !1) {
					if (this.premultiplied = !1, this.premultiplied = s$1, t$1) {
						const s$2 = t$1.image.height, o$1 = s$2 * s$2;
						this.premultiplied ? (e$1 = 0 === i$1 ? 0 : e$1 / i$1 * (s$2 - 1), r$1 = 0 === i$1 ? 0 : r$1 / i$1 * (s$2 - 1), n$1 = 0 === i$1 ? 0 : n$1 / i$1 * (s$2 - 1)) : (e$1 *= s$2 - 1, r$1 *= s$2 - 1, n$1 *= s$2 - 1);
						const a$1 = Math.floor(e$1), l$1 = Math.floor(r$1), u$1 = Math.floor(n$1), c$1 = Math.ceil(e$1), h$1 = Math.ceil(r$1), p$1 = Math.ceil(n$1), d$1 = e$1 - a$1, f$1 = r$1 - l$1, m$1 = n$1 - u$1, y$1 = t$1.image.data, g$1 = 4 * (a$1 + l$1 * o$1 + u$1 * s$2), x$1 = 4 * (a$1 + l$1 * o$1 + p$1 * s$2), v$1 = 4 * (a$1 + h$1 * o$1 + u$1 * s$2), b$1 = 4 * (a$1 + h$1 * o$1 + p$1 * s$2), w$1 = 4 * (c$1 + l$1 * o$1 + u$1 * s$2), _$1 = 4 * (c$1 + l$1 * o$1 + p$1 * s$2), A$1 = 4 * (c$1 + h$1 * o$1 + u$1 * s$2), I$1 = 4 * (c$1 + h$1 * o$1 + p$1 * s$2);
						if (g$1 < 0 || I$1 >= y$1.length) throw new Error("out of range");
						this.r = pr(pr(pr(y$1[g$1], y$1[x$1], m$1), pr(y$1[v$1], y$1[b$1], m$1), f$1), pr(pr(y$1[w$1], y$1[_$1], m$1), pr(y$1[A$1], y$1[I$1], m$1), f$1), d$1) / 255 * (this.premultiplied ? i$1 : 1), this.g = pr(pr(pr(y$1[g$1 + 1], y$1[x$1 + 1], m$1), pr(y$1[v$1 + 1], y$1[b$1 + 1], m$1), f$1), pr(pr(y$1[w$1 + 1], y$1[_$1 + 1], m$1), pr(y$1[A$1 + 1], y$1[I$1 + 1], m$1), f$1), d$1) / 255 * (this.premultiplied ? i$1 : 1), this.b = pr(pr(pr(y$1[g$1 + 2], y$1[x$1 + 2], m$1), pr(y$1[v$1 + 2], y$1[b$1 + 2], m$1), f$1), pr(pr(y$1[w$1 + 2], y$1[_$1 + 2], m$1), pr(y$1[A$1 + 2], y$1[I$1 + 2], m$1), f$1), d$1) / 255 * (this.premultiplied ? i$1 : 1), this.a = i$1;
					} else this.r = e$1, this.g = r$1, this.b = n$1, this.a = i$1;
				}
				toArray() {
					const { r: t$1, g: e$1, b: r$1, a: n$1 } = this;
					return [
						255 * t$1,
						255 * e$1,
						255 * r$1,
						n$1
					];
				}
				toHslaArray() {
					let { r: t$1, g: e$1, b: r$1, a: n$1 } = this;
					if (this.premultiplied) {
						if (0 === n$1) return [
							0,
							0,
							0,
							0
						];
						const i$2 = 1 / n$1;
						t$1 *= i$2, e$1 *= i$2, r$1 *= i$2;
					}
					const i$1 = Math.min(Math.max(t$1, 0), 1), s$1 = Math.min(Math.max(e$1, 0), 1), o$1 = Math.min(Math.max(r$1, 0), 1), a$1 = Math.min(i$1, s$1, o$1), l$1 = Math.max(i$1, s$1, o$1), u$1 = l$1 - a$1, c$1 = .5 * (a$1 + l$1);
					if (0 === u$1) return [
						0,
						0,
						100 * c$1,
						n$1
					];
					const h$1 = c$1 > .5 ? u$1 / (2 - l$1 - a$1) : u$1 / (l$1 + a$1);
					let p$1;
					switch (l$1) {
						case i$1:
							p$1 = 60 * ((s$1 - o$1) / u$1 + (s$1 < o$1 ? 6 : 0));
							break;
						case s$1:
							p$1 = 60 * ((o$1 - i$1) / u$1 + 2);
							break;
						default: p$1 = 60 * ((i$1 - s$1) / u$1 + 4);
					}
					return [
						p$1,
						100 * h$1,
						100 * c$1,
						n$1
					];
				}
				toArray01() {
					const { r: t$1, g: e$1, b: r$1, a: n$1 } = this;
					return [
						t$1,
						e$1,
						r$1,
						n$1
					];
				}
				toArray01Scaled(t$1) {
					const { r: e$1, g: r$1, b: n$1 } = this;
					return [
						e$1 * t$1,
						r$1 * t$1,
						n$1 * t$1
					];
				}
				toArray01Linear() {
					const { r: t$1, g: e$1, b: r$1, a: n$1 } = this;
					return [
						Math.pow(t$1, 2.2),
						Math.pow(e$1, 2.2),
						Math.pow(r$1, 2.2),
						n$1
					];
				}
			}
			class cr extends ur {
				constructor(t$1, e$1, r$1, n$1, i$1) {
					super(t$1, e$1, r$1, n$1, i$1, !1);
				}
			}
			class hr extends ur {
				constructor(t$1, e$1, r$1, n$1, i$1) {
					super(t$1, e$1, r$1, n$1, i$1, !0);
				}
			}
			function pr(t$1, e$1, r$1) {
				return t$1 * (1 - r$1) + e$1 * r$1;
			}
			function dr(t$1, e$1, r$1) {
				return t$1.map(((t$2, n$1) => pr(t$2, e$1[n$1], r$1)));
			}
			lr.black = new lr(0, 0, 0, 1), lr.white = new lr(1, 1, 1, 1), lr.transparent = new lr(0, 0, 0, 0), lr.red = new lr(1, 0, 0, 1), lr.blue = new lr(0, 0, 1, 1);
			var fr = Object.freeze({
				__proto__: null,
				array: dr,
				color: function(t$1, e$1, r$1) {
					return new lr(pr(t$1.r, e$1.r, r$1), pr(t$1.g, e$1.g, r$1), pr(t$1.b, e$1.b, r$1), pr(t$1.a, e$1.a, r$1));
				},
				number: pr
			});
			class mr extends Error {
				constructor(t$1, e$1) {
					super(e$1), this.message = e$1, this.key = t$1;
				}
			}
			class yr {
				constructor(t$1, e$1 = []) {
					this.parent = t$1, this.bindings = {};
					for (const [t$2, r$1] of e$1) this.bindings[t$2] = r$1;
				}
				concat(t$1) {
					return new yr(this, t$1);
				}
				get(t$1) {
					if (this.bindings[t$1]) return this.bindings[t$1];
					if (this.parent) return this.parent.get(t$1);
					throw new Error(`${t$1} not found in scope.`);
				}
				has(t$1) {
					return !!this.bindings[t$1] || !!this.parent && this.parent.has(t$1);
				}
			}
			const gr = { kind: "null" }, xr = { kind: "number" }, vr = { kind: "string" }, br = { kind: "boolean" }, wr = { kind: "color" }, _r = { kind: "object" }, Ar = { kind: "value" }, Ir = { kind: "collator" }, Mr = { kind: "formatted" }, Sr = { kind: "resolvedImage" };
			function Pr(t$1, e$1) {
				return {
					kind: "array",
					itemType: t$1,
					N: e$1
				};
			}
			function kr(t$1) {
				if ("array" === t$1.kind) {
					const e$1 = kr(t$1.itemType);
					return "number" == typeof t$1.N ? `array<${e$1}, ${t$1.N}>` : "value" === t$1.itemType.kind ? "array" : `array<${e$1}>`;
				}
				return t$1.kind;
			}
			const Br = [
				gr,
				xr,
				vr,
				br,
				wr,
				Mr,
				_r,
				Pr(Ar),
				Sr
			];
			function zr(t$1, e$1) {
				if ("error" === e$1.kind) return null;
				if ("array" === t$1.kind) {
					if ("array" === e$1.kind && (0 === e$1.N && "value" === e$1.itemType.kind || !zr(t$1.itemType, e$1.itemType)) && ("number" != typeof t$1.N || t$1.N === e$1.N)) return null;
				} else {
					if (t$1.kind === e$1.kind) return null;
					if ("value" === t$1.kind) {
						for (const t$2 of Br) if (!zr(t$2, e$1)) return null;
					}
				}
				return `Expected ${kr(t$1)} but found ${kr(e$1)} instead.`;
			}
			function Tr(t$1, e$1) {
				return e$1.some(((e$2) => e$2.kind === t$1.kind));
			}
			function Er(t$1, e$1) {
				return e$1.some(((e$2) => "null" === e$2 ? null === t$1 : "array" === e$2 ? Array.isArray(t$1) : "object" === e$2 ? t$1 && !Array.isArray(t$1) && "object" == typeof t$1 : e$2 === typeof t$1));
			}
			function Vr(t$1, e$1) {
				return "array" === t$1.kind && "array" === e$1.kind ? t$1.N === e$1.N && Vr(t$1.itemType, e$1.itemType) : t$1.kind === e$1.kind;
			}
			class Fr {
				constructor(t$1, e$1, r$1) {
					this.sensitivity = t$1 ? e$1 ? "variant" : "case" : e$1 ? "accent" : "base", this.locale = r$1, this.collator = new Intl.Collator(this.locale ? this.locale : [], {
						sensitivity: this.sensitivity,
						usage: "search"
					});
				}
				compare(t$1, e$1) {
					return this.collator.compare(t$1, e$1);
				}
				resolvedLocale() {
					return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
				}
			}
			class Cr {
				constructor(t$1, e$1, r$1, n$1, i$1) {
					this.text = t$1.normalize ? t$1.normalize() : t$1, this.image = e$1, this.scale = r$1, this.fontStack = n$1, this.textColor = i$1;
				}
			}
			class Dr {
				constructor(t$1) {
					this.sections = t$1;
				}
				static fromString(t$1) {
					return new Dr([new Cr(t$1, null, null, null, null)]);
				}
				isEmpty() {
					return 0 === this.sections.length || !this.sections.some(((t$1) => 0 !== t$1.text.length || !!t$1.image && t$1.image.hasPrimary()));
				}
				static factory(t$1) {
					return t$1 instanceof Dr ? t$1 : Dr.fromString(t$1);
				}
				toString() {
					return 0 === this.sections.length ? "" : this.sections.map(((t$1) => t$1.text)).join("");
				}
				serialize() {
					const t$1 = ["format"];
					for (const e$1 of this.sections) {
						if (e$1.image) {
							const r$2 = e$1.image.getPrimary().id.toString();
							t$1.push(["image", r$2]);
							continue;
						}
						t$1.push(e$1.text);
						const r$1 = {};
						e$1.fontStack && (r$1["text-font"] = ["literal", e$1.fontStack.split(",")]), e$1.scale && (r$1["font-scale"] = e$1.scale), e$1.textColor && (r$1["text-color"] = ["rgba"].concat(e$1.textColor.toNonPremultipliedRenderColor(null).toArray())), t$1.push(r$1);
					}
					return t$1;
				}
			}
			class Rr {
				constructor(t$1, e$1 = {}) {
					this.id = ir.from(t$1), this.params = e$1.params, this.sx = e$1.sx || 1, this.sy = e$1.sy || 1;
				}
				toString() {
					return JSON.stringify(this);
				}
				static parse(t$1) {
					let e$1, r$1, n$1, i$1;
					try {
						({id: e$1, params: r$1, sx: n$1, sy: i$1} = JSON.parse(t$1) || {});
					} catch (t$2) {
						return null;
					}
					return e$1 ? new Rr(e$1, {
						params: r$1,
						sx: n$1,
						sy: i$1
					}) : null;
				}
				scaleSelf(t$1, e$1 = t$1) {
					return this.sx *= t$1, this.sy *= e$1, this;
				}
			}
			class Lr {
				constructor(t$1, e$1, r$1, n$1, i$1 = !1) {
					this.primaryId = ir.from(t$1), this.primaryOptions = e$1, r$1 && (this.secondaryId = ir.from(r$1)), this.secondaryOptions = n$1, this.available = i$1;
				}
				toString() {
					return this.primaryId && this.secondaryId ? `[${this.primaryId.name},${this.secondaryId.name}]` : this.primaryId.name;
				}
				hasPrimary() {
					return !!this.primaryId;
				}
				getPrimary() {
					return new Rr(this.primaryId, this.primaryOptions);
				}
				hasSecondary() {
					return !!this.secondaryId;
				}
				getSecondary() {
					return this.secondaryId ? new Rr(this.secondaryId, this.secondaryOptions) : null;
				}
				static from(t$1) {
					return "string" == typeof t$1 ? Lr.build({ name: t$1 }) : t$1;
				}
				static build(t$1, e$1, r$1, n$1) {
					return !t$1 || "object" == typeof t$1 && !("name" in t$1) ? null : new Lr(t$1, r$1, e$1, n$1);
				}
			}
			function Or(t$1, e$1, r$1, n$1) {
				return "number" == typeof t$1 && t$1 >= 0 && t$1 <= 255 && "number" == typeof e$1 && e$1 >= 0 && e$1 <= 255 && "number" == typeof r$1 && r$1 >= 0 && r$1 <= 255 ? void 0 === n$1 || "number" == typeof n$1 && n$1 >= 0 && n$1 <= 1 ? null : `Invalid rgba value [${[
					t$1,
					e$1,
					r$1,
					n$1
				].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${("number" == typeof n$1 ? [
					t$1,
					e$1,
					r$1,
					n$1
				] : [
					t$1,
					e$1,
					r$1
				]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`;
			}
			function Ur(t$1) {
				if (null === t$1) return !0;
				if ("string" == typeof t$1) return !0;
				if ("boolean" == typeof t$1) return !0;
				if ("number" == typeof t$1) return !0;
				if (t$1 instanceof lr) return !0;
				if (t$1 instanceof Fr) return !0;
				if (t$1 instanceof Dr) return !0;
				if (t$1 instanceof Lr) return !0;
				if (Array.isArray(t$1)) {
					for (const e$1 of t$1) if (!Ur(e$1)) return !1;
					return !0;
				}
				if ("object" == typeof t$1) {
					for (const e$1 in t$1) if (!Ur(t$1[e$1])) return !1;
					return !0;
				}
				return !1;
			}
			function Nr(t$1) {
				if (null === t$1) return gr;
				if ("string" == typeof t$1) return vr;
				if ("boolean" == typeof t$1) return br;
				if ("number" == typeof t$1) return xr;
				if (t$1 instanceof lr) return wr;
				if (t$1 instanceof Fr) return Ir;
				if (t$1 instanceof Dr) return Mr;
				if (t$1 instanceof Lr) return Sr;
				if (Array.isArray(t$1)) {
					const e$1 = t$1.length;
					let r$1;
					for (const e$2 of t$1) {
						const t$2 = Nr(e$2);
						if (r$1) {
							if (r$1 === t$2) continue;
							r$1 = Ar;
							break;
						}
						r$1 = t$2;
					}
					return Pr(r$1 || Ar, e$1);
				}
				return _r;
			}
			function jr(t$1) {
				const e$1 = typeof t$1;
				return null === t$1 ? "" : "string" === e$1 || "number" === e$1 || "boolean" === e$1 ? String(t$1) : t$1 instanceof Dr || t$1 instanceof Lr || t$1 instanceof lr ? t$1.toString() : JSON.stringify(t$1);
			}
			class $r {
				constructor(t$1, e$1) {
					this.type = t$1, this.value = e$1;
				}
				static parse(t$1, e$1) {
					if (2 !== t$1.length) return e$1.error(`'literal' expression requires exactly one argument, but found ${t$1.length - 1} instead.`);
					if (!Ur(t$1[1])) return e$1.error("invalid value");
					const r$1 = t$1[1];
					let n$1 = Nr(r$1);
					const i$1 = e$1.expectedType;
					return "array" !== n$1.kind || 0 !== n$1.N || !i$1 || "array" !== i$1.kind || "number" == typeof i$1.N && 0 !== i$1.N || (n$1 = i$1), new $r(n$1, r$1);
				}
				evaluate() {
					return this.value;
				}
				eachChild() {}
				outputDefined() {
					return !0;
				}
				serialize() {
					return "array" === this.type.kind || "object" === this.type.kind ? ["literal", this.value] : this.value instanceof lr ? ["rgba"].concat(this.value.toNonPremultipliedRenderColor(null).toArray()) : this.value instanceof Dr ? this.value.serialize() : this.value;
				}
			}
			class Gr {
				constructor(t$1) {
					this.name = "ExpressionEvaluationError", this.message = t$1;
				}
				toJSON() {
					return this.message;
				}
			}
			const qr = {
				string: vr,
				number: xr,
				boolean: br,
				object: _r
			};
			class Hr {
				constructor(t$1, e$1) {
					this.type = t$1, this.args = e$1;
				}
				static parse(t$1, e$1) {
					if (t$1.length < 2) return e$1.error("Expected at least one argument.");
					let r$1, n$1 = 1;
					const i$1 = t$1[0];
					if ("array" === i$1) {
						let i$2, s$2;
						if (t$1.length > 2) {
							const r$2 = t$1[1];
							if ("string" != typeof r$2 || !(r$2 in qr) || "object" === r$2) return e$1.error("The item type argument of \"array\" must be one of string, number, boolean", 1);
							i$2 = qr[r$2], n$1++;
						} else i$2 = Ar;
						if (t$1.length > 3) {
							if (null !== t$1[2] && ("number" != typeof t$1[2] || t$1[2] < 0 || t$1[2] !== Math.floor(t$1[2]))) return e$1.error("The length argument to \"array\" must be a positive integer literal", 2);
							s$2 = t$1[2], n$1++;
						}
						r$1 = Pr(i$2, s$2);
					} else r$1 = qr[i$1];
					const s$1 = [];
					for (; n$1 < t$1.length; n$1++) {
						const r$2 = e$1.parse(t$1[n$1], n$1, Ar);
						if (!r$2) return null;
						s$1.push(r$2);
					}
					return new Hr(r$1, s$1);
				}
				evaluate(t$1) {
					for (let e$1 = 0; e$1 < this.args.length; e$1++) {
						const r$1 = this.args[e$1].evaluate(t$1);
						if (!zr(this.type, Nr(r$1))) return r$1;
						if (e$1 === this.args.length - 1) throw new Gr(`The expression ${JSON.stringify(this.args[e$1].serialize())} evaluated to ${kr(Nr(r$1))} but was expected to be of type ${kr(this.type)}.`);
					}
					return null;
				}
				eachChild(t$1) {
					this.args.forEach(t$1);
				}
				outputDefined() {
					return this.args.every(((t$1) => t$1.outputDefined()));
				}
				serialize() {
					const t$1 = this.type, e$1 = [t$1.kind];
					if ("array" === t$1.kind) {
						const r$1 = t$1.itemType;
						if ("string" === r$1.kind || "number" === r$1.kind || "boolean" === r$1.kind) {
							e$1.push(r$1.kind);
							const n$1 = t$1.N;
							("number" == typeof n$1 || this.args.length > 1) && e$1.push(n$1);
						}
					}
					return e$1.concat(this.args.map(((t$2) => t$2.serialize())));
				}
			}
			class Xr {
				constructor(t$1) {
					this.type = Mr, this.sections = t$1;
				}
				static parse(t$1, e$1) {
					if (t$1.length < 2) return e$1.error("Expected at least one argument.");
					const r$1 = t$1[1];
					if (!Array.isArray(r$1) && "object" == typeof r$1) return e$1.error("First argument must be an image or text section.");
					const n$1 = [];
					let i$1 = !1;
					for (let r$2 = 1; r$2 <= t$1.length - 1; ++r$2) {
						const s$1 = t$1[r$2];
						if (i$1 && "object" == typeof s$1 && !Array.isArray(s$1)) {
							i$1 = !1;
							let t$2 = null;
							if (s$1["font-scale"] && (t$2 = e$1.parseObjectValue(s$1["font-scale"], r$2, "font-scale", xr), !t$2)) return null;
							let o$1 = null;
							if (s$1["text-font"] && (o$1 = e$1.parseObjectValue(s$1["text-font"], r$2, "text-font", Pr(vr)), !o$1)) return null;
							let a$1 = null;
							if (s$1["text-color"] && (a$1 = e$1.parseObjectValue(s$1["text-color"], r$2, "text-color", wr), !a$1)) return null;
							const l$1 = n$1[n$1.length - 1];
							l$1.scale = t$2, l$1.font = o$1, l$1.textColor = a$1;
						} else {
							const s$2 = e$1.parse(t$1[r$2], r$2, Ar);
							if (!s$2) return null;
							const o$1 = s$2.type.kind;
							if ("string" !== o$1 && "value" !== o$1 && "null" !== o$1 && "resolvedImage" !== o$1) return e$1.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
							i$1 = !0, n$1.push({
								content: s$2,
								scale: null,
								font: null,
								textColor: null
							});
						}
					}
					return new Xr(n$1);
				}
				evaluate(t$1) {
					return new Dr(this.sections.map(((e$1) => {
						const r$1 = e$1.content.evaluate(t$1);
						return Vr(Nr(r$1), Sr) ? new Cr("", r$1, null, null, null) : new Cr(jr(r$1), null, e$1.scale ? e$1.scale.evaluate(t$1) : null, e$1.font ? e$1.font.evaluate(t$1).join(",") : null, e$1.textColor ? e$1.textColor.evaluate(t$1) : null);
					})));
				}
				eachChild(t$1) {
					for (const e$1 of this.sections) t$1(e$1.content), e$1.scale && t$1(e$1.scale), e$1.font && t$1(e$1.font), e$1.textColor && t$1(e$1.textColor);
				}
				outputDefined() {
					return !1;
				}
				serialize() {
					const t$1 = ["format"];
					for (const e$1 of this.sections) {
						t$1.push(e$1.content.serialize());
						const r$1 = {};
						e$1.scale && (r$1["font-scale"] = e$1.scale.serialize()), e$1.font && (r$1["text-font"] = e$1.font.serialize()), e$1.textColor && (r$1["text-color"] = e$1.textColor.serialize()), t$1.push(r$1);
					}
					return t$1;
				}
			}
			class Zr {
				constructor(t$1, e$1, r$1, n$1) {
					this._imageWarnHistory = {}, this.type = Sr, this.namePrimary = t$1, this.nameSecondary = e$1, r$1 && (this.paramsPrimary = r$1.params, this.iconsetIdPrimary = r$1.iconset ? r$1.iconset.id : void 0), n$1 && (this.paramsSecondary = n$1.params, this.iconsetIdSecondary = n$1.iconset ? n$1.iconset.id : void 0);
				}
				static parse(t$1, e$1) {
					if (t$1.length < 2) return e$1.error("Expected two or more arguments.");
					let r$1 = 1;
					const n$1 = [];
					function i$1() {
						if (r$1 < t$1.length) {
							const i$2 = e$1.parse(t$1[r$1], r$1++, vr);
							return i$2 ? (n$1.push({
								image: i$2,
								options: {}
							}), !0) : (e$1.error(n$1.length ? "Secondary image variant is not a string." : "No image name provided."), !1);
						}
						return !0;
					}
					function s$1() {
						if (r$1 < t$1.length) {
							const s$2 = t$1[r$1];
							if (null === (i$2 = s$2) || "object" != typeof i$2 || Array.isArray(i$2)) return !0;
							const o$1 = s$2.params, a$1 = s$2.iconset, l$1 = e$1.concat(r$1);
							if (!o$1 && !a$1) return r$1++, !0;
							if (o$1) {
								if ("object" != typeof o$1 || o$1.constructor !== Object) return l$1.error("Image options \"params\" should be an object"), !1;
								const t$2 = {}, e$2 = l$1.concat(void 0, "params");
								for (const r$2 in o$1) {
									if (!r$2) return e$2.error("Image parameter name should be non-empty"), !1;
									const n$2 = e$2.concat(void 0, r$2).parse(o$1[r$2], void 0, wr, void 0, { typeAnnotation: "coerce" });
									if (!n$2) return !1;
									t$2[r$2] = n$2;
								}
								n$1[n$1.length - 1].options.params = t$2;
							}
							if (a$1) {
								if ("object" != typeof a$1 || a$1.constructor !== Object) return l$1.error("Image options \"iconset\" should be an object"), !1;
								if (!a$1.id) return l$1.error("Image options \"iconset\" should have an \"id\" property"), !1;
								n$1[n$1.length - 1].options.iconset = a$1;
							}
							return r$1++, !0;
						}
						var i$2;
						return !0;
					}
					for (let t$2 = 0; t$2 < 2; t$2++) if (!i$1() || !s$1()) return;
					return new Zr(n$1[0].image, n$1[1] ? n$1[1].image : void 0, n$1[0].options, n$1[1] ? n$1[1].options : void 0);
				}
				evaluateParams(t$1, e$1) {
					const r$1 = {};
					if (e$1) {
						for (const n$1 in e$1) if (e$1[n$1]) try {
							r$1[n$1] = e$1[n$1].evaluate(t$1);
						} catch (t$2) {
							continue;
						}
						if (0 !== Object.keys(r$1).length) return { params: r$1 };
					}
				}
				evaluate(t$1) {
					const e$1 = {
						name: this.namePrimary.evaluate(t$1),
						iconsetId: this.iconsetIdPrimary
					}, r$1 = this.nameSecondary ? {
						name: this.nameSecondary.evaluate(t$1),
						iconsetId: this.iconsetIdSecondary
					} : void 0, n$1 = Lr.build(e$1, r$1, this.paramsPrimary ? this.evaluateParams(t$1, this.paramsPrimary) : void 0, this.paramsSecondary ? this.evaluateParams(t$1, this.paramsSecondary) : void 0);
					if (n$1 && t$1.availableImages) {
						const e$2 = n$1.getPrimary().id;
						if (n$1.available = t$1.availableImages.some(((t$2) => ir.isEqual(t$2, e$2))), n$1.available) {
							const e$3 = n$1.getSecondary() ? n$1.getSecondary().id : null;
							e$3 && (n$1.available = t$1.availableImages.some(((t$2) => ir.isEqual(t$2, e$3))));
						}
					}
					return n$1;
				}
				eachChild(t$1) {
					if (t$1(this.namePrimary), this.paramsPrimary) for (const e$1 in this.paramsPrimary) this.paramsPrimary[e$1] && t$1(this.paramsPrimary[e$1]);
					if (this.nameSecondary && (t$1(this.nameSecondary), this.paramsSecondary)) for (const e$1 in this.paramsSecondary) this.paramsSecondary[e$1] && t$1(this.paramsSecondary[e$1]);
				}
				outputDefined() {
					return !1;
				}
				serializeOptions(t$1, e$1) {
					const r$1 = {};
					if (e$1 && (r$1.iconset = { id: e$1 }), t$1) {
						r$1.params = {};
						for (const e$2 in t$1) t$1[e$2] && (r$1.params[e$2] = t$1[e$2].serialize());
					}
					return Object.keys(r$1).length > 0 ? r$1 : void 0;
				}
				serialize() {
					const t$1 = ["image", this.namePrimary.serialize()];
					if (this.paramsPrimary || this.iconsetIdPrimary) {
						const e$1 = this.serializeOptions(this.paramsPrimary, this.iconsetIdPrimary);
						e$1 && t$1.push(e$1);
					}
					if (this.nameSecondary && (t$1.push(this.nameSecondary.serialize()), this.paramsSecondary || this.iconsetIdSecondary)) {
						const e$1 = this.serializeOptions(this.paramsSecondary, this.iconsetIdSecondary);
						e$1 && t$1.push(e$1);
					}
					return t$1;
				}
			}
			function Wr(t$1) {
				return Kr(t$1) ? "string" : Jr(t$1) ? "number" : Qr(t$1) ? "boolean" : Array.isArray(t$1) ? "array" : null === t$1 ? "null" : Yr(t$1) ? "object" : typeof t$1;
			}
			function Yr(t$1) {
				return null != t$1 && !Array.isArray(t$1) && "function" != typeof t$1 && !(t$1 instanceof String || t$1 instanceof Number || t$1 instanceof Boolean) && "object" == typeof t$1;
			}
			function Kr(t$1) {
				return "string" == typeof t$1 || t$1 instanceof String;
			}
			function Jr(t$1) {
				return "number" == typeof t$1 || t$1 instanceof Number;
			}
			function Qr(t$1) {
				return "boolean" == typeof t$1 || t$1 instanceof Boolean;
			}
			const tn = {
				"to-boolean": br,
				"to-color": wr,
				"to-number": xr,
				"to-string": vr
			};
			class en {
				constructor(t$1, e$1) {
					this.type = t$1, this.args = e$1;
				}
				static parse(t$1, e$1) {
					if (t$1.length < 2) return e$1.error("Expected at least one argument.");
					const r$1 = t$1[0], n$1 = [];
					let i$1 = gr;
					if ("to-array" === r$1) {
						if (!Array.isArray(t$1[1])) return null;
						const r$2 = t$1[1].length;
						if (e$1.expectedType) {
							if ("array" !== e$1.expectedType.kind) return e$1.error(`Expected ${e$1.expectedType.kind} but found array.`);
							i$1 = Pr(e$1.expectedType.itemType, r$2);
						} else {
							if (!(r$2 > 0 && Ur(t$1[1][0]))) return null;
							i$1 = Pr(Nr(t$1[1][0]), r$2);
						}
						for (let s$1 = 0; s$1 < r$2; s$1++) {
							const r$3 = t$1[1][s$1];
							let o$1;
							if (Array.isArray(r$3)) o$1 = e$1.parse(r$3, void 0, i$1.itemType);
							else {
								const t$2 = Wr(r$3);
								if (t$2 !== i$1.itemType.kind) return e$1.error(`Expected ${i$1.itemType.kind} but found ${t$2}.`);
								o$1 = e$1.registry.literal.parse(["literal", void 0 === r$3 ? null : r$3], e$1);
							}
							if (!o$1) return null;
							n$1.push(o$1);
						}
					} else {
						if (("to-boolean" === r$1 || "to-string" === r$1) && 2 !== t$1.length) return e$1.error("Expected one argument.");
						i$1 = tn[r$1];
						for (let r$2 = 1; r$2 < t$1.length; r$2++) {
							const i$2 = e$1.parse(t$1[r$2], r$2, Ar);
							if (!i$2) return null;
							n$1.push(i$2);
						}
					}
					return new en(i$1, n$1);
				}
				evaluate(t$1) {
					if ("boolean" === this.type.kind) return Boolean(this.args[0].evaluate(t$1));
					if ("color" === this.type.kind) {
						let e$1, r$1;
						for (const n$1 of this.args) {
							if (e$1 = n$1.evaluate(t$1), r$1 = null, e$1 instanceof lr) return e$1;
							if ("string" == typeof e$1) {
								const r$2 = t$1.parseColor(e$1);
								if (r$2) return r$2;
							} else if (Array.isArray(e$1) && (r$1 = e$1.length < 3 || e$1.length > 4 ? `Invalid rbga value ${JSON.stringify(e$1)}: expected an array containing either three or four numeric values.` : Or(e$1[0], e$1[1], e$1[2], e$1[3]), !r$1)) return new lr(e$1[0] / 255, e$1[1] / 255, e$1[2] / 255, e$1[3]);
						}
						throw new Gr(r$1 || `Could not parse color from value '${"string" == typeof e$1 ? e$1 : String(JSON.stringify(e$1))}'`);
					}
					if ("number" === this.type.kind) {
						let e$1 = null;
						for (const r$1 of this.args) {
							if (e$1 = r$1.evaluate(t$1), null === e$1) return 0;
							const n$1 = Number(e$1);
							if (!isNaN(n$1)) return n$1;
						}
						throw new Gr(`Could not convert ${JSON.stringify(e$1)} to number.`);
					}
					return "formatted" === this.type.kind ? Dr.fromString(jr(this.args[0].evaluate(t$1))) : "resolvedImage" === this.type.kind ? Lr.build(jr(this.args[0].evaluate(t$1))) : "array" === this.type.kind ? this.args.map(((e$1) => e$1.evaluate(t$1))) : jr(this.args[0].evaluate(t$1));
				}
				eachChild(t$1) {
					this.args.forEach(t$1);
				}
				outputDefined() {
					return this.args.every(((t$1) => t$1.outputDefined()));
				}
				serialize() {
					if ("formatted" === this.type.kind) return new Xr([{
						content: this.args[0],
						scale: null,
						font: null,
						textColor: null
					}]).serialize();
					if ("resolvedImage" === this.type.kind) return new Zr(this.args[0]).serialize();
					const t$1 = "array" === this.type.kind ? [] : [`to-${this.type.kind}`];
					return this.eachChild(((e$1) => {
						t$1.push(e$1.serialize());
					})), t$1;
				}
			}
			const rn = [
				"Unknown",
				"Point",
				"LineString",
				"Polygon"
			];
			class nn {
				constructor(t$1, e$1, r$1) {
					this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = {}, this.availableImages = null, this.canonical = null, this.featureTileCoord = null, this.featureDistanceData = null, this.scope = t$1, this.options = e$1, this.iconImageUseTheme = r$1;
				}
				id() {
					return this.feature && void 0 !== this.feature.id ? this.feature.id : null;
				}
				geometryType() {
					return this.feature ? "number" == typeof this.feature.type ? rn[this.feature.type] : this.feature.type : null;
				}
				geometry() {
					return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
				}
				canonicalID() {
					return this.canonical;
				}
				properties() {
					return this.feature && this.feature.properties || {};
				}
				measureLight(t$1) {
					return this.globals.brightness || 0;
				}
				distanceFromCenter() {
					if (this.featureTileCoord && this.featureDistanceData) {
						const t$1 = this.featureDistanceData.center, e$1 = this.featureDistanceData.scale, { x: r$1, y: n$1 } = this.featureTileCoord;
						return this.featureDistanceData.bearing[0] * (r$1 * e$1 - t$1[0]) + this.featureDistanceData.bearing[1] * (n$1 * e$1 - t$1[1]);
					}
					return 0;
				}
				parseColor(t$1) {
					let e$1 = this._parseColorCache[t$1];
					return e$1 || (e$1 = this._parseColorCache[t$1] = lr.parse(t$1)), e$1;
				}
				getConfig(t$1) {
					return this.options ? this.options.get(t$1) : null;
				}
			}
			class sn {
				constructor(t$1, e$1, r$1, n$1, i$1) {
					this.name = t$1, this.type = e$1, this._evaluate = r$1, this.args = n$1, this._overloadIndex = i$1;
				}
				evaluate(t$1) {
					if (!this._evaluate) {
						const t$2 = sn.definitions[this.name];
						this._evaluate = Array.isArray(t$2) ? t$2[2] : t$2.overloads[this._overloadIndex][1];
					}
					return this._evaluate(t$1, this.args);
				}
				eachChild(t$1) {
					this.args.forEach(t$1);
				}
				outputDefined() {
					return !1;
				}
				serialize() {
					return [this.name].concat(this.args.map(((t$1) => t$1.serialize())));
				}
				static parse(t$1, e$1) {
					const r$1 = t$1[0], n$1 = sn.definitions[r$1];
					if (!n$1) return e$1.error(`Unknown expression "${r$1}". If you wanted a literal array, use ["literal", [...]].`, 0);
					const i$1 = Array.isArray(n$1) ? n$1[0] : n$1.type, s$1 = Array.isArray(n$1) ? [[n$1[1], n$1[2]]] : n$1.overloads, o$1 = [];
					let a$1 = null, l$1 = -1;
					for (const [n$2, u$1] of s$1) {
						if (Array.isArray(n$2) && n$2.length !== t$1.length - 1) continue;
						o$1.push(n$2), l$1++, a$1 = new Mi(e$1.registry, e$1.path, null, e$1.scope, void 0, e$1._scope, e$1.options, e$1.iconImageUseTheme);
						const s$2 = [];
						let c$1 = !1;
						for (let e$2 = 1; e$2 < t$1.length; e$2++) {
							const r$2 = t$1[e$2], i$2 = Array.isArray(n$2) ? n$2[e$2 - 1] : n$2.type, o$2 = a$1.parse(r$2, 1 + s$2.length, i$2);
							if (!o$2) {
								c$1 = !0;
								break;
							}
							s$2.push(o$2);
						}
						if (!c$1) if (Array.isArray(n$2) && n$2.length !== s$2.length) a$1.error(`Expected ${n$2.length} arguments, but found ${s$2.length} instead.`);
						else {
							for (let t$2 = 0; t$2 < s$2.length; t$2++) {
								const e$2 = Array.isArray(n$2) ? n$2[t$2] : n$2.type, r$2 = s$2[t$2];
								a$1.concat(t$2 + 1).checkSubtype(e$2, r$2.type);
							}
							if (0 === a$1.errors.length) return new sn(r$1, i$1, u$1, s$2, l$1);
						}
					}
					if (1 === o$1.length) e$1.errors.push(...a$1.errors);
					else {
						const r$2 = (o$1.length ? o$1 : s$1.map((([t$2]) => t$2))).map(on).join(" | "), n$2 = [];
						for (let r$3 = 1; r$3 < t$1.length; r$3++) {
							const i$2 = e$1.parse(t$1[r$3], 1 + n$2.length);
							if (!i$2) return null;
							n$2.push(kr(i$2.type));
						}
						e$1.error(`Expected arguments of type ${r$2}, but found (${n$2.join(", ")}) instead.`);
					}
					return null;
				}
				static register(t$1, e$1) {
					sn.definitions = e$1;
					for (const r$1 in e$1) t$1[r$1] = sn;
				}
			}
			function on(t$1) {
				return Array.isArray(t$1) ? `(${t$1.map(kr).join(", ")})` : `(${kr(t$1.type)}...)`;
			}
			class an {
				constructor(t$1, e$1, r$1) {
					this.type = Ir, this.locale = r$1, this.caseSensitive = t$1, this.diacriticSensitive = e$1;
				}
				static parse(t$1, e$1) {
					if (2 !== t$1.length) return e$1.error("Expected one argument.");
					const r$1 = t$1[1];
					if ("object" != typeof r$1 || Array.isArray(r$1)) return e$1.error("Collator options argument must be an object.");
					const n$1 = void 0 === r$1["case-sensitive"] ? e$1.parse(!1, 1, br) : e$1.parseObjectValue(r$1["case-sensitive"], 1, "case-sensitive", br);
					if (!n$1) return null;
					const i$1 = void 0 === r$1["diacritic-sensitive"] ? e$1.parse(!1, 1, br) : e$1.parseObjectValue(r$1["diacritic-sensitive"], 1, "diacritic-sensitive", br);
					if (!i$1) return null;
					let s$1 = null;
					return r$1.locale && (s$1 = e$1.parseObjectValue(r$1.locale, 1, "locale", vr), !s$1) ? null : new an(n$1, i$1, s$1);
				}
				evaluate(t$1) {
					return new Fr(this.caseSensitive.evaluate(t$1), this.diacriticSensitive.evaluate(t$1), this.locale ? this.locale.evaluate(t$1) : null);
				}
				eachChild(t$1) {
					t$1(this.caseSensitive), t$1(this.diacriticSensitive), this.locale && t$1(this.locale);
				}
				outputDefined() {
					return !1;
				}
				serialize() {
					const t$1 = {};
					return t$1["case-sensitive"] = this.caseSensitive.serialize(), t$1["diacritic-sensitive"] = this.diacriticSensitive.serialize(), this.locale && (t$1.locale = this.locale.serialize()), ["collator", t$1];
				}
			}
			function ln(t$1, e$1, r$1 = 0, n$1 = t$1.length - 1, i$1 = cn) {
				for (; n$1 > r$1;) {
					if (n$1 - r$1 > 600) {
						const s$2 = n$1 - r$1 + 1, o$2 = e$1 - r$1 + 1, a$2 = Math.log(s$2), l$1 = .5 * Math.exp(2 * a$2 / 3), u$1 = .5 * Math.sqrt(a$2 * l$1 * (s$2 - l$1) / s$2) * (o$2 - s$2 / 2 < 0 ? -1 : 1);
						ln(t$1, e$1, Math.max(r$1, Math.floor(e$1 - o$2 * l$1 / s$2 + u$1)), Math.min(n$1, Math.floor(e$1 + (s$2 - o$2) * l$1 / s$2 + u$1)), i$1);
					}
					const s$1 = t$1[e$1];
					let o$1 = r$1, a$1 = n$1;
					for (un(t$1, r$1, e$1), i$1(t$1[n$1], s$1) > 0 && un(t$1, r$1, n$1); o$1 < a$1;) {
						for (un(t$1, o$1, a$1), o$1++, a$1--; i$1(t$1[o$1], s$1) < 0;) o$1++;
						for (; i$1(t$1[a$1], s$1) > 0;) a$1--;
					}
					0 === i$1(t$1[r$1], s$1) ? un(t$1, r$1, a$1) : (a$1++, un(t$1, a$1, n$1)), a$1 <= e$1 && (r$1 = a$1 + 1), e$1 <= a$1 && (n$1 = a$1 - 1);
				}
			}
			function un(t$1, e$1, r$1) {
				const n$1 = t$1[e$1];
				t$1[e$1] = t$1[r$1], t$1[r$1] = n$1;
			}
			function cn(t$1, e$1) {
				return t$1 < e$1 ? -1 : t$1 > e$1 ? 1 : 0;
			}
			function hn(t$1) {
				let e$1 = 0;
				for (let r$1, n$1, i$1 = 0, s$1 = t$1.length, o$1 = s$1 - 1; i$1 < s$1; o$1 = i$1++) r$1 = t$1[i$1], n$1 = t$1[o$1], e$1 += (n$1.x - r$1.x) * (r$1.y + n$1.y);
				return e$1;
			}
			function pn(t$1, e$1) {
				t$1[0] = Math.min(t$1[0], e$1[0]), t$1[1] = Math.min(t$1[1], e$1[1]), t$1[2] = Math.max(t$1[2], e$1[0]), t$1[3] = Math.max(t$1[3], e$1[1]);
			}
			function dn(t$1, e$1) {
				return !(t$1[0] <= e$1[0] || t$1[2] >= e$1[2] || t$1[1] <= e$1[1] || t$1[3] >= e$1[3]);
			}
			function fn(t$1, e$1, r$1) {
				const n$1 = t$1[0] - e$1[0], i$1 = t$1[1] - e$1[1], s$1 = t$1[0] - r$1[0], o$1 = t$1[1] - r$1[1];
				return n$1 * o$1 - s$1 * i$1 == 0 && n$1 * s$1 <= 0 && i$1 * o$1 <= 0;
			}
			function mn(t$1, e$1, r$1 = !1) {
				let n$1 = !1;
				for (let a$1 = 0, l$1 = e$1.length; a$1 < l$1; a$1++) {
					const l$2 = e$1[a$1];
					for (let e$2 = 0, a$2 = l$2.length, u$1 = a$2 - 1; e$2 < a$2; u$1 = e$2++) {
						const a$3 = l$2[u$1], c$1 = l$2[e$2];
						if (fn(t$1, a$3, c$1)) return r$1;
						(s$1 = a$3)[1] > (i$1 = t$1)[1] != (o$1 = c$1)[1] > i$1[1] && i$1[0] < (o$1[0] - s$1[0]) * (i$1[1] - s$1[1]) / (o$1[1] - s$1[1]) + s$1[0] && (n$1 = !n$1);
					}
				}
				var i$1, s$1, o$1;
				return n$1;
			}
			function yn(t$1, e$1, r$1, n$1) {
				const i$1 = n$1[0] - r$1[0], s$1 = n$1[1] - r$1[1], o$1 = (t$1[0] - r$1[0]) * s$1 - i$1 * (t$1[1] - r$1[1]), a$1 = (e$1[0] - r$1[0]) * s$1 - i$1 * (e$1[1] - r$1[1]);
				return o$1 > 0 && a$1 < 0 || o$1 < 0 && a$1 > 0;
			}
			function gn(t$1, e$1, r$1, n$1) {
				return 0 != (i$1 = [n$1[0] - r$1[0], n$1[1] - r$1[1]])[0] * (s$1 = [e$1[0] - t$1[0], e$1[1] - t$1[1]])[1] - i$1[1] * s$1[0] && !(!yn(t$1, e$1, r$1, n$1) || !yn(r$1, n$1, t$1, e$1));
				var i$1, s$1;
			}
			function xn(t$1) {
				const e$1 = new It(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY), r$1 = new It(Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY);
				for (const n$1 of t$1[0]) e$1.x > n$1.x && (e$1.x = n$1.x), e$1.y > n$1.y && (e$1.y = n$1.y), r$1.x < n$1.x && (r$1.x = n$1.x), r$1.y < n$1.y && (r$1.y = n$1.y);
				return {
					min: e$1,
					max: r$1
				};
			}
			const vn = 8192;
			function bn(t$1, e$1) {
				const r$1 = (180 + t$1[0]) / 360, n$1 = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t$1[1] * Math.PI / 360))) / 360, i$1 = Math.pow(2, e$1.z);
				return [Math.round(r$1 * i$1 * vn), Math.round(n$1 * i$1 * vn)];
			}
			function wn(t$1, e$1) {
				for (let r$1 = 0; r$1 < e$1.length; r$1++) if (mn(t$1, e$1[r$1])) return !0;
				return !1;
			}
			function _n(t$1, e$1, r$1) {
				for (const n$1 of r$1) for (let r$2 = 0, i$1 = n$1.length, s$1 = i$1 - 1; r$2 < i$1; s$1 = r$2++) if (gn(t$1, e$1, n$1[s$1], n$1[r$2])) return !0;
				return !1;
			}
			function An(t$1, e$1) {
				for (let r$1 = 0; r$1 < t$1.length; ++r$1) if (!mn(t$1[r$1], e$1)) return !1;
				for (let r$1 = 0; r$1 < t$1.length - 1; ++r$1) if (_n(t$1[r$1], t$1[r$1 + 1], e$1)) return !1;
				return !0;
			}
			function In(t$1, e$1) {
				for (let r$1 = 0; r$1 < e$1.length; r$1++) if (An(t$1, e$1[r$1])) return !0;
				return !1;
			}
			function Mn(t$1, e$1, r$1) {
				const n$1 = [];
				for (let i$1 = 0; i$1 < t$1.length; i$1++) {
					const s$1 = [];
					for (let n$2 = 0; n$2 < t$1[i$1].length; n$2++) {
						const o$1 = bn(t$1[i$1][n$2], r$1);
						pn(e$1, o$1), s$1.push(o$1);
					}
					n$1.push(s$1);
				}
				return n$1;
			}
			function Sn(t$1, e$1, r$1) {
				const n$1 = [];
				for (let i$1 = 0; i$1 < t$1.length; i$1++) {
					const s$1 = Mn(t$1[i$1], e$1, r$1);
					n$1.push(s$1);
				}
				return n$1;
			}
			function Pn(t$1, e$1, r$1, n$1) {
				if (t$1[0] < r$1[0] || t$1[0] > r$1[2]) {
					const e$2 = .5 * n$1;
					let i$1 = t$1[0] - r$1[0] > e$2 ? -n$1 : r$1[0] - t$1[0] > e$2 ? n$1 : 0;
					0 === i$1 && (i$1 = t$1[0] - r$1[2] > e$2 ? -n$1 : r$1[2] - t$1[0] > e$2 ? n$1 : 0), t$1[0] += i$1;
				}
				pn(e$1, t$1);
			}
			function kn(t$1, e$1, r$1, n$1) {
				const i$1 = Math.pow(2, n$1.z) * vn, s$1 = [n$1.x * vn, n$1.y * vn], o$1 = [];
				if (!t$1) return o$1;
				for (const n$2 of t$1) for (const t$2 of n$2) {
					const n$3 = [t$2.x + s$1[0], t$2.y + s$1[1]];
					Pn(n$3, e$1, r$1, i$1), o$1.push(n$3);
				}
				return o$1;
			}
			function Bn(t$1, e$1, r$1, n$1) {
				const i$1 = Math.pow(2, n$1.z) * vn, s$1 = [n$1.x * vn, n$1.y * vn], o$1 = [];
				if (!t$1) return o$1;
				for (const r$2 of t$1) {
					const t$2 = [];
					for (const n$2 of r$2) {
						const r$3 = [n$2.x + s$1[0], n$2.y + s$1[1]];
						pn(e$1, r$3), t$2.push(r$3);
					}
					o$1.push(t$2);
				}
				if (e$1[2] - e$1[0] <= i$1 / 2) {
					(a$1 = e$1)[0] = a$1[1] = Infinity, a$1[2] = a$1[3] = -Infinity;
					for (const t$2 of o$1) for (const n$2 of t$2) Pn(n$2, e$1, r$1, i$1);
				}
				var a$1;
				return o$1;
			}
			class zn {
				constructor(t$1, e$1) {
					this.type = br, this.geojson = t$1, this.geometries = e$1;
				}
				static parse(t$1, e$1) {
					if (2 !== t$1.length) return e$1.error(`'within' expression requires exactly one argument, but found ${t$1.length - 1} instead.`);
					if (Ur(t$1[1])) {
						const e$2 = t$1[1];
						if ("FeatureCollection" === e$2.type) for (let t$2 = 0; t$2 < e$2.features.length; ++t$2) {
							const r$1 = e$2.features[t$2].geometry.type;
							if ("Polygon" === r$1 || "MultiPolygon" === r$1) return new zn(e$2, e$2.features[t$2].geometry);
						}
						else if ("Feature" === e$2.type) {
							const t$2 = e$2.geometry.type;
							if ("Polygon" === t$2 || "MultiPolygon" === t$2) return new zn(e$2, e$2.geometry);
						} else if ("Polygon" === e$2.type || "MultiPolygon" === e$2.type) return new zn(e$2, e$2);
					}
					return e$1.error("'within' expression requires valid geojson object that contains polygon geometry type.");
				}
				evaluate(t$1) {
					if (null != t$1.geometry() && null != t$1.canonicalID()) {
						if ("Point" === t$1.geometryType()) return function(t$2, e$1) {
							const r$1 = [
								Infinity,
								Infinity,
								-Infinity,
								-Infinity
							], n$1 = [
								Infinity,
								Infinity,
								-Infinity,
								-Infinity
							], i$1 = t$2.canonicalID();
							if (!i$1) return !1;
							if ("Polygon" === e$1.type) {
								const s$1 = Mn(e$1.coordinates, n$1, i$1), o$1 = kn(t$2.geometry(), r$1, n$1, i$1);
								if (!dn(r$1, n$1)) return !1;
								for (const t$3 of o$1) if (!mn(t$3, s$1)) return !1;
							}
							if ("MultiPolygon" === e$1.type) {
								const s$1 = Sn(e$1.coordinates, n$1, i$1), o$1 = kn(t$2.geometry(), r$1, n$1, i$1);
								if (!dn(r$1, n$1)) return !1;
								for (const t$3 of o$1) if (!wn(t$3, s$1)) return !1;
							}
							return !0;
						}(t$1, this.geometries);
						if ("LineString" === t$1.geometryType()) return function(t$2, e$1) {
							const r$1 = [
								Infinity,
								Infinity,
								-Infinity,
								-Infinity
							], n$1 = [
								Infinity,
								Infinity,
								-Infinity,
								-Infinity
							], i$1 = t$2.canonicalID();
							if (!i$1) return !1;
							if ("Polygon" === e$1.type) {
								const s$1 = Mn(e$1.coordinates, n$1, i$1), o$1 = Bn(t$2.geometry(), r$1, n$1, i$1);
								if (!dn(r$1, n$1)) return !1;
								for (const t$3 of o$1) if (!An(t$3, s$1)) return !1;
							}
							if ("MultiPolygon" === e$1.type) {
								const s$1 = Sn(e$1.coordinates, n$1, i$1), o$1 = Bn(t$2.geometry(), r$1, n$1, i$1);
								if (!dn(r$1, n$1)) return !1;
								for (const t$3 of o$1) if (!In(t$3, s$1)) return !1;
							}
							return !0;
						}(t$1, this.geometries);
					}
					return !1;
				}
				eachChild() {}
				outputDefined() {
					return !0;
				}
				serialize() {
					return ["within", this.geojson];
				}
			}
			const Tn = {
				kilometers: 1,
				miles: 1e3 / 1609.344,
				nauticalmiles: 1e3 / 1852,
				meters: 1e3,
				metres: 1e3,
				yards: 1e3 / .9144,
				feet: 1e3 / .3048,
				inches: 1e3 / .0254
			}, En = 1 / 298.257223563, Vn = En * (2 - En), Fn = Math.PI / 180;
			class Cn {
				static fromTile(t$1, e$1, r$1) {
					const n$1 = Math.PI * (1 - 2 * (t$1 + .5) / Math.pow(2, e$1));
					return new Cn(Math.atan(.5 * (Math.exp(n$1) - Math.exp(-n$1))) / Fn, r$1);
				}
				static get units() {
					return Tn;
				}
				constructor(t$1, e$1) {
					if (void 0 === t$1) throw new Error("No latitude given.");
					if (e$1 && !Tn[e$1]) throw new Error(`Unknown unit ${e$1}. Use one of: ${Object.keys(Tn).join(", ")}`);
					const r$1 = 6378.137 * Fn * (e$1 ? Tn[e$1] : 1), n$1 = Math.cos(t$1 * Fn), i$1 = 1 / (1 - Vn * (1 - n$1 * n$1)), s$1 = Math.sqrt(i$1);
					this.kx = r$1 * s$1 * n$1, this.ky = r$1 * s$1 * i$1 * (1 - Vn);
				}
				distance(t$1, e$1) {
					const r$1 = Ln(t$1[0] - e$1[0]) * this.kx, n$1 = (t$1[1] - e$1[1]) * this.ky;
					return Math.sqrt(r$1 * r$1 + n$1 * n$1);
				}
				bearing(t$1, e$1) {
					const r$1 = Ln(e$1[0] - t$1[0]) * this.kx;
					return Math.atan2(r$1, (e$1[1] - t$1[1]) * this.ky) / Fn;
				}
				destination(t$1, e$1, r$1) {
					const n$1 = r$1 * Fn;
					return this.offset(t$1, Math.sin(n$1) * e$1, Math.cos(n$1) * e$1);
				}
				offset(t$1, e$1, r$1) {
					return [t$1[0] + e$1 / this.kx, t$1[1] + r$1 / this.ky];
				}
				lineDistance(t$1) {
					let e$1 = 0;
					for (let r$1 = 0; r$1 < t$1.length - 1; r$1++) e$1 += this.distance(t$1[r$1], t$1[r$1 + 1]);
					return e$1;
				}
				area(t$1) {
					let e$1 = 0;
					for (let r$1 = 0; r$1 < t$1.length; r$1++) {
						const n$1 = t$1[r$1];
						for (let t$2 = 0, i$1 = n$1.length, s$1 = i$1 - 1; t$2 < i$1; s$1 = t$2++) e$1 += Ln(n$1[t$2][0] - n$1[s$1][0]) * (n$1[t$2][1] + n$1[s$1][1]) * (r$1 ? -1 : 1);
					}
					return Math.abs(e$1) / 2 * this.kx * this.ky;
				}
				along(t$1, e$1) {
					let r$1 = 0;
					if (e$1 <= 0) return t$1[0];
					for (let n$1 = 0; n$1 < t$1.length - 1; n$1++) {
						const i$1 = t$1[n$1], s$1 = t$1[n$1 + 1], o$1 = this.distance(i$1, s$1);
						if (r$1 += o$1, r$1 > e$1) return Rn(i$1, s$1, (e$1 - (r$1 - o$1)) / o$1);
					}
					return t$1[t$1.length - 1];
				}
				pointToSegmentDistance(t$1, e$1, r$1) {
					let [n$1, i$1] = e$1, s$1 = Ln(r$1[0] - n$1) * this.kx, o$1 = (r$1[1] - i$1) * this.ky;
					if (0 !== s$1 || 0 !== o$1) {
						const e$2 = (Ln(t$1[0] - n$1) * this.kx * s$1 + (t$1[1] - i$1) * this.ky * o$1) / (s$1 * s$1 + o$1 * o$1);
						e$2 > 1 ? (n$1 = r$1[0], i$1 = r$1[1]) : e$2 > 0 && (n$1 += s$1 / this.kx * e$2, i$1 += o$1 / this.ky * e$2);
					}
					return s$1 = Ln(t$1[0] - n$1) * this.kx, o$1 = (t$1[1] - i$1) * this.ky, Math.sqrt(s$1 * s$1 + o$1 * o$1);
				}
				pointOnLine(t$1, e$1) {
					let r$1 = Infinity, n$1 = t$1[0][0], i$1 = t$1[0][1], s$1 = 0, o$1 = 0;
					for (let a$1 = 0; a$1 < t$1.length - 1; a$1++) {
						let l$1 = t$1[a$1][0], u$1 = t$1[a$1][1], c$1 = Ln(t$1[a$1 + 1][0] - l$1) * this.kx, h$1 = (t$1[a$1 + 1][1] - u$1) * this.ky, p$1 = 0;
						0 === c$1 && 0 === h$1 || (p$1 = (Ln(e$1[0] - l$1) * this.kx * c$1 + (e$1[1] - u$1) * this.ky * h$1) / (c$1 * c$1 + h$1 * h$1), p$1 > 1 ? (l$1 = t$1[a$1 + 1][0], u$1 = t$1[a$1 + 1][1]) : p$1 > 0 && (l$1 += c$1 / this.kx * p$1, u$1 += h$1 / this.ky * p$1)), c$1 = Ln(e$1[0] - l$1) * this.kx, h$1 = (e$1[1] - u$1) * this.ky;
						const d$1 = c$1 * c$1 + h$1 * h$1;
						d$1 < r$1 && (r$1 = d$1, n$1 = l$1, i$1 = u$1, s$1 = a$1, o$1 = p$1);
					}
					return {
						point: [n$1, i$1],
						index: s$1,
						t: Math.max(0, Math.min(1, o$1))
					};
				}
				lineSlice(t$1, e$1, r$1) {
					let n$1 = this.pointOnLine(r$1, t$1), i$1 = this.pointOnLine(r$1, e$1);
					if (n$1.index > i$1.index || n$1.index === i$1.index && n$1.t > i$1.t) {
						const t$2 = n$1;
						n$1 = i$1, i$1 = t$2;
					}
					const s$1 = [n$1.point], o$1 = n$1.index + 1, a$1 = i$1.index;
					!Dn(r$1[o$1], s$1[0]) && o$1 <= a$1 && s$1.push(r$1[o$1]);
					for (let t$2 = o$1 + 1; t$2 <= a$1; t$2++) s$1.push(r$1[t$2]);
					return Dn(r$1[a$1], i$1.point) || s$1.push(i$1.point), s$1;
				}
				lineSliceAlong(t$1, e$1, r$1) {
					let n$1 = 0;
					const i$1 = [];
					for (let s$1 = 0; s$1 < r$1.length - 1; s$1++) {
						const o$1 = r$1[s$1], a$1 = r$1[s$1 + 1], l$1 = this.distance(o$1, a$1);
						if (n$1 += l$1, n$1 > t$1 && 0 === i$1.length && i$1.push(Rn(o$1, a$1, (t$1 - (n$1 - l$1)) / l$1)), n$1 >= e$1) return i$1.push(Rn(o$1, a$1, (e$1 - (n$1 - l$1)) / l$1)), i$1;
						n$1 > t$1 && i$1.push(a$1);
					}
					return i$1;
				}
				bufferPoint(t$1, e$1) {
					const r$1 = e$1 / this.ky, n$1 = e$1 / this.kx;
					return [
						t$1[0] - n$1,
						t$1[1] - r$1,
						t$1[0] + n$1,
						t$1[1] + r$1
					];
				}
				bufferBBox(t$1, e$1) {
					const r$1 = e$1 / this.ky, n$1 = e$1 / this.kx;
					return [
						t$1[0] - n$1,
						t$1[1] - r$1,
						t$1[2] + n$1,
						t$1[3] + r$1
					];
				}
				insideBBox(t$1, e$1) {
					return Ln(t$1[0] - e$1[0]) >= 0 && Ln(t$1[0] - e$1[2]) <= 0 && t$1[1] >= e$1[1] && t$1[1] <= e$1[3];
				}
			}
			function Dn(t$1, e$1) {
				return t$1[0] === e$1[0] && t$1[1] === e$1[1];
			}
			function Rn(t$1, e$1, r$1) {
				const n$1 = Ln(e$1[0] - t$1[0]);
				return [t$1[0] + n$1 * r$1, t$1[1] + (e$1[1] - t$1[1]) * r$1];
			}
			function Ln(t$1) {
				for (; t$1 < -180;) t$1 += 360;
				for (; t$1 > 180;) t$1 -= 360;
				return t$1;
			}
			class On {
				constructor(t$1 = [], e$1 = ((t$2, e$2) => t$2 < e$2 ? -1 : t$2 > e$2 ? 1 : 0)) {
					if (this.data = t$1, this.length = this.data.length, this.compare = e$1, this.length > 0) for (let t$2 = (this.length >> 1) - 1; t$2 >= 0; t$2--) this._down(t$2);
				}
				push(t$1) {
					this.data.push(t$1), this._up(this.length++);
				}
				pop() {
					if (0 === this.length) return;
					const t$1 = this.data[0], e$1 = this.data.pop();
					return --this.length > 0 && (this.data[0] = e$1, this._down(0)), t$1;
				}
				peek() {
					return this.data[0];
				}
				_up(t$1) {
					const { data: e$1, compare: r$1 } = this, n$1 = e$1[t$1];
					for (; t$1 > 0;) {
						const i$1 = t$1 - 1 >> 1, s$1 = e$1[i$1];
						if (r$1(n$1, s$1) >= 0) break;
						e$1[t$1] = s$1, t$1 = i$1;
					}
					e$1[t$1] = n$1;
				}
				_down(t$1) {
					const { data: e$1, compare: r$1 } = this, n$1 = this.length >> 1, i$1 = e$1[t$1];
					for (; t$1 < n$1;) {
						let n$2 = 1 + (t$1 << 1);
						const s$1 = n$2 + 1;
						if (s$1 < this.length && r$1(e$1[s$1], e$1[n$2]) < 0 && (n$2 = s$1), r$1(e$1[n$2], i$1) >= 0) break;
						e$1[t$1] = e$1[n$2], t$1 = n$2;
					}
					e$1[t$1] = i$1;
				}
			}
			var Un = 8192;
			function Nn(t$1, e$1) {
				return e$1.dist - t$1.dist;
			}
			const jn = 100, $n = 50;
			function Gn(t$1) {
				const e$1 = [
					Infinity,
					Infinity,
					-Infinity,
					-Infinity
				];
				if (e$1.length !== t$1.length) return !1;
				for (let r$1 = 0; r$1 < e$1.length; r$1++) if (e$1[r$1] !== t$1[r$1]) return !1;
				return !0;
			}
			function qn(t$1) {
				return t$1[1] - t$1[0] + 1;
			}
			function Hn(t$1, e$1) {
				const r$1 = t$1[1] >= t$1[0] && t$1[1] < e$1;
				return r$1 || console.warn("Distance Expression: Index is out of range"), r$1;
			}
			function Xn(t$1, e$1) {
				if (t$1[0] > t$1[1]) return [null, null];
				const r$1 = qn(t$1);
				if (e$1) {
					if (2 === r$1) return [t$1, null];
					const e$2 = Math.floor(r$1 / 2);
					return [[t$1[0], t$1[0] + e$2], [t$1[0] + e$2, t$1[1]]];
				}
				{
					if (1 === r$1) return [t$1, null];
					const e$2 = Math.floor(r$1 / 2) - 1;
					return [[t$1[0], t$1[0] + e$2], [t$1[0] + e$2 + 1, t$1[1]]];
				}
			}
			function Zn(t$1, e$1) {
				const r$1 = [
					Infinity,
					Infinity,
					-Infinity,
					-Infinity
				];
				if (!Hn(e$1, t$1.length)) return r$1;
				for (let n$1 = e$1[0]; n$1 <= e$1[1]; ++n$1) pn(r$1, t$1[n$1]);
				return r$1;
			}
			function Wn(t$1) {
				const e$1 = [
					Infinity,
					Infinity,
					-Infinity,
					-Infinity
				];
				for (let r$1 = 0; r$1 < t$1.length; ++r$1) for (let n$1 = 0; n$1 < t$1[r$1].length; ++n$1) pn(e$1, t$1[r$1][n$1]);
				return e$1;
			}
			function Yn(t$1, e$1, r$1) {
				if (Gn(t$1) || Gn(e$1)) return NaN;
				let n$1 = 0, i$1 = 0;
				return t$1[2] < e$1[0] && (n$1 = e$1[0] - t$1[2]), t$1[0] > e$1[2] && (n$1 = t$1[0] - e$1[2]), t$1[1] > e$1[3] && (i$1 = t$1[1] - e$1[3]), t$1[3] < e$1[1] && (i$1 = e$1[1] - t$1[3]), r$1.distance([0, 0], [n$1, i$1]);
			}
			function Kn(t$1) {
				return 360 * t$1 - 180;
			}
			function Jn(t$1) {
				return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * t$1) * Math.PI / 180)) - 90;
			}
			function Qn(t$1, e$1) {
				const r$1 = Math.pow(2, e$1.z), n$1 = (t$1.y / Un + e$1.y) / r$1;
				return [Kn((t$1.x / Un + e$1.x) / r$1), Jn(n$1)];
			}
			function ti(t$1, e$1) {
				const r$1 = [];
				for (let n$1 = 0; n$1 < t$1.length; ++n$1) r$1.push(Qn(t$1[n$1], e$1));
				return r$1;
			}
			function ei(t$1, e$1, r$1) {
				const n$1 = r$1.pointOnLine(e$1, t$1).point;
				return r$1.distance(t$1, n$1);
			}
			function ri(t$1, e$1, r$1, n$1, i$1) {
				const s$1 = r$1.slice(n$1[0], n$1[1] + 1);
				let o$1 = Infinity;
				for (let r$2 = e$1[0]; r$2 <= e$1[1]; ++r$2) if (0 === (o$1 = Math.min(o$1, ei(t$1[r$2], s$1, i$1)))) return 0;
				return o$1;
			}
			function ni(t$1, e$1, r$1, n$1, i$1) {
				const s$1 = Math.min(i$1.pointToSegmentDistance(t$1, r$1, n$1), i$1.pointToSegmentDistance(e$1, r$1, n$1)), o$1 = Math.min(i$1.pointToSegmentDistance(r$1, t$1, e$1), i$1.pointToSegmentDistance(n$1, t$1, e$1));
				return Math.min(s$1, o$1);
			}
			function ii(t$1, e$1, r$1, n$1, i$1) {
				if (!Hn(e$1, t$1.length) || !Hn(n$1, r$1.length)) return NaN;
				let s$1 = Infinity;
				for (let o$1 = e$1[0]; o$1 < e$1[1]; ++o$1) for (let e$2 = n$1[0]; e$2 < n$1[1]; ++e$2) {
					if (gn(t$1[o$1], t$1[o$1 + 1], r$1[e$2], r$1[e$2 + 1])) return 0;
					s$1 = Math.min(s$1, ni(t$1[o$1], t$1[o$1 + 1], r$1[e$2], r$1[e$2 + 1], i$1));
				}
				return s$1;
			}
			function si(t$1, e$1, r$1, n$1, i$1) {
				if (!Hn(e$1, t$1.length) || !Hn(n$1, r$1.length)) return NaN;
				let s$1 = Infinity;
				for (let o$1 = e$1[0]; o$1 <= e$1[1]; ++o$1) for (let e$2 = n$1[0]; e$2 <= n$1[1]; ++e$2) if (0 === (s$1 = Math.min(s$1, i$1.distance(t$1[o$1], r$1[e$2])))) return s$1;
				return s$1;
			}
			function oi(t$1, e$1, r$1) {
				if (mn(t$1, e$1, !0)) return 0;
				let n$1 = Infinity;
				for (const i$1 of e$1) {
					const e$2 = i$1.length;
					if (e$2 < 2) return console.warn("Distance Expression: Invalid polygon!"), NaN;
					if (i$1[0] !== i$1[e$2 - 1] && 0 === (n$1 = Math.min(n$1, r$1.pointToSegmentDistance(t$1, i$1[e$2 - 1], i$1[0])))) return n$1;
					if (0 === (n$1 = Math.min(n$1, ei(t$1, i$1, r$1)))) return n$1;
				}
				return n$1;
			}
			function ai(t$1, e$1, r$1, n$1) {
				if (!Hn(e$1, t$1.length)) return NaN;
				for (let n$2 = e$1[0]; n$2 <= e$1[1]; ++n$2) if (mn(t$1[n$2], r$1, !0)) return 0;
				let i$1 = Infinity;
				for (let s$1 = e$1[0]; s$1 < e$1[1]; ++s$1) for (const e$2 of r$1) for (let r$2 = 0, o$1 = e$2.length, a$1 = o$1 - 1; r$2 < o$1; a$1 = r$2++) {
					if (gn(t$1[s$1], t$1[s$1 + 1], e$2[a$1], e$2[r$2])) return 0;
					i$1 = Math.min(i$1, ni(t$1[s$1], t$1[s$1 + 1], e$2[a$1], e$2[r$2], n$1));
				}
				return i$1;
			}
			function li(t$1, e$1) {
				for (const r$1 of t$1) for (let t$2 = 0; t$2 <= r$1.length - 1; ++t$2) if (mn(r$1[t$2], e$1, !0)) return !0;
				return !1;
			}
			function ui(t$1, e$1, r$1, n$1 = Infinity) {
				const i$1 = Wn(t$1), s$1 = Wn(e$1);
				if (n$1 !== Infinity && Yn(i$1, s$1, r$1) >= n$1) return n$1;
				if (dn(i$1, s$1)) {
					if (li(t$1, e$1)) return 0;
				} else if (li(e$1, t$1)) return 0;
				let o$1 = n$1;
				for (const n$2 of t$1) for (let t$2 = 0, i$2 = n$2.length, s$2 = i$2 - 1; t$2 < i$2; s$2 = t$2++) for (const i$3 of e$1) for (let e$2 = 0, a$1 = i$3.length, l$1 = a$1 - 1; e$2 < a$1; l$1 = e$2++) {
					if (gn(n$2[s$2], n$2[t$2], i$3[l$1], i$3[e$2])) return 0;
					o$1 = Math.min(o$1, ni(n$2[s$2], n$2[t$2], i$3[l$1], i$3[e$2], r$1));
				}
				return o$1;
			}
			function ci(t$1, e$1, r$1, n$1, i$1, s$1, o$1) {
				if (null === s$1 || null === o$1) return;
				const a$1 = Yn(Zn(n$1, s$1), Zn(i$1, o$1), r$1);
				a$1 < e$1 && t$1.push({
					dist: a$1,
					range1: s$1,
					range2: o$1
				});
			}
			function hi(t$1, e$1, r$1, n$1, i$1 = Infinity) {
				let s$1 = Math.min(n$1.distance(t$1[0], r$1[0][0]), i$1);
				if (0 === s$1) return s$1;
				const o$1 = new On([{
					dist: 0,
					range1: [0, t$1.length - 1],
					range2: [0, 0]
				}], Nn), a$1 = e$1 ? $n : jn, l$1 = Wn(r$1);
				for (; o$1.length;) {
					const i$2 = o$1.pop();
					if (i$2.dist >= s$1) continue;
					const u$1 = i$2.range1;
					if (qn(u$1) <= a$1) {
						if (!Hn(u$1, t$1.length)) return NaN;
						if (e$1) {
							const e$2 = ai(t$1, u$1, r$1, n$1);
							if (0 === (s$1 = Math.min(s$1, e$2))) return s$1;
						} else for (let e$2 = u$1[0]; e$2 <= u$1[1]; ++e$2) {
							const i$3 = oi(t$1[e$2], r$1, n$1);
							if (0 === (s$1 = Math.min(s$1, i$3))) return s$1;
						}
					} else {
						const r$2 = Xn(u$1, e$1);
						if (null !== r$2[0]) {
							const e$2 = Yn(Zn(t$1, r$2[0]), l$1, n$1);
							e$2 < s$1 && o$1.push({
								dist: e$2,
								range1: r$2[0],
								range2: [0, 0]
							});
						}
						if (null !== r$2[1]) {
							const e$2 = Yn(Zn(t$1, r$2[1]), l$1, n$1);
							e$2 < s$1 && o$1.push({
								dist: e$2,
								range1: r$2[1],
								range2: [0, 0]
							});
						}
					}
				}
				return s$1;
			}
			function pi(t$1, e$1, r$1, n$1, i$1, s$1 = Infinity) {
				let o$1 = Math.min(s$1, i$1.distance(t$1[0], r$1[0]));
				if (0 === o$1) return o$1;
				const a$1 = new On([{
					dist: 0,
					range1: [0, t$1.length - 1],
					range2: [0, r$1.length - 1]
				}], Nn), l$1 = e$1 ? $n : jn, u$1 = n$1 ? $n : jn;
				for (; a$1.length;) {
					const s$2 = a$1.pop();
					if (s$2.dist >= o$1) continue;
					const c$1 = s$2.range1, h$1 = s$2.range2;
					if (qn(c$1) <= l$1 && qn(h$1) <= u$1) {
						if (!Hn(c$1, t$1.length) || !Hn(h$1, r$1.length)) return NaN;
						if (e$1 && n$1 ? o$1 = Math.min(o$1, ii(t$1, c$1, r$1, h$1, i$1)) : e$1 || n$1 ? e$1 && !n$1 ? o$1 = Math.min(o$1, ri(r$1, h$1, t$1, c$1, i$1)) : !e$1 && n$1 && (o$1 = Math.min(o$1, ri(t$1, c$1, r$1, h$1, i$1))) : o$1 = Math.min(o$1, si(t$1, c$1, r$1, h$1, i$1)), 0 === o$1) return o$1;
					} else {
						const s$3 = Xn(c$1, e$1), l$2 = Xn(h$1, n$1);
						ci(a$1, o$1, i$1, t$1, r$1, s$3[0], l$2[0]), ci(a$1, o$1, i$1, t$1, r$1, s$3[0], l$2[1]), ci(a$1, o$1, i$1, t$1, r$1, s$3[1], l$2[0]), ci(a$1, o$1, i$1, t$1, r$1, s$3[1], l$2[1]);
					}
				}
				return o$1;
			}
			function di(t$1, e$1, r$1, n$1, i$1 = Infinity) {
				let s$1 = i$1;
				const o$1 = Zn(t$1, [0, t$1.length - 1]);
				for (const i$2 of r$1) if (!(s$1 !== Infinity && Yn(o$1, Zn(i$2, [0, i$2.length - 1]), n$1) >= s$1) && (s$1 = Math.min(s$1, pi(t$1, e$1, i$2, !0, n$1, s$1)), 0 === s$1)) return s$1;
				return s$1;
			}
			function fi(t$1, e$1, r$1, n$1, i$1 = Infinity) {
				let s$1 = i$1;
				const o$1 = Zn(t$1, [0, t$1.length - 1]);
				for (const i$2 of r$1) {
					if (s$1 !== Infinity && Yn(o$1, Wn(i$2), n$1) >= s$1) continue;
					const r$2 = hi(t$1, e$1, i$2, n$1, s$1);
					if (isNaN(r$2)) return r$2;
					if (0 === (s$1 = Math.min(s$1, r$2))) return s$1;
				}
				return s$1;
			}
			function mi(t$1) {
				return "Point" === t$1 || "MultiPoint" === t$1 || "LineString" === t$1 || "MultiLineString" === t$1 || "Polygon" === t$1 || "MultiPolygon" === t$1;
			}
			class yi {
				constructor(t$1, e$1) {
					this.type = xr, this.geojson = t$1, this.geometries = e$1;
				}
				static parse(t$1, e$1) {
					if (2 !== t$1.length) return e$1.error(`'distance' expression requires either one argument, but found ' ${t$1.length - 1} instead.`);
					if (Ur(t$1[1])) {
						const e$2 = t$1[1];
						if ("FeatureCollection" === e$2.type) {
							for (let t$2 = 0; t$2 < e$2.features.length; ++t$2) if (mi(e$2.features[t$2].geometry.type)) return new yi(e$2, e$2.features[t$2].geometry);
						} else if ("Feature" === e$2.type) {
							if (mi(e$2.geometry.type)) return new yi(e$2, e$2.geometry);
						} else if (mi(e$2.type)) return new yi(e$2, e$2);
					}
					return e$1.error("'distance' expression needs to be an array with format ['Distance', GeoJSONObj].");
				}
				evaluate(t$1) {
					const e$1 = t$1.geometry(), r$1 = t$1.canonicalID();
					if (null != e$1 && null != r$1) {
						if ("Point" === t$1.geometryType()) return function(t$2, e$2, r$2) {
							const n$1 = [];
							for (const r$3 of t$2) for (const t$3 of r$3) n$1.push(Qn(t$3, e$2));
							const i$1 = new Cn(n$1[0][1], "meters");
							return "Point" === r$2.type || "MultiPoint" === r$2.type || "LineString" === r$2.type ? pi(n$1, !1, "Point" === r$2.type ? [r$2.coordinates] : r$2.coordinates, "LineString" === r$2.type, i$1) : "MultiLineString" === r$2.type ? di(n$1, !1, r$2.coordinates, i$1) : "Polygon" === r$2.type || "MultiPolygon" === r$2.type ? fi(n$1, !1, "Polygon" === r$2.type ? [r$2.coordinates] : r$2.coordinates, i$1) : null;
						}(e$1, r$1, this.geometries);
						if ("LineString" === t$1.geometryType()) return function(t$2, e$2, r$2) {
							const n$1 = [];
							for (const r$3 of t$2) {
								const t$3 = [];
								for (const n$2 of r$3) t$3.push(Qn(n$2, e$2));
								n$1.push(t$3);
							}
							const i$1 = new Cn(n$1[0][0][1], "meters");
							if ("Point" === r$2.type || "MultiPoint" === r$2.type || "LineString" === r$2.type) return di("Point" === r$2.type ? [r$2.coordinates] : r$2.coordinates, "LineString" === r$2.type, n$1, i$1);
							if ("MultiLineString" === r$2.type) {
								let t$3 = Infinity;
								for (let e$3 = 0; e$3 < r$2.coordinates.length; e$3++) {
									const s$1 = di(r$2.coordinates[e$3], !0, n$1, i$1, t$3);
									if (isNaN(s$1)) return s$1;
									if (0 === (t$3 = Math.min(t$3, s$1))) return t$3;
								}
								return t$3;
							}
							if ("Polygon" === r$2.type || "MultiPolygon" === r$2.type) {
								let t$3 = Infinity;
								for (let e$3 = 0; e$3 < n$1.length; e$3++) {
									const s$1 = fi(n$1[e$3], !0, "Polygon" === r$2.type ? [r$2.coordinates] : r$2.coordinates, i$1, t$3);
									if (isNaN(s$1)) return s$1;
									if (0 === (t$3 = Math.min(t$3, s$1))) return t$3;
								}
								return t$3;
							}
							return null;
						}(e$1, r$1, this.geometries);
						if ("Polygon" === t$1.geometryType()) return function(t$2, e$2, r$2) {
							const n$1 = [];
							for (const r$3 of function(t$3, e$3) {
								const r$4 = t$3.length;
								if (r$4 <= 1) return [t$3];
								const n$2 = [];
								let i$2, s$1;
								for (let e$4 = 0; e$4 < r$4; e$4++) {
									const r$5 = hn(t$3[e$4]);
									0 !== r$5 && (t$3[e$4].area = Math.abs(r$5), void 0 === s$1 && (s$1 = r$5 < 0), s$1 === r$5 < 0 ? (i$2 && n$2.push(i$2), i$2 = [t$3[e$4]]) : i$2.push(t$3[e$4]));
								}
								return i$2 && n$2.push(i$2), n$2;
							}(t$2)) {
								const t$3 = [];
								for (let n$2 = 0; n$2 < r$3.length; ++n$2) t$3.push(ti(r$3[n$2], e$2));
								n$1.push(t$3);
							}
							const i$1 = new Cn(n$1[0][0][0][1], "meters");
							if ("Point" === r$2.type || "MultiPoint" === r$2.type || "LineString" === r$2.type) return fi("Point" === r$2.type ? [r$2.coordinates] : r$2.coordinates, "LineString" === r$2.type, n$1, i$1);
							if ("MultiLineString" === r$2.type) {
								let t$3 = Infinity;
								for (let e$3 = 0; e$3 < r$2.coordinates.length; e$3++) {
									const s$1 = fi(r$2.coordinates[e$3], !0, n$1, i$1, t$3);
									if (isNaN(s$1)) return s$1;
									if (0 === (t$3 = Math.min(t$3, s$1))) return t$3;
								}
								return t$3;
							}
							return "Polygon" === r$2.type || "MultiPolygon" === r$2.type ? function(t$3, e$3, r$3) {
								let n$2 = Infinity;
								for (const i$2 of t$3) for (const t$4 of e$3) {
									const e$4 = ui(i$2, t$4, r$3, n$2);
									if (isNaN(e$4)) return e$4;
									if (0 === (n$2 = Math.min(n$2, e$4))) return n$2;
								}
								return n$2;
							}("Polygon" === r$2.type ? [r$2.coordinates] : r$2.coordinates, n$1, i$1) : null;
						}(e$1, r$1, this.geometries);
						console.warn("Distance Expression: currently only evaluates valid Point/LineString/Polygon geometries.");
					} else console.warn("Distance Expression: requirs valid feature and canonical information.");
					return null;
				}
				eachChild() {}
				outputDefined() {
					return !0;
				}
				serialize() {
					return ["distance", this.geojson];
				}
			}
			function gi(t$1) {
				if (t$1 instanceof sn) {
					if ("get" === t$1.name && 1 === t$1.args.length) return !1;
					if ("feature-state" === t$1.name) return !1;
					if ("has" === t$1.name && 1 === t$1.args.length) return !1;
					if ("properties" === t$1.name || "geometry-type" === t$1.name || "id" === t$1.name) return !1;
					if (/^filter-/.test(t$1.name)) return !1;
				}
				if (t$1 instanceof zn) return !1;
				if (t$1 instanceof yi) return !1;
				if (t$1 instanceof Ai) return t$1.featureConstant;
				let e$1 = !0;
				return t$1.eachChild(((t$2) => {
					e$1 && !gi(t$2) && (e$1 = !1);
				})), e$1;
			}
			function xi(t$1) {
				if (t$1 instanceof sn && "feature-state" === t$1.name) return !1;
				let e$1 = !0;
				return t$1.eachChild(((t$2) => {
					e$1 && !xi(t$2) && (e$1 = !1);
				})), e$1;
			}
			function vi(t$1, e$1) {
				if (t$1 instanceof sn && e$1.indexOf(t$1.name) >= 0) return !1;
				let r$1 = !0;
				return t$1.eachChild(((t$2) => {
					r$1 && !vi(t$2, e$1) && (r$1 = !1);
				})), r$1;
			}
			function bi(t$1, e$1, r$1) {
				return [
					t$1,
					e$1,
					r$1
				].filter(Boolean).join("");
			}
			function wi(t$1, e$1) {
				switch (t$1) {
					case "string": return jr(e$1);
					case "number": return +e$1;
					case "boolean": return !!e$1;
					case "color": return lr.parse(e$1);
					case "formatted": return Dr.fromString(jr(e$1));
					case "resolvedImage": return Lr.build(jr(e$1));
				}
				return e$1;
			}
			function _i(t$1, e$1, r$1, n$1) {
				return void 0 !== n$1 && (t$1 = n$1 * Math.round(t$1 / n$1)), void 0 !== e$1 && t$1 < e$1 && (t$1 = e$1), void 0 !== r$1 && t$1 > r$1 && (t$1 = r$1), t$1;
			}
			class Ai {
				constructor(t$1, e$1, r$1, n$1 = !1) {
					this.type = t$1, this.key = e$1, this.scope = r$1, this.featureConstant = n$1;
				}
				static parse(t$1, e$1) {
					let r$1 = e$1.expectedType;
					if (r$1 ??= Ar, t$1.length < 2 || t$1.length > 3) return e$1.error("Invalid number of arguments for 'config' expression.");
					const n$1 = e$1.parse(t$1[1], 1);
					if (!(n$1 instanceof $r)) return e$1.error("Key name of 'config' expression must be a string literal.");
					let i$1, s$1 = !0;
					const o$1 = jr(n$1.value);
					if (t$1.length >= 3) {
						const r$2 = e$1.parse(t$1[2], 2);
						if (!(r$2 instanceof $r)) return e$1.error("Scope of 'config' expression must be a string literal.");
						i$1 = jr(r$2.value);
					}
					if (e$1.options) {
						const t$2 = bi(o$1, i$1, e$1._scope), r$2 = e$1.options.get(t$2);
						r$2 && (s$1 = gi(r$2.value || r$2.default));
					}
					return new Ai(r$1, o$1, i$1, s$1);
				}
				evaluate(t$1) {
					const e$1 = bi(this.key, this.scope, t$1.scope), r$1 = t$1.getConfig(e$1);
					if (!r$1) return null;
					const { type: n$1, value: i$1, values: s$1, minValue: o$1, maxValue: a$1, stepValue: l$1 } = r$1, u$1 = r$1.default.evaluate(t$1);
					let c$1 = u$1;
					if (i$1) {
						const e$2 = t$1.scope;
						t$1.scope = (e$2 || "").split("").slice(1).join(""), c$1 = i$1.evaluate(t$1), t$1.scope = e$2;
					}
					return n$1 && (c$1 = wi(n$1, c$1)), void 0 === c$1 || void 0 === o$1 && void 0 === a$1 && void 0 === l$1 || ("number" == typeof c$1 ? c$1 = _i(c$1, o$1, a$1, l$1) : Array.isArray(c$1) && (c$1 = c$1.map(((t$2) => "number" == typeof t$2 ? _i(t$2, o$1, a$1, l$1) : t$2)))), void 0 !== i$1 && void 0 !== c$1 && s$1 && !s$1.includes(c$1) && (c$1 = u$1, n$1 && (c$1 = wi(n$1, c$1))), (n$1 && n$1 !== this.type || void 0 !== c$1 && !Vr(Nr(c$1), this.type)) && (c$1 = wi(this.type.kind, c$1)), c$1;
				}
				eachChild() {}
				outputDefined() {
					return !1;
				}
				serialize() {
					const t$1 = ["config", this.key];
					return this.scope && t$1.concat(this.scope), t$1;
				}
			}
			class Ii {
				constructor(t$1, e$1) {
					this.type = e$1.type, this.name = t$1, this.boundExpression = e$1;
				}
				static parse(t$1, e$1) {
					if (2 !== t$1.length || "string" != typeof t$1[1]) return e$1.error("'var' expression requires exactly one string literal argument.");
					const r$1 = t$1[1];
					return e$1.scope.has(r$1) ? new Ii(r$1, e$1.scope.get(r$1)) : e$1.error(`Unknown variable "${r$1}". Make sure "${r$1}" has been bound in an enclosing "let" expression before using it.`, 1);
				}
				evaluate(t$1) {
					return this.boundExpression.evaluate(t$1);
				}
				eachChild() {}
				outputDefined() {
					return !1;
				}
				serialize() {
					return ["var", this.name];
				}
			}
			class Mi {
				constructor(t$1, e$1 = [], r$1, n$1 = new yr(), i$1 = [], s$1, o$1, a$1) {
					this.registry = t$1, this.path = e$1, this.key = e$1.map(((t$2) => "string" == typeof t$2 ? `['${t$2}']` : `[${t$2}]`)).join(""), this.scope = n$1, this.errors = i$1, this.expectedType = r$1, this._scope = s$1, this.options = o$1, this.iconImageUseTheme = a$1;
				}
				parse(t$1, e$1, r$1, n$1, i$1 = {}) {
					return e$1 || r$1 ? this.concat(e$1, null, r$1, n$1)._parse(t$1, i$1) : this._parse(t$1, i$1);
				}
				parseObjectValue(t$1, e$1, r$1, n$1, i$1, s$1 = {}) {
					return this.concat(e$1, r$1, n$1, i$1)._parse(t$1, s$1);
				}
				_parse(t$1, e$1) {
					function r$1(t$2, e$2, r$2) {
						return "assert" === r$2 ? new Hr(e$2, [t$2]) : "coerce" === r$2 ? new en(e$2, [t$2]) : t$2;
					}
					if (null !== t$1 && "string" != typeof t$1 && "boolean" != typeof t$1 && "number" != typeof t$1 || (t$1 = ["literal", t$1]), Array.isArray(t$1)) {
						if (0 === t$1.length) return this.error("Expected an array with at least one element. If you wanted a literal array, use [\"literal\", []].");
						const n$1 = "string" == typeof t$1[0] ? this.registry[t$1[0]] : void 0;
						if (n$1) {
							let i$1 = n$1.parse(t$1, this);
							if (!i$1) return null;
							if (this.expectedType) {
								const t$2 = this.expectedType, n$2 = i$1.type;
								if ("string" !== t$2.kind && "number" !== t$2.kind && "boolean" !== t$2.kind && "object" !== t$2.kind && "array" !== t$2.kind || "value" !== n$2.kind) if ("color" !== t$2.kind && "formatted" !== t$2.kind && "resolvedImage" !== t$2.kind || "value" !== n$2.kind && "string" !== n$2.kind) {
									if (this.checkSubtype(t$2, n$2)) return null;
								} else i$1 = r$1(i$1, t$2, e$1.typeAnnotation || "coerce");
								else i$1 = r$1(i$1, t$2, e$1.typeAnnotation || "assert");
							}
							if (!(i$1 instanceof $r) && "resolvedImage" !== i$1.type.kind && Si(i$1)) {
								const t$2 = new nn(this._scope, this.options, this.iconImageUseTheme);
								try {
									i$1 = new $r(i$1.type, i$1.evaluate(t$2));
								} catch (t$3) {
									return this.error(t$3.message), null;
								}
							}
							return i$1;
						}
						return en.parse(["to-array", t$1], this);
					}
					return this.error(void 0 === t$1 ? "'undefined' value invalid. Use null instead." : "object" == typeof t$1 ? "Bare objects invalid. Use [\"literal\", {...}] instead." : `Expected an array, but found ${typeof t$1} instead.`);
				}
				concat(t$1, e$1, r$1, n$1) {
					let i$1 = "number" == typeof t$1 ? this.path.concat(t$1) : this.path;
					i$1 = "string" == typeof e$1 ? i$1.concat(e$1) : i$1;
					const s$1 = n$1 ? this.scope.concat(n$1) : this.scope;
					return new Mi(this.registry, i$1, r$1 || null, s$1, this.errors, this._scope, this.options, this.iconImageUseTheme);
				}
				error(t$1, ...e$1) {
					const r$1 = `${this.key}${e$1.map(((t$2) => `[${t$2}]`)).join("")}`;
					this.errors.push(new mr(r$1, t$1));
				}
				checkSubtype(t$1, e$1) {
					const r$1 = zr(t$1, e$1);
					return r$1 && this.error(r$1), r$1;
				}
			}
			function Si(t$1) {
				if (t$1 instanceof Ii) return Si(t$1.boundExpression);
				if (t$1 instanceof sn && "error" === t$1.name) return !1;
				if (t$1 instanceof an) return !1;
				if (t$1 instanceof zn) return !1;
				if (t$1 instanceof yi) return !1;
				if (t$1 instanceof Ai) return !1;
				const e$1 = t$1 instanceof en || t$1 instanceof Hr;
				let r$1 = !0;
				return t$1.eachChild(((t$2) => {
					r$1 = e$1 ? r$1 && Si(t$2) : r$1 && t$2 instanceof $r;
				})), !!r$1 && gi(t$1) && vi(t$1, [
					"zoom",
					"heatmap-density",
					"worldview",
					"line-progress",
					"raster-value",
					"sky-radial-progress",
					"accumulated",
					"is-supported-script",
					"pitch",
					"distance-from-center",
					"measure-light",
					"raster-particle-speed"
				]);
			}
			function Pi(t$1, e$1) {
				const r$1 = t$1.length - 1;
				let n$1, i$1, s$1 = 0, o$1 = r$1, a$1 = 0;
				for (; s$1 <= o$1;) if (a$1 = Math.floor((s$1 + o$1) / 2), n$1 = t$1[a$1], i$1 = t$1[a$1 + 1], n$1 <= e$1) {
					if (a$1 === r$1 || e$1 < i$1) return a$1;
					s$1 = a$1 + 1;
				} else {
					if (!(n$1 > e$1)) throw new Gr("Input is not a number.");
					o$1 = a$1 - 1;
				}
				return 0;
			}
			class ki {
				constructor(t$1, e$1, r$1) {
					this.type = t$1, this.input = e$1, this.labels = [], this.outputs = [];
					for (const [t$2, e$2] of r$1) this.labels.push(t$2), this.outputs.push(e$2);
				}
				static parse(t$1, e$1) {
					if (t$1.length - 1 < 4) return e$1.error(`Expected at least 4 arguments, but found only ${t$1.length - 1}.`);
					if ((t$1.length - 1) % 2 != 0) return e$1.error("Expected an even number of arguments.");
					const r$1 = e$1.parse(t$1[1], 1, xr);
					if (!r$1) return null;
					const n$1 = [];
					let i$1 = null;
					e$1.expectedType && "value" !== e$1.expectedType.kind && (i$1 = e$1.expectedType);
					for (let r$2 = 1; r$2 < t$1.length; r$2 += 2) {
						const s$1 = 1 === r$2 ? -Infinity : t$1[r$2], o$1 = t$1[r$2 + 1], a$1 = r$2, l$1 = r$2 + 1;
						if ("number" != typeof s$1) return e$1.error("Input/output pairs for \"step\" expressions must be defined using literal numeric values (not computed expressions) for the input values.", a$1);
						if (n$1.length && n$1[n$1.length - 1][0] >= s$1) return e$1.error("Input/output pairs for \"step\" expressions must be arranged with input values in strictly ascending order.", a$1);
						const u$1 = e$1.parse(o$1, l$1, i$1);
						if (!u$1) return null;
						i$1 = i$1 || u$1.type, n$1.push([s$1, u$1]);
					}
					return new ki(i$1, r$1, n$1);
				}
				evaluate(t$1) {
					const e$1 = this.labels, r$1 = this.outputs;
					if (1 === e$1.length) return r$1[0].evaluate(t$1);
					const n$1 = this.input.evaluate(t$1);
					if (n$1 <= e$1[0]) return r$1[0].evaluate(t$1);
					const i$1 = e$1.length;
					return n$1 >= e$1[i$1 - 1] ? r$1[i$1 - 1].evaluate(t$1) : r$1[Pi(e$1, n$1)].evaluate(t$1);
				}
				eachChild(t$1) {
					t$1(this.input);
					for (const e$1 of this.outputs) t$1(e$1);
				}
				outputDefined() {
					return this.outputs.every(((t$1) => t$1.outputDefined()));
				}
				serialize() {
					const t$1 = ["step", this.input.serialize()];
					for (let e$1 = 0; e$1 < this.labels.length; e$1++) e$1 > 0 && t$1.push(this.labels[e$1]), t$1.push(this.outputs[e$1].serialize());
					return t$1;
				}
			}
			const Bi = .95047, zi = 1.08883, Ti = 4 / 29, Ei = 6 / 29, Vi = 3 * Ei * Ei, Fi = Ei * Ei * Ei, Ci = Math.PI / 180, Di = 180 / Math.PI;
			function Ri(t$1) {
				return t$1 > Fi ? Math.pow(t$1, 1 / 3) : t$1 / Vi + Ti;
			}
			function Li(t$1) {
				return t$1 > Ei ? t$1 * t$1 * t$1 : Vi * (t$1 - Ti);
			}
			function Oi(t$1) {
				return 255 * (t$1 <= .0031308 ? 12.92 * t$1 : 1.055 * Math.pow(t$1, 1 / 2.4) - .055);
			}
			function Ui(t$1) {
				return (t$1 /= 255) <= .04045 ? t$1 / 12.92 : Math.pow((t$1 + .055) / 1.055, 2.4);
			}
			function Ni(t$1) {
				const e$1 = Ui(t$1.r), r$1 = Ui(t$1.g), n$1 = Ui(t$1.b), i$1 = Ri((.4124564 * e$1 + .3575761 * r$1 + .1804375 * n$1) / Bi), s$1 = Ri((.2126729 * e$1 + .7151522 * r$1 + .072175 * n$1) / 1);
				return {
					l: 116 * s$1 - 16,
					a: 500 * (i$1 - s$1),
					b: 200 * (s$1 - Ri((.0193339 * e$1 + .119192 * r$1 + .9503041 * n$1) / zi)),
					alpha: t$1.a
				};
			}
			function ji(t$1) {
				let e$1 = (t$1.l + 16) / 116, r$1 = isNaN(t$1.a) ? e$1 : e$1 + t$1.a / 500, n$1 = isNaN(t$1.b) ? e$1 : e$1 - t$1.b / 200;
				return e$1 = 1 * Li(e$1), r$1 = Bi * Li(r$1), n$1 = zi * Li(n$1), new lr(Oi(3.2404542 * r$1 - 1.5371385 * e$1 - .4985314 * n$1), Oi(-.969266 * r$1 + 1.8760108 * e$1 + .041556 * n$1), Oi(.0556434 * r$1 - .2040259 * e$1 + 1.0572252 * n$1), t$1.alpha);
			}
			function $i(t$1, e$1, r$1) {
				const n$1 = e$1 - t$1;
				return t$1 + r$1 * (n$1 > 180 || n$1 < -180 ? n$1 - 360 * Math.round(n$1 / 360) : n$1);
			}
			const Gi = {
				forward: Ni,
				reverse: ji,
				interpolate: function(t$1, e$1, r$1) {
					return {
						l: pr(t$1.l, e$1.l, r$1),
						a: pr(t$1.a, e$1.a, r$1),
						b: pr(t$1.b, e$1.b, r$1),
						alpha: pr(t$1.alpha, e$1.alpha, r$1)
					};
				}
			}, qi = {
				forward: function(t$1) {
					const { l: e$1, a: r$1, b: n$1 } = Ni(t$1), i$1 = Math.atan2(n$1, r$1) * Di;
					return {
						h: i$1 < 0 ? i$1 + 360 : i$1,
						c: Math.sqrt(r$1 * r$1 + n$1 * n$1),
						l: e$1,
						alpha: t$1.a
					};
				},
				reverse: function(t$1) {
					const e$1 = t$1.h * Ci, r$1 = t$1.c;
					return ji({
						l: t$1.l,
						a: Math.cos(e$1) * r$1,
						b: Math.sin(e$1) * r$1,
						alpha: t$1.alpha
					});
				},
				interpolate: function(t$1, e$1, r$1) {
					return {
						h: $i(t$1.h, e$1.h, r$1),
						c: pr(t$1.c, e$1.c, r$1),
						l: pr(t$1.l, e$1.l, r$1),
						alpha: pr(t$1.alpha, e$1.alpha, r$1)
					};
				}
			};
			var Hi = Object.freeze({
				__proto__: null,
				hcl: qi,
				lab: Gi
			});
			class Xi {
				constructor(t$1, e$1, r$1, n$1, i$1) {
					this.type = t$1, this.operator = e$1, this.interpolation = r$1, this.input = n$1, this.labels = [], this.outputs = [];
					for (const [t$2, e$2] of i$1) this.labels.push(t$2), this.outputs.push(e$2);
				}
				static interpolationFactor(t$1, e$1, r$1, n$1) {
					let i$1 = 0;
					if ("exponential" === t$1.name) i$1 = Zi(e$1, t$1.base, r$1, n$1);
					else if ("linear" === t$1.name) i$1 = Zi(e$1, 1, r$1, n$1);
					else if ("cubic-bezier" === t$1.name) {
						const s$1 = t$1.controlPoints;
						i$1 = new At(s$1[0], s$1[1], s$1[2], s$1[3]).solve(Zi(e$1, 1, r$1, n$1));
					}
					return i$1;
				}
				static parse(t$1, e$1) {
					let [r$1, n$1, i$1, ...s$1] = t$1;
					if (!Array.isArray(n$1) || 0 === n$1.length) return e$1.error("Expected an interpolation type expression.", 1);
					if ("linear" === n$1[0]) n$1 = { name: "linear" };
					else if ("exponential" === n$1[0]) {
						const t$2 = n$1[1];
						if ("number" != typeof t$2) return e$1.error("Exponential interpolation requires a numeric base.", 1, 1);
						n$1 = {
							name: "exponential",
							base: t$2
						};
					} else {
						if ("cubic-bezier" !== n$1[0]) return e$1.error(`Unknown interpolation type ${String(n$1[0])}`, 1, 0);
						{
							const t$2 = n$1.slice(1);
							if (4 !== t$2.length || t$2.some(((t$3) => "number" != typeof t$3 || t$3 < 0 || t$3 > 1))) return e$1.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
							n$1 = {
								name: "cubic-bezier",
								controlPoints: t$2
							};
						}
					}
					if (t$1.length - 1 < 4) return e$1.error(`Expected at least 4 arguments, but found only ${t$1.length - 1}.`);
					if (t$1.length - 1 > 3 && (t$1.length - 1) % 2 != 0) return e$1.error("Expected an even number of arguments.");
					if (i$1 = e$1.parse(i$1, 2, xr), !i$1) return null;
					const o$1 = [];
					let a$1 = null;
					"interpolate-hcl" === r$1 || "interpolate-lab" === r$1 ? a$1 = wr : e$1.expectedType && "value" !== e$1.expectedType.kind && (a$1 = e$1.expectedType);
					for (let t$2 = 0; t$2 < s$1.length; t$2 += 2) {
						const r$2 = s$1[t$2], n$2 = s$1[t$2 + 1], i$2 = t$2 + 3, l$1 = t$2 + 4;
						if ("number" != typeof r$2) return e$1.error("Input/output pairs for \"interpolate\" expressions must be defined using literal numeric values (not computed expressions) for the input values.", i$2);
						if (o$1.length && o$1[o$1.length - 1][0] >= r$2) return e$1.error("Input/output pairs for \"interpolate\" expressions must be arranged with input values in strictly ascending order.", i$2);
						const u$1 = e$1.parse(n$2, l$1, a$1);
						if (!u$1) return null;
						a$1 = a$1 || u$1.type, o$1.push([r$2, u$1]);
					}
					return "number" === a$1.kind || "color" === a$1.kind || "array" === a$1.kind && "number" === a$1.itemType.kind && "number" == typeof a$1.N ? new Xi(a$1, r$1, n$1, i$1, o$1) : e$1.error(`Type ${kr(a$1)} is not interpolatable.`);
				}
				evaluate(t$1) {
					const e$1 = this.labels, r$1 = this.outputs;
					if (1 === e$1.length) return r$1[0].evaluate(t$1);
					const n$1 = this.input.evaluate(t$1);
					if (n$1 <= e$1[0]) return r$1[0].evaluate(t$1);
					const i$1 = e$1.length;
					if (n$1 >= e$1[i$1 - 1]) return r$1[i$1 - 1].evaluate(t$1);
					const s$1 = Pi(e$1, n$1), o$1 = Xi.interpolationFactor(this.interpolation, n$1, e$1[s$1], e$1[s$1 + 1]), a$1 = r$1[s$1].evaluate(t$1), l$1 = r$1[s$1 + 1].evaluate(t$1);
					return "interpolate" === this.operator ? fr[this.type.kind.toLowerCase()](a$1, l$1, o$1) : "interpolate-hcl" === this.operator ? qi.reverse(qi.interpolate(qi.forward(a$1), qi.forward(l$1), o$1)) : Gi.reverse(Gi.interpolate(Gi.forward(a$1), Gi.forward(l$1), o$1));
				}
				eachChild(t$1) {
					t$1(this.input);
					for (const e$1 of this.outputs) t$1(e$1);
				}
				outputDefined() {
					return this.outputs.every(((t$1) => t$1.outputDefined()));
				}
				serialize() {
					let t$1;
					t$1 = "linear" === this.interpolation.name ? ["linear"] : "exponential" === this.interpolation.name ? 1 === this.interpolation.base ? ["linear"] : ["exponential", this.interpolation.base] : ["cubic-bezier", ...this.interpolation.controlPoints];
					const e$1 = [
						this.operator,
						t$1,
						this.input.serialize()
					];
					for (let t$2 = 0; t$2 < this.labels.length; t$2++) e$1.push(this.labels[t$2], this.outputs[t$2].serialize());
					return e$1;
				}
			}
			function Zi(t$1, e$1, r$1, n$1) {
				const i$1 = n$1 - r$1, s$1 = t$1 - r$1;
				return 0 === i$1 ? 0 : 1 === e$1 ? s$1 / i$1 : (Math.pow(e$1, s$1) - 1) / (Math.pow(e$1, i$1) - 1);
			}
			class Wi {
				constructor(t$1, e$1) {
					this.type = t$1, this.args = e$1;
				}
				static parse(t$1, e$1) {
					if (t$1.length < 2) return e$1.error("Expectected at least one argument.");
					let r$1 = null;
					const n$1 = e$1.expectedType;
					n$1 && "value" !== n$1.kind && (r$1 = n$1);
					const i$1 = [];
					for (const n$2 of t$1.slice(1)) {
						const t$2 = e$1.parse(n$2, 1 + i$1.length, r$1, void 0, { typeAnnotation: "omit" });
						if (!t$2) return null;
						r$1 = r$1 || t$2.type, i$1.push(t$2);
					}
					return new Wi(n$1 && i$1.some(((t$2) => zr(n$1, t$2.type))) ? Ar : r$1, i$1);
				}
				evaluate(t$1) {
					let e$1, r$1 = null, n$1 = 0;
					for (const i$1 of this.args) {
						if (n$1++, r$1 = i$1.evaluate(t$1), r$1 && r$1 instanceof Lr && !r$1.available && (e$1 || (e$1 = r$1), r$1 = null, n$1 === this.args.length)) return e$1;
						if (null !== r$1) break;
					}
					return r$1;
				}
				eachChild(t$1) {
					this.args.forEach(t$1);
				}
				outputDefined() {
					return this.args.every(((t$1) => t$1.outputDefined()));
				}
				serialize() {
					const t$1 = ["coalesce"];
					return this.eachChild(((e$1) => {
						t$1.push(e$1.serialize());
					})), t$1;
				}
			}
			class Yi {
				constructor(t$1, e$1) {
					this.type = e$1.type, this.bindings = [].concat(t$1), this.result = e$1;
				}
				evaluate(t$1) {
					return this.result.evaluate(t$1);
				}
				eachChild(t$1) {
					for (const e$1 of this.bindings) t$1(e$1[1]);
					t$1(this.result);
				}
				static parse(t$1, e$1) {
					if (t$1.length < 4) return e$1.error(`Expected at least 3 arguments, but found ${t$1.length - 1} instead.`);
					const r$1 = [];
					for (let n$2 = 1; n$2 < t$1.length - 1; n$2 += 2) {
						const i$1 = t$1[n$2];
						if ("string" != typeof i$1) return e$1.error(`Expected string, but found ${typeof i$1} instead.`, n$2);
						if (/[^a-zA-Z0-9_]/.test(i$1)) return e$1.error("Variable names must contain only alphanumeric characters or '_'.", n$2);
						const s$1 = e$1.parse(t$1[n$2 + 1], n$2 + 1);
						if (!s$1) return null;
						r$1.push([i$1, s$1]);
					}
					const n$1 = e$1.parse(t$1[t$1.length - 1], t$1.length - 1, e$1.expectedType, r$1);
					return n$1 ? new Yi(r$1, n$1) : null;
				}
				outputDefined() {
					return this.result.outputDefined();
				}
				serialize() {
					const t$1 = ["let"];
					for (const [e$1, r$1] of this.bindings) t$1.push(e$1, r$1.serialize());
					return t$1.push(this.result.serialize()), t$1;
				}
			}
			class Ki {
				constructor(t$1, e$1, r$1) {
					this.type = t$1, this.index = e$1, this.input = r$1;
				}
				static parse(t$1, e$1) {
					if (3 !== t$1.length) return e$1.error(`Expected 2 arguments, but found ${t$1.length - 1} instead.`);
					const r$1 = e$1.parse(t$1[1], 1, xr), n$1 = e$1.parse(t$1[2], 2, Pr(e$1.expectedType || Ar));
					return r$1 && n$1 ? new Ki(n$1.type.itemType, r$1, n$1) : null;
				}
				evaluate(t$1) {
					const e$1 = this.index.evaluate(t$1), r$1 = this.input.evaluate(t$1);
					if (e$1 < 0) throw new Gr("Array index out of bounds: negative index");
					if (e$1 >= r$1.length) throw new Gr("Array index out of bounds: index exceeds array size");
					if (e$1 !== Math.floor(e$1)) throw new Gr("Array index must be an integer. Use at-interpolated for fractional indices");
					return r$1[e$1];
				}
				eachChild(t$1) {
					t$1(this.index), t$1(this.input);
				}
				outputDefined() {
					return !1;
				}
				serialize() {
					return [
						"at",
						this.index.serialize(),
						this.input.serialize()
					];
				}
			}
			class Ji {
				constructor(t$1, e$1, r$1) {
					this.type = t$1, this.index = e$1, this.input = r$1;
				}
				static parse(t$1, e$1) {
					if (3 !== t$1.length) return e$1.error(`Expected 2 arguments, but found ${t$1.length - 1} instead.`);
					const r$1 = e$1.parse(t$1[1], 1, xr), n$1 = e$1.parse(t$1[2], 2, Pr(e$1.expectedType || Ar));
					return r$1 && n$1 ? new Ji(n$1.type.itemType, r$1, n$1) : null;
				}
				evaluate(t$1) {
					const e$1 = this.index.evaluate(t$1), r$1 = this.input.evaluate(t$1);
					if (e$1 < 0) throw new Gr(`Array index out of bounds: ${e$1} < 0.`);
					if (e$1 > r$1.length - 1) throw new Gr(`Array index out of bounds: ${e$1} > ${r$1.length - 1}.`);
					if (e$1 === Math.floor(e$1)) return r$1[e$1];
					const n$1 = Math.floor(e$1), i$1 = Math.ceil(e$1), s$1 = r$1[n$1], o$1 = r$1[i$1];
					if ("number" != typeof s$1 || "number" != typeof o$1) throw new Gr(`Cannot interpolate between non-number values at index ${e$1}.`);
					const a$1 = e$1 - n$1;
					return s$1 * (1 - a$1) + o$1 * a$1;
				}
				eachChild(t$1) {
					t$1(this.index), t$1(this.input);
				}
				outputDefined() {
					return !1;
				}
				serialize() {
					return [
						"at-interpolated",
						this.index.serialize(),
						this.input.serialize()
					];
				}
			}
			class Qi {
				constructor(t$1, e$1) {
					this.type = br, this.needle = t$1, this.haystack = e$1;
				}
				static parse(t$1, e$1) {
					if (3 !== t$1.length) return e$1.error(`Expected 2 arguments, but found ${t$1.length - 1} instead.`);
					const r$1 = e$1.parse(t$1[1], 1, Ar), n$1 = e$1.parse(t$1[2], 2, Ar);
					return r$1 && n$1 ? Tr(r$1.type, [
						br,
						vr,
						xr,
						gr,
						Ar
					]) ? new Qi(r$1, n$1) : e$1.error(`Expected first argument to be of type boolean, string, number or null, but found ${kr(r$1.type)} instead`) : null;
				}
				evaluate(t$1) {
					const e$1 = this.needle.evaluate(t$1), r$1 = this.haystack.evaluate(t$1);
					if (null == r$1) return !1;
					if (!Er(e$1, [
						"boolean",
						"string",
						"number",
						"null"
					])) throw new Gr(`Expected first argument to be of type boolean, string, number or null, but found ${kr(Nr(e$1))} instead.`);
					if (!Er(r$1, ["string", "array"])) throw new Gr(`Expected second argument to be of type array or string, but found ${kr(Nr(r$1))} instead.`);
					return r$1.indexOf(e$1) >= 0;
				}
				eachChild(t$1) {
					t$1(this.needle), t$1(this.haystack);
				}
				outputDefined() {
					return !0;
				}
				serialize() {
					return [
						"in",
						this.needle.serialize(),
						this.haystack.serialize()
					];
				}
			}
			class ts {
				constructor(t$1, e$1, r$1) {
					this.type = xr, this.needle = t$1, this.haystack = e$1, this.fromIndex = r$1;
				}
				static parse(t$1, e$1) {
					if (t$1.length <= 2 || t$1.length >= 5) return e$1.error(`Expected 3 or 4 arguments, but found ${t$1.length - 1} instead.`);
					const r$1 = e$1.parse(t$1[1], 1, Ar), n$1 = e$1.parse(t$1[2], 2, Ar);
					if (!r$1 || !n$1) return null;
					if (!Tr(r$1.type, [
						br,
						vr,
						xr,
						gr,
						Ar
					])) return e$1.error(`Expected first argument to be of type boolean, string, number or null, but found ${kr(r$1.type)} instead`);
					if (4 === t$1.length) {
						const i$1 = e$1.parse(t$1[3], 3, xr);
						return i$1 ? new ts(r$1, n$1, i$1) : null;
					}
					return new ts(r$1, n$1);
				}
				evaluate(t$1) {
					const e$1 = this.needle.evaluate(t$1), r$1 = this.haystack.evaluate(t$1);
					if (!Er(e$1, [
						"boolean",
						"string",
						"number",
						"null"
					])) throw new Gr(`Expected first argument to be of type boolean, string, number or null, but found ${kr(Nr(e$1))} instead.`);
					if (!Er(r$1, ["string", "array"])) throw new Gr(`Expected second argument to be of type array or string, but found ${kr(Nr(r$1))} instead.`);
					if (this.fromIndex) {
						const n$1 = this.fromIndex.evaluate(t$1);
						return r$1.indexOf(e$1, n$1);
					}
					return r$1.indexOf(e$1);
				}
				eachChild(t$1) {
					t$1(this.needle), t$1(this.haystack), this.fromIndex && t$1(this.fromIndex);
				}
				outputDefined() {
					return !1;
				}
				serialize() {
					if (null != this.fromIndex && void 0 !== this.fromIndex) {
						const t$1 = this.fromIndex.serialize();
						return [
							"index-of",
							this.needle.serialize(),
							this.haystack.serialize(),
							t$1
						];
					}
					return [
						"index-of",
						this.needle.serialize(),
						this.haystack.serialize()
					];
				}
			}
			class es {
				constructor(t$1, e$1, r$1, n$1, i$1, s$1) {
					this.inputType = t$1, this.type = e$1, this.input = r$1, this.cases = n$1, this.outputs = i$1, this.otherwise = s$1;
				}
				static parse(t$1, e$1) {
					if (t$1.length < 5) return e$1.error(`Expected at least 4 arguments, but found only ${t$1.length - 1}.`);
					if (t$1.length % 2 != 1) return e$1.error("Expected an even number of arguments.");
					let r$1, n$1;
					e$1.expectedType && "value" !== e$1.expectedType.kind && (n$1 = e$1.expectedType);
					const i$1 = {}, s$1 = [];
					for (let o$2 = 2; o$2 < t$1.length - 1; o$2 += 2) {
						let a$2 = t$1[o$2];
						const l$1 = t$1[o$2 + 1];
						Array.isArray(a$2) || (a$2 = [a$2]);
						const u$1 = e$1.concat(o$2);
						if (0 === a$2.length) return u$1.error("Expected at least one branch label.");
						for (const t$2 of a$2) {
							if ("number" != typeof t$2 && "string" != typeof t$2) return u$1.error("Branch labels must be numbers or strings.");
							if ("number" == typeof t$2 && Math.abs(t$2) > Number.MAX_SAFE_INTEGER) return u$1.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
							if ("number" == typeof t$2 && Math.floor(t$2) !== t$2) return u$1.error("Numeric branch labels must be integer values.");
							if (r$1) {
								if (u$1.checkSubtype(r$1, Nr(t$2))) return null;
							} else r$1 = Nr(t$2);
							if (void 0 !== i$1[String(t$2)]) return u$1.error("Branch labels must be unique.");
							i$1[String(t$2)] = s$1.length;
						}
						const c$1 = e$1.parse(l$1, o$2, n$1);
						if (!c$1) return null;
						n$1 = n$1 || c$1.type, s$1.push(c$1);
					}
					const o$1 = e$1.parse(t$1[1], 1, Ar);
					if (!o$1) return null;
					const a$1 = e$1.parse(t$1[t$1.length - 1], t$1.length - 1, n$1);
					return a$1 ? "value" !== o$1.type.kind && e$1.concat(1).checkSubtype(r$1, o$1.type) ? null : new es(r$1, n$1, o$1, i$1, s$1, a$1) : null;
				}
				evaluate(t$1) {
					const e$1 = this.input.evaluate(t$1);
					return (Vr(Nr(e$1), this.inputType) && this.outputs[this.cases[e$1]] || this.otherwise).evaluate(t$1);
				}
				eachChild(t$1) {
					t$1(this.input), this.outputs.forEach(t$1), t$1(this.otherwise);
				}
				outputDefined() {
					return this.outputs.every(((t$1) => t$1.outputDefined())) && this.otherwise.outputDefined();
				}
				serialize() {
					const t$1 = ["match", this.input.serialize()], e$1 = Object.keys(this.cases).sort(), r$1 = [], n$1 = {};
					for (const t$2 of e$1) {
						const e$2 = n$1[this.cases[t$2]];
						void 0 === e$2 ? (n$1[this.cases[t$2]] = r$1.length, r$1.push([this.cases[t$2], [t$2]])) : r$1[e$2][1].push(t$2);
					}
					const i$1 = (t$2) => "number" === this.inputType.kind ? Number(t$2) : t$2;
					for (const [e$2, n$2] of r$1) t$1.push(1 === n$2.length ? i$1(n$2[0]) : n$2.map(i$1)), t$1.push(this.outputs[e$2].serialize());
					return t$1.push(this.otherwise.serialize()), t$1;
				}
			}
			class rs {
				constructor(t$1, e$1, r$1) {
					this.type = t$1, this.branches = e$1, this.otherwise = r$1;
				}
				static parse(t$1, e$1) {
					if (t$1.length < 4) return e$1.error(`Expected at least 3 arguments, but found only ${t$1.length - 1}.`);
					if (t$1.length % 2 != 0) return e$1.error("Expected an odd number of arguments.");
					let r$1;
					e$1.expectedType && "value" !== e$1.expectedType.kind && (r$1 = e$1.expectedType);
					const n$1 = [];
					for (let i$2 = 1; i$2 < t$1.length - 1; i$2 += 2) {
						const s$1 = e$1.parse(t$1[i$2], i$2, br);
						if (!s$1) return null;
						const o$1 = e$1.parse(t$1[i$2 + 1], i$2 + 1, r$1);
						if (!o$1) return null;
						n$1.push([s$1, o$1]), r$1 = r$1 || o$1.type;
					}
					const i$1 = e$1.parse(t$1[t$1.length - 1], t$1.length - 1, r$1);
					return i$1 ? new rs(r$1, n$1, i$1) : null;
				}
				evaluate(t$1) {
					for (const [e$1, r$1] of this.branches) if (e$1.evaluate(t$1)) return r$1.evaluate(t$1);
					return this.otherwise.evaluate(t$1);
				}
				eachChild(t$1) {
					for (const [e$1, r$1] of this.branches) t$1(e$1), t$1(r$1);
					t$1(this.otherwise);
				}
				outputDefined() {
					return this.branches.every((([t$1, e$1]) => e$1.outputDefined())) && this.otherwise.outputDefined();
				}
				serialize() {
					const t$1 = ["case"];
					return this.eachChild(((e$1) => {
						t$1.push(e$1.serialize());
					})), t$1;
				}
			}
			class ns {
				constructor(t$1, e$1, r$1, n$1) {
					this.type = t$1, this.input = e$1, this.beginIndex = r$1, this.endIndex = n$1;
				}
				static parse(t$1, e$1) {
					if (t$1.length <= 2 || t$1.length >= 5) return e$1.error(`Expected 3 or 4 arguments, but found ${t$1.length - 1} instead.`);
					const r$1 = e$1.parse(t$1[1], 1, Ar), n$1 = e$1.parse(t$1[2], 2, xr);
					if (!r$1 || !n$1) return null;
					if (!Tr(r$1.type, [
						Pr(Ar),
						vr,
						Ar
					])) return e$1.error(`Expected first argument to be of type array or string, but found ${kr(r$1.type)} instead`);
					if (4 === t$1.length) {
						const i$1 = e$1.parse(t$1[3], 3, xr);
						return i$1 ? new ns(r$1.type, r$1, n$1, i$1) : null;
					}
					return new ns(r$1.type, r$1, n$1);
				}
				evaluate(t$1) {
					const e$1 = this.input.evaluate(t$1), r$1 = this.beginIndex.evaluate(t$1);
					if (!Er(e$1, ["string", "array"])) throw new Gr(`Expected first argument to be of type array or string, but found ${kr(Nr(e$1))} instead.`);
					if (this.endIndex) {
						const n$1 = this.endIndex.evaluate(t$1);
						return e$1.slice(r$1, n$1);
					}
					return e$1.slice(r$1);
				}
				eachChild(t$1) {
					t$1(this.input), t$1(this.beginIndex), this.endIndex && t$1(this.endIndex);
				}
				outputDefined() {
					return !1;
				}
				serialize() {
					if (null != this.endIndex && void 0 !== this.endIndex) {
						const t$1 = this.endIndex.serialize();
						return [
							"slice",
							this.input.serialize(),
							this.beginIndex.serialize(),
							t$1
						];
					}
					return [
						"slice",
						this.input.serialize(),
						this.beginIndex.serialize()
					];
				}
			}
			class is {
				constructor(t$1, e$1) {
					this.type = Pr(vr), this.str = t$1, this.delimiter = e$1;
				}
				static parse(t$1, e$1) {
					if (3 !== t$1.length) return e$1.error(`Expected 2 arguments, but found ${t$1.length - 1} instead.`);
					const r$1 = e$1.parse(t$1[1], 1, vr), n$1 = e$1.parse(t$1[2], 2, vr);
					return r$1 && n$1 ? new is(r$1, n$1) : void 0;
				}
				evaluate(t$1) {
					const e$1 = this.str.evaluate(t$1), r$1 = this.delimiter.evaluate(t$1);
					return e$1.split(r$1);
				}
				eachChild(t$1) {
					t$1(this.str), t$1(this.delimiter);
				}
				outputDefined() {
					return !1;
				}
				serialize() {
					return [
						"split",
						this.str.serialize(),
						this.delimiter.serialize()
					];
				}
			}
			function ss(t$1, e$1) {
				return "==" === t$1 || "!=" === t$1 ? "boolean" === e$1.kind || "string" === e$1.kind || "number" === e$1.kind || "null" === e$1.kind || "value" === e$1.kind : "string" === e$1.kind || "number" === e$1.kind || "value" === e$1.kind;
			}
			function os(t$1, e$1, r$1, n$1) {
				return 0 === n$1.compare(e$1, r$1);
			}
			function as(t$1, e$1, r$1) {
				const n$1 = "==" !== t$1 && "!=" !== t$1;
				return class i$1 {
					constructor(t$2, e$2, r$2) {
						this.type = br, this.lhs = t$2, this.rhs = e$2, this.collator = r$2, this.hasUntypedArgument = "value" === t$2.type.kind || "value" === e$2.type.kind;
					}
					static parse(t$2, e$2) {
						if (3 !== t$2.length && 4 !== t$2.length) return e$2.error("Expected two or three arguments.");
						const r$2 = t$2[0];
						let s$1 = e$2.parse(t$2[1], 1, Ar);
						if (!s$1) return null;
						if (!ss(r$2, s$1.type)) return e$2.concat(1).error(`"${r$2}" comparisons are not supported for type '${kr(s$1.type)}'.`);
						let o$1 = e$2.parse(t$2[2], 2, Ar);
						if (!o$1) return null;
						if (!ss(r$2, o$1.type)) return e$2.concat(2).error(`"${r$2}" comparisons are not supported for type '${kr(o$1.type)}'.`);
						if (s$1.type.kind !== o$1.type.kind && "value" !== s$1.type.kind && "value" !== o$1.type.kind) return e$2.error(`Cannot compare types '${kr(s$1.type)}' and '${kr(o$1.type)}'.`);
						n$1 && ("value" === s$1.type.kind && "value" !== o$1.type.kind ? s$1 = new Hr(o$1.type, [s$1]) : "value" !== s$1.type.kind && "value" === o$1.type.kind && (o$1 = new Hr(s$1.type, [o$1])));
						let a$1 = null;
						if (4 === t$2.length) {
							if ("string" !== s$1.type.kind && "string" !== o$1.type.kind && "value" !== s$1.type.kind && "value" !== o$1.type.kind) return e$2.error("Cannot use collator to compare non-string types.");
							if (a$1 = e$2.parse(t$2[3], 3, Ir), !a$1) return null;
						}
						return new i$1(s$1, o$1, a$1);
					}
					evaluate(i$2) {
						const s$1 = this.lhs.evaluate(i$2), o$1 = this.rhs.evaluate(i$2);
						if (n$1 && this.hasUntypedArgument) {
							const e$2 = Nr(s$1), r$2 = Nr(o$1);
							if (e$2.kind !== r$2.kind || "string" !== e$2.kind && "number" !== e$2.kind) throw new Gr(`Expected arguments for "${t$1}" to be (string, string) or (number, number), but found (${e$2.kind}, ${r$2.kind}) instead.`);
						}
						if (this.collator && !n$1 && this.hasUntypedArgument) {
							const t$2 = Nr(s$1), r$2 = Nr(o$1);
							if ("string" !== t$2.kind || "string" !== r$2.kind) return e$1(i$2, s$1, o$1);
						}
						return this.collator ? r$1(i$2, s$1, o$1, this.collator.evaluate(i$2)) : e$1(i$2, s$1, o$1);
					}
					eachChild(t$2) {
						t$2(this.lhs), t$2(this.rhs), this.collator && t$2(this.collator);
					}
					outputDefined() {
						return !0;
					}
					serialize() {
						const e$2 = [t$1];
						return this.eachChild(((t$2) => {
							e$2.push(t$2.serialize());
						})), e$2;
					}
				};
			}
			const ls = as("==", (function(t$1, e$1, r$1) {
				return e$1 === r$1;
			}), os), us = as("!=", (function(t$1, e$1, r$1) {
				return e$1 !== r$1;
			}), (function(t$1, e$1, r$1, n$1) {
				return !os(0, e$1, r$1, n$1);
			})), cs = as("<", (function(t$1, e$1, r$1) {
				return e$1 < r$1;
			}), (function(t$1, e$1, r$1, n$1) {
				return n$1.compare(e$1, r$1) < 0;
			})), hs = as(">", (function(t$1, e$1, r$1) {
				return e$1 > r$1;
			}), (function(t$1, e$1, r$1, n$1) {
				return n$1.compare(e$1, r$1) > 0;
			})), ps = as("<=", (function(t$1, e$1, r$1) {
				return e$1 <= r$1;
			}), (function(t$1, e$1, r$1, n$1) {
				return n$1.compare(e$1, r$1) <= 0;
			})), ds = as(">=", (function(t$1, e$1, r$1) {
				return e$1 >= r$1;
			}), (function(t$1, e$1, r$1, n$1) {
				return n$1.compare(e$1, r$1) >= 0;
			}));
			class fs {
				constructor(t$1, e$1, r$1, n$1, i$1, s$1) {
					this.type = vr, this.number = t$1, this.locale = e$1, this.currency = r$1, this.unit = n$1, this.minFractionDigits = i$1, this.maxFractionDigits = s$1;
				}
				static parse(t$1, e$1) {
					if (3 !== t$1.length) return e$1.error("Expected two arguments.");
					const r$1 = e$1.parse(t$1[1], 1, xr);
					if (!r$1) return null;
					const n$1 = t$1[2];
					if ("object" != typeof n$1 || Array.isArray(n$1)) return e$1.error("NumberFormat options argument must be an object.");
					let i$1 = null;
					if (n$1.locale && (i$1 = e$1.parseObjectValue(n$1.locale, 2, "locale", vr), !i$1)) return null;
					let s$1 = null;
					if (n$1.currency && (s$1 = e$1.parseObjectValue(n$1.currency, 2, "currency", vr), !s$1)) return null;
					let o$1 = null;
					if (n$1.unit && (o$1 = e$1.parseObjectValue(n$1.unit, 2, "unit", vr), !o$1)) return null;
					let a$1 = null;
					if (n$1["min-fraction-digits"] && (a$1 = e$1.parseObjectValue(n$1["min-fraction-digits"], 2, "min-fraction-digits", xr), !a$1)) return null;
					let l$1 = null;
					return n$1["max-fraction-digits"] && (l$1 = e$1.parseObjectValue(n$1["max-fraction-digits"], 2, "max-fraction-digits", xr), !l$1) ? null : new fs(r$1, i$1, s$1, o$1, a$1, l$1);
				}
				evaluate(t$1) {
					return new Intl.NumberFormat(this.locale ? this.locale.evaluate(t$1) : [], {
						style: (this.currency ? "currency" : this.unit && "unit") || "decimal",
						currency: this.currency ? this.currency.evaluate(t$1) : void 0,
						unit: this.unit ? this.unit.evaluate(t$1) : void 0,
						minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(t$1) : void 0,
						maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(t$1) : void 0
					}).format(this.number.evaluate(t$1));
				}
				eachChild(t$1) {
					t$1(this.number), this.locale && t$1(this.locale), this.currency && t$1(this.currency), this.unit && t$1(this.unit), this.minFractionDigits && t$1(this.minFractionDigits), this.maxFractionDigits && t$1(this.maxFractionDigits);
				}
				outputDefined() {
					return !1;
				}
				serialize() {
					const t$1 = {};
					return this.locale && (t$1.locale = this.locale.serialize()), this.currency && (t$1.currency = this.currency.serialize()), this.unit && (t$1.unit = this.unit.serialize()), this.minFractionDigits && (t$1["min-fraction-digits"] = this.minFractionDigits.serialize()), this.maxFractionDigits && (t$1["max-fraction-digits"] = this.maxFractionDigits.serialize()), [
						"number-format",
						this.number.serialize(),
						t$1
					];
				}
			}
			class ms {
				constructor(t$1) {
					this.type = xr, this.input = t$1;
				}
				static parse(t$1, e$1) {
					if (2 !== t$1.length) return e$1.error(`Expected 1 argument, but found ${t$1.length - 1} instead.`);
					const r$1 = e$1.parse(t$1[1], 1);
					return r$1 ? "array" !== r$1.type.kind && "string" !== r$1.type.kind && "value" !== r$1.type.kind ? e$1.error(`Expected argument of type string or array, but found ${kr(r$1.type)} instead.`) : new ms(r$1) : null;
				}
				evaluate(t$1) {
					const e$1 = this.input.evaluate(t$1);
					if ("string" == typeof e$1) return e$1.length;
					if (Array.isArray(e$1)) return e$1.length;
					throw new Gr(`Expected value to be of type string or array, but found ${kr(Nr(e$1))} instead.`);
				}
				eachChild(t$1) {
					t$1(this.input);
				}
				outputDefined() {
					return !1;
				}
				serialize() {
					const t$1 = ["length"];
					return this.eachChild(((e$1) => {
						t$1.push(e$1.serialize());
					})), t$1;
				}
			}
			function ys(t$1) {
				return function() {
					t$1 = 1831565813 + (t$1 |= 0) | 0;
					let e$1 = Math.imul(t$1 ^ t$1 >>> 15, 1 | t$1);
					return e$1 = e$1 + Math.imul(e$1 ^ e$1 >>> 7, 61 | e$1) ^ e$1, ((e$1 ^ e$1 >>> 14) >>> 0) / 4294967296;
				};
			}
			const gs = {
				"==": ls,
				"!=": us,
				">": hs,
				"<": cs,
				">=": ds,
				"<=": ps,
				array: Hr,
				at: Ki,
				"at-interpolated": Ji,
				boolean: Hr,
				case: rs,
				coalesce: Wi,
				collator: an,
				format: Xr,
				image: Zr,
				in: Qi,
				"index-of": ts,
				interpolate: Xi,
				"interpolate-hcl": Xi,
				"interpolate-lab": Xi,
				length: ms,
				let: Yi,
				literal: $r,
				match: es,
				number: Hr,
				"number-format": fs,
				object: Hr,
				slice: ns,
				step: ki,
				string: Hr,
				"to-boolean": en,
				"to-color": en,
				"to-number": en,
				"to-string": en,
				var: Ii,
				within: zn,
				distance: yi,
				config: Ai,
				split: is
			};
			function xs(t$1, [e$1, r$1, n$1, i$1]) {
				e$1 = e$1.evaluate(t$1), r$1 = r$1.evaluate(t$1), n$1 = n$1.evaluate(t$1);
				const s$1 = i$1 ? i$1.evaluate(t$1) : 1, o$1 = Or(e$1, r$1, n$1, s$1);
				if (o$1) throw new Gr(o$1);
				return new lr(e$1 / 255, r$1 / 255, n$1 / 255, s$1);
			}
			function vs(t$1, [e$1, r$1, n$1, i$1]) {
				e$1 = e$1.evaluate(t$1), r$1 = r$1.evaluate(t$1), n$1 = n$1.evaluate(t$1);
				const s$1 = i$1 ? i$1.evaluate(t$1) : 1, o$1 = function(t$2, e$2, r$2, n$2) {
					return "number" == typeof t$2 && t$2 >= 0 && t$2 <= 360 ? "number" == typeof e$2 && e$2 >= 0 && e$2 <= 100 && "number" == typeof r$2 && r$2 >= 0 && r$2 <= 100 ? void 0 === n$2 || "number" == typeof n$2 && n$2 >= 0 && n$2 <= 1 ? null : `Invalid hsla value [${[
						t$2,
						e$2,
						r$2,
						n$2
					].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid hsla value [${("number" == typeof n$2 ? [
						t$2,
						e$2,
						r$2,
						n$2
					] : [
						t$2,
						e$2,
						r$2
					]).join(", ")}]: 's', and 'l' must be between 0 and 100.` : `Invalid hsla value [${("number" == typeof n$2 ? [
						t$2,
						e$2,
						r$2,
						n$2
					] : [
						t$2,
						e$2,
						r$2
					]).join(", ")}]: 'h' must be between 0 and 360.`;
				}(e$1, r$1, n$1, s$1);
				if (o$1) throw new Gr(o$1);
				const a$1 = `hsla(${e$1}, ${r$1}%, ${n$1}%, ${s$1})`, l$1 = lr.parse(a$1);
				if (!l$1) throw new Gr(`Failed to parse HSLA color: ${a$1}`);
				return l$1;
			}
			function bs(t$1, e$1) {
				return t$1 in e$1;
			}
			function ws(t$1, e$1) {
				const r$1 = e$1[t$1];
				return void 0 === r$1 ? null : r$1;
			}
			function _s(t$1) {
				return { type: t$1 };
			}
			function As(t$1) {
				if (t$1 instanceof Ai) return new Set([t$1.key]);
				let e$1 = /* @__PURE__ */ new Set();
				return t$1.eachChild(((t$2) => {
					e$1 = new Set([...e$1, ...As(t$2)]);
				})), e$1;
			}
			function Is(t$1) {
				if (t$1 instanceof sn && "is-active-floor" === t$1.name) return !0;
				let e$1 = !1;
				return t$1.eachChild(((t$2) => {
					!e$1 && Is(t$2) && (e$1 = !0);
				})), e$1;
			}
			function Ms(t$1) {
				return {
					result: "success",
					value: t$1
				};
			}
			function Ss(t$1) {
				return {
					result: "error",
					value: t$1
				};
			}
			function Ps(t$1, e$1) {
				return !!t$1 && !!t$1.parameters && t$1.parameters.indexOf(e$1) > -1;
			}
			function ks(t$1) {
				return "data-driven" === t$1["property-type"];
			}
			function Bs(t$1) {
				return Ps(t$1.expression, "measure-light");
			}
			function zs(t$1) {
				return Ps(t$1.expression, "zoom");
			}
			function Ts(t$1) {
				return !!t$1.expression && t$1.expression.interpolated;
			}
			function Es(t$1) {
				return "object" == typeof t$1 && null !== t$1 && !Array.isArray(t$1);
			}
			function Vs(t$1) {
				return t$1;
			}
			function Fs(t$1, e$1) {
				const r$1 = "color" === e$1.type, n$1 = t$1.stops && "object" == typeof t$1.stops[0][0], i$1 = n$1 || !(n$1 || void 0 !== t$1.property), s$1 = t$1.type || (Ts(e$1) ? "exponential" : "interval");
				if (r$1 && ((t$1 = Object.assign({}, t$1)).stops && (t$1.stops = t$1.stops.map(((t$2) => [t$2[0], lr.parse(t$2[1])]))), t$1.default = lr.parse(t$1.default ? t$1.default : e$1.default)), t$1.colorSpace && "rgb" !== t$1.colorSpace && !Hi[t$1.colorSpace]) throw new Error(`Unknown color space: ${t$1.colorSpace}`);
				let o$1, a$1, l$1;
				if ("exponential" === s$1) o$1 = Ls;
				else if ("interval" === s$1) o$1 = Rs;
				else if ("categorical" === s$1) {
					o$1 = Ds, a$1 = Object.create(null);
					for (const e$2 of t$1.stops) a$1[e$2[0]] = e$2[1];
					l$1 = typeof t$1.stops[0][0];
				} else {
					if ("identity" !== s$1) throw new Error(`Unknown function type "${s$1}"`);
					o$1 = Os;
				}
				if (n$1) {
					const r$2 = {}, n$2 = [];
					for (let e$2 = 0; e$2 < t$1.stops.length; e$2++) {
						const i$3 = t$1.stops[e$2], s$3 = i$3[0].zoom;
						void 0 === r$2[s$3] && (r$2[s$3] = {
							zoom: s$3,
							type: t$1.type,
							property: t$1.property,
							default: t$1.default,
							stops: []
						}, n$2.push(s$3)), r$2[s$3].stops.push([i$3[0].value, i$3[1]]);
					}
					const i$2 = [];
					for (const t$2 of n$2) i$2.push([r$2[t$2].zoom, Fs(r$2[t$2], e$1)]);
					const s$2 = { name: "linear" };
					return {
						kind: "composite",
						interpolationType: s$2,
						interpolationFactor: Xi.interpolationFactor.bind(void 0, s$2),
						zoomStops: i$2.map(((t$2) => t$2[0])),
						evaluate: ({ zoom: r$3 }, n$3) => Ls({
							stops: i$2,
							base: t$1.base
						}, e$1, r$3).evaluate(r$3, n$3)
					};
				}
				if (i$1) {
					const r$2 = "exponential" === s$1 ? {
						name: "exponential",
						base: void 0 !== t$1.base ? t$1.base : 1
					} : null;
					return {
						kind: "camera",
						interpolationType: r$2,
						interpolationFactor: Xi.interpolationFactor.bind(void 0, r$2),
						zoomStops: t$1.stops.map(((t$2) => t$2[0])),
						evaluate: ({ zoom: r$3 }) => o$1(t$1, e$1, r$3, a$1, l$1)
					};
				}
				return {
					kind: "source",
					evaluate(r$2, n$2) {
						const i$2 = n$2 && n$2.properties ? n$2.properties[t$1.property] : void 0;
						return void 0 === i$2 ? Cs(t$1.default, e$1.default) : o$1(t$1, e$1, i$2, a$1, l$1);
					}
				};
			}
			function Cs(t$1, e$1, r$1) {
				return void 0 !== t$1 ? t$1 : void 0 !== e$1 ? e$1 : void 0 !== r$1 ? r$1 : void 0;
			}
			function Ds(t$1, e$1, r$1, n$1, i$1) {
				return Cs(typeof r$1 === i$1 ? n$1[r$1] : void 0, t$1.default, e$1.default);
			}
			function Rs(t$1, e$1, r$1) {
				if (!Jr(r$1)) return Cs(t$1.default, e$1.default);
				const n$1 = t$1.stops.length;
				if (1 === n$1) return t$1.stops[0][1];
				if (r$1 <= t$1.stops[0][0]) return t$1.stops[0][1];
				if (r$1 >= t$1.stops[n$1 - 1][0]) return t$1.stops[n$1 - 1][1];
				const i$1 = Pi(t$1.stops.map(((t$2) => t$2[0])), r$1);
				return t$1.stops[i$1][1];
			}
			function Ls(t$1, e$1, r$1) {
				const n$1 = void 0 !== t$1.base ? t$1.base : 1;
				if (!Jr(r$1)) return Cs(t$1.default, e$1.default);
				const i$1 = t$1.stops.length;
				if (1 === i$1) return t$1.stops[0][1];
				if (r$1 <= t$1.stops[0][0]) return t$1.stops[0][1];
				if (r$1 >= t$1.stops[i$1 - 1][0]) return t$1.stops[i$1 - 1][1];
				const s$1 = Pi(t$1.stops.map(((t$2) => t$2[0])), r$1), o$1 = function(t$2, e$2, r$2, n$2) {
					const i$2 = n$2 - r$2, s$2 = t$2 - r$2;
					return 0 === i$2 ? 0 : 1 === e$2 ? s$2 / i$2 : (Math.pow(e$2, s$2) - 1) / (Math.pow(e$2, i$2) - 1);
				}(r$1, n$1, t$1.stops[s$1][0], t$1.stops[s$1 + 1][0]), a$1 = t$1.stops[s$1][1], l$1 = t$1.stops[s$1 + 1][1];
				let u$1 = fr[e$1.type] || Vs;
				if (t$1.colorSpace && "rgb" !== t$1.colorSpace) {
					const e$2 = Hi[t$1.colorSpace];
					u$1 = (t$2, r$2) => e$2.reverse(e$2.interpolate(e$2.forward(t$2), e$2.forward(r$2), o$1));
				}
				return "function" == typeof a$1.evaluate ? { evaluate(...t$2) {
					const e$2 = a$1.evaluate.apply(void 0, t$2), r$2 = l$1.evaluate.apply(void 0, t$2);
					if (void 0 !== e$2 && void 0 !== r$2) return u$1(e$2, r$2, o$1);
				} } : u$1(a$1, l$1, o$1);
			}
			function Os(t$1, e$1, r$1) {
				return "color" === e$1.type ? r$1 = lr.parse(r$1) : "formatted" === e$1.type ? r$1 = Dr.fromString(r$1.toString()) : "resolvedImage" === e$1.type ? r$1 = Lr.build(r$1.toString()) : Wr(r$1) === e$1.type || "enum" === e$1.type && e$1.values[r$1] || (r$1 = void 0), Cs(r$1, t$1.default, e$1.default);
			}
			sn.register(gs, {
				error: [
					{ kind: "error" },
					[vr],
					(t$1, [e$1]) => {
						throw new Gr(e$1.evaluate(t$1));
					}
				],
				typeof: [
					vr,
					[Ar],
					(t$1, [e$1]) => kr(Nr(e$1.evaluate(t$1)))
				],
				"to-rgba": [
					Pr(xr, 4),
					[wr],
					(t$1, [e$1]) => e$1.evaluate(t$1).toNonPremultipliedRenderColor(null).toArray()
				],
				"to-hsla": [
					Pr(xr, 4),
					[wr],
					(t$1, [e$1]) => e$1.evaluate(t$1).toNonPremultipliedRenderColor(null).toHslaArray()
				],
				rgb: [
					wr,
					[
						xr,
						xr,
						xr
					],
					xs
				],
				rgba: [
					wr,
					[
						xr,
						xr,
						xr,
						xr
					],
					xs
				],
				hsl: [
					wr,
					[
						xr,
						xr,
						xr
					],
					vs
				],
				hsla: [
					wr,
					[
						xr,
						xr,
						xr,
						xr
					],
					vs
				],
				has: {
					type: br,
					overloads: [[[vr], (t$1, [e$1]) => bs(e$1.evaluate(t$1), t$1.properties())], [[vr, _r], (t$1, [e$1, r$1]) => bs(e$1.evaluate(t$1), r$1.evaluate(t$1))]]
				},
				get: {
					type: Ar,
					overloads: [[[vr], (t$1, [e$1]) => ws(e$1.evaluate(t$1), t$1.properties())], [[vr, _r], (t$1, [e$1, r$1]) => ws(e$1.evaluate(t$1), r$1.evaluate(t$1))]]
				},
				"feature-state": [
					Ar,
					[vr],
					(t$1, [e$1]) => ws(e$1.evaluate(t$1), t$1.featureState || {})
				],
				properties: [
					_r,
					[],
					(t$1) => t$1.properties()
				],
				"geometry-type": [
					vr,
					[],
					(t$1) => t$1.geometryType()
				],
				worldview: [
					vr,
					[],
					(t$1) => t$1.globals.worldview || ""
				],
				"is-active-floor": [
					br,
					_s(vr),
					(t$1, e$1) => {
						if (!(t$1.globals.activeFloors && t$1.globals.activeFloors.size > 0)) return !1;
						const r$1 = t$1.globals.activeFloors;
						return e$1.some(((e$2) => {
							const n$1 = e$2.evaluate(t$1);
							return r$1.has(n$1);
						}));
					}
				],
				id: [
					Ar,
					[],
					(t$1) => t$1.id()
				],
				zoom: [
					xr,
					[],
					(t$1) => t$1.globals.zoom
				],
				pitch: [
					xr,
					[],
					(t$1) => t$1.globals.pitch || 0
				],
				"distance-from-center": [
					xr,
					[],
					(t$1) => t$1.distanceFromCenter()
				],
				"measure-light": [
					xr,
					[vr],
					(t$1, [e$1]) => t$1.measureLight(e$1.evaluate(t$1))
				],
				"heatmap-density": [
					xr,
					[],
					(t$1) => t$1.globals.heatmapDensity || 0
				],
				"line-progress": [
					xr,
					[],
					(t$1) => t$1.globals.lineProgress || 0
				],
				"raster-value": [
					xr,
					[],
					(t$1) => t$1.globals.rasterValue || 0
				],
				"raster-particle-speed": [
					xr,
					[],
					(t$1) => t$1.globals.rasterParticleSpeed || 0
				],
				"sky-radial-progress": [
					xr,
					[],
					(t$1) => t$1.globals.skyRadialProgress || 0
				],
				accumulated: [
					Ar,
					[],
					(t$1) => void 0 === t$1.globals.accumulated ? null : t$1.globals.accumulated
				],
				"+": [
					xr,
					_s(xr),
					(t$1, e$1) => {
						let r$1 = 0;
						for (const n$1 of e$1) r$1 += n$1.evaluate(t$1);
						return r$1;
					}
				],
				"*": [
					xr,
					_s(xr),
					(t$1, e$1) => {
						let r$1 = 1;
						for (const n$1 of e$1) r$1 *= n$1.evaluate(t$1);
						return r$1;
					}
				],
				"-": {
					type: xr,
					overloads: [[[xr, xr], (t$1, [e$1, r$1]) => e$1.evaluate(t$1) - r$1.evaluate(t$1)], [[xr], (t$1, [e$1]) => -e$1.evaluate(t$1)]]
				},
				"/": [
					xr,
					[xr, xr],
					(t$1, [e$1, r$1]) => e$1.evaluate(t$1) / r$1.evaluate(t$1)
				],
				"%": [
					xr,
					[xr, xr],
					(t$1, [e$1, r$1]) => e$1.evaluate(t$1) % r$1.evaluate(t$1)
				],
				ln2: [
					xr,
					[],
					() => Math.LN2
				],
				pi: [
					xr,
					[],
					() => Math.PI
				],
				e: [
					xr,
					[],
					() => Math.E
				],
				"^": [
					xr,
					[xr, xr],
					(t$1, [e$1, r$1]) => Math.pow(e$1.evaluate(t$1), r$1.evaluate(t$1))
				],
				sqrt: [
					xr,
					[xr],
					(t$1, [e$1]) => Math.sqrt(e$1.evaluate(t$1))
				],
				log10: [
					xr,
					[xr],
					(t$1, [e$1]) => Math.log(e$1.evaluate(t$1)) / Math.LN10
				],
				ln: [
					xr,
					[xr],
					(t$1, [e$1]) => Math.log(e$1.evaluate(t$1))
				],
				log2: [
					xr,
					[xr],
					(t$1, [e$1]) => Math.log2(e$1.evaluate(t$1))
				],
				sin: [
					xr,
					[xr],
					(t$1, [e$1]) => Math.sin(e$1.evaluate(t$1))
				],
				cos: [
					xr,
					[xr],
					(t$1, [e$1]) => Math.cos(e$1.evaluate(t$1))
				],
				tan: [
					xr,
					[xr],
					(t$1, [e$1]) => Math.tan(e$1.evaluate(t$1))
				],
				asin: [
					xr,
					[xr],
					(t$1, [e$1]) => Math.asin(e$1.evaluate(t$1))
				],
				acos: [
					xr,
					[xr],
					(t$1, [e$1]) => Math.acos(e$1.evaluate(t$1))
				],
				atan: [
					xr,
					[xr],
					(t$1, [e$1]) => Math.atan(e$1.evaluate(t$1))
				],
				min: [
					xr,
					_s(xr),
					(t$1, e$1) => Math.min(...e$1.map(((e$2) => e$2.evaluate(t$1))))
				],
				max: [
					xr,
					_s(xr),
					(t$1, e$1) => Math.max(...e$1.map(((e$2) => e$2.evaluate(t$1))))
				],
				abs: [
					xr,
					[xr],
					(t$1, [e$1]) => Math.abs(e$1.evaluate(t$1))
				],
				round: [
					xr,
					[xr],
					(t$1, [e$1]) => {
						const r$1 = e$1.evaluate(t$1);
						return r$1 < 0 ? -Math.round(-r$1) : Math.round(r$1);
					}
				],
				floor: [
					xr,
					[xr],
					(t$1, [e$1]) => Math.floor(e$1.evaluate(t$1))
				],
				ceil: [
					xr,
					[xr],
					(t$1, [e$1]) => Math.ceil(e$1.evaluate(t$1))
				],
				"filter-==": [
					br,
					[vr, Ar],
					(t$1, [e$1, r$1]) => t$1.properties()[e$1.value] === r$1.value
				],
				"filter-id-==": [
					br,
					[Ar],
					(t$1, [e$1]) => t$1.id() === e$1.value
				],
				"filter-type-==": [
					br,
					[vr],
					(t$1, [e$1]) => t$1.geometryType() === e$1.value
				],
				"filter-<": [
					br,
					[vr, Ar],
					(t$1, [e$1, r$1]) => {
						const n$1 = t$1.properties()[e$1.value], i$1 = r$1.value;
						return typeof n$1 == typeof i$1 && n$1 < i$1;
					}
				],
				"filter-id-<": [
					br,
					[Ar],
					(t$1, [e$1]) => {
						const r$1 = t$1.id(), n$1 = e$1.value;
						return typeof r$1 == typeof n$1 && r$1 < n$1;
					}
				],
				"filter->": [
					br,
					[vr, Ar],
					(t$1, [e$1, r$1]) => {
						const n$1 = t$1.properties()[e$1.value], i$1 = r$1.value;
						return typeof n$1 == typeof i$1 && n$1 > i$1;
					}
				],
				"filter-id->": [
					br,
					[Ar],
					(t$1, [e$1]) => {
						const r$1 = t$1.id(), n$1 = e$1.value;
						return typeof r$1 == typeof n$1 && r$1 > n$1;
					}
				],
				"filter-<=": [
					br,
					[vr, Ar],
					(t$1, [e$1, r$1]) => {
						const n$1 = t$1.properties()[e$1.value], i$1 = r$1.value;
						return typeof n$1 == typeof i$1 && n$1 <= i$1;
					}
				],
				"filter-id-<=": [
					br,
					[Ar],
					(t$1, [e$1]) => {
						const r$1 = t$1.id(), n$1 = e$1.value;
						return typeof r$1 == typeof n$1 && r$1 <= n$1;
					}
				],
				"filter->=": [
					br,
					[vr, Ar],
					(t$1, [e$1, r$1]) => {
						const n$1 = t$1.properties()[e$1.value], i$1 = r$1.value;
						return typeof n$1 == typeof i$1 && n$1 >= i$1;
					}
				],
				"filter-id->=": [
					br,
					[Ar],
					(t$1, [e$1]) => {
						const r$1 = t$1.id(), n$1 = e$1.value;
						return typeof r$1 == typeof n$1 && r$1 >= n$1;
					}
				],
				"filter-has": [
					br,
					[Ar],
					(t$1, [e$1]) => e$1.value in t$1.properties()
				],
				"filter-has-id": [
					br,
					[],
					(t$1) => null !== t$1.id() && void 0 !== t$1.id()
				],
				"filter-type-in": [
					br,
					[Pr(vr)],
					(t$1, [e$1]) => e$1.value.indexOf(t$1.geometryType()) >= 0
				],
				"filter-id-in": [
					br,
					[Pr(Ar)],
					(t$1, [e$1]) => e$1.value.indexOf(t$1.id()) >= 0
				],
				"filter-in-small": [
					br,
					[vr, Pr(Ar)],
					(t$1, [e$1, r$1]) => r$1.value.indexOf(t$1.properties()[e$1.value]) >= 0
				],
				"filter-in-large": [
					br,
					[vr, Pr(Ar)],
					(t$1, [e$1, r$1]) => function(t$2, e$2, r$2, n$1) {
						for (; r$2 <= n$1;) {
							const i$1 = r$2 + n$1 >> 1;
							if (e$2[i$1] === t$2) return !0;
							e$2[i$1] > t$2 ? n$1 = i$1 - 1 : r$2 = i$1 + 1;
						}
						return !1;
					}(t$1.properties()[e$1.value], r$1.value, 0, r$1.value.length - 1)
				],
				all: {
					type: br,
					overloads: [[[br, br], (t$1, [e$1, r$1]) => e$1.evaluate(t$1) && r$1.evaluate(t$1)], [_s(br), (t$1, e$1) => {
						for (const r$1 of e$1) if (!r$1.evaluate(t$1)) return !1;
						return !0;
					}]]
				},
				any: {
					type: br,
					overloads: [[[br, br], (t$1, [e$1, r$1]) => e$1.evaluate(t$1) || r$1.evaluate(t$1)], [_s(br), (t$1, e$1) => {
						for (const r$1 of e$1) if (r$1.evaluate(t$1)) return !0;
						return !1;
					}]]
				},
				"!": [
					br,
					[br],
					(t$1, [e$1]) => !e$1.evaluate(t$1)
				],
				"is-supported-script": [
					br,
					[vr],
					(t$1, [e$1]) => {
						const r$1 = t$1.globals && t$1.globals.isSupportedScript;
						return !r$1 || r$1(e$1.evaluate(t$1));
					}
				],
				upcase: [
					vr,
					[vr],
					(t$1, [e$1]) => e$1.evaluate(t$1).toUpperCase()
				],
				downcase: [
					vr,
					[vr],
					(t$1, [e$1]) => e$1.evaluate(t$1).toLowerCase()
				],
				concat: [
					vr,
					_s(Ar),
					(t$1, e$1) => e$1.map(((e$2) => jr(e$2.evaluate(t$1)))).join("")
				],
				"resolved-locale": [
					vr,
					[Ir],
					(t$1, [e$1]) => e$1.evaluate(t$1).resolvedLocale()
				],
				random: [
					xr,
					[
						xr,
						xr,
						Ar
					],
					(t$1, e$1) => {
						const [r$1, n$1, i$1] = e$1.map(((e$2) => e$2.evaluate(t$1)));
						if (r$1 > n$1) return r$1;
						if (r$1 === n$1) return r$1;
						let s$1;
						if ("string" == typeof i$1) s$1 = function(t$2) {
							let e$2 = 0;
							if (0 === t$2.length) return e$2;
							for (let r$2 = 0; r$2 < t$2.length; r$2++) e$2 = (e$2 << 5) - e$2 + t$2.charCodeAt(r$2), e$2 |= 0;
							return e$2;
						}(i$1);
						else {
							if ("number" != typeof i$1) throw new Gr(`Invalid seed input: ${i$1}`);
							s$1 = i$1;
						}
						return r$1 + ys(s$1)() * (n$1 - r$1);
					}
				]
			});
			class Us {
				constructor(t$1, e$1, r$1, n$1, i$1) {
					this.expression = t$1, this._warningHistory = {}, this._scope = r$1, this._options = n$1, this._iconImageUseTheme = i$1, this._evaluator = new nn(r$1, n$1, i$1), this._defaultValue = e$1 ? function(t$2) {
						return "color" === t$2.type && (Es(t$2.default) || Array.isArray(t$2.default)) ? new lr(0, 0, 0, 0) : "color" === t$2.type ? lr.parse(t$2.default) || null : void 0 === t$2.default ? null : t$2.default;
					}(e$1) : null, this._enumValues = e$1 && "enum" === e$1.type ? e$1.values : null, this.configDependencies = As(t$1), this.isIndoorDependent = Is(t$1);
				}
				evaluateWithoutErrorHandling(t$1, e$1, r$1, n$1, i$1, s$1, o$1, a$1) {
					return this._evaluator.globals = t$1, this._evaluator.feature = e$1, this._evaluator.featureState = r$1, this._evaluator.canonical = n$1 || null, this._evaluator.availableImages = i$1 || null, this._evaluator.formattedSection = s$1, this._evaluator.featureTileCoord = o$1 || null, this._evaluator.featureDistanceData = a$1 || null, this.expression.evaluate(this._evaluator);
				}
				evaluate(t$1, e$1, r$1, n$1, i$1, s$1, o$1, a$1, l$1) {
					this._evaluator || (this._evaluator = new nn(this._scope, this._options, this._iconImageUseTheme)), this._evaluator.globals = t$1, this._evaluator.feature = e$1 || null, this._evaluator.featureState = r$1 || null, this._evaluator.canonical = n$1 || null, this._evaluator.availableImages = i$1 || null, this._evaluator.formattedSection = s$1 || null, this._evaluator.featureTileCoord = o$1 || null, this._evaluator.featureDistanceData = a$1 || null, this._evaluator.iconImageUseTheme = l$1 || null;
					try {
						const t$2 = this.expression.evaluate(this._evaluator);
						if (null == t$2 || "number" == typeof t$2 && t$2 != t$2) return this._defaultValue;
						if (this._enumValues && !(t$2 in this._enumValues)) throw new Gr(`Expected value to be one of ${Object.keys(this._enumValues).map(((t$3) => JSON.stringify(t$3))).join(", ")}, but found ${JSON.stringify(t$2)} instead.`);
						return t$2;
					} catch (t$2) {
						const e$2 = t$2;
						return this._warningHistory[e$2.message] || (this._warningHistory[e$2.message] = !0, "undefined" != typeof console && console.warn(`Failed to evaluate expression "${JSON.stringify(this.expression.serialize())}". ${e$2.message}`)), this._defaultValue;
					}
				}
			}
			function Ns(t$1) {
				return Array.isArray(t$1) && t$1.length > 0 && "string" == typeof t$1[0] && t$1[0] in gs;
			}
			function js(t$1, e$1, r$1, n$1, i$1) {
				const s$1 = new Mi(gs, [], e$1 ? function(t$2) {
					const e$2 = {
						color: wr,
						string: vr,
						number: xr,
						enum: vr,
						boolean: br,
						formatted: Mr,
						resolvedImage: Sr
					};
					return "array" === t$2.type ? Pr(e$2[t$2.value] || Ar, t$2.length) : e$2[t$2.type];
				}(e$1) : void 0, void 0, void 0, r$1, n$1, i$1), o$1 = s$1.parse(t$1, void 0, void 0, void 0, e$1 && "string" === e$1.type ? { typeAnnotation: "coerce" } : void 0);
				return o$1 ? Ms(new Us(o$1, e$1, r$1, n$1, i$1)) : Ss(s$1.errors);
			}
			class $s {
				constructor(t$1, e$1, r$1, n$1) {
					this.kind = t$1, this._styleExpression = e$1, this.isLightConstant = r$1, this.isLineProgressConstant = n$1, this.isStateDependent = "constant" !== t$1 && !xi(e$1.expression), this.configDependencies = As(e$1.expression), this.isIndoorDependent = Is(e$1.expression);
				}
				evaluateWithoutErrorHandling(t$1, e$1, r$1, n$1, i$1, s$1) {
					return this._styleExpression.evaluateWithoutErrorHandling(t$1, e$1, r$1, n$1, i$1, s$1);
				}
				evaluate(t$1, e$1, r$1, n$1, i$1, s$1, o$1) {
					return this._styleExpression.evaluate(t$1, e$1, r$1, n$1, i$1, s$1, void 0, void 0, o$1);
				}
			}
			class Gs {
				constructor(t$1, e$1, r$1, n$1, i$1, s$1) {
					this.kind = t$1, this.zoomStops = r$1, this._styleExpression = e$1, this.isStateDependent = "camera" !== t$1 && !xi(e$1.expression), this.isIndoorDependent = Is(e$1.expression), this.isLightConstant = i$1, this.isLineProgressConstant = s$1, this.configDependencies = As(e$1.expression), this.interpolationType = n$1;
				}
				evaluateWithoutErrorHandling(t$1, e$1, r$1, n$1, i$1, s$1) {
					return this._styleExpression.evaluateWithoutErrorHandling(t$1, e$1, r$1, n$1, i$1, s$1);
				}
				evaluate(t$1, e$1, r$1, n$1, i$1, s$1) {
					return this._styleExpression.evaluate(t$1, e$1, r$1, n$1, i$1, s$1);
				}
				interpolationFactor(t$1, e$1, r$1) {
					return this.interpolationType ? Xi.interpolationFactor(this.interpolationType, t$1, e$1, r$1) : 0;
				}
			}
			function qs(t$1, e$1, r$1, n$1, i$1) {
				if ("error" === (t$1 = js(t$1, e$1, r$1, n$1, i$1)).result) return t$1;
				const s$1 = t$1.value.expression, o$1 = gi(s$1);
				if (!o$1 && !ks(e$1)) return Ss([new mr("", "data expressions not supported")]);
				const a$1 = vi(s$1, [
					"zoom",
					"pitch",
					"distance-from-center"
				]);
				if (!a$1 && !zs(e$1)) return Ss([new mr("", "zoom expressions not supported")]);
				const l$1 = vi(s$1, ["measure-light"]);
				if (!l$1 && !Bs(e$1)) return Ss([new mr("", "measure-light expression not supported")]);
				const u$1 = vi(s$1, ["line-progress"]);
				if (!u$1 && !function(t$2) {
					return Ps(t$2.expression, "line-progress");
				}(e$1)) return Ss([new mr("", "line-progress expression not supported")]);
				const c$1 = e$1.expression && e$1.expression.relaxZoomRestriction, h$1 = Xs(s$1);
				return h$1 || a$1 || c$1 ? h$1 instanceof mr ? Ss([h$1]) : h$1 instanceof Xi && !Ts(e$1) ? Ss([new mr("", "\"interpolate\" expressions cannot be used with this property")]) : Ms(h$1 ? new Gs(o$1 && u$1 ? "camera" : "composite", t$1.value, h$1.labels, h$1 instanceof Xi ? h$1.interpolation : void 0, l$1, u$1) : new $s(o$1 && u$1 ? "constant" : "source", t$1.value, l$1, u$1)) : Ss([new mr("", "\"zoom\" expression may only be used as input to a top-level \"step\" or \"interpolate\" expression, or in the properties of atmosphere.")]);
			}
			class Hs {
				constructor(t$1, e$1) {
					this._parameters = t$1, this._specification = e$1, Object.assign(this, Fs(this._parameters, this._specification));
				}
				static deserialize(t$1) {
					return new Hs(t$1._parameters, t$1._specification);
				}
				static serialize(t$1) {
					return {
						_parameters: t$1._parameters,
						_specification: t$1._specification
					};
				}
			}
			function Xs(t$1) {
				let e$1 = null;
				if (t$1 instanceof Yi) e$1 = Xs(t$1.result);
				else if (t$1 instanceof Wi) {
					for (const r$1 of t$1.args) if (e$1 = Xs(r$1), e$1) break;
				} else (t$1 instanceof ki || t$1 instanceof Xi) && t$1.input instanceof sn && "zoom" === t$1.input.name && (e$1 = t$1);
				return e$1 instanceof mr || t$1.eachChild(((t$2) => {
					const r$1 = Xs(t$2);
					r$1 instanceof mr ? e$1 = r$1 : e$1 && r$1 && e$1 !== r$1 && (e$1 = new mr("", "Only one zoom-based \"step\" or \"interpolate\" subexpression may be used in an expression."));
				})), e$1;
			}
			var Zs, Ws, Ks = wt(function() {
				if (Ws) return Zs;
				Ws = 1, Zs = e$1;
				var t$1 = 3;
				function e$1(e$2, r$1, n$1) {
					var i$1 = this.cells = [];
					if (e$2 instanceof ArrayBuffer) {
						this.arrayBuffer = e$2;
						var s$1 = new Int32Array(this.arrayBuffer);
						e$2 = s$1[0], this.d = (r$1 = s$1[1]) + 2 * (n$1 = s$1[2]);
						for (var o$1 = 0; o$1 < this.d * this.d; o$1++) {
							var a$1 = s$1[t$1 + o$1], l$1 = s$1[t$1 + o$1 + 1];
							i$1.push(a$1 === l$1 ? null : s$1.subarray(a$1, l$1));
						}
						var u$1 = s$1[t$1 + i$1.length + 1];
						this.keys = s$1.subarray(s$1[t$1 + i$1.length], u$1), this.bboxes = s$1.subarray(u$1), this.insert = this._insertReadonly;
					} else {
						this.d = r$1 + 2 * n$1;
						for (var c$1 = 0; c$1 < this.d * this.d; c$1++) i$1.push([]);
						this.keys = [], this.bboxes = [];
					}
					this.n = r$1, this.extent = e$2, this.padding = n$1, this.scale = r$1 / e$2, this.uid = 0;
					var h$1 = n$1 / r$1 * e$2;
					this.min = -h$1, this.max = e$2 + h$1;
				}
				return e$1.prototype.insert = function(t$2, e$2, r$1, n$1, i$1) {
					this._forEachCell(e$2, r$1, n$1, i$1, this._insertCell, this.uid++), this.keys.push(t$2), this.bboxes.push(e$2), this.bboxes.push(r$1), this.bboxes.push(n$1), this.bboxes.push(i$1);
				}, e$1.prototype._insertReadonly = function() {
					throw "Cannot insert into a GridIndex created from an ArrayBuffer.";
				}, e$1.prototype._insertCell = function(t$2, e$2, r$1, n$1, i$1, s$1) {
					this.cells[i$1].push(s$1);
				}, e$1.prototype.query = function(t$2, e$2, r$1, n$1, i$1) {
					var s$1 = this.min, o$1 = this.max;
					if (t$2 <= s$1 && e$2 <= s$1 && o$1 <= r$1 && o$1 <= n$1 && !i$1) return Array.prototype.slice.call(this.keys);
					var a$1 = [];
					return this._forEachCell(t$2, e$2, r$1, n$1, this._queryCell, a$1, {}, i$1), a$1;
				}, e$1.prototype._queryCell = function(t$2, e$2, r$1, n$1, i$1, s$1, o$1, a$1) {
					var l$1 = this.cells[i$1];
					if (null !== l$1) for (var u$1 = this.keys, c$1 = this.bboxes, h$1 = 0; h$1 < l$1.length; h$1++) {
						var p$1 = l$1[h$1];
						if (void 0 === o$1[p$1]) {
							var d$1 = 4 * p$1;
							(a$1 ? a$1(c$1[d$1 + 0], c$1[d$1 + 1], c$1[d$1 + 2], c$1[d$1 + 3]) : t$2 <= c$1[d$1 + 2] && e$2 <= c$1[d$1 + 3] && r$1 >= c$1[d$1 + 0] && n$1 >= c$1[d$1 + 1]) ? (o$1[p$1] = !0, s$1.push(u$1[p$1])) : o$1[p$1] = !1;
						}
					}
				}, e$1.prototype._forEachCell = function(t$2, e$2, r$1, n$1, i$1, s$1, o$1, a$1) {
					for (var l$1 = this._convertToCellCoord(t$2), u$1 = this._convertToCellCoord(e$2), c$1 = this._convertToCellCoord(r$1), h$1 = this._convertToCellCoord(n$1), p$1 = l$1; p$1 <= c$1; p$1++) for (var d$1 = u$1; d$1 <= h$1; d$1++) {
						var f$1 = this.d * d$1 + p$1;
						if ((!a$1 || a$1(this._convertFromCellCoord(p$1), this._convertFromCellCoord(d$1), this._convertFromCellCoord(p$1 + 1), this._convertFromCellCoord(d$1 + 1))) && i$1.call(this, t$2, e$2, r$1, n$1, f$1, s$1, o$1, a$1)) return;
					}
				}, e$1.prototype._convertFromCellCoord = function(t$2) {
					return (t$2 - this.padding) / this.scale;
				}, e$1.prototype._convertToCellCoord = function(t$2) {
					return Math.max(0, Math.min(this.d - 1, Math.floor(t$2 * this.scale) + this.padding));
				}, e$1.prototype.toArrayBuffer = function() {
					if (this.arrayBuffer) return this.arrayBuffer;
					for (var e$2 = this.cells, r$1 = t$1 + this.cells.length + 1 + 1, n$1 = 0, i$1 = 0; i$1 < this.cells.length; i$1++) n$1 += this.cells[i$1].length;
					var s$1 = new Int32Array(r$1 + n$1 + this.keys.length + this.bboxes.length);
					s$1[0] = this.extent, s$1[1] = this.n, s$1[2] = this.padding;
					for (var o$1 = r$1, a$1 = 0; a$1 < e$2.length; a$1++) {
						var l$1 = e$2[a$1];
						s$1[t$1 + a$1] = o$1, s$1.set(l$1, o$1), o$1 += l$1.length;
					}
					return s$1[t$1 + e$2.length] = o$1, s$1.set(this.keys, o$1), s$1[t$1 + e$2.length + 1] = o$1 += this.keys.length, s$1.set(this.bboxes, o$1), o$1 += this.bboxes.length, s$1.buffer;
				}, Zs;
			}());
			const Js = {};
			function Qs(t$1, e$1, r$1 = {}) {
				Object.defineProperty(t$1, "_classRegistryKey", {
					value: e$1,
					writable: !1
				}), Js[e$1] = {
					klass: t$1,
					omit: r$1.omit || []
				};
			}
			Qs(Object, "Object"), Ks.serialize = function(t$1, e$1) {
				const r$1 = t$1.toArrayBuffer();
				return e$1 && e$1.add(r$1), { buffer: r$1 };
			}, Ks.deserialize = function(t$1) {
				return new Ks(t$1.buffer);
			}, Object.defineProperty(Ks, "name", { value: "Grid" }), Qs(Ks, "Grid"), delete It.prototype.constructor, Qs(lr, "Color"), Qs(Error, "Error"), Qs(Dr, "Formatted"), Qs(Cr, "FormattedSection"), Qs(De, "AJAXError"), Qs(Lr, "ResolvedImage"), Qs(Hs, "StylePropertyFunction"), Qs(Us, "StyleExpression", { omit: ["_evaluator"] }), Qs(ir, "ImageId"), Qs(Rr, "ImageVariant"), Qs(Gs, "ZoomDependentExpression"), Qs($s, "ZoomConstantExpression"), Qs(sn, "CompoundExpression", { omit: ["_evaluate"] });
			for (const t$1 in gs) Js[gs[t$1]._classRegistryKey] || Qs(gs[t$1], `Expression${t$1}`);
			function to(t$1) {
				return t$1 && (t$1 instanceof ArrayBuffer || t$1.constructor && "ArrayBuffer" === t$1.constructor.name);
			}
			function eo(t$1, e$1) {
				if (null == t$1 || "boolean" == typeof t$1 || "number" == typeof t$1 || "string" == typeof t$1 || t$1 instanceof Boolean || t$1 instanceof Number || t$1 instanceof String || t$1 instanceof Date || t$1 instanceof RegExp) return t$1;
				if (to(t$1) || t$1 instanceof ImageBitmap) return e$1 && e$1.add(t$1), t$1;
				if (ArrayBuffer.isView(t$1)) return e$1 && e$1.add(t$1.buffer), t$1;
				if (t$1 instanceof ImageData) return e$1 && e$1.add(t$1.data.buffer), t$1;
				if (Array.isArray(t$1)) {
					const r$1 = [];
					for (const n$1 of t$1) r$1.push(eo(n$1, e$1));
					return r$1;
				}
				if (t$1 instanceof Map) {
					const r$1 = {
						$name: "Map",
						entries: []
					};
					for (const [n$1, i$1] of t$1.entries()) r$1.entries.push(eo(n$1), eo(i$1, e$1));
					return r$1;
				}
				if (t$1 instanceof Set) {
					const e$2 = { $name: "Set" };
					let r$1 = 0;
					for (const n$1 of t$1.values()) e$2[++r$1] = eo(n$1);
					return e$2;
				}
				if ("bigint" == typeof t$1) return {
					$name: "BigInt",
					value: t$1.toString()
				};
				if ("object" == typeof t$1) {
					const r$1 = t$1.constructor, n$1 = r$1._classRegistryKey;
					if (!n$1) throw new Error(`Can't serialize object of unregistered class "${r$1.name}".`);
					const i$1 = r$1.serialize ? r$1.serialize(t$1, e$1) : {};
					if (!r$1.serialize) {
						for (const r$2 in t$1) t$1.hasOwnProperty(r$2) && (Js[n$1].omit.indexOf(r$2) >= 0 || (i$1[r$2] = eo(t$1[r$2], e$1)));
						t$1 instanceof Error && (i$1.message = t$1.message);
					}
					if (i$1.$name) throw new Error("$name property is reserved for worker serialization logic.");
					return "Object" !== n$1 && (i$1.$name = n$1), i$1;
				}
				throw new Error("can't serialize object of type " + typeof t$1);
			}
			function ro(t$1) {
				if (null == t$1 || "boolean" == typeof t$1 || "number" == typeof t$1 || "string" == typeof t$1 || t$1 instanceof Boolean || t$1 instanceof Number || t$1 instanceof String || t$1 instanceof Date || t$1 instanceof RegExp || to(t$1) || t$1 instanceof ImageBitmap || ArrayBuffer.isView(t$1) || t$1 instanceof ImageData) return t$1;
				if (Array.isArray(t$1)) return t$1.map(ro);
				if ("object" == typeof t$1) {
					const e$1 = t$1.$name || "Object";
					if ("Map" === e$1) {
						const e$2 = t$1.entries || [], r$2 = /* @__PURE__ */ new Map();
						for (let t$2 = 0; t$2 < e$2.length; t$2 += 2) r$2.set(ro(e$2[t$2]), ro(e$2[t$2 + 1]));
						return r$2;
					}
					if ("Set" === e$1) {
						const e$2 = /* @__PURE__ */ new Set();
						for (const r$2 of Object.keys(t$1)) "$name" !== r$2 && e$2.add(ro(t$1[r$2]));
						return e$2;
					}
					if ("BigInt" === e$1) return BigInt(t$1.value);
					const { klass: r$1 } = Js[e$1];
					if (!r$1) throw new Error(`Can't deserialize unregistered class "${e$1}".`);
					if (r$1.deserialize) return r$1.deserialize(t$1);
					const n$1 = Object.create(r$1.prototype);
					for (const e$2 of Object.keys(t$1)) "$name" !== e$2 && (n$1[e$2] = ro(t$1[e$2]));
					return n$1;
				}
				throw new Error("can't deserialize object of type " + typeof t$1);
			}
			const no = {
				"Latin-1 Supplement": (t$1) => t$1 >= 128 && t$1 <= 255,
				Arabic: (t$1) => t$1 >= 1536 && t$1 <= 1791,
				"Arabic Supplement": (t$1) => t$1 >= 1872 && t$1 <= 1919,
				"Arabic Extended-A": (t$1) => t$1 >= 2208 && t$1 <= 2303,
				"Hangul Jamo": (t$1) => t$1 >= 4352 && t$1 <= 4607,
				"Unified Canadian Aboriginal Syllabics": (t$1) => t$1 >= 5120 && t$1 <= 5759,
				Khmer: (t$1) => t$1 >= 6016 && t$1 <= 6143,
				"Unified Canadian Aboriginal Syllabics Extended": (t$1) => t$1 >= 6320 && t$1 <= 6399,
				"General Punctuation": (t$1) => t$1 >= 8192 && t$1 <= 8303,
				"Letterlike Symbols": (t$1) => t$1 >= 8448 && t$1 <= 8527,
				"Number Forms": (t$1) => t$1 >= 8528 && t$1 <= 8591,
				"Miscellaneous Technical": (t$1) => t$1 >= 8960 && t$1 <= 9215,
				"Control Pictures": (t$1) => t$1 >= 9216 && t$1 <= 9279,
				"Optical Character Recognition": (t$1) => t$1 >= 9280 && t$1 <= 9311,
				"Enclosed Alphanumerics": (t$1) => t$1 >= 9312 && t$1 <= 9471,
				"Geometric Shapes": (t$1) => t$1 >= 9632 && t$1 <= 9727,
				"Miscellaneous Symbols": (t$1) => t$1 >= 9728 && t$1 <= 9983,
				"Miscellaneous Symbols and Arrows": (t$1) => t$1 >= 11008 && t$1 <= 11263,
				"CJK Radicals Supplement": (t$1) => t$1 >= 11904 && t$1 <= 12031,
				"Kangxi Radicals": (t$1) => t$1 >= 12032 && t$1 <= 12255,
				"Ideographic Description Characters": (t$1) => t$1 >= 12272 && t$1 <= 12287,
				"CJK Symbols and Punctuation": (t$1) => t$1 >= 12288 && t$1 <= 12351,
				Hiragana: (t$1) => t$1 >= 12352 && t$1 <= 12447,
				Katakana: (t$1) => t$1 >= 12448 && t$1 <= 12543,
				Bopomofo: (t$1) => t$1 >= 12544 && t$1 <= 12591,
				"Hangul Compatibility Jamo": (t$1) => t$1 >= 12592 && t$1 <= 12687,
				Kanbun: (t$1) => t$1 >= 12688 && t$1 <= 12703,
				"Bopomofo Extended": (t$1) => t$1 >= 12704 && t$1 <= 12735,
				"CJK Strokes": (t$1) => t$1 >= 12736 && t$1 <= 12783,
				"Katakana Phonetic Extensions": (t$1) => t$1 >= 12784 && t$1 <= 12799,
				"Enclosed CJK Letters and Months": (t$1) => t$1 >= 12800 && t$1 <= 13055,
				"CJK Compatibility": (t$1) => t$1 >= 13056 && t$1 <= 13311,
				"CJK Unified Ideographs Extension A": (t$1) => t$1 >= 13312 && t$1 <= 19903,
				"Yijing Hexagram Symbols": (t$1) => t$1 >= 19904 && t$1 <= 19967,
				"CJK Unified Ideographs": (t$1) => t$1 >= 19968 && t$1 <= 40959,
				"Yi Syllables": (t$1) => t$1 >= 40960 && t$1 <= 42127,
				"Yi Radicals": (t$1) => t$1 >= 42128 && t$1 <= 42191,
				"Hangul Jamo Extended-A": (t$1) => t$1 >= 43360 && t$1 <= 43391,
				"Hangul Syllables": (t$1) => t$1 >= 44032 && t$1 <= 55215,
				"Hangul Jamo Extended-B": (t$1) => t$1 >= 55216 && t$1 <= 55295,
				"Private Use Area": (t$1) => t$1 >= 57344 && t$1 <= 63743,
				"CJK Compatibility Ideographs": (t$1) => t$1 >= 63744 && t$1 <= 64255,
				"Arabic Presentation Forms-A": (t$1) => t$1 >= 64336 && t$1 <= 65023,
				"Vertical Forms": (t$1) => t$1 >= 65040 && t$1 <= 65055,
				"CJK Compatibility Forms": (t$1) => t$1 >= 65072 && t$1 <= 65103,
				"Small Form Variants": (t$1) => t$1 >= 65104 && t$1 <= 65135,
				"Arabic Presentation Forms-B": (t$1) => t$1 >= 65136 && t$1 <= 65279,
				"Halfwidth and Fullwidth Forms": (t$1) => t$1 >= 65280 && t$1 <= 65519,
				Osage: (t$1) => t$1 >= 66736 && t$1 <= 66815,
				"CJK Unified Ideographs Extension B": (t$1) => t$1 >= 131072 && t$1 <= 173791
			};
			function io(t$1) {
				for (const e$1 of t$1) if (ao(e$1.charCodeAt(0))) return !0;
				return !1;
			}
			function so(t$1) {
				for (const e$1 of t$1) if (!oo(e$1.charCodeAt(0))) return !1;
				return !0;
			}
			function oo(t$1) {
				return !(no.Arabic(t$1) || no["Arabic Supplement"](t$1) || no["Arabic Extended-A"](t$1) || no["Arabic Presentation Forms-A"](t$1) || no["Arabic Presentation Forms-B"](t$1));
			}
			function ao(t$1) {
				return !(746 !== t$1 && 747 !== t$1 && (t$1 < 4352 || !(no["Bopomofo Extended"](t$1) || no.Bopomofo(t$1) || no["CJK Compatibility Forms"](t$1) && !(t$1 >= 65097 && t$1 <= 65103) || no["CJK Compatibility Ideographs"](t$1) || no["CJK Compatibility"](t$1) || no["CJK Radicals Supplement"](t$1) || no["CJK Strokes"](t$1) || !(!no["CJK Symbols and Punctuation"](t$1) || t$1 >= 12296 && t$1 <= 12305 || t$1 >= 12308 && t$1 <= 12319 || 12336 === t$1) || no["CJK Unified Ideographs Extension A"](t$1) || no["CJK Unified Ideographs"](t$1) || no["Enclosed CJK Letters and Months"](t$1) || no["Hangul Compatibility Jamo"](t$1) || no["Hangul Jamo Extended-A"](t$1) || no["Hangul Jamo Extended-B"](t$1) || no["Hangul Jamo"](t$1) || no["Hangul Syllables"](t$1) || no.Hiragana(t$1) || no["Ideographic Description Characters"](t$1) || no.Kanbun(t$1) || no["Kangxi Radicals"](t$1) || no["Katakana Phonetic Extensions"](t$1) || no.Katakana(t$1) && 12540 !== t$1 || !(!no["Halfwidth and Fullwidth Forms"](t$1) || 65288 === t$1 || 65289 === t$1 || 65293 === t$1 || t$1 >= 65306 && t$1 <= 65310 || 65339 === t$1 || 65341 === t$1 || 65343 === t$1 || t$1 >= 65371 && t$1 <= 65503 || 65507 === t$1 || t$1 >= 65512 && t$1 <= 65519) || !(!no["Small Form Variants"](t$1) || t$1 >= 65112 && t$1 <= 65118 || t$1 >= 65123 && t$1 <= 65126) || no["Unified Canadian Aboriginal Syllabics"](t$1) || no["Unified Canadian Aboriginal Syllabics Extended"](t$1) || no["Vertical Forms"](t$1) || no["Yijing Hexagram Symbols"](t$1) || no["Yi Syllables"](t$1) || no["Yi Radicals"](t$1))));
			}
			function lo(t$1) {
				return !(ao(t$1) || function(t$2) {
					return !!(no["Latin-1 Supplement"](t$2) && (167 === t$2 || 169 === t$2 || 174 === t$2 || 177 === t$2 || 188 === t$2 || 189 === t$2 || 190 === t$2 || 215 === t$2 || 247 === t$2) || no["General Punctuation"](t$2) && (8214 === t$2 || 8224 === t$2 || 8225 === t$2 || 8240 === t$2 || 8241 === t$2 || 8251 === t$2 || 8252 === t$2 || 8258 === t$2 || 8263 === t$2 || 8264 === t$2 || 8265 === t$2 || 8273 === t$2) || no["Letterlike Symbols"](t$2) || no["Number Forms"](t$2) || no["Miscellaneous Technical"](t$2) && (t$2 >= 8960 && t$2 <= 8967 || t$2 >= 8972 && t$2 <= 8991 || t$2 >= 8996 && t$2 <= 9e3 || 9003 === t$2 || t$2 >= 9085 && t$2 <= 9114 || t$2 >= 9150 && t$2 <= 9165 || 9167 === t$2 || t$2 >= 9169 && t$2 <= 9179 || t$2 >= 9186 && t$2 <= 9215) || no["Control Pictures"](t$2) && 9251 !== t$2 || no["Optical Character Recognition"](t$2) || no["Enclosed Alphanumerics"](t$2) || no["Geometric Shapes"](t$2) || no["Miscellaneous Symbols"](t$2) && !(t$2 >= 9754 && t$2 <= 9759) || no["Miscellaneous Symbols and Arrows"](t$2) && (t$2 >= 11026 && t$2 <= 11055 || t$2 >= 11088 && t$2 <= 11097 || t$2 >= 11192 && t$2 <= 11243) || no["CJK Symbols and Punctuation"](t$2) || no.Katakana(t$2) || no["Private Use Area"](t$2) || no["CJK Compatibility Forms"](t$2) || no["Small Form Variants"](t$2) || no["Halfwidth and Fullwidth Forms"](t$2) || 8734 === t$2 || 8756 === t$2 || 8757 === t$2 || t$2 >= 9984 && t$2 <= 10087 || t$2 >= 10102 && t$2 <= 10131 || 65532 === t$2 || 65533 === t$2);
				}(t$1));
			}
			function uo(t$1) {
				return no.Arabic(t$1) || no["Arabic Supplement"](t$1) || no["Arabic Extended-A"](t$1) || no["Arabic Presentation Forms-A"](t$1) || no["Arabic Presentation Forms-B"](t$1);
			}
			function co(t$1) {
				return t$1 >= 1424 && t$1 <= 2303 || no["Arabic Presentation Forms-A"](t$1) || no["Arabic Presentation Forms-B"](t$1);
			}
			function ho(t$1, e$1) {
				return !(!e$1 && co(t$1) || t$1 >= 2304 && t$1 <= 3583 || t$1 >= 3840 && t$1 <= 4255 || no.Khmer(t$1));
			}
			function po(t$1) {
				for (const e$1 of t$1) if (co(e$1.charCodeAt(0))) return !0;
				return !1;
			}
			const fo = {
				unavailable: "unavailable",
				deferred: "deferred",
				loading: "loading",
				parsing: "parsing",
				parsed: "parsed",
				loaded: "loaded",
				error: "error"
			};
			let mo = null, yo = fo.unavailable, go = null;
			const xo = function(t$1) {
				t$1 && "string" == typeof t$1 && t$1.indexOf("NetworkError") > -1 && (yo = fo.error), mo && mo(t$1);
			};
			function vo() {
				bo.fire(new Qe("pluginStateChange", {
					pluginStatus: yo,
					pluginURL: go
				}));
			}
			const bo = new nr(), wo = function() {
				return yo;
			}, _o = function() {
				if (yo !== fo.deferred || !go) throw new Error("rtl-text-plugin cannot be downloaded unless a pluginURL is specified");
				yo = fo.loading, vo(), go && Oe({ url: go }, ((t$1) => {
					t$1 ? xo(t$1) : (yo = fo.loaded, vo());
				}));
			}, Ao = {
				applyArabicShaping: null,
				processBidirectionalText: null,
				processStyledBidirectionalText: null,
				isLoaded: () => yo === fo.loaded || null != Ao.applyArabicShaping,
				isLoading: () => yo === fo.loading,
				setState(t$1) {
					yo = t$1.pluginStatus, go = t$1.pluginURL;
				},
				isParsing: () => yo === fo.parsing,
				isParsed: () => yo === fo.parsed,
				getPluginURL: () => go
			};
			class Io {
				constructor(t$1, e$1) {
					this.zoom = t$1, e$1 ? (this.now = e$1.now, this.fadeDuration = e$1.fadeDuration, this.transition = e$1.transition, this.pitch = e$1.pitch, this.brightness = e$1.brightness, this.worldview = e$1.worldview, this.activeFloors = e$1.activeFloors) : (this.now = 0, this.fadeDuration = 0, this.transition = {}, this.pitch = 0, this.brightness = 0);
				}
				isSupportedScript(t$1) {
					return function(t$2, e$1) {
						for (const r$1 of t$2) if (!ho(r$1.charCodeAt(0), e$1)) return !1;
						return !0;
					}(t$1, Ao.isLoaded());
				}
			}
			class Mo {
				constructor(t$1, e$1, r$1, n$1, i$1) {
					this.property = t$1, this.value = e$1, this.expression = function(t$2, e$2, r$2, n$2, i$2) {
						if (Es(t$2)) return new Hs(t$2, e$2);
						if (Ns(t$2) || Array.isArray(t$2) && t$2.length > 0) {
							const s$1 = qs(t$2, e$2, r$2, n$2, i$2);
							if ("error" === s$1.result) throw new Error(s$1.value.map(((t$3) => `${t$3.key}: ${t$3.message}`)).join(", "));
							return s$1.value;
						}
						{
							let r$3 = t$2;
							return "string" == typeof t$2 && "color" === e$2.type && (r$3 = lr.parse(t$2)), {
								kind: "constant",
								configDependencies: /* @__PURE__ */ new Set(),
								isIndoorDependent: !1,
								evaluate: () => r$3
							};
						}
					}(void 0 === e$1 ? t$1.specification.default : e$1, t$1.specification, r$1, n$1, i$1);
				}
				isIndoorDependent() {
					return this.expression.isIndoorDependent;
				}
				isDataDriven() {
					return "source" === this.expression.kind || "composite" === this.expression.kind;
				}
				possiblyEvaluate(t$1, e$1, r$1, n$1) {
					return this.property.possiblyEvaluate(this, t$1, e$1, r$1, n$1);
				}
			}
			class So {
				constructor(t$1, e$1, r$1, n$1) {
					this.property = t$1, this.value = new Mo(t$1, void 0, e$1, r$1, n$1);
				}
				transitioned(t$1, e$1) {
					return new ko(this.property, this.value, e$1, Object.assign({}, t$1.transition, this.transition), t$1.now);
				}
				untransitioned() {
					return new ko(this.property, this.value, null, {}, 0);
				}
			}
			class Po {
				constructor(t$1, e$1, r$1, n$1) {
					this._properties = t$1, this._values = Object.create(t$1.defaultTransitionablePropertyValues), this._scope = e$1, this._options = r$1, this._iconImageUseTheme = n$1, this._isIndoorDependent = !1, this.configDependencies = /* @__PURE__ */ new Set();
				}
				getValue(t$1) {
					return Gt(this._values[t$1].value.value);
				}
				setValue(t$1, e$1) {
					this._values.hasOwnProperty(t$1) || (this._values[t$1] = new So(this._values[t$1].property, this._scope, this._options, this._iconImageUseTheme)), this._values[t$1].value = new Mo(this._values[t$1].property, null === e$1 ? void 0 : Gt(e$1), this._scope, this._options, this._iconImageUseTheme), this._values[t$1].value.expression.configDependencies && (this.configDependencies = new Set([...this.configDependencies, ...this._values[t$1].value.expression.configDependencies]), this._isIndoorDependent = this._isIndoorDependent || this._values[t$1].value.isIndoorDependent());
				}
				setTransitionOrValue(t$1, e$1) {
					e$1 && (this._options = e$1);
					const r$1 = this._properties.properties;
					if (t$1) for (const e$2 in t$1) {
						const n$1 = t$1[e$2];
						if (e$2.endsWith("-transition")) {
							const t$2 = e$2.slice(0, -11);
							r$1[t$2] && this.setTransition(t$2, n$1);
						} else r$1.hasOwnProperty(e$2) && this.setValue(e$2, n$1);
					}
				}
				getTransition(t$1) {
					return Gt(this._values[t$1].transition);
				}
				setTransition(t$1, e$1) {
					this._values.hasOwnProperty(t$1) || (this._values[t$1] = new So(this._values[t$1].property)), this._values[t$1].transition = Gt(e$1) || void 0;
				}
				serialize() {
					const t$1 = {};
					for (const e$1 of Object.keys(this._values)) {
						const r$1 = this.getValue(e$1);
						void 0 !== r$1 && (t$1[e$1] = r$1);
						const n$1 = this.getTransition(e$1);
						void 0 !== n$1 && (t$1[`${e$1}-transition`] = n$1);
					}
					return t$1;
				}
				transitioned(t$1, e$1) {
					const r$1 = new Bo(this._properties);
					for (const n$1 of Object.keys(this._values)) r$1._values[n$1] = this._values[n$1].transitioned(t$1, e$1._values[n$1]);
					return r$1;
				}
				untransitioned() {
					const t$1 = new Bo(this._properties);
					for (const e$1 of Object.keys(this._values)) t$1._values[e$1] = this._values[e$1].untransitioned();
					return t$1;
				}
				isIndoorDependent() {
					return this._isIndoorDependent;
				}
			}
			class ko {
				constructor(t$1, e$1, r$1, n$1, i$1) {
					const s$1 = n$1.delay || 0, o$1 = n$1.duration || 0;
					i$1 = i$1 || 0, this.property = t$1, this.value = e$1, this.begin = i$1 + s$1, this.end = this.begin + o$1, t$1.specification.transition && (n$1.delay || n$1.duration) && (this.prior = r$1);
				}
				possiblyEvaluate(t$1, e$1, r$1) {
					const n$1 = t$1.now || 0, i$1 = this.value.possiblyEvaluate(t$1, e$1, r$1), s$1 = this.prior;
					if (s$1) {
						if (n$1 > this.end) return this.prior = null, i$1;
						if (this.value.isDataDriven()) return this.prior = null, i$1;
						if (n$1 < this.begin) return s$1.possiblyEvaluate(t$1, e$1, r$1);
						{
							const o$1 = (n$1 - this.begin) / (this.end - this.begin);
							return this.property.interpolate(s$1.possiblyEvaluate(t$1, e$1, r$1), i$1, Tt(o$1));
						}
					}
					return i$1;
				}
			}
			class Bo {
				constructor(t$1) {
					this._properties = t$1, this._values = Object.create(t$1.defaultTransitioningPropertyValues);
				}
				possiblyEvaluate(t$1, e$1, r$1) {
					const n$1 = new Eo(this._properties);
					for (const i$1 of Object.keys(this._values)) n$1._values[i$1] = this._values[i$1].possiblyEvaluate(t$1, e$1, r$1);
					return n$1;
				}
				hasTransition() {
					for (const t$1 of Object.keys(this._values)) if (this._values[t$1].prior) return !0;
					return !1;
				}
			}
			class zo {
				constructor(t$1, e$1, r$1, n$1) {
					this._properties = t$1, this._values = Object.create(t$1.defaultPropertyValues), this._scope = e$1, this._options = r$1, this._iconImageUseTheme = n$1, this._isIndoorDependent = !1, this.configDependencies = /* @__PURE__ */ new Set();
				}
				getValue(t$1) {
					return Gt(this._values[t$1].value);
				}
				setValue(t$1, e$1) {
					this._values[t$1] = new Mo(this._values[t$1].property, null === e$1 ? void 0 : Gt(e$1), this._scope, this._options, this._iconImageUseTheme), this._values[t$1].expression.configDependencies && (this.configDependencies = new Set([...this.configDependencies, ...this._values[t$1].expression.configDependencies]), this._isIndoorDependent = this._isIndoorDependent || this._values[t$1].isIndoorDependent());
				}
				serialize() {
					const t$1 = {};
					for (const e$1 of Object.keys(this._values)) {
						const r$1 = this.getValue(e$1);
						void 0 !== r$1 && (t$1[e$1] = r$1);
					}
					return t$1;
				}
				possiblyEvaluate(t$1, e$1, r$1, n$1) {
					const i$1 = new Eo(this._properties);
					for (const s$1 of Object.keys(this._values)) i$1._values[s$1] = this._values[s$1].possiblyEvaluate(t$1, e$1, r$1, n$1);
					return i$1;
				}
				isIndoorDependent() {
					return this._isIndoorDependent;
				}
			}
			class To {
				constructor(t$1, e$1, r$1, n$1) {
					this.property = t$1, this.value = e$1, this.parameters = r$1, this.iconImageUseTheme = n$1;
				}
				isConstant() {
					return "constant" === this.value.kind;
				}
				constantOr(t$1) {
					return "constant" === this.value.kind ? this.value.value : t$1;
				}
				evaluate(t$1, e$1, r$1, n$1) {
					return this.property.evaluate(this.value, this.parameters, t$1, e$1, r$1, n$1, this.iconImageUseTheme);
				}
			}
			class Eo {
				constructor(t$1) {
					this._properties = t$1, this._values = Object.create(t$1.defaultPossiblyEvaluatedValues);
				}
				get(t$1) {
					return this._values[t$1];
				}
			}
			class Vo {
				constructor(t$1) {
					this.specification = t$1;
				}
				possiblyEvaluate(t$1, e$1) {
					return t$1.expression.evaluate(e$1);
				}
				interpolate(t$1, e$1, r$1) {
					const n$1 = fr[this.specification.type];
					return n$1 ? n$1(t$1, e$1, r$1) : t$1;
				}
			}
			class Fo {
				constructor(t$1, e$1) {
					this.specification = t$1, this.overrides = e$1;
				}
				possiblyEvaluate(t$1, e$1, r$1, n$1, i$1) {
					return "constant" === t$1.expression.kind || "camera" === t$1.expression.kind ? new To(this, {
						kind: "constant",
						value: t$1.expression.evaluate(e$1, null, {}, r$1, n$1, void 0, i$1)
					}, e$1) : new To(this, t$1.expression, e$1, i$1);
				}
				interpolate(t$1, e$1, r$1) {
					if ("constant" !== t$1.value.kind || "constant" !== e$1.value.kind) return t$1;
					if (void 0 === t$1.value.value || void 0 === e$1.value.value) return new To(this, {
						kind: "constant",
						value: void 0
					}, t$1.parameters);
					const n$1 = fr[this.specification.type];
					return n$1 ? new To(this, {
						kind: "constant",
						value: n$1(t$1.value.value, e$1.value.value, r$1)
					}, t$1.parameters) : t$1;
				}
				evaluate(t$1, e$1, r$1, n$1, i$1, s$1, o$1) {
					return "constant" === t$1.kind ? t$1.value : t$1.evaluate(e$1, r$1, n$1, i$1, s$1, void 0, o$1);
				}
			}
			class Co {
				constructor(t$1) {
					this.specification = t$1;
				}
				possiblyEvaluate(t$1, e$1, r$1, n$1) {
					return !!t$1.expression.evaluate(e$1, null, {}, r$1, n$1);
				}
				interpolate() {
					return !1;
				}
			}
			class Do {
				constructor(t$1) {
					this.properties = t$1, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];
					const e$1 = new Io(0, {});
					for (const r$1 in t$1) {
						const n$1 = t$1[r$1];
						n$1.specification.overridable && this.overridableProperties.push(r$1);
						const i$1 = this.defaultPropertyValues[r$1] = new Mo(n$1, void 0), s$1 = this.defaultTransitionablePropertyValues[r$1] = new So(n$1);
						this.defaultTransitioningPropertyValues[r$1] = s$1.untransitioned(), this.defaultPossiblyEvaluatedValues[r$1] = i$1.possiblyEvaluate(e$1);
					}
				}
			}
			Qs(Fo, "DataDrivenProperty"), Qs(Vo, "DataConstantProperty"), Qs(Co, "ColorRampProperty");
			var Ro = JSON.parse("{\"$version\":8,\"$root\":{\"version\":{\"type\":\"enum\",\"values\":[8]},\"fragment\":{\"type\":\"boolean\"},\"name\":{\"type\":\"string\"},\"metadata\":{\"type\":\"*\"},\"center\":{\"type\":\"array\",\"value\":\"number\"},\"zoom\":{\"type\":\"number\"},\"bearing\":{\"type\":\"number\",\"default\":0,\"period\":360},\"pitch\":{\"type\":\"number\",\"default\":0},\"light\":{\"type\":\"light\"},\"lights\":{\"type\":\"array\",\"value\":\"light-3d\"},\"terrain\":{\"type\":\"terrain\",\"optional\":true},\"fog\":{\"type\":\"fog\"},\"snow\":{\"type\":\"snow\"},\"rain\":{\"type\":\"rain\"},\"camera\":{\"type\":\"camera\"},\"color-theme\":{\"type\":\"colorTheme\"},\"indoor\":{\"type\":\"indoor\"},\"imports\":{\"type\":\"array\",\"value\":\"import\"},\"iconsets\":{\"type\":\"iconsets\"},\"schema\":{\"type\":\"schema\"},\"sources\":{\"type\":\"sources\"},\"sprite\":{\"type\":\"string\"},\"glyphs\":{\"type\":\"string\",\"default\":\"mapbox://fonts/mapbox/{fontstack}/{range}.pbf\"},\"transition\":{\"type\":\"transition\"},\"projection\":{\"type\":\"projection\"},\"layers\":{\"type\":\"array\",\"value\":\"layer\"},\"models\":{\"type\":\"models\"},\"featuresets\":{\"type\":\"featuresets\"}},\"featuresets\":{\"*\":{\"type\":\"featureset\"}},\"featureset\":{\"metadata\":{\"type\":\"*\"},\"selectors\":{\"type\":\"array\",\"value\":\"selector\"}},\"selector\":{\"layer\":{\"type\":\"string\"},\"properties\":{\"type\":\"selectorProperty\"},\"featureNamespace\":{\"type\":\"string\"},\"_uniqueFeatureID\":{\"type\":\"boolean\"}},\"selectorProperty\":{\"*\":{\"type\":\"*\"}},\"model\":{\"type\":\"string\"},\"import\":{\"id\":{\"type\":\"string\"},\"url\":{\"type\":\"string\"},\"config\":{\"type\":\"config\"},\"data\":{\"type\":\"$root\"},\"color-theme\":{\"type\":\"colorTheme\",\"optional\":true}},\"config\":{\"*\":{\"type\":\"*\"}},\"schema\":{\"*\":{\"type\":\"option\"}},\"option\":{\"default\":{\"type\":\"*\",\"expression\":{}},\"type\":{\"type\":\"enum\",\"values\":{\"string\":1,\"number\":1,\"boolean\":1,\"color\":1}},\"array\":{\"type\":\"boolean\"},\"minValue\":{\"type\":\"number\"},\"maxValue\":{\"type\":\"number\"},\"stepValue\":{\"type\":\"number\"},\"values\":{\"type\":\"array\",\"value\":\"*\"},\"metadata\":{\"type\":\"*\"}},\"models\":{\"*\":{\"type\":\"model\"}},\"light-3d\":{\"id\":{\"type\":\"string\"},\"properties\":{\"type\":\"properties\"},\"type\":{\"type\":\"enum\",\"values\":{\"ambient\":{},\"directional\":{},\"flat\":{}}}},\"properties\":[\"properties_light_directional\",\"properties_light_ambient\",\"properties_light_flat\"],\"properties_light_directional\":{\"direction\":{\"type\":\"array\",\"default\":[210,30],\"minimum\":[0,0],\"maximum\":[360,90],\"length\":2,\"value\":\"number\",\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"color\":{\"type\":\"color\",\"default\":\"#ffffff\",\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"use-theme\":true,\"transition\":true},\"intensity\":{\"type\":\"number\",\"default\":0.5,\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"transition\":true},\"cast-shadows\":{\"type\":\"boolean\",\"default\":false},\"shadow-quality\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"expression\":{\"parameters\":[\"zoom\"]}},\"shadow-intensity\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"transition\":true}},\"properties_light_ambient\":{\"color\":{\"type\":\"color\",\"default\":\"#ffffff\",\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"use-theme\":true,\"transition\":true},\"intensity\":{\"type\":\"number\",\"default\":0.5,\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"transition\":true}},\"properties_light_flat\":{\"anchor\":{\"type\":\"enum\",\"default\":\"viewport\",\"values\":{\"map\":1,\"viewport\":1},\"expression\":{\"parameters\":[\"zoom\"]}},\"position\":{\"type\":\"array\",\"default\":[1.15,210,30],\"length\":3,\"value\":\"number\",\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"color\":{\"type\":\"color\",\"default\":\"#ffffff\",\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"use-theme\":true,\"transition\":true},\"intensity\":{\"type\":\"number\",\"default\":0.5,\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"transition\":true}},\"iconsets\":{\"*\":{\"type\":\"iconset\"}},\"iconset\":[\"iconset_sprite\",\"iconset_source\"],\"iconset_sprite\":{\"type\":{\"type\":\"enum\",\"values\":{\"sprite\":1}},\"url\":{\"type\":\"string\"}},\"iconset_source\":{\"type\":{\"type\":\"enum\",\"values\":{\"source\":1}},\"source\":{\"type\":\"string\"}},\"sources\":{\"*\":{\"type\":\"source\"}},\"source\":[\"source_vector\",\"source_raster\",\"source_raster_dem\",\"source_raster_array\",\"source_geojson\",\"source_video\",\"source_image\",\"source_model\"],\"source_vector\":{\"type\":{\"type\":\"enum\",\"values\":{\"vector\":1}},\"url\":{\"type\":\"string\"},\"tiles\":{\"type\":\"array\",\"value\":\"string\"},\"bounds\":{\"type\":\"array\",\"value\":\"number\",\"length\":4,\"default\":[-180,-85.051129,180,85.051129]},\"extra_bounds\":{\"type\":\"array\",\"value\":{\"type\":\"array\",\"value\":\"number\",\"length\":4}},\"scheme\":{\"type\":\"enum\",\"values\":{\"xyz\":1,\"tms\":1},\"default\":\"xyz\"},\"minzoom\":{\"type\":\"number\",\"default\":0},\"maxzoom\":{\"type\":\"number\",\"default\":22},\"attribution\":{\"type\":\"string\"},\"promoteId\":{\"type\":\"promoteId\"},\"volatile\":{\"type\":\"boolean\",\"default\":false},\"*\":{\"type\":\"*\"}},\"source_raster\":{\"type\":{\"type\":\"enum\",\"values\":{\"raster\":1}},\"url\":{\"type\":\"string\"},\"tiles\":{\"type\":\"array\",\"value\":\"string\"},\"bounds\":{\"type\":\"array\",\"value\":\"number\",\"length\":4,\"default\":[-180,-85.051129,180,85.051129]},\"extra_bounds\":{\"type\":\"array\",\"value\":{\"type\":\"array\",\"value\":\"number\",\"length\":4}},\"minzoom\":{\"type\":\"number\",\"default\":0},\"maxzoom\":{\"type\":\"number\",\"default\":22},\"tileSize\":{\"type\":\"number\",\"default\":512},\"scheme\":{\"type\":\"enum\",\"values\":{\"xyz\":1,\"tms\":1},\"default\":\"xyz\"},\"attribution\":{\"type\":\"string\"},\"volatile\":{\"type\":\"boolean\",\"default\":false},\"*\":{\"type\":\"*\"}},\"source_raster_dem\":{\"type\":{\"type\":\"enum\",\"values\":{\"raster-dem\":1}},\"url\":{\"type\":\"string\"},\"tiles\":{\"type\":\"array\",\"value\":\"string\"},\"bounds\":{\"type\":\"array\",\"value\":\"number\",\"length\":4,\"default\":[-180,-85.051129,180,85.051129]},\"extra_bounds\":{\"type\":\"array\",\"value\":{\"type\":\"array\",\"value\":\"number\",\"length\":4}},\"minzoom\":{\"type\":\"number\",\"default\":0},\"maxzoom\":{\"type\":\"number\",\"default\":22},\"tileSize\":{\"type\":\"number\",\"default\":512},\"attribution\":{\"type\":\"string\"},\"encoding\":{\"type\":\"enum\",\"values\":{\"terrarium\":1,\"mapbox\":1},\"default\":\"mapbox\"},\"volatile\":{\"type\":\"boolean\",\"default\":false},\"*\":{\"type\":\"*\"}},\"source_raster_array\":{\"type\":{\"type\":\"enum\",\"values\":{\"raster-array\":1}},\"url\":{\"type\":\"string\"},\"tiles\":{\"type\":\"array\",\"value\":\"string\"},\"bounds\":{\"type\":\"array\",\"value\":\"number\",\"length\":4,\"default\":[-180,-85.051129,180,85.051129]},\"extra_bounds\":{\"type\":\"array\",\"value\":{\"type\":\"array\",\"value\":\"number\",\"length\":4}},\"minzoom\":{\"type\":\"number\",\"default\":0},\"maxzoom\":{\"type\":\"number\",\"default\":22},\"tileSize\":{\"type\":\"number\",\"default\":512},\"attribution\":{\"type\":\"string\"},\"rasterLayers\":{\"type\":\"*\"},\"volatile\":{\"type\":\"boolean\",\"default\":false},\"*\":{\"type\":\"*\"}},\"source_geojson\":{\"type\":{\"type\":\"enum\",\"values\":{\"geojson\":1}},\"data\":{\"type\":\"*\"},\"maxzoom\":{\"type\":\"number\",\"default\":18},\"minzoom\":{\"type\":\"number\",\"default\":0},\"attribution\":{\"type\":\"string\"},\"buffer\":{\"type\":\"number\",\"default\":128,\"maximum\":512,\"minimum\":0},\"filter\":{\"type\":\"*\"},\"tolerance\":{\"type\":\"number\",\"default\":0.375},\"cluster\":{\"type\":\"boolean\",\"default\":false},\"clusterRadius\":{\"type\":\"number\",\"default\":50,\"minimum\":0},\"clusterMaxZoom\":{\"type\":\"number\"},\"clusterMinPoints\":{\"type\":\"number\"},\"clusterProperties\":{\"type\":\"*\"},\"lineMetrics\":{\"type\":\"boolean\",\"default\":false},\"generateId\":{\"type\":\"boolean\",\"default\":false},\"promoteId\":{\"type\":\"promoteId\"},\"dynamic\":{\"type\":\"boolean\",\"default\":false}},\"source_video\":{\"type\":{\"type\":\"enum\",\"values\":{\"video\":1}},\"urls\":{\"type\":\"array\",\"value\":\"string\"},\"coordinates\":{\"type\":\"array\",\"length\":4,\"value\":{\"type\":\"array\",\"length\":2,\"value\":\"number\"}}},\"source_image\":{\"type\":{\"type\":\"enum\",\"values\":{\"image\":1}},\"url\":{\"type\":\"string\"},\"coordinates\":{\"type\":\"array\",\"length\":4,\"value\":{\"type\":\"array\",\"length\":2,\"value\":\"number\"}}},\"modelNodeOverride\":{\"orientation\":{\"type\":\"array\",\"value\":\"number\",\"length\":3,\"default\":[0,0,0],\"period\":360}},\"modelNodeOverrides\":{\"*\":{\"type\":\"modelNodeOverride\"}},\"modelMaterialOverride\":{\"model-color\":{\"type\":\"color\"},\"model-color-mix-intensity\":{\"type\":\"number\"},\"model-opacity\":{\"type\":\"number\"},\"model-emissive-strength\":{\"type\":\"number\"}},\"modelMaterialOverrides\":{\"*\":{\"type\":\"modelMaterialOverride\"}},\"modelSourceModel\":{\"uri\":{\"type\":\"string\"},\"position\":{\"type\":\"array\",\"value\":\"number\",\"length\":2,\"default\":[0,0],\"minimum\":[-180,-90],\"maximum\":[180,90]},\"orientation\":{\"type\":\"array\",\"value\":\"number\",\"length\":3,\"default\":[0,0,0],\"period\":360},\"nodeOverrides\":{\"type\":\"modelNodeOverrides\"},\"materialOverrides\":{\"type\":\"modelMaterialOverrides\"},\"nodeOverrideNames\":{\"type\":\"array\",\"value\":\"string\"},\"materialOverrideNames\":{\"type\":\"array\",\"value\":\"string\"},\"featureProperties\":{\"type\":\"*\"}},\"modelSourceModels\":{\"*\":{\"type\":\"modelSourceModel\"}},\"source_model\":{\"type\":{\"type\":\"enum\",\"values\":{\"model\":1,\"batched-model\":1}},\"maxzoom\":{\"type\":\"number\",\"default\":18},\"minzoom\":{\"type\":\"number\",\"default\":0},\"tiles\":{\"type\":\"array\",\"value\":\"string\"},\"models\":{\"type\":\"modelSourceModels\"}},\"layer\":{\"id\":{\"type\":\"string\"},\"type\":{\"type\":\"enum\",\"values\":{\"fill\":{},\"line\":{},\"symbol\":{},\"circle\":{},\"heatmap\":{},\"fill-extrusion\":{},\"building\":{},\"raster\":{},\"raster-particle\":{},\"hillshade\":{},\"model\":{},\"background\":{},\"sky\":{},\"slot\":{},\"clip\":{}}},\"metadata\":{\"type\":\"*\"},\"source\":{\"type\":\"string\"},\"source-layer\":{\"type\":\"string\"},\"slot\":{\"type\":\"string\"},\"minzoom\":{\"type\":\"number\",\"minimum\":0,\"maximum\":24},\"maxzoom\":{\"type\":\"number\",\"minimum\":0,\"maximum\":24},\"filter\":{\"type\":\"filter\"},\"layout\":{\"type\":\"layout\"},\"paint\":{\"type\":\"paint\"},\"appearances\":{\"type\":\"array\",\"value\":\"appearance\",\"supported-layer-types\":[\"symbol\"]}},\"appearance\":{\"condition\":{\"type\":\"boolean\",\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"pitch\",\"feature\",\"feature-state\",\"measure-light\",\"distance-from-center\"]},\"property-type\":\"data-driven\"},\"name\":{\"type\":\"string\"},\"properties\":{\"type\":\"*\"}},\"layout\":[\"layout_clip\",\"layout_fill\",\"layout_line\",\"layout_circle\",\"layout_heatmap\",\"layout_fill-extrusion\",\"layout_building\",\"layout_symbol\",\"layout_raster\",\"layout_raster-particle\",\"layout_hillshade\",\"layout_background\",\"layout_sky\",\"layout_model\"],\"layout_background\":{\"visibility\":{\"type\":\"enum\",\"values\":{\"visible\":1,\"none\":1},\"default\":\"visible\",\"expression\":{}}},\"layout_sky\":{\"visibility\":{\"type\":\"enum\",\"values\":{\"visible\":1,\"none\":1},\"default\":\"visible\",\"expression\":{}}},\"layout_model\":{\"visibility\":{\"type\":\"enum\",\"values\":{\"visible\":1,\"none\":1},\"default\":\"visible\",\"expression\":{}},\"model-id\":{\"type\":\"string\",\"default\":\"\",\"property-type\":\"data-driven\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]}}},\"layout_clip\":{\"clip-layer-types\":{\"type\":\"array\",\"value\":\"enum\",\"values\":{\"model\":1,\"symbol\":1},\"default\":[],\"expression\":{}},\"clip-layer-scope\":{\"type\":\"array\",\"value\":\"string\",\"default\":[],\"expression\":{}}},\"layout_fill\":{\"fill-sort-key\":{\"type\":\"number\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"visibility\":{\"type\":\"enum\",\"values\":{\"visible\":1,\"none\":1},\"default\":\"visible\",\"expression\":{}},\"fill-elevation-reference\":{\"type\":\"enum\",\"values\":{\"none\":1,\"hd-road-base\":1,\"hd-road-markup\":1},\"default\":\"none\",\"expression\":{}},\"fill-construct-bridge-guard-rail\":{\"type\":\"boolean\",\"default\":\"true\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"}},\"layout_circle\":{\"circle-sort-key\":{\"type\":\"number\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"circle-elevation-reference\":{\"type\":\"enum\",\"values\":{\"none\":1,\"hd-road-markup\":1},\"default\":\"none\",\"expression\":{}},\"visibility\":{\"type\":\"enum\",\"values\":{\"visible\":1,\"none\":1},\"default\":\"visible\",\"expression\":{}}},\"layout_heatmap\":{\"visibility\":{\"type\":\"enum\",\"values\":{\"visible\":1,\"none\":1},\"default\":\"visible\",\"expression\":{}}},\"layout_fill-extrusion\":{\"visibility\":{\"type\":\"enum\",\"values\":{\"visible\":1,\"none\":1},\"default\":\"visible\",\"expression\":{}},\"fill-extrusion-edge-radius\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"maximum\":1,\"expression\":{}}},\"layout_building\":{\"visibility\":{\"type\":\"enum\",\"values\":{\"visible\":1,\"none\":1},\"default\":\"visible\",\"expression\":{}},\"building-facade\":{\"type\":\"boolean\",\"default\":false,\"expression\":{\"parameters\":[\"feature\"]},\"property-type\":\"data-driven\"},\"building-facade-floors\":{\"type\":\"number\",\"minimum\":1,\"maximum\":200,\"default\":3,\"property-type\":\"data-driven\",\"expression\":{\"parameters\":[\"feature\"]}},\"building-facade-unit-width\":{\"type\":\"number\",\"minimum\":1,\"maximum\":20,\"default\":3.1,\"property-type\":\"data-driven\",\"expression\":{\"parameters\":[\"feature\"]}},\"building-facade-window\":{\"type\":\"array\",\"length\":2,\"value\":\"number\",\"minimum\":0.1,\"maximum\":1,\"default\":[0.9,0.9],\"property-type\":\"data-driven\",\"expression\":{\"parameters\":[\"feature\"]}},\"building-roof-shape\":{\"type\":\"enum\",\"values\":{\"flat\":1,\"hipped\":1,\"gabled\":1,\"parapet\":1,\"mansard\":1,\"skillion\":1,\"pyramidal\":1},\"default\":\"flat\",\"expression\":{\"parameters\":[\"feature\"]},\"property-type\":\"data-driven\"},\"building-height\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{},\"property-type\":\"data-driven\"},\"building-base\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{},\"property-type\":\"data-driven\"},\"building-flood-light-wall-radius\":{\"property-type\":\"data-driven\",\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"feature\",\"feature-state\"]}},\"building-flood-light-ground-radius\":{\"property-type\":\"data-driven\",\"type\":\"number\",\"default\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"feature\",\"feature-state\"]}},\"building-flip-roof-orientation\":{\"property-type\":\"data-driven\",\"type\":\"boolean\",\"default\":false,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"feature\",\"feature-state\"]}}},\"layout_line\":{\"line-cap\":{\"type\":\"enum\",\"values\":{\"butt\":1,\"round\":1,\"square\":1},\"default\":\"butt\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"line-join\":{\"type\":\"enum\",\"values\":{\"bevel\":1,\"round\":1,\"miter\":1,\"none\":1},\"default\":\"miter\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"line-miter-limit\":{\"type\":\"number\",\"default\":2,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"line-round-limit\":{\"type\":\"number\",\"default\":1.05,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"line-sort-key\":{\"type\":\"number\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"line-z-offset\":{\"type\":\"number\",\"default\":0,\"expression\":{\"parameters\":[\"zoom\",\"feature\",\"line-progress\"]},\"property-type\":\"data-driven\"},\"line-elevation-reference\":{\"type\":\"enum\",\"values\":{\"none\":1,\"sea\":1,\"ground\":1,\"hd-road-markup\":1},\"default\":\"none\",\"expression\":{}},\"line-cross-slope\":{\"type\":\"number\",\"expression\":{}},\"visibility\":{\"type\":\"enum\",\"values\":{\"visible\":1,\"none\":1},\"default\":\"visible\",\"expression\":{}},\"line-width-unit\":{\"type\":\"enum\",\"values\":{\"pixels\":1,\"meters\":1},\"default\":\"pixels\",\"expression\":{\"parameters\":[\"zoom\"]}}},\"layout_symbol\":{\"symbol-placement\":{\"type\":\"enum\",\"values\":{\"point\":1,\"line\":1,\"line-center\":1},\"default\":\"point\",\"expression\":{\"parameters\":[\"zoom\"]}},\"symbol-spacing\":{\"type\":\"number\",\"default\":250,\"minimum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"symbol-avoid-edges\":{\"type\":\"boolean\",\"default\":false,\"expression\":{\"parameters\":[\"zoom\"]}},\"symbol-sort-key\":{\"type\":\"number\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"symbol-z-order\":{\"type\":\"enum\",\"values\":{\"auto\":1,\"viewport-y\":1,\"source\":1},\"default\":\"auto\",\"expression\":{\"parameters\":[\"zoom\"]}},\"symbol-z-elevate\":{\"type\":\"boolean\",\"default\":false,\"expression\":{\"parameters\":[\"zoom\"]}},\"symbol-elevation-reference\":{\"type\":\"enum\",\"values\":{\"sea\":1,\"ground\":1,\"hd-road-markup\":1},\"default\":\"ground\",\"expression\":{\"parameters\":[\"zoom\"]}},\"icon-allow-overlap\":{\"type\":\"boolean\",\"default\":false,\"expression\":{\"parameters\":[\"zoom\"]}},\"icon-ignore-placement\":{\"type\":\"boolean\",\"default\":false,\"expression\":{\"parameters\":[\"zoom\"]}},\"icon-optional\":{\"type\":\"boolean\",\"default\":false,\"expression\":{\"parameters\":[\"zoom\"]}},\"icon-rotation-alignment\":{\"type\":\"enum\",\"values\":{\"map\":1,\"viewport\":1,\"auto\":1},\"default\":\"auto\",\"expression\":{\"parameters\":[\"zoom\"]}},\"icon-size\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"appearance\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"icon-size-scale-range\":{\"type\":\"array\",\"value\":\"number\",\"length\":2,\"default\":[0.8,2],\"minimum\":[0.1,0.1],\"maximum\":[10,10],\"expression\":{}},\"icon-text-fit\":{\"type\":\"enum\",\"values\":{\"none\":1,\"width\":1,\"height\":1,\"both\":1},\"default\":\"none\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"icon-text-fit-padding\":{\"type\":\"array\",\"value\":\"number\",\"length\":4,\"default\":[0,0,0,0],\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"icon-image\":{\"type\":\"resolvedImage\",\"tokens\":true,\"appearance\":true,\"use-theme\":true,\"expression\":{\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"icon-rotate\":{\"type\":\"number\",\"default\":0,\"period\":360,\"appearance\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"icon-padding\":{\"type\":\"number\",\"default\":2,\"minimum\":0,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"icon-keep-upright\":{\"type\":\"boolean\",\"default\":false,\"expression\":{\"parameters\":[\"zoom\"]}},\"icon-offset\":{\"type\":\"array\",\"value\":\"number\",\"length\":2,\"default\":[0,0],\"appearance\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"icon-anchor\":{\"type\":\"enum\",\"values\":{\"center\":1,\"left\":1,\"right\":1,\"top\":1,\"bottom\":1,\"top-left\":1,\"top-right\":1,\"bottom-left\":1,\"bottom-right\":1},\"default\":\"center\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"icon-pitch-alignment\":{\"type\":\"enum\",\"values\":{\"map\":1,\"viewport\":1,\"auto\":1},\"default\":\"auto\",\"expression\":{\"parameters\":[\"zoom\"]}},\"text-pitch-alignment\":{\"type\":\"enum\",\"values\":{\"map\":1,\"viewport\":1,\"auto\":1},\"default\":\"auto\",\"expression\":{\"parameters\":[\"zoom\"]}},\"text-rotation-alignment\":{\"type\":\"enum\",\"values\":{\"map\":1,\"viewport\":1,\"auto\":1},\"default\":\"auto\",\"expression\":{\"parameters\":[\"zoom\"]}},\"text-field\":{\"type\":\"formatted\",\"default\":\"\",\"tokens\":true,\"expression\":{\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"text-font\":{\"type\":\"array\",\"value\":\"string\",\"default\":[\"Open Sans Regular\",\"Arial Unicode MS Regular\"],\"expression\":{\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"text-size\":{\"type\":\"number\",\"default\":16,\"minimum\":0,\"appearance\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"text-size-scale-range\":{\"type\":\"array\",\"value\":\"number\",\"length\":2,\"default\":[0.8,2],\"minimum\":[0.1,0.1],\"maximum\":[10,10],\"expression\":{}},\"text-max-width\":{\"type\":\"number\",\"default\":10,\"minimum\":0,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"text-line-height\":{\"type\":\"number\",\"default\":1.2,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"text-letter-spacing\":{\"type\":\"number\",\"default\":0,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"text-justify\":{\"type\":\"enum\",\"values\":{\"auto\":1,\"left\":1,\"center\":1,\"right\":1},\"default\":\"center\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"text-radial-offset\":{\"type\":\"number\",\"default\":0,\"property-type\":\"data-driven\",\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\"]}},\"text-variable-anchor\":{\"type\":\"array\",\"value\":\"enum\",\"values\":{\"center\":1,\"left\":1,\"right\":1,\"top\":1,\"bottom\":1,\"top-left\":1,\"top-right\":1,\"bottom-left\":1,\"bottom-right\":1},\"expression\":{\"parameters\":[\"zoom\"]}},\"text-anchor\":{\"type\":\"enum\",\"values\":{\"center\":1,\"left\":1,\"right\":1,\"top\":1,\"bottom\":1,\"top-left\":1,\"top-right\":1,\"bottom-left\":1,\"bottom-right\":1},\"default\":\"center\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"text-max-angle\":{\"type\":\"number\",\"default\":45,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"text-writing-mode\":{\"type\":\"array\",\"value\":\"enum\",\"values\":{\"horizontal\":1,\"vertical\":1},\"expression\":{\"parameters\":[\"zoom\"]}},\"text-rotate\":{\"type\":\"number\",\"default\":0,\"period\":360,\"appearance\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"text-padding\":{\"type\":\"number\",\"default\":2,\"minimum\":0,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"text-keep-upright\":{\"type\":\"boolean\",\"default\":true,\"expression\":{\"parameters\":[\"zoom\"]}},\"text-transform\":{\"type\":\"enum\",\"values\":{\"none\":1,\"uppercase\":1,\"lowercase\":1},\"default\":\"none\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"text-offset\":{\"type\":\"array\",\"value\":\"number\",\"length\":2,\"default\":[0,0],\"appearance\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"text-allow-overlap\":{\"type\":\"boolean\",\"default\":false,\"expression\":{\"parameters\":[\"zoom\"]}},\"text-ignore-placement\":{\"type\":\"boolean\",\"default\":false,\"expression\":{\"parameters\":[\"zoom\"]}},\"text-optional\":{\"type\":\"boolean\",\"default\":false,\"expression\":{\"parameters\":[\"zoom\"]}},\"visibility\":{\"type\":\"enum\",\"values\":{\"visible\":1,\"none\":1},\"default\":\"visible\",\"expression\":{}}},\"layout_raster\":{\"visibility\":{\"type\":\"enum\",\"values\":{\"visible\":1,\"none\":1},\"default\":\"visible\",\"expression\":{}}},\"layout_raster-particle\":{\"visibility\":{\"type\":\"enum\",\"values\":{\"visible\":1,\"none\":1},\"default\":\"visible\",\"expression\":{}}},\"layout_hillshade\":{\"visibility\":{\"type\":\"enum\",\"values\":{\"visible\":1,\"none\":1},\"default\":\"visible\",\"expression\":{}}},\"filter\":{\"type\":\"array\",\"value\":\"*\"},\"filter_symbol\":{\"type\":\"boolean\",\"default\":false,\"property-type\":\"data-driven\",\"expression\":{\"parameters\":[\"zoom\",\"feature\",\"pitch\",\"distance-from-center\"]}},\"filter_fill\":{\"type\":\"boolean\",\"default\":false,\"property-type\":\"data-driven\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]}},\"filter_hillshade\":{\"type\":\"boolean\",\"default\":false,\"property-type\":\"data-driven\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]}},\"filter_raster\":{\"type\":\"boolean\",\"default\":false,\"property-type\":\"data-driven\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]}},\"filter_raster-particle\":{\"type\":\"boolean\",\"default\":false,\"property-type\":\"data-driven\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]}},\"filter_clip\":{\"type\":\"boolean\",\"default\":false,\"property-type\":\"data-driven\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]}},\"filter_model\":{\"type\":\"boolean\",\"default\":false,\"property-type\":\"data-driven\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]}},\"filter_line\":{\"type\":\"boolean\",\"default\":false,\"property-type\":\"data-driven\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]}},\"filter_circle\":{\"type\":\"boolean\",\"default\":false,\"property-type\":\"data-driven\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]}},\"filter_fill-extrusion\":{\"type\":\"boolean\",\"default\":false,\"property-type\":\"data-driven\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]}},\"filter_building\":{\"type\":\"boolean\",\"default\":false,\"property-type\":\"data-driven\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]}},\"filter_heatmap\":{\"type\":\"boolean\",\"default\":false,\"property-type\":\"data-driven\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]}},\"filter_operator\":{\"type\":\"enum\",\"values\":{\"==\":1,\"!=\":1,\">\":1,\">=\":1,\"<\":1,\"<=\":1,\"in\":1,\"!in\":1,\"all\":1,\"any\":1,\"none\":1,\"has\":1,\"!has\":1}},\"geometry_type\":{\"type\":\"enum\",\"values\":{\"Point\":1,\"LineString\":1,\"Polygon\":1}},\"function\":{\"expression\":{\"type\":\"expression\"},\"stops\":{\"type\":\"array\",\"value\":\"function_stop\"},\"base\":{\"type\":\"number\",\"default\":1,\"minimum\":0},\"property\":{\"type\":\"string\",\"default\":\"$zoom\"},\"type\":{\"type\":\"enum\",\"values\":{\"identity\":1,\"exponential\":1,\"interval\":1,\"categorical\":1},\"default\":\"exponential\"},\"colorSpace\":{\"type\":\"enum\",\"values\":{\"rgb\":1,\"lab\":1,\"hcl\":1},\"default\":\"rgb\"},\"default\":{\"type\":\"*\"}},\"function_stop\":{\"type\":\"array\",\"minimum\":0,\"maximum\":24,\"value\":[\"number\",\"color\"],\"length\":2},\"expression\":{\"type\":\"array\",\"value\":\"*\",\"minimum\":1},\"fog\":{\"range\":{\"type\":\"array\",\"default\":[0.5,10],\"minimum\":-20,\"maximum\":20,\"length\":2,\"value\":\"number\",\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"],\"relaxZoomRestriction\":true}},\"color\":{\"type\":\"color\",\"default\":\"#ffffff\",\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"],\"relaxZoomRestriction\":true},\"use-theme\":true,\"transition\":true},\"high-color\":{\"type\":\"color\",\"default\":\"#245cdf\",\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"],\"relaxZoomRestriction\":true},\"use-theme\":true,\"transition\":true},\"space-color\":{\"type\":\"color\",\"default\":[\"interpolate\",[\"linear\"],[\"zoom\"],4,\"#010b19\",7,\"#367ab9\"],\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"],\"relaxZoomRestriction\":true},\"use-theme\":true,\"transition\":true},\"horizon-blend\":{\"type\":\"number\",\"default\":[\"interpolate\",[\"linear\"],[\"zoom\"],4,0.2,7,0.1],\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"],\"relaxZoomRestriction\":true},\"transition\":true},\"star-intensity\":{\"type\":\"number\",\"default\":[\"interpolate\",[\"linear\"],[\"zoom\"],5,0.35,6,0],\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"],\"relaxZoomRestriction\":true},\"transition\":true},\"vertical-range\":{\"type\":\"array\",\"default\":[0,0],\"minimum\":0,\"length\":2,\"value\":\"number\",\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"],\"relaxZoomRestriction\":true}}},\"snow\":{\"density\":{\"type\":\"number\",\"default\":[\"interpolate\",[\"linear\"],[\"zoom\"],11,0,13,0.85],\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"],\"relaxZoomRestriction\":true},\"transition\":true},\"intensity\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"],\"relaxZoomRestriction\":true},\"transition\":true},\"color\":{\"type\":\"color\",\"default\":\"#ffffff\",\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"],\"relaxZoomRestriction\":true},\"use-theme\":true,\"transition\":true},\"opacity\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"],\"relaxZoomRestriction\":true},\"transition\":true},\"vignette\":{\"type\":\"number\",\"default\":[\"interpolate\",[\"linear\"],[\"zoom\"],11,0,13,0.3],\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"],\"relaxZoomRestriction\":true},\"transition\":true},\"vignette-color\":{\"type\":\"color\",\"default\":\"#ffffff\",\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"],\"relaxZoomRestriction\":true},\"use-theme\":true,\"transition\":true},\"center-thinning\":{\"type\":\"number\",\"default\":0.4,\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"],\"relaxZoomRestriction\":true},\"transition\":true},\"direction\":{\"type\":\"array\",\"default\":[0,50],\"minimum\":0,\"maximum\":360,\"length\":2,\"value\":\"number\",\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"],\"relaxZoomRestriction\":true}},\"flake-size\":{\"type\":\"number\",\"default\":0.71,\"minimum\":0,\"maximum\":5,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"],\"relaxZoomRestriction\":true},\"transition\":true}},\"rain\":{\"density\":{\"type\":\"number\",\"default\":[\"interpolate\",[\"linear\"],[\"zoom\"],11,0,13,0.5],\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"],\"relaxZoomRestriction\":true},\"transition\":true},\"intensity\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"],\"relaxZoomRestriction\":true},\"transition\":true},\"color\":{\"type\":\"color\",\"default\":[\"interpolate\",[\"linear\"],[\"measure-light\",\"brightness\"],0,\"#03113d\",0.3,\"#a8adbc\"],\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"],\"relaxZoomRestriction\":true},\"use-theme\":true,\"transition\":true},\"opacity\":{\"type\":\"number\",\"default\":[\"interpolate\",[\"linear\"],[\"measure-light\",\"brightness\"],0,0.88,1,0.7],\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"],\"relaxZoomRestriction\":true},\"transition\":true},\"vignette\":{\"type\":\"number\",\"default\":[\"interpolate\",[\"linear\"],[\"zoom\"],11,0,13,1],\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"],\"relaxZoomRestriction\":true},\"transition\":true},\"vignette-color\":{\"type\":\"color\",\"default\":[\"interpolate\",[\"linear\"],[\"measure-light\",\"brightness\"],0,\"#001736\",0.3,\"#464646\"],\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"],\"relaxZoomRestriction\":true},\"use-theme\":true,\"transition\":true},\"center-thinning\":{\"type\":\"number\",\"default\":0.57,\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"],\"relaxZoomRestriction\":true},\"transition\":true},\"direction\":{\"type\":\"array\",\"default\":[0,80],\"minimum\":0,\"maximum\":360,\"length\":2,\"value\":\"number\",\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"],\"relaxZoomRestriction\":true}},\"droplet-size\":{\"type\":\"array\",\"default\":[2.6,18.2],\"minimum\":0,\"maximum\":50,\"length\":2,\"value\":\"number\",\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"],\"relaxZoomRestriction\":true}},\"distortion-strength\":{\"type\":\"number\",\"default\":0.7,\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"],\"relaxZoomRestriction\":true},\"transition\":true}},\"camera\":{\"camera-projection\":{\"type\":\"enum\",\"values\":{\"perspective\":1,\"orthographic\":1},\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"default\":\"perspective\"}},\"colorTheme\":{\"data\":{\"type\":\"string\",\"expression\":{}}},\"indoor_source\":{\"sourceId\":{\"type\":\"string\"},\"sourceLayers\":{\"type\":\"array\",\"value\":\"string\"}},\"indoor\":{\"*\":{\"type\":\"indoor_source\"}},\"light\":{\"anchor\":{\"type\":\"enum\",\"default\":\"viewport\",\"values\":{\"map\":1,\"viewport\":1},\"expression\":{\"parameters\":[\"zoom\"]}},\"position\":{\"type\":\"array\",\"default\":[1.15,210,30],\"length\":3,\"value\":\"number\",\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"color\":{\"type\":\"color\",\"default\":\"#ffffff\",\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"use-theme\":true,\"transition\":true},\"intensity\":{\"type\":\"number\",\"default\":0.5,\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"transition\":true}},\"projection\":{\"name\":{\"type\":\"enum\",\"values\":{\"albers\":1,\"equalEarth\":1,\"equirectangular\":1,\"lambertConformalConic\":1,\"mercator\":1,\"naturalEarth\":1,\"winkelTripel\":1,\"globe\":1},\"default\":\"mercator\"},\"center\":{\"type\":\"array\",\"length\":2,\"value\":\"number\",\"minimum\":[-180,-90],\"maximum\":[180,90]},\"parallels\":{\"type\":\"array\",\"length\":2,\"value\":\"number\",\"minimum\":[-90,-90],\"maximum\":[90,90]}},\"terrain\":{\"source\":{\"type\":\"string\"},\"exaggeration\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1000,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"transition\":true}},\"paint\":[\"paint_fill\",\"paint_line\",\"paint_circle\",\"paint_heatmap\",\"paint_fill-extrusion\",\"paint_building\",\"paint_symbol\",\"paint_raster\",\"paint_raster-particle\",\"paint_hillshade\",\"paint_background\",\"paint_sky\",\"paint_model\"],\"paint_fill\":{\"fill-antialias\":{\"type\":\"boolean\",\"default\":true,\"expression\":{\"parameters\":[\"zoom\"]}},\"fill-opacity\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"fill-color\":{\"type\":\"color\",\"default\":\"#000000\",\"use-theme\":true,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"fill-outline-color\":{\"type\":\"color\",\"use-theme\":true,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"fill-translate\":{\"type\":\"array\",\"value\":\"number\",\"length\":2,\"default\":[0,0],\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"fill-translate-anchor\":{\"type\":\"enum\",\"values\":{\"map\":1,\"viewport\":1},\"default\":\"map\",\"expression\":{\"parameters\":[\"zoom\"]}},\"fill-pattern\":{\"type\":\"resolvedImage\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"fill-pattern-cross-fade\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"]}},\"fill-emissive-strength\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"]}},\"fill-z-offset\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"fill-bridge-guard-rail-color\":{\"type\":\"color\",\"default\":\"rgba(241, 236, 225, 255)\",\"use-theme\":true,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\",\"feature\"]},\"property-type\":\"data-driven\"},\"fill-tunnel-structure-color\":{\"type\":\"color\",\"default\":\"rgba(241, 236, 225, 255)\",\"use-theme\":true,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\",\"feature\"]},\"property-type\":\"data-driven\"}},\"paint_fill-extrusion\":{\"fill-extrusion-opacity\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"fill-extrusion-color\":{\"type\":\"color\",\"default\":\"#000000\",\"use-theme\":true,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"fill-extrusion-translate\":{\"type\":\"array\",\"value\":\"number\",\"length\":2,\"default\":[0,0],\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"fill-extrusion-translate-anchor\":{\"type\":\"enum\",\"values\":{\"map\":1,\"viewport\":1},\"default\":\"map\",\"expression\":{\"parameters\":[\"zoom\"]}},\"fill-extrusion-pattern\":{\"type\":\"resolvedImage\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"fill-extrusion-pattern-cross-fade\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"]}},\"fill-extrusion-height\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\"]},\"property-type\":\"data-driven\"},\"fill-extrusion-base\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\"]},\"property-type\":\"data-driven\"},\"fill-extrusion-height-alignment\":{\"type\":\"enum\",\"values\":{\"terrain\":1,\"flat\":1},\"default\":\"flat\"},\"fill-extrusion-base-alignment\":{\"type\":\"enum\",\"values\":{\"terrain\":1,\"flat\":1},\"default\":\"terrain\"},\"fill-extrusion-vertical-gradient\":{\"type\":\"boolean\",\"default\":true,\"expression\":{\"parameters\":[\"zoom\"]}},\"fill-extrusion-ambient-occlusion-intensity\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"transition\":true},\"fill-extrusion-ambient-occlusion-radius\":{\"type\":\"number\",\"default\":3,\"minimum\":0,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"transition\":true},\"fill-extrusion-ambient-occlusion-wall-radius\":{\"type\":\"number\",\"default\":3,\"minimum\":0,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"transition\":true},\"fill-extrusion-ambient-occlusion-ground-radius\":{\"type\":\"number\",\"default\":3,\"minimum\":0,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"transition\":true},\"fill-extrusion-ambient-occlusion-ground-attenuation\":{\"type\":\"number\",\"default\":0.69,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"fill-extrusion-flood-light-color\":{\"type\":\"color\",\"default\":\"#ffffff\",\"use-theme\":true,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"]}},\"fill-extrusion-flood-light-intensity\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"]}},\"fill-extrusion-flood-light-wall-radius\":{\"property-type\":\"data-driven\",\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"feature\",\"feature-state\"]}},\"fill-extrusion-flood-light-ground-radius\":{\"property-type\":\"data-driven\",\"type\":\"number\",\"default\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"feature\",\"feature-state\"]}},\"fill-extrusion-flood-light-ground-attenuation\":{\"type\":\"number\",\"default\":0.69,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"fill-extrusion-vertical-scale\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"fill-extrusion-rounded-roof\":{\"type\":\"boolean\",\"default\":true,\"expression\":{\"parameters\":[\"zoom\"]}},\"fill-extrusion-cutoff-fade-range\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"maximum\":1,\"expression\":{}},\"fill-extrusion-emissive-strength\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\",\"feature-state\"]},\"property-type\":\"data-driven\"},\"fill-extrusion-line-width\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"fill-extrusion-cast-shadows\":{\"type\":\"boolean\",\"default\":true}},\"paint_building\":{\"building-opacity\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"building-ambient-occlusion-intensity\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"maximum\":1,\"expression\":{\"parameters\":[]},\"transition\":true},\"building-ambient-occlusion-ground-intensity\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"transition\":true},\"building-ambient-occlusion-ground-radius\":{\"type\":\"number\",\"default\":3,\"minimum\":0,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"transition\":true},\"building-ambient-occlusion-ground-attenuation\":{\"type\":\"number\",\"default\":0.69,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"building-vertical-scale\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"building-cast-shadows\":{\"type\":\"boolean\",\"default\":true},\"building-color\":{\"type\":\"color\",\"default\":\"rgba(193, 154, 127, 1)\",\"use-theme\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"building-emissive-strength\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"maximum\":5,\"expression\":{\"interpolated\":true,\"parameters\":[\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"building-facade-emissive-chance\":{\"type\":\"number\",\"default\":0.35,\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"measure-light\",\"zoom\"]}},\"building-cutoff-fade-range\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"maximum\":1,\"expression\":{}},\"building-flood-light-color\":{\"type\":\"color\",\"default\":\"#ffffff\",\"use-theme\":true,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"]}},\"building-flood-light-intensity\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"]}},\"building-flood-light-ground-attenuation\":{\"type\":\"number\",\"default\":0.69,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}}},\"paint_line\":{\"line-opacity\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"line-color\":{\"type\":\"color\",\"default\":\"#000000\",\"use-theme\":true,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"line-translate\":{\"type\":\"array\",\"value\":\"number\",\"length\":2,\"default\":[0,0],\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"line-translate-anchor\":{\"type\":\"enum\",\"values\":{\"map\":1,\"viewport\":1},\"default\":\"map\",\"expression\":{\"parameters\":[\"zoom\"]}},\"line-width\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\",\"line-progress\"]},\"property-type\":\"data-driven\"},\"line-gap-width\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"line-offset\":{\"type\":\"number\",\"default\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"line-blur\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"line-dasharray\":{\"type\":\"array\",\"value\":\"number\",\"minimum\":0,\"expression\":{\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"line-pattern\":{\"type\":\"resolvedImage\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"line-pattern-cross-fade\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"]}},\"line-gradient\":{\"type\":\"color\",\"use-theme\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"line-progress\"]}},\"line-trim-offset\":{\"type\":\"array\",\"value\":\"number\",\"length\":2,\"default\":[0,0],\"minimum\":[0,0],\"maximum\":[1,1]},\"line-trim-fade-range\":{\"type\":\"array\",\"value\":\"number\",\"length\":2,\"default\":[0,0],\"minimum\":[0,0],\"maximum\":[1,1],\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"]}},\"line-trim-color\":{\"type\":\"color\",\"default\":\"transparent\",\"use-theme\":true,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"]}},\"line-emissive-strength\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"line-border-width\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\"]},\"property-type\":\"data-driven\"},\"line-border-color\":{\"type\":\"color\",\"default\":\"rgba(0, 0, 0, 0)\",\"use-theme\":true,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\"]},\"property-type\":\"data-driven\"},\"line-occlusion-opacity\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"transition\":true}},\"paint_circle\":{\"circle-radius\":{\"type\":\"number\",\"default\":5,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"circle-color\":{\"type\":\"color\",\"default\":\"#000000\",\"use-theme\":true,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"circle-blur\":{\"type\":\"number\",\"default\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"circle-opacity\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"circle-translate\":{\"type\":\"array\",\"value\":\"number\",\"length\":2,\"default\":[0,0],\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"circle-translate-anchor\":{\"type\":\"enum\",\"values\":{\"map\":1,\"viewport\":1},\"default\":\"map\",\"expression\":{\"parameters\":[\"zoom\"]}},\"circle-pitch-scale\":{\"type\":\"enum\",\"values\":{\"map\":1,\"viewport\":1},\"default\":\"map\",\"expression\":{\"parameters\":[\"zoom\"]}},\"circle-pitch-alignment\":{\"type\":\"enum\",\"values\":{\"map\":1,\"viewport\":1},\"default\":\"viewport\",\"expression\":{\"parameters\":[\"zoom\"]}},\"circle-stroke-width\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"circle-stroke-color\":{\"type\":\"color\",\"default\":\"#000000\",\"use-theme\":true,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"circle-stroke-opacity\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"circle-emissive-strength\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"]}}},\"paint_heatmap\":{\"heatmap-radius\":{\"type\":\"number\",\"default\":30,\"minimum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"heatmap-weight\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"heatmap-intensity\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"heatmap-color\":{\"type\":\"color\",\"default\":[\"interpolate\",[\"linear\"],[\"heatmap-density\"],0,\"rgba(0, 0, 255, 0)\",0.1,\"royalblue\",0.3,\"cyan\",0.5,\"lime\",0.7,\"yellow\",1,\"red\"],\"use-theme\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"heatmap-density\"]}},\"heatmap-opacity\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}}},\"paint_symbol\":{\"icon-opacity\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"icon-occlusion-opacity\":{\"type\":\"number\",\"minimum\":0,\"maximum\":1,\"default\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"icon-emissive-strength\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\",\"feature-state\"]},\"property-type\":\"data-driven\"},\"text-emissive-strength\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\",\"feature-state\"]},\"property-type\":\"data-driven\"},\"icon-color\":{\"type\":\"color\",\"default\":\"#000000\",\"use-theme\":true,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"icon-halo-color\":{\"type\":\"color\",\"default\":\"rgba(0, 0, 0, 0)\",\"use-theme\":true,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"icon-halo-width\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"icon-halo-blur\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"icon-translate\":{\"type\":\"array\",\"value\":\"number\",\"length\":2,\"default\":[0,0],\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"icon-translate-anchor\":{\"type\":\"enum\",\"values\":{\"map\":1,\"viewport\":1},\"default\":\"map\",\"expression\":{\"parameters\":[\"zoom\"]}},\"icon-image-cross-fade\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"]}},\"text-opacity\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"text-occlusion-opacity\":{\"type\":\"number\",\"minimum\":0,\"maximum\":1,\"default\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"text-color\":{\"type\":\"color\",\"default\":\"#000000\",\"use-theme\":true,\"transition\":true,\"overridable\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"text-halo-color\":{\"type\":\"color\",\"default\":\"rgba(0, 0, 0, 0)\",\"use-theme\":true,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"text-halo-width\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"text-halo-blur\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"text-translate\":{\"type\":\"array\",\"value\":\"number\",\"length\":2,\"default\":[0,0],\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"text-translate-anchor\":{\"type\":\"enum\",\"values\":{\"map\":1,\"viewport\":1},\"default\":\"map\",\"expression\":{\"parameters\":[\"zoom\"]}},\"icon-color-saturation\":{\"type\":\"number\",\"default\":0,\"minimum\":-1,\"maximum\":1,\"expression\":{}},\"icon-color-contrast\":{\"type\":\"number\",\"default\":0,\"minimum\":-1,\"maximum\":1,\"expression\":{}},\"icon-color-brightness-min\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"maximum\":1,\"expression\":{}},\"icon-color-brightness-max\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"expression\":{}},\"symbol-z-offset\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"}},\"paint_raster\":{\"raster-opacity\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"raster-color\":{\"type\":\"color\",\"use-theme\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"raster-value\"]}},\"raster-color-mix\":{\"type\":\"array\",\"default\":[0.2126,0.7152,0.0722,0],\"length\":4,\"value\":\"number\",\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"raster-color-range\":{\"type\":\"array\",\"length\":2,\"value\":\"number\",\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"raster-hue-rotate\":{\"type\":\"number\",\"default\":0,\"period\":360,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"raster-brightness-min\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"raster-brightness-max\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"raster-saturation\":{\"type\":\"number\",\"default\":0,\"minimum\":-1,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"raster-contrast\":{\"type\":\"number\",\"default\":0,\"minimum\":-1,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"raster-resampling\":{\"type\":\"enum\",\"values\":{\"linear\":1,\"nearest\":1},\"default\":\"linear\",\"expression\":{\"parameters\":[\"zoom\"]}},\"raster-fade-duration\":{\"type\":\"number\",\"default\":300,\"minimum\":0,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"raster-emissive-strength\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"]}},\"raster-array-band\":{\"type\":\"string\"},\"raster-elevation\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}}},\"paint_raster-particle\":{\"raster-particle-array-band\":{\"type\":\"string\"},\"raster-particle-count\":{\"type\":\"number\",\"default\":512,\"minimum\":1},\"raster-particle-color\":{\"type\":\"color\",\"use-theme\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"raster-particle-speed\"]}},\"raster-particle-max-speed\":{\"type\":\"number\",\"default\":1,\"minimum\":1},\"raster-particle-speed-factor\":{\"type\":\"number\",\"default\":0.2,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"raster-particle-fade-opacity-factor\":{\"type\":\"number\",\"default\":0.98,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"raster-particle-reset-rate-factor\":{\"type\":\"number\",\"default\":0.8,\"minimum\":0,\"maximum\":1},\"raster-particle-elevation\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}}},\"paint_hillshade\":{\"hillshade-illumination-direction\":{\"type\":\"number\",\"default\":335,\"minimum\":0,\"maximum\":359,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"hillshade-illumination-anchor\":{\"type\":\"enum\",\"values\":{\"map\":1,\"viewport\":1},\"default\":\"viewport\",\"expression\":{\"parameters\":[\"zoom\"]}},\"hillshade-exaggeration\":{\"type\":\"number\",\"default\":0.5,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"hillshade-shadow-color\":{\"type\":\"color\",\"default\":\"#000000\",\"use-theme\":true,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"]}},\"hillshade-highlight-color\":{\"type\":\"color\",\"default\":\"#FFFFFF\",\"use-theme\":true,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"]}},\"hillshade-accent-color\":{\"type\":\"color\",\"default\":\"#000000\",\"use-theme\":true,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"]}},\"hillshade-emissive-strength\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"]}}},\"paint_background\":{\"background-pitch-alignment\":{\"type\":\"enum\",\"values\":{\"map\":1,\"viewport\":1},\"default\":\"map\",\"expression\":{\"parameters\":[]}},\"background-color\":{\"type\":\"color\",\"default\":\"#000000\",\"use-theme\":true,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"]}},\"background-pattern\":{\"type\":\"resolvedImage\",\"expression\":{\"parameters\":[\"zoom\"]}},\"background-opacity\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"background-emissive-strength\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"]}}},\"paint_sky\":{\"sky-type\":{\"type\":\"enum\",\"values\":{\"gradient\":1,\"atmosphere\":1},\"default\":\"atmosphere\",\"expression\":{\"parameters\":[\"zoom\"]}},\"sky-atmosphere-sun\":{\"type\":\"array\",\"value\":\"number\",\"length\":2,\"minimum\":[0,0],\"maximum\":[360,180],\"expression\":{\"parameters\":[\"zoom\"]}},\"sky-atmosphere-sun-intensity\":{\"type\":\"number\",\"default\":10,\"minimum\":0,\"maximum\":100},\"sky-gradient-center\":{\"type\":\"array\",\"value\":\"number\",\"default\":[0,0],\"length\":2,\"minimum\":[0,0],\"maximum\":[360,180],\"expression\":{\"parameters\":[\"zoom\"]}},\"sky-gradient-radius\":{\"type\":\"number\",\"default\":90,\"minimum\":0,\"maximum\":180,\"expression\":{\"parameters\":[\"zoom\"]}},\"sky-gradient\":{\"type\":\"color\",\"default\":[\"interpolate\",[\"linear\"],[\"sky-radial-progress\"],0.8,\"#87ceeb\",1,\"white\"],\"use-theme\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"sky-radial-progress\"]}},\"sky-atmosphere-halo-color\":{\"type\":\"color\",\"default\":\"white\",\"use-theme\":true},\"sky-atmosphere-color\":{\"type\":\"color\",\"default\":\"white\",\"use-theme\":true},\"sky-opacity\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}}},\"paint_model\":{\"model-opacity\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"feature\",\"feature-state\",\"zoom\"]},\"property-type\":\"data-driven\"},\"model-rotation\":{\"type\":\"array\",\"value\":\"number\",\"length\":3,\"default\":[0,0,0],\"period\":360,\"property-type\":\"data-driven\",\"expression\":{\"interpolated\":true,\"parameters\":[\"feature\",\"feature-state\",\"zoom\"]},\"transition\":true},\"model-scale\":{\"type\":\"array\",\"value\":\"number\",\"length\":3,\"default\":[1,1,1],\"property-type\":\"data-driven\",\"expression\":{\"interpolated\":true,\"parameters\":[\"feature\",\"feature-state\",\"zoom\"]},\"transition\":true},\"model-translation\":{\"type\":\"array\",\"value\":\"number\",\"length\":3,\"default\":[0,0,0],\"property-type\":\"data-driven\",\"expression\":{\"interpolated\":true,\"parameters\":[\"feature\",\"feature-state\",\"zoom\"]},\"transition\":true},\"model-color\":{\"type\":\"color\",\"default\":\"#ffffff\",\"property-type\":\"data-driven\",\"expression\":{\"interpolated\":true,\"parameters\":[\"feature\",\"feature-state\",\"measure-light\",\"zoom\"]},\"use-theme\":true,\"transition\":true},\"model-color-mix-intensity\":{\"type\":\"number\",\"property-type\":\"data-driven\",\"default\":0,\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"feature\",\"feature-state\",\"measure-light\"]},\"transition\":true},\"model-type\":{\"type\":\"enum\",\"values\":{\"common-3d\":1,\"location-indicator\":1},\"default\":\"common-3d\"},\"model-cast-shadows\":{\"type\":\"boolean\",\"default\":true},\"model-receive-shadows\":{\"type\":\"boolean\",\"default\":true},\"model-ambient-occlusion-intensity\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"transition\":true},\"model-emissive-strength\":{\"type\":\"number\",\"property-type\":\"data-driven\",\"default\":0,\"minimum\":0,\"maximum\":5,\"expression\":{\"interpolated\":true,\"parameters\":[\"feature\",\"feature-state\",\"measure-light\"]},\"transition\":true},\"model-roughness\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"property-type\":\"data-driven\",\"expression\":{\"interpolated\":true,\"parameters\":[\"feature\",\"feature-state\"]},\"transition\":true},\"model-height-based-emissive-strength-multiplier\":{\"type\":\"array\",\"default\":[1,1,1,1,0],\"length\":5,\"value\":\"number\",\"property-type\":\"data-driven\",\"expression\":{\"interpolated\":true,\"parameters\":[\"feature\",\"feature-state\",\"measure-light\"]},\"transition\":true},\"model-cutoff-fade-range\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"maximum\":1,\"expression\":{}},\"model-front-cutoff\":{\"type\":\"array\",\"value\":\"number\",\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"length\":3,\"default\":[0,0,1],\"minimum\":[0,0,0],\"maximum\":[1,1,1]},\"model-elevation-reference\":{\"type\":\"enum\",\"values\":{\"sea\":1,\"ground\":1,\"hd-road-markup\":1},\"default\":\"ground\",\"expression\":{}}},\"transition\":{\"duration\":{\"type\":\"number\",\"default\":300,\"minimum\":0},\"delay\":{\"type\":\"number\",\"default\":0,\"minimum\":0}},\"promoteId\":{\"*\":{\"type\":\"*\"}}}");
			function Lo(t$1) {
				return t$1 instanceof Number || t$1 instanceof String || t$1 instanceof Boolean ? t$1.valueOf() : t$1;
			}
			function Oo(t$1) {
				if (Array.isArray(t$1)) return t$1.map(Oo);
				if (t$1 instanceof Object && !(t$1 instanceof Number || t$1 instanceof String || t$1 instanceof Boolean)) {
					const e$1 = {};
					for (const r$1 in t$1) e$1[r$1] = Oo(t$1[r$1]);
					return e$1;
				}
				return Lo(t$1);
			}
			function Uo(t$1) {
				if (!0 === t$1 || !1 === t$1) return !0;
				if (!Array.isArray(t$1) || 0 === t$1.length) return !1;
				switch (t$1[0]) {
					case "has": return t$1.length >= 2 && "$id" !== t$1[1] && "$type" !== t$1[1];
					case "in": return t$1.length >= 3 && ("string" != typeof t$1[1] || Array.isArray(t$1[2]));
					case "!in":
					case "!has":
					case "none": return !1;
					case "==":
					case "!=":
					case ">":
					case ">=":
					case "<":
					case "<=": return 3 !== t$1.length || Array.isArray(t$1[1]) || Array.isArray(t$1[2]);
					case "any":
					case "all":
						for (const e$1 of t$1.slice(1)) if (!Uo(e$1) && "boolean" != typeof e$1) return !1;
						return !0;
					default: return !0;
				}
			}
			function No(t$1, e$1 = "", r$1 = null, n$1 = "fill") {
				if (null == t$1) return {
					filter: () => !0,
					needGeometry: !1,
					needFeature: !1
				};
				Uo(t$1) || (t$1 = Zo(t$1));
				const i$1 = t$1;
				let s$1 = !0;
				try {
					s$1 = function(t$2) {
						if (!Go(t$2)) return t$2;
						let e$2 = Oo(t$2);
						return $o(e$2), e$2 = jo(e$2), e$2;
					}(i$1);
				} catch (t$2) {
					console.warn(`Failed to extract static filter. Filter will continue working, but at higher memory usage and slower framerate.\nThis is most likely a bug, please report this via https://github.com/mapbox/mapbox-gl-js/issues/new?assignees=&labels=&template=Bug_report.md\nand paste the contents of this message in the report.\nThank you!\nFilter Expression:\n${JSON.stringify(i$1, null, 2)}\n        `);
				}
				let o$1 = null, a$1 = null;
				if ("background" !== n$1 && "sky" !== n$1 && "slot" !== n$1) {
					a$1 = Ro[`filter_${n$1}`];
					const t$2 = js(s$1, a$1, e$1, r$1);
					if ("error" === t$2.result) throw new Error(t$2.value.map(((t$3) => `${t$3.key}: ${t$3.message}`)).join(", "));
					o$1 = (e$2, r$2, n$2) => t$2.value.evaluate(e$2, r$2, {}, n$2);
				}
				let l$1 = null, u$1 = null;
				if (s$1 !== i$1) {
					const t$2 = js(i$1, a$1, e$1, r$1);
					if ("error" === t$2.result) throw new Error(t$2.value.map(((t$3) => `${t$3.key}: ${t$3.message}`)).join(", "));
					l$1 = (e$2, r$2, n$2, i$2, s$2) => t$2.value.evaluate(e$2, r$2, {}, n$2, void 0, void 0, i$2, s$2), u$1 = !gi(t$2.value.expression);
				}
				return {
					filter: o$1,
					dynamicFilter: l$1 || void 0,
					needGeometry: Xo(s$1),
					needFeature: !!u$1
				};
			}
			function jo(t$1) {
				if (!Array.isArray(t$1)) return t$1;
				const e$1 = function(t$2) {
					if (qo.has(t$2[0])) {
						for (let e$2 = 1; e$2 < t$2.length; e$2++) if (Go(t$2[e$2])) return !0;
					}
					return t$2;
				}(t$1);
				return !0 === e$1 ? e$1 : e$1.map(((t$2) => jo(t$2)));
			}
			function $o(t$1) {
				let e$1 = !1;
				const r$1 = [];
				if ("case" === t$1[0]) {
					for (let n$1 = 1; n$1 < t$1.length - 1; n$1 += 2) e$1 = e$1 || Go(t$1[n$1]), r$1.push(t$1[n$1 + 1]);
					r$1.push(t$1[t$1.length - 1]);
				} else if ("match" === t$1[0]) {
					e$1 = e$1 || Go(t$1[1]);
					for (let e$2 = 2; e$2 < t$1.length - 1; e$2 += 2) r$1.push(t$1[e$2 + 1]);
					r$1.push(t$1[t$1.length - 1]);
				} else if ("step" === t$1[0]) {
					e$1 = e$1 || Go(t$1[1]);
					for (let e$2 = 1; e$2 < t$1.length - 1; e$2 += 2) r$1.push(t$1[e$2 + 1]);
				}
				e$1 && (t$1.length = 0, t$1.push("any", ...r$1));
				for (let e$2 = 1; e$2 < t$1.length; e$2++) $o(t$1[e$2]);
			}
			function Go(t$1) {
				if (!Array.isArray(t$1)) return !1;
				if ("pitch" === (e$1 = t$1[0]) || "distance-from-center" === e$1) return !0;
				var e$1;
				for (let e$2 = 1; e$2 < t$1.length; e$2++) if (Go(t$1[e$2])) return !0;
				return !1;
			}
			const qo = new Set([
				"in",
				"==",
				"!=",
				">",
				">=",
				"<",
				"<=",
				"to-boolean"
			]);
			function Ho(t$1, e$1) {
				return t$1 < e$1 ? -1 : t$1 > e$1 ? 1 : 0;
			}
			function Xo(t$1) {
				if (!Array.isArray(t$1)) return !1;
				if ("within" === t$1[0] || "distance" === t$1[0]) return !0;
				for (let e$1 = 1; e$1 < t$1.length; e$1++) if (Xo(t$1[e$1])) return !0;
				return !1;
			}
			function Zo(t$1) {
				if (!t$1) return !0;
				const e$1 = t$1[0];
				return t$1.length <= 1 ? "any" !== e$1 : "==" === e$1 ? Wo(t$1[1], t$1[2], "==") : "!=" === e$1 ? Jo(Wo(t$1[1], t$1[2], "==")) : "<" === e$1 || ">" === e$1 || "<=" === e$1 || ">=" === e$1 ? Wo(t$1[1], t$1[2], e$1) : "any" === e$1 ? (r$1 = t$1.slice(1), ["any"].concat(r$1.map(Zo))) : "all" === e$1 ? ["all"].concat(t$1.slice(1).map(Zo)) : "none" === e$1 ? ["all"].concat(t$1.slice(1).map(Zo).map(Jo)) : "in" === e$1 ? Yo(t$1[1], t$1.slice(2)) : "!in" === e$1 ? Jo(Yo(t$1[1], t$1.slice(2))) : "has" === e$1 ? Ko(t$1[1]) : "!has" !== e$1 || Jo(Ko(t$1[1]));
				var r$1;
			}
			function Wo(t$1, e$1, r$1) {
				switch (t$1) {
					case "$type": return [`filter-type-${r$1}`, e$1];
					case "$id": return [`filter-id-${r$1}`, e$1];
					default: return [
						`filter-${r$1}`,
						t$1,
						e$1
					];
				}
			}
			function Yo(t$1, e$1) {
				if (0 === e$1.length) return !1;
				switch (t$1) {
					case "$type": return ["filter-type-in", ["literal", e$1]];
					case "$id": return ["filter-id-in", ["literal", e$1]];
					default: return e$1.length > 200 && !e$1.some(((t$2) => typeof t$2 != typeof e$1[0])) ? [
						"filter-in-large",
						t$1,
						["literal", e$1.sort(Ho)]
					] : [
						"filter-in-small",
						t$1,
						["literal", e$1]
					];
				}
			}
			function Ko(t$1) {
				switch (t$1) {
					case "$type": return !0;
					case "$id": return ["filter-has-id"];
					default: return ["filter-has", t$1];
				}
			}
			function Jo(t$1) {
				return ["!", t$1];
			}
			const Qo = "";
			function ta(t$1, e$1) {
				return e$1 ? `${t$1}${Qo}${e$1}` : t$1;
			}
			let ea;
			const ra = () => ea || (ea = new Do({
				"icon-size": new Fo(Ro.layout_symbol["icon-size"]),
				"icon-image": new Fo(Ro.layout_symbol["icon-image"]),
				"icon-rotate": new Fo(Ro.layout_symbol["icon-rotate"]),
				"icon-offset": new Fo(Ro.layout_symbol["icon-offset"]),
				"text-size": new Fo(Ro.layout_symbol["text-size"]),
				"text-rotate": new Fo(Ro.layout_symbol["text-rotate"]),
				"text-offset": new Fo(Ro.layout_symbol["text-offset"])
			}));
			class na {
				constructor(t$1, e$1, r$1, n$1, i$1, s$1) {
					const o$1 = js(t$1, Ro.appearance.condition);
					if ("success" === o$1.result && (this.condition = o$1.value), this.name = e$1, r$1) {
						this.properties = new Eo(ra()), this.unevaluatedLayout = new zo(ra(), n$1, i$1, s$1);
						for (const t$2 in r$1) this.unevaluatedLayout.setValue(t$2, r$1[t$2]);
					}
				}
				isActive(t$1) {
					return !(this.condition || !t$1.isHidden || "hidden" !== this.name) || this.condition.evaluate(t$1.globals, t$1.feature, t$1.featureState, t$1.canonical);
				}
				getCondition() {
					return this.condition;
				}
				getName() {
					return this.name;
				}
				getProperty(t$1) {
					return this.properties.get(t$1);
				}
				getUnevaluatedProperties() {
					return this.unevaluatedLayout;
				}
				getUnevaluatedProperty(t$1) {
					return this.unevaluatedLayout._values[t$1];
				}
				recalculate(t$1, e$1, r$1) {
					this.unevaluatedLayout && (this.properties = this.unevaluatedLayout.possiblyEvaluate(t$1, void 0, e$1, r$1));
				}
				serialize() {
					const t$1 = {};
					return t$1.condition = this.condition.expression.serialize(), this.name && (t$1.name = this.name), this.unevaluatedLayout && (t$1.properties = this.unevaluatedLayout.serialize()), t$1;
				}
				hasIconProperties() {
					const t$1 = this.hasProperty("icon-image"), e$1 = this.hasProperty("icon-size"), r$1 = this.hasProperty("icon-offset"), n$1 = this.hasProperty("icon-rotate");
					return t$1 || e$1 || r$1 || n$1;
				}
				hasTextProperties() {
					const t$1 = this.hasProperty("text-size"), e$1 = this.hasProperty("text-offset"), r$1 = this.hasProperty("text-rotate");
					return t$1 || e$1 || r$1;
				}
				hasProperty(t$1) {
					return void 0 !== this.getUnevaluatedProperty(t$1).value;
				}
			}
			const ia = "-transition", sa = new Set([
				"fill",
				"line",
				"background",
				"hillshade",
				"raster"
			]);
			class oa extends nr {
				constructor(t$1, e$1, r$1, n$1, i$1, s$1) {
					if (super(), this.id = t$1.id, this.fqid = ta(this.id, r$1), this.type = t$1.type, this.scope = r$1, this.lut = n$1, this.options = i$1, this.iconImageUseTheme = s$1, this.appearances = new Array(), this._featureFilter = {
						filter: () => !0,
						needGeometry: !1,
						needFeature: !1
					}, this._filterCompiled = !1, this.expressionDependencies = {
						isIndoorDependent: !1,
						configDependencies: /* @__PURE__ */ new Set()
					}, "custom" !== t$1.type) {
						if (this.metadata = t$1.metadata, this.minzoom = t$1.minzoom, this.maxzoom = t$1.maxzoom, t$1.type && "background" !== t$1.type && "sky" !== t$1.type && "slot" !== t$1.type) {
							this.source = t$1.source, this.sourceLayer = t$1["source-layer"], this.filter = t$1.filter;
							const e$2 = js(this.filter, Ro[`filter_${t$1.type}`]);
							"error" !== e$2.result && (this.expressionDependencies.configDependencies = new Set([...this.expressionDependencies.configDependencies, ...e$2.value.configDependencies]), this.expressionDependencies.isIndoorDependent = this.expressionDependencies.isIndoorDependent || e$2.value.isIndoorDependent);
						}
						if (t$1.slot && (this.slot = t$1.slot), t$1.appearances && this.setAppearances(t$1.appearances), e$1.layout && (this._unevaluatedLayout = new zo(e$1.layout, this.scope, i$1, this.iconImageUseTheme), this.expressionDependencies.configDependencies = new Set([...this.expressionDependencies.configDependencies, ...this._unevaluatedLayout.configDependencies]), this.expressionDependencies.isIndoorDependent = this.expressionDependencies.isIndoorDependent || this._unevaluatedLayout.isIndoorDependent()), e$1.paint) {
							this._transitionablePaint = new Po(e$1.paint, this.scope, i$1);
							for (const e$2 in t$1.paint) this.setPaintProperty(e$2, t$1.paint[e$2]);
							for (const e$2 in t$1.layout) this.setLayoutProperty(e$2, t$1.layout[e$2]);
							this.expressionDependencies.configDependencies = new Set([...this.expressionDependencies.configDependencies, ...this._transitionablePaint.configDependencies]), this.expressionDependencies.isIndoorDependent = this.expressionDependencies.isIndoorDependent || this._transitionablePaint.isIndoorDependent(), this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new Eo(e$1.paint);
						}
					}
				}
				onAdd(t$1) {}
				onRemove(t$1) {}
				isDraped(t$1) {
					return !this.is3D(!0) && sa.has(this.type);
				}
				getLayoutProperty(t$1) {
					return "visibility" === t$1 ? this.visibility : this._unevaluatedLayout.getValue(t$1);
				}
				setLayoutProperty(t$1, e$1) {
					if ("custom" === this.type && "visibility" === t$1) return void (this.visibility = e$1);
					const r$1 = this._unevaluatedLayout;
					r$1._properties.properties[t$1] && (r$1.setValue(t$1, e$1), this.expressionDependencies.configDependencies = new Set([...this.expressionDependencies.configDependencies, ...r$1.configDependencies]), this.expressionDependencies.isIndoorDependent = this.expressionDependencies.isIndoorDependent || r$1.isIndoorDependent(), "visibility" === t$1 && this.possiblyEvaluateVisibility());
				}
				setAppearances(t$1) {
					this.appearances = [], t$1.forEach(((t$2) => {
						this.appearances.push(new na(t$2.condition, t$2.name, t$2.properties, this.scope, this.options, this.iconImageUseTheme));
					}));
				}
				possiblyEvaluateVisibility() {
					this._unevaluatedLayout._values.visibility && (this.visibility = this._unevaluatedLayout._values.visibility.possiblyEvaluate({ zoom: 0 }));
				}
				getPaintProperty(t$1) {
					return t$1.endsWith(ia) ? this._transitionablePaint.getTransition(t$1.slice(0, -11)) : this._transitionablePaint.getValue(t$1);
				}
				isPaintProperty(t$1) {
					return !!this._transitionablePaint._properties.properties[t$1];
				}
				setPaintProperty(t$1, e$1) {
					const r$1 = this._transitionablePaint, n$1 = r$1._properties.properties;
					if (t$1.endsWith(ia)) {
						const i$2 = t$1.slice(0, -11);
						return n$1[i$2] && r$1.setTransition(i$2, e$1 || void 0), !1;
					}
					if (!n$1[t$1]) return !1;
					const i$1 = r$1._values[t$1], s$1 = i$1.value.isDataDriven(), o$1 = i$1.value;
					r$1.setValue(t$1, e$1), this.expressionDependencies.configDependencies = new Set([...this.expressionDependencies.configDependencies, ...r$1.configDependencies]), this.expressionDependencies.isIndoorDependent = this.expressionDependencies.isIndoorDependent || r$1.isIndoorDependent(), this._handleSpecialPaintPropertyUpdate(t$1);
					const a$1 = r$1._values[t$1].value, l$1 = a$1.isDataDriven(), u$1 = t$1.endsWith("pattern") || "line-dasharray" === t$1;
					return l$1 || s$1 || u$1 || this._handleOverridablePaintPropertyUpdate(t$1, o$1, a$1);
				}
				_handleSpecialPaintPropertyUpdate(t$1) {}
				getProgramIds() {
					return null;
				}
				getDefaultProgramParams(t$1, e$1, r$1) {
					return null;
				}
				_handleOverridablePaintPropertyUpdate(t$1, e$1, r$1) {
					return !1;
				}
				isHidden(t$1) {
					return !!(this.minzoom && t$1 < this.minzoom) || !!(this.maxzoom && t$1 >= this.maxzoom) || "none" === this.visibility;
				}
				updateTransitions(t$1) {
					this._transitioningPaint = this._transitionablePaint.transitioned(t$1, this._transitioningPaint);
				}
				hasTransition() {
					return this._transitioningPaint.hasTransition();
				}
				recalculate(t$1, e$1) {
					this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(t$1, void 0, e$1, this.iconImageUseTheme)), this.paint = this._transitioningPaint.possiblyEvaluate(t$1, void 0, e$1);
				}
				serialize() {
					const t$1 = {
						id: this.id,
						type: this.type,
						slot: this.slot,
						source: this.source,
						"source-layer": this.sourceLayer,
						metadata: this.metadata,
						minzoom: this.minzoom,
						maxzoom: this.maxzoom,
						filter: this.filter,
						layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(),
						paint: this._transitionablePaint && this._transitionablePaint.serialize()
					};
					return 0 !== this.appearances.length && (t$1.appearances = this.appearances.map(((t$2) => t$2.serialize()))), $t(t$1, ((t$2, e$1) => !(void 0 === t$2 || "layout" === e$1 && !Object.keys(t$2).length || "paint" === e$1 && !Object.keys(t$2).length)));
				}
				is3D(t$1) {
					return !1;
				}
				hasElevation() {
					return !1;
				}
				isSky() {
					return !1;
				}
				isTileClipped() {
					return !1;
				}
				hasOffscreenPass() {
					return !1;
				}
				hasShadowPass() {
					return !1;
				}
				canCastShadows() {
					return !1;
				}
				hasLightBeamPass() {
					return !1;
				}
				cutoffRange() {
					return 0;
				}
				tileCoverLift() {
					return 0;
				}
				resize() {}
				_clear() {}
				isStateDependent() {
					for (const t$1 in this.paint._values) {
						const e$1 = this.paint.get(t$1);
						if (e$1 instanceof To && ks(e$1.property.specification) && ("source" === e$1.value.kind || "composite" === e$1.value.kind) && e$1.value.isStateDependent) return !0;
					}
					for (const t$1 of this.appearances) if (!xi(t$1.condition.expression)) return !0;
					return !1;
				}
				compileFilter(t$1) {
					this._filterCompiled || (this._featureFilter = No(this.filter, this.scope, t$1), this._filterCompiled = !0);
				}
				invalidateCompiledFilter() {
					this._filterCompiled = !1;
				}
				dynamicFilter() {
					return this._featureFilter.dynamicFilter;
				}
				dynamicFilterNeedsFeature() {
					return this._featureFilter.needFeature;
				}
				getLayerRenderingStats() {
					return this._stats;
				}
				resetLayerRenderingStats(t$1) {
					this._stats && ("shadow" === t$1.renderPass ? this._stats.numRenderedVerticesInShadowPass = 0 : this._stats.numRenderedVerticesInTransparentPass = 0);
				}
				getAppearances() {
					return this.appearances;
				}
				queryRenderedFeatures(t$1, e$1, r$1) {
					return {};
				}
				queryRadius(t$1) {}
				queryIntersectsFeature(t$1, e$1, r$1, n$1, i$1, s$1, o$1, a$1, l$1) {}
			}
			const aa = {
				Int8: Int8Array,
				Uint8: Uint8Array,
				Int16: Int16Array,
				Uint16: Uint16Array,
				Int32: Int32Array,
				Uint32: Uint32Array,
				Float32: Float32Array
			};
			class la {
				constructor(t$1, e$1) {
					this._structArray = t$1, this._pos1 = e$1 * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;
				}
			}
			const ua = /* @__PURE__ */ new ArrayBuffer(0);
			class ca {
				constructor() {
					this._reallocCount = 0, this.capacity = 0, this.length = 0;
				}
				static serialize(t$1, e$1) {
					return t$1._trim(), e$1 && t$1.arrayBuffer && e$1.add(t$1.arrayBuffer), {
						length: t$1.length,
						arrayBuffer: t$1.arrayBuffer
					};
				}
				static deserialize(t$1) {
					const e$1 = Object.create(this.prototype);
					return e$1.arrayBuffer = t$1.arrayBuffer, e$1.length = t$1.length, t$1.arrayBuffer ? e$1.capacity = t$1.arrayBuffer.byteLength / e$1.bytesPerElement : (e$1.capacity = 0, e$1.arrayBuffer = ua), e$1._refreshViews(), e$1;
				}
				_trim() {
					this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());
				}
				clear() {
					this.length = 0;
				}
				resize(t$1) {
					this.reserve(t$1), this.length = t$1;
				}
				reserve(t$1) {
					if (t$1 > this.capacity) {
						this._reallocCount++, this.capacity = Math.max(t$1, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
						const e$1 = this.uint8;
						this._refreshViews(), e$1 && this.uint8.set(e$1);
					}
				}
				reserveForAdditional(t$1) {
					this.reserve(this.length + t$1);
				}
				_refreshViews() {
					throw new Error("StructArray#_refreshViews() must be implemented by each concrete StructArray layout");
				}
				emplace(...t$1) {
					throw new Error("StructArray#emplace() must be implemented by each concrete StructArray layout");
				}
				emplaceBack(...t$1) {
					throw new Error("StructArray#emplaceBack() must be implemented by each concrete StructArray layout");
				}
				destroy() {
					this.int8 = this.uint8 = this.int16 = this.uint16 = this.int32 = this.uint32 = this.float32 = null, this.arrayBuffer = null;
				}
			}
			function ha(t$1, e$1 = 1) {
				let r$1 = 0, n$1 = 0;
				return {
					members: t$1.map(((t$2) => {
						const i$1 = aa[t$2.type].BYTES_PER_ELEMENT, s$1 = r$1 = pa(r$1, Math.max(e$1, i$1)), o$1 = t$2.components || 1;
						return n$1 = Math.max(n$1, i$1), r$1 += i$1 * o$1, {
							name: t$2.name,
							type: t$2.type,
							components: o$1,
							offset: s$1
						};
					})),
					size: pa(r$1, Math.max(n$1, e$1)),
					alignment: e$1
				};
			}
			function pa(t$1, e$1) {
				return Math.ceil(t$1 / e$1) * e$1;
			}
			class da extends ca {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1) {
					const r$1 = this.length;
					return this.resize(r$1 + 1), this.emplace(r$1, t$1, e$1);
				}
				emplace(t$1, e$1, r$1) {
					const n$1 = 2 * t$1;
					return this.int16[n$1 + 0] = e$1, this.int16[n$1 + 1] = r$1, t$1;
				}
			}
			da.prototype.bytesPerElement = 4, Qs(da, "StructArrayLayout2i4");
			class fa extends ca {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1, r$1) {
					const n$1 = this.length;
					return this.resize(n$1 + 1), this.emplace(n$1, t$1, e$1, r$1);
				}
				emplace(t$1, e$1, r$1, n$1) {
					const i$1 = 3 * t$1;
					return this.int16[i$1 + 0] = e$1, this.int16[i$1 + 1] = r$1, this.int16[i$1 + 2] = n$1, t$1;
				}
			}
			fa.prototype.bytesPerElement = 6, Qs(fa, "StructArrayLayout3i6");
			class ma extends ca {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1, r$1, n$1) {
					const i$1 = this.length;
					return this.resize(i$1 + 1), this.emplace(i$1, t$1, e$1, r$1, n$1);
				}
				emplace(t$1, e$1, r$1, n$1, i$1) {
					const s$1 = 4 * t$1;
					return this.int16[s$1 + 0] = e$1, this.int16[s$1 + 1] = r$1, this.int16[s$1 + 2] = n$1, this.int16[s$1 + 3] = i$1, t$1;
				}
			}
			ma.prototype.bytesPerElement = 8, Qs(ma, "StructArrayLayout4i8");
			class ya extends ca {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
				}
				emplaceBack(t$1) {
					const e$1 = this.length;
					return this.resize(e$1 + 1), this.emplace(e$1, t$1);
				}
				emplace(t$1, e$1) {
					return this.float32[1 * t$1 + 0] = e$1, t$1;
				}
			}
			ya.prototype.bytesPerElement = 4, Qs(ya, "StructArrayLayout1f4");
			class ga extends ca {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1, r$1) {
					const n$1 = this.length;
					return this.resize(n$1 + 1), this.emplace(n$1, t$1, e$1, r$1);
				}
				emplace(t$1, e$1, r$1, n$1) {
					const i$1 = 4 * t$1, s$1 = 2 * t$1;
					return this.int16[i$1 + 0] = e$1, this.int16[i$1 + 1] = r$1, this.float32[s$1 + 1] = n$1, t$1;
				}
			}
			ga.prototype.bytesPerElement = 8, Qs(ga, "StructArrayLayout2i1f8");
			class xa extends ca {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1, r$1) {
					const n$1 = this.length;
					return this.resize(n$1 + 1), this.emplace(n$1, t$1, e$1, r$1);
				}
				emplace(t$1, e$1, r$1, n$1) {
					const i$1 = 4 * t$1;
					return this.int16[i$1 + 0] = e$1, this.int16[i$1 + 1] = r$1, this.int16[i$1 + 2] = n$1, t$1;
				}
			}
			xa.prototype.bytesPerElement = 8, Qs(xa, "StructArrayLayout3i8");
			class va extends ca {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1, r$1, n$1, i$1) {
					const s$1 = this.length;
					return this.resize(s$1 + 1), this.emplace(s$1, t$1, e$1, r$1, n$1, i$1);
				}
				emplace(t$1, e$1, r$1, n$1, i$1, s$1) {
					const o$1 = 5 * t$1;
					return this.int16[o$1 + 0] = e$1, this.int16[o$1 + 1] = r$1, this.int16[o$1 + 2] = n$1, this.int16[o$1 + 3] = i$1, this.int16[o$1 + 4] = s$1, t$1;
				}
			}
			va.prototype.bytesPerElement = 10, Qs(va, "StructArrayLayout5i10");
			class ba extends ca {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1, r$1, n$1, i$1, s$1, o$1) {
					const a$1 = this.length;
					return this.resize(a$1 + 1), this.emplace(a$1, t$1, e$1, r$1, n$1, i$1, s$1, o$1);
				}
				emplace(t$1, e$1, r$1, n$1, i$1, s$1, o$1, a$1) {
					const l$1 = 6 * t$1, u$1 = 12 * t$1, c$1 = 3 * t$1;
					return this.int16[l$1 + 0] = e$1, this.int16[l$1 + 1] = r$1, this.uint8[u$1 + 4] = n$1, this.uint8[u$1 + 5] = i$1, this.uint8[u$1 + 6] = s$1, this.uint8[u$1 + 7] = o$1, this.float32[c$1 + 2] = a$1, t$1;
				}
			}
			ba.prototype.bytesPerElement = 12, Qs(ba, "StructArrayLayout2i4ub1f12");
			class wa extends ca {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1, r$1) {
					const n$1 = this.length;
					return this.resize(n$1 + 1), this.emplace(n$1, t$1, e$1, r$1);
				}
				emplace(t$1, e$1, r$1, n$1) {
					const i$1 = 3 * t$1;
					return this.float32[i$1 + 0] = e$1, this.float32[i$1 + 1] = r$1, this.float32[i$1 + 2] = n$1, t$1;
				}
			}
			wa.prototype.bytesPerElement = 12, Qs(wa, "StructArrayLayout3f12");
			class _a extends ca {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1, r$1, n$1, i$1) {
					const s$1 = this.length;
					return this.resize(s$1 + 1), this.emplace(s$1, t$1, e$1, r$1, n$1, i$1);
				}
				emplace(t$1, e$1, r$1, n$1, i$1, s$1) {
					const o$1 = 6 * t$1, a$1 = 3 * t$1;
					return this.uint16[o$1 + 0] = e$1, this.uint16[o$1 + 1] = r$1, this.uint16[o$1 + 2] = n$1, this.uint16[o$1 + 3] = i$1, this.float32[a$1 + 2] = s$1, t$1;
				}
			}
			_a.prototype.bytesPerElement = 12, Qs(_a, "StructArrayLayout4ui1f12");
			class Aa extends ca {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1, r$1, n$1) {
					const i$1 = this.length;
					return this.resize(i$1 + 1), this.emplace(i$1, t$1, e$1, r$1, n$1);
				}
				emplace(t$1, e$1, r$1, n$1, i$1) {
					const s$1 = 4 * t$1;
					return this.uint16[s$1 + 0] = e$1, this.uint16[s$1 + 1] = r$1, this.uint16[s$1 + 2] = n$1, this.uint16[s$1 + 3] = i$1, t$1;
				}
			}
			Aa.prototype.bytesPerElement = 8, Qs(Aa, "StructArrayLayout4ui8");
			class Ia extends ca {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1, r$1, n$1, i$1, s$1) {
					const o$1 = this.length;
					return this.resize(o$1 + 1), this.emplace(o$1, t$1, e$1, r$1, n$1, i$1, s$1);
				}
				emplace(t$1, e$1, r$1, n$1, i$1, s$1, o$1) {
					const a$1 = 6 * t$1;
					return this.int16[a$1 + 0] = e$1, this.int16[a$1 + 1] = r$1, this.int16[a$1 + 2] = n$1, this.int16[a$1 + 3] = i$1, this.int16[a$1 + 4] = s$1, this.int16[a$1 + 5] = o$1, t$1;
				}
			}
			Ia.prototype.bytesPerElement = 12, Qs(Ia, "StructArrayLayout6i12");
			class Ma extends ca {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1, r$1, n$1, i$1, s$1, o$1, a$1, l$1, u$1, c$1, h$1) {
					const p$1 = this.length;
					return this.resize(p$1 + 1), this.emplace(p$1, t$1, e$1, r$1, n$1, i$1, s$1, o$1, a$1, l$1, u$1, c$1, h$1);
				}
				emplace(t$1, e$1, r$1, n$1, i$1, s$1, o$1, a$1, l$1, u$1, c$1, h$1, p$1) {
					const d$1 = 12 * t$1;
					return this.int16[d$1 + 0] = e$1, this.int16[d$1 + 1] = r$1, this.int16[d$1 + 2] = n$1, this.int16[d$1 + 3] = i$1, this.uint16[d$1 + 4] = s$1, this.uint16[d$1 + 5] = o$1, this.uint16[d$1 + 6] = a$1, this.uint16[d$1 + 7] = l$1, this.int16[d$1 + 8] = u$1, this.int16[d$1 + 9] = c$1, this.int16[d$1 + 10] = h$1, this.int16[d$1 + 11] = p$1, t$1;
				}
			}
			Ma.prototype.bytesPerElement = 24, Qs(Ma, "StructArrayLayout4i4ui4i24");
			class Sa extends ca {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1, r$1, n$1, i$1, s$1) {
					const o$1 = this.length;
					return this.resize(o$1 + 1), this.emplace(o$1, t$1, e$1, r$1, n$1, i$1, s$1);
				}
				emplace(t$1, e$1, r$1, n$1, i$1, s$1, o$1) {
					const a$1 = 10 * t$1, l$1 = 5 * t$1;
					return this.int16[a$1 + 0] = e$1, this.int16[a$1 + 1] = r$1, this.int16[a$1 + 2] = n$1, this.float32[l$1 + 2] = i$1, this.float32[l$1 + 3] = s$1, this.float32[l$1 + 4] = o$1, t$1;
				}
			}
			Sa.prototype.bytesPerElement = 20, Qs(Sa, "StructArrayLayout3i3f20");
			class Pa extends ca {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1, r$1, n$1) {
					const i$1 = this.length;
					return this.resize(i$1 + 1), this.emplace(i$1, t$1, e$1, r$1, n$1);
				}
				emplace(t$1, e$1, r$1, n$1, i$1) {
					const s$1 = 4 * t$1;
					return this.float32[s$1 + 0] = e$1, this.float32[s$1 + 1] = r$1, this.float32[s$1 + 2] = n$1, this.float32[s$1 + 3] = i$1, t$1;
				}
			}
			Pa.prototype.bytesPerElement = 16, Qs(Pa, "StructArrayLayout4f16");
			class ka extends ca {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
				}
				emplaceBack(t$1) {
					const e$1 = this.length;
					return this.resize(e$1 + 1), this.emplace(e$1, t$1);
				}
				emplace(t$1, e$1) {
					return this.uint32[1 * t$1 + 0] = e$1, t$1;
				}
			}
			ka.prototype.bytesPerElement = 4, Qs(ka, "StructArrayLayout1ul4");
			class Ba extends ca {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1) {
					const r$1 = this.length;
					return this.resize(r$1 + 1), this.emplace(r$1, t$1, e$1);
				}
				emplace(t$1, e$1, r$1) {
					const n$1 = 2 * t$1;
					return this.uint16[n$1 + 0] = e$1, this.uint16[n$1 + 1] = r$1, t$1;
				}
			}
			Ba.prototype.bytesPerElement = 4, Qs(Ba, "StructArrayLayout2ui4");
			class za extends ca {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1, r$1, n$1, i$1, s$1, o$1, a$1, l$1, u$1, c$1, h$1, p$1) {
					const d$1 = this.length;
					return this.resize(d$1 + 1), this.emplace(d$1, t$1, e$1, r$1, n$1, i$1, s$1, o$1, a$1, l$1, u$1, c$1, h$1, p$1);
				}
				emplace(t$1, e$1, r$1, n$1, i$1, s$1, o$1, a$1, l$1, u$1, c$1, h$1, p$1, d$1) {
					const f$1 = 20 * t$1, m$1 = 10 * t$1;
					return this.int16[f$1 + 0] = e$1, this.int16[f$1 + 1] = r$1, this.int16[f$1 + 2] = n$1, this.int16[f$1 + 3] = i$1, this.int16[f$1 + 4] = s$1, this.float32[m$1 + 3] = o$1, this.float32[m$1 + 4] = a$1, this.float32[m$1 + 5] = l$1, this.float32[m$1 + 6] = u$1, this.int16[f$1 + 14] = c$1, this.uint32[m$1 + 8] = h$1, this.uint16[f$1 + 18] = p$1, this.uint16[f$1 + 19] = d$1, t$1;
				}
			}
			za.prototype.bytesPerElement = 40, Qs(za, "StructArrayLayout5i4f1i1ul2ui40");
			class Ta extends ca {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1, r$1, n$1, i$1, s$1, o$1) {
					const a$1 = this.length;
					return this.resize(a$1 + 1), this.emplace(a$1, t$1, e$1, r$1, n$1, i$1, s$1, o$1);
				}
				emplace(t$1, e$1, r$1, n$1, i$1, s$1, o$1, a$1) {
					const l$1 = 8 * t$1;
					return this.int16[l$1 + 0] = e$1, this.int16[l$1 + 1] = r$1, this.int16[l$1 + 2] = n$1, this.int16[l$1 + 4] = i$1, this.int16[l$1 + 5] = s$1, this.int16[l$1 + 6] = o$1, this.int16[l$1 + 7] = a$1, t$1;
				}
			}
			Ta.prototype.bytesPerElement = 16, Qs(Ta, "StructArrayLayout3i2i2i16");
			class Ea extends ca {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1, r$1, n$1, i$1) {
					const s$1 = this.length;
					return this.resize(s$1 + 1), this.emplace(s$1, t$1, e$1, r$1, n$1, i$1);
				}
				emplace(t$1, e$1, r$1, n$1, i$1, s$1) {
					const o$1 = 4 * t$1, a$1 = 8 * t$1;
					return this.float32[o$1 + 0] = e$1, this.float32[o$1 + 1] = r$1, this.float32[o$1 + 2] = n$1, this.int16[a$1 + 6] = i$1, this.int16[a$1 + 7] = s$1, t$1;
				}
			}
			Ea.prototype.bytesPerElement = 16, Qs(Ea, "StructArrayLayout2f1f2i16");
			class Va extends ca {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1, r$1, n$1, i$1, s$1) {
					const o$1 = this.length;
					return this.resize(o$1 + 1), this.emplace(o$1, t$1, e$1, r$1, n$1, i$1, s$1);
				}
				emplace(t$1, e$1, r$1, n$1, i$1, s$1, o$1) {
					const a$1 = 20 * t$1, l$1 = 5 * t$1;
					return this.uint8[a$1 + 0] = e$1, this.uint8[a$1 + 1] = r$1, this.float32[l$1 + 1] = n$1, this.float32[l$1 + 2] = i$1, this.float32[l$1 + 3] = s$1, this.float32[l$1 + 4] = o$1, t$1;
				}
			}
			Va.prototype.bytesPerElement = 20, Qs(Va, "StructArrayLayout2ub4f20");
			class Fa extends ca {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1, r$1) {
					const n$1 = this.length;
					return this.resize(n$1 + 1), this.emplace(n$1, t$1, e$1, r$1);
				}
				emplace(t$1, e$1, r$1, n$1) {
					const i$1 = 3 * t$1;
					return this.uint16[i$1 + 0] = e$1, this.uint16[i$1 + 1] = r$1, this.uint16[i$1 + 2] = n$1, t$1;
				}
			}
			Fa.prototype.bytesPerElement = 6, Qs(Fa, "StructArrayLayout3ui6");
			class Ca extends ca {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1, r$1, n$1, i$1, s$1, o$1, a$1, l$1, u$1, c$1, h$1, p$1, d$1, f$1, m$1, y$1, g$1, x$1, v$1, b$1) {
					const w$1 = this.length;
					return this.resize(w$1 + 1), this.emplace(w$1, t$1, e$1, r$1, n$1, i$1, s$1, o$1, a$1, l$1, u$1, c$1, h$1, p$1, d$1, f$1, m$1, y$1, g$1, x$1, v$1, b$1);
				}
				emplace(t$1, e$1, r$1, n$1, i$1, s$1, o$1, a$1, l$1, u$1, c$1, h$1, p$1, d$1, f$1, m$1, y$1, g$1, x$1, v$1, b$1, w$1) {
					const _$1 = 30 * t$1, A$1 = 15 * t$1, I$1 = 60 * t$1;
					return this.int16[_$1 + 0] = e$1, this.int16[_$1 + 1] = r$1, this.int16[_$1 + 2] = n$1, this.float32[A$1 + 2] = i$1, this.float32[A$1 + 3] = s$1, this.uint16[_$1 + 8] = o$1, this.uint16[_$1 + 9] = a$1, this.uint32[A$1 + 5] = l$1, this.uint32[A$1 + 6] = u$1, this.uint32[A$1 + 7] = c$1, this.uint16[_$1 + 16] = h$1, this.uint16[_$1 + 17] = p$1, this.uint16[_$1 + 18] = d$1, this.float32[A$1 + 10] = f$1, this.float32[A$1 + 11] = m$1, this.uint8[I$1 + 48] = y$1, this.uint8[I$1 + 49] = g$1, this.uint8[I$1 + 50] = x$1, this.uint32[A$1 + 13] = v$1, this.int16[_$1 + 28] = b$1, this.uint8[I$1 + 58] = w$1, t$1;
				}
			}
			Ca.prototype.bytesPerElement = 60, Qs(Ca, "StructArrayLayout3i2f2ui3ul3ui2f3ub1ul1i1ub60");
			class Da extends ca {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1, r$1, n$1, i$1, s$1, o$1, a$1, l$1, u$1, c$1, h$1, p$1, d$1, f$1, m$1, y$1, g$1, x$1, v$1, b$1, w$1, _$1, A$1, I$1, M$1, S$1, P$1, k$1, B$1, z$1, T$1, E$1) {
					const V$1 = this.length;
					return this.resize(V$1 + 1), this.emplace(V$1, t$1, e$1, r$1, n$1, i$1, s$1, o$1, a$1, l$1, u$1, c$1, h$1, p$1, d$1, f$1, m$1, y$1, g$1, x$1, v$1, b$1, w$1, _$1, A$1, I$1, M$1, S$1, P$1, k$1, B$1, z$1, T$1, E$1);
				}
				emplace(t$1, e$1, r$1, n$1, i$1, s$1, o$1, a$1, l$1, u$1, c$1, h$1, p$1, d$1, f$1, m$1, y$1, g$1, x$1, v$1, b$1, w$1, _$1, A$1, I$1, M$1, S$1, P$1, k$1, B$1, z$1, T$1, E$1, V$1) {
					const F$1 = 20 * t$1, C$1 = 40 * t$1, D$1 = 80 * t$1;
					return this.float32[F$1 + 0] = e$1, this.float32[F$1 + 1] = r$1, this.int16[C$1 + 4] = n$1, this.int16[C$1 + 5] = i$1, this.int16[C$1 + 6] = s$1, this.int16[C$1 + 7] = o$1, this.int16[C$1 + 8] = a$1, this.int16[C$1 + 9] = l$1, this.int16[C$1 + 10] = u$1, this.int16[C$1 + 11] = c$1, this.int16[C$1 + 12] = h$1, this.uint16[C$1 + 13] = p$1, this.uint16[C$1 + 14] = d$1, this.uint16[C$1 + 15] = f$1, this.uint16[C$1 + 16] = m$1, this.uint16[C$1 + 17] = y$1, this.uint16[C$1 + 18] = g$1, this.uint16[C$1 + 19] = x$1, this.uint16[C$1 + 20] = v$1, this.uint16[C$1 + 21] = b$1, this.uint16[C$1 + 22] = w$1, this.uint16[C$1 + 23] = _$1, this.uint16[C$1 + 24] = A$1, this.uint16[C$1 + 25] = I$1, this.uint16[C$1 + 26] = M$1, this.uint16[C$1 + 27] = S$1, this.uint32[F$1 + 14] = P$1, this.float32[F$1 + 15] = k$1, this.float32[F$1 + 16] = B$1, this.float32[F$1 + 17] = z$1, this.float32[F$1 + 18] = T$1, this.uint8[D$1 + 76] = E$1, this.uint16[C$1 + 39] = V$1, t$1;
				}
			}
			Da.prototype.bytesPerElement = 80, Qs(Da, "StructArrayLayout2f9i15ui1ul4f1ub1ui80");
			class Ra extends ca {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1, r$1, n$1, i$1, s$1) {
					const o$1 = this.length;
					return this.resize(o$1 + 1), this.emplace(o$1, t$1, e$1, r$1, n$1, i$1, s$1);
				}
				emplace(t$1, e$1, r$1, n$1, i$1, s$1, o$1) {
					const a$1 = 6 * t$1;
					return this.float32[a$1 + 0] = e$1, this.float32[a$1 + 1] = r$1, this.float32[a$1 + 2] = n$1, this.float32[a$1 + 3] = i$1, this.float32[a$1 + 4] = s$1, this.float32[a$1 + 5] = o$1, t$1;
				}
			}
			Ra.prototype.bytesPerElement = 24, Qs(Ra, "StructArrayLayout6f24");
			class La extends ca {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1, r$1, n$1, i$1) {
					const s$1 = this.length;
					return this.resize(s$1 + 1), this.emplace(s$1, t$1, e$1, r$1, n$1, i$1);
				}
				emplace(t$1, e$1, r$1, n$1, i$1, s$1) {
					const o$1 = 5 * t$1;
					return this.float32[o$1 + 0] = e$1, this.float32[o$1 + 1] = r$1, this.float32[o$1 + 2] = n$1, this.float32[o$1 + 3] = i$1, this.float32[o$1 + 4] = s$1, t$1;
				}
			}
			La.prototype.bytesPerElement = 20, Qs(La, "StructArrayLayout5f20");
			class Oa extends ca {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1, r$1, n$1, i$1, s$1, o$1) {
					const a$1 = this.length;
					return this.resize(a$1 + 1), this.emplace(a$1, t$1, e$1, r$1, n$1, i$1, s$1, o$1);
				}
				emplace(t$1, e$1, r$1, n$1, i$1, s$1, o$1, a$1) {
					const l$1 = 7 * t$1;
					return this.float32[l$1 + 0] = e$1, this.float32[l$1 + 1] = r$1, this.float32[l$1 + 2] = n$1, this.float32[l$1 + 3] = i$1, this.float32[l$1 + 4] = s$1, this.float32[l$1 + 5] = o$1, this.float32[l$1 + 6] = a$1, t$1;
				}
			}
			Oa.prototype.bytesPerElement = 28, Qs(Oa, "StructArrayLayout7f28");
			class Ua extends ca {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1, r$1, n$1, i$1, s$1, o$1, a$1, l$1, u$1, c$1) {
					const h$1 = this.length;
					return this.resize(h$1 + 1), this.emplace(h$1, t$1, e$1, r$1, n$1, i$1, s$1, o$1, a$1, l$1, u$1, c$1);
				}
				emplace(t$1, e$1, r$1, n$1, i$1, s$1, o$1, a$1, l$1, u$1, c$1, h$1) {
					const p$1 = 11 * t$1;
					return this.float32[p$1 + 0] = e$1, this.float32[p$1 + 1] = r$1, this.float32[p$1 + 2] = n$1, this.float32[p$1 + 3] = i$1, this.float32[p$1 + 4] = s$1, this.float32[p$1 + 5] = o$1, this.float32[p$1 + 6] = a$1, this.float32[p$1 + 7] = l$1, this.float32[p$1 + 8] = u$1, this.float32[p$1 + 9] = c$1, this.float32[p$1 + 10] = h$1, t$1;
				}
			}
			Ua.prototype.bytesPerElement = 44, Qs(Ua, "StructArrayLayout11f44");
			class Na extends ca {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1, r$1, n$1, i$1, s$1, o$1, a$1, l$1) {
					const u$1 = this.length;
					return this.resize(u$1 + 1), this.emplace(u$1, t$1, e$1, r$1, n$1, i$1, s$1, o$1, a$1, l$1);
				}
				emplace(t$1, e$1, r$1, n$1, i$1, s$1, o$1, a$1, l$1, u$1) {
					const c$1 = 9 * t$1;
					return this.float32[c$1 + 0] = e$1, this.float32[c$1 + 1] = r$1, this.float32[c$1 + 2] = n$1, this.float32[c$1 + 3] = i$1, this.float32[c$1 + 4] = s$1, this.float32[c$1 + 5] = o$1, this.float32[c$1 + 6] = a$1, this.float32[c$1 + 7] = l$1, this.float32[c$1 + 8] = u$1, t$1;
				}
			}
			Na.prototype.bytesPerElement = 36, Qs(Na, "StructArrayLayout9f36");
			class ja extends ca {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1) {
					const r$1 = this.length;
					return this.resize(r$1 + 1), this.emplace(r$1, t$1, e$1);
				}
				emplace(t$1, e$1, r$1) {
					const n$1 = 2 * t$1;
					return this.float32[n$1 + 0] = e$1, this.float32[n$1 + 1] = r$1, t$1;
				}
			}
			ja.prototype.bytesPerElement = 8, Qs(ja, "StructArrayLayout2f8");
			class $a extends ca {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1, r$1, n$1) {
					const i$1 = this.length;
					return this.resize(i$1 + 1), this.emplace(i$1, t$1, e$1, r$1, n$1);
				}
				emplace(t$1, e$1, r$1, n$1, i$1) {
					const s$1 = 6 * t$1;
					return this.uint32[3 * t$1 + 0] = e$1, this.uint16[s$1 + 2] = r$1, this.uint16[s$1 + 3] = n$1, this.uint16[s$1 + 4] = i$1, t$1;
				}
			}
			$a.prototype.bytesPerElement = 12, Qs($a, "StructArrayLayout1ul3ui12");
			class Ga extends ca {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
				}
				emplaceBack(t$1) {
					const e$1 = this.length;
					return this.resize(e$1 + 1), this.emplace(e$1, t$1);
				}
				emplace(t$1, e$1) {
					return this.uint16[1 * t$1 + 0] = e$1, t$1;
				}
			}
			Ga.prototype.bytesPerElement = 2, Qs(Ga, "StructArrayLayout1ui2");
			class qa extends ca {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1, r$1, n$1, i$1, s$1, o$1, a$1, l$1, u$1, c$1, h$1, p$1, d$1, f$1, m$1) {
					const y$1 = this.length;
					return this.resize(y$1 + 1), this.emplace(y$1, t$1, e$1, r$1, n$1, i$1, s$1, o$1, a$1, l$1, u$1, c$1, h$1, p$1, d$1, f$1, m$1);
				}
				emplace(t$1, e$1, r$1, n$1, i$1, s$1, o$1, a$1, l$1, u$1, c$1, h$1, p$1, d$1, f$1, m$1, y$1) {
					const g$1 = 16 * t$1;
					return this.float32[g$1 + 0] = e$1, this.float32[g$1 + 1] = r$1, this.float32[g$1 + 2] = n$1, this.float32[g$1 + 3] = i$1, this.float32[g$1 + 4] = s$1, this.float32[g$1 + 5] = o$1, this.float32[g$1 + 6] = a$1, this.float32[g$1 + 7] = l$1, this.float32[g$1 + 8] = u$1, this.float32[g$1 + 9] = c$1, this.float32[g$1 + 10] = h$1, this.float32[g$1 + 11] = p$1, this.float32[g$1 + 12] = d$1, this.float32[g$1 + 13] = f$1, this.float32[g$1 + 14] = m$1, this.float32[g$1 + 15] = y$1, t$1;
				}
			}
			qa.prototype.bytesPerElement = 64, Qs(qa, "StructArrayLayout16f64");
			class Ha extends ca {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1, r$1, n$1, i$1, s$1, o$1) {
					const a$1 = this.length;
					return this.resize(a$1 + 1), this.emplace(a$1, t$1, e$1, r$1, n$1, i$1, s$1, o$1);
				}
				emplace(t$1, e$1, r$1, n$1, i$1, s$1, o$1, a$1) {
					const l$1 = 10 * t$1, u$1 = 5 * t$1;
					return this.uint16[l$1 + 0] = e$1, this.uint16[l$1 + 1] = r$1, this.uint16[l$1 + 2] = n$1, this.uint16[l$1 + 3] = i$1, this.float32[u$1 + 2] = s$1, this.float32[u$1 + 3] = o$1, this.float32[u$1 + 4] = a$1, t$1;
				}
			}
			Ha.prototype.bytesPerElement = 20, Qs(Ha, "StructArrayLayout4ui3f20");
			class Xa extends ca {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
				}
				emplaceBack(t$1) {
					const e$1 = this.length;
					return this.resize(e$1 + 1), this.emplace(e$1, t$1);
				}
				emplace(t$1, e$1) {
					return this.int16[1 * t$1 + 0] = e$1, t$1;
				}
			}
			Xa.prototype.bytesPerElement = 2, Qs(Xa, "StructArrayLayout1i2");
			class Za extends ca {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer);
				}
				emplaceBack(t$1) {
					const e$1 = this.length;
					return this.resize(e$1 + 1), this.emplace(e$1, t$1);
				}
				emplace(t$1, e$1) {
					return this.uint8[1 * t$1 + 0] = e$1, t$1;
				}
			}
			Za.prototype.bytesPerElement = 1, Qs(Za, "StructArrayLayout1ub1");
			class Wa extends la {
				get projectedAnchorX() {
					return this._structArray.int16[this._pos2 + 0];
				}
				get projectedAnchorY() {
					return this._structArray.int16[this._pos2 + 1];
				}
				get projectedAnchorZ() {
					return this._structArray.int16[this._pos2 + 2];
				}
				get tileAnchorX() {
					return this._structArray.int16[this._pos2 + 3];
				}
				get tileAnchorY() {
					return this._structArray.int16[this._pos2 + 4];
				}
				get x1() {
					return this._structArray.float32[this._pos4 + 3];
				}
				get y1() {
					return this._structArray.float32[this._pos4 + 4];
				}
				get x2() {
					return this._structArray.float32[this._pos4 + 5];
				}
				get y2() {
					return this._structArray.float32[this._pos4 + 6];
				}
				get padding() {
					return this._structArray.int16[this._pos2 + 14];
				}
				get featureIndex() {
					return this._structArray.uint32[this._pos4 + 8];
				}
				get sourceLayerIndex() {
					return this._structArray.uint16[this._pos2 + 18];
				}
				get bucketIndex() {
					return this._structArray.uint16[this._pos2 + 19];
				}
			}
			Wa.prototype.size = 40;
			class Ya extends za {
				get(t$1) {
					return new Wa(this, t$1);
				}
			}
			Qs(Ya, "CollisionBoxArray");
			class Ka extends la {
				get projectedAnchorX() {
					return this._structArray.int16[this._pos2 + 0];
				}
				get projectedAnchorY() {
					return this._structArray.int16[this._pos2 + 1];
				}
				get projectedAnchorZ() {
					return this._structArray.int16[this._pos2 + 2];
				}
				get tileAnchorX() {
					return this._structArray.float32[this._pos4 + 2];
				}
				get tileAnchorY() {
					return this._structArray.float32[this._pos4 + 3];
				}
				get glyphStartIndex() {
					return this._structArray.uint16[this._pos2 + 8];
				}
				get numGlyphs() {
					return this._structArray.uint16[this._pos2 + 9];
				}
				get vertexStartIndex() {
					return this._structArray.uint32[this._pos4 + 5];
				}
				get lineStartIndex() {
					return this._structArray.uint32[this._pos4 + 6];
				}
				get lineLength() {
					return this._structArray.uint32[this._pos4 + 7];
				}
				get segment() {
					return this._structArray.uint16[this._pos2 + 16];
				}
				get lowerSize() {
					return this._structArray.uint16[this._pos2 + 17];
				}
				get upperSize() {
					return this._structArray.uint16[this._pos2 + 18];
				}
				get lineOffsetX() {
					return this._structArray.float32[this._pos4 + 10];
				}
				get lineOffsetY() {
					return this._structArray.float32[this._pos4 + 11];
				}
				get writingMode() {
					return this._structArray.uint8[this._pos1 + 48];
				}
				get placedOrientation() {
					return this._structArray.uint8[this._pos1 + 49];
				}
				set placedOrientation(t$1) {
					this._structArray.uint8[this._pos1 + 49] = t$1;
				}
				get hidden() {
					return this._structArray.uint8[this._pos1 + 50];
				}
				set hidden(t$1) {
					this._structArray.uint8[this._pos1 + 50] = t$1;
				}
				get crossTileID() {
					return this._structArray.uint32[this._pos4 + 13];
				}
				set crossTileID(t$1) {
					this._structArray.uint32[this._pos4 + 13] = t$1;
				}
				get associatedIconIndex() {
					return this._structArray.int16[this._pos2 + 28];
				}
				get flipState() {
					return this._structArray.uint8[this._pos1 + 58];
				}
				set flipState(t$1) {
					this._structArray.uint8[this._pos1 + 58] = t$1;
				}
			}
			Ka.prototype.size = 60;
			class Ja extends Ca {
				get(t$1) {
					return new Ka(this, t$1);
				}
			}
			Qs(Ja, "PlacedSymbolArray");
			class Qa extends la {
				get tileAnchorX() {
					return this._structArray.float32[this._pos4 + 0];
				}
				get tileAnchorY() {
					return this._structArray.float32[this._pos4 + 1];
				}
				get projectedAnchorX() {
					return this._structArray.int16[this._pos2 + 4];
				}
				get projectedAnchorY() {
					return this._structArray.int16[this._pos2 + 5];
				}
				get projectedAnchorZ() {
					return this._structArray.int16[this._pos2 + 6];
				}
				get rightJustifiedTextSymbolIndex() {
					return this._structArray.int16[this._pos2 + 7];
				}
				get centerJustifiedTextSymbolIndex() {
					return this._structArray.int16[this._pos2 + 8];
				}
				get leftJustifiedTextSymbolIndex() {
					return this._structArray.int16[this._pos2 + 9];
				}
				get verticalPlacedTextSymbolIndex() {
					return this._structArray.int16[this._pos2 + 10];
				}
				get placedIconSymbolIndex() {
					return this._structArray.int16[this._pos2 + 11];
				}
				get verticalPlacedIconSymbolIndex() {
					return this._structArray.int16[this._pos2 + 12];
				}
				get key() {
					return this._structArray.uint16[this._pos2 + 13];
				}
				get textBoxStartIndex() {
					return this._structArray.uint16[this._pos2 + 14];
				}
				get textBoxEndIndex() {
					return this._structArray.uint16[this._pos2 + 15];
				}
				get verticalTextBoxStartIndex() {
					return this._structArray.uint16[this._pos2 + 16];
				}
				get verticalTextBoxEndIndex() {
					return this._structArray.uint16[this._pos2 + 17];
				}
				get iconBoxStartIndex() {
					return this._structArray.uint16[this._pos2 + 18];
				}
				get iconBoxEndIndex() {
					return this._structArray.uint16[this._pos2 + 19];
				}
				get verticalIconBoxStartIndex() {
					return this._structArray.uint16[this._pos2 + 20];
				}
				get verticalIconBoxEndIndex() {
					return this._structArray.uint16[this._pos2 + 21];
				}
				get featureIndex() {
					return this._structArray.uint16[this._pos2 + 22];
				}
				get numHorizontalGlyphVertices() {
					return this._structArray.uint16[this._pos2 + 23];
				}
				get numVerticalGlyphVertices() {
					return this._structArray.uint16[this._pos2 + 24];
				}
				get numIconVertices() {
					return this._structArray.uint16[this._pos2 + 25];
				}
				get numVerticalIconVertices() {
					return this._structArray.uint16[this._pos2 + 26];
				}
				get useRuntimeCollisionCircles() {
					return this._structArray.uint16[this._pos2 + 27];
				}
				get crossTileID() {
					return this._structArray.uint32[this._pos4 + 14];
				}
				set crossTileID(t$1) {
					this._structArray.uint32[this._pos4 + 14] = t$1;
				}
				get textOffset0() {
					return this._structArray.float32[this._pos4 + 15];
				}
				get textOffset1() {
					return this._structArray.float32[this._pos4 + 16];
				}
				get collisionCircleDiameter() {
					return this._structArray.float32[this._pos4 + 17];
				}
				get zOffset() {
					return this._structArray.float32[this._pos4 + 18];
				}
				set zOffset(t$1) {
					this._structArray.float32[this._pos4 + 18] = t$1;
				}
				get hasIconTextFit() {
					return this._structArray.uint8[this._pos1 + 76];
				}
				get elevationFeatureIndex() {
					return this._structArray.uint16[this._pos2 + 39];
				}
			}
			Qa.prototype.size = 80;
			class tl extends Da {
				get(t$1) {
					return new Qa(this, t$1);
				}
			}
			Qs(tl, "SymbolInstanceArray");
			class el extends ya {
				getoffsetX(t$1) {
					return this.float32[1 * t$1 + 0];
				}
			}
			Qs(el, "GlyphOffsetArray");
			class rl extends da {
				getx(t$1) {
					return this.int16[2 * t$1 + 0];
				}
				gety(t$1) {
					return this.int16[2 * t$1 + 1];
				}
			}
			Qs(rl, "SymbolLineVertexArray");
			class nl extends la {
				get featureIndex() {
					return this._structArray.uint32[this._pos4 + 0];
				}
				get sourceLayerIndex() {
					return this._structArray.uint16[this._pos2 + 2];
				}
				get bucketIndex() {
					return this._structArray.uint16[this._pos2 + 3];
				}
				get layoutVertexArrayOffset() {
					return this._structArray.uint16[this._pos2 + 4];
				}
			}
			nl.prototype.size = 12;
			class il extends $a {
				get(t$1) {
					return new nl(this, t$1);
				}
			}
			Qs(il, "FeatureIndexArray");
			class sl extends Ba {
				geta_centroid_pos0(t$1) {
					return this.uint16[2 * t$1 + 0];
				}
				geta_centroid_pos1(t$1) {
					return this.uint16[2 * t$1 + 1];
				}
			}
			Qs(sl, "FillExtrusionCentroidArray");
			class ol extends la {
				get a_join_normal_inside0() {
					return this._structArray.int16[this._pos2 + 0];
				}
				get a_join_normal_inside1() {
					return this._structArray.int16[this._pos2 + 1];
				}
				get a_join_normal_inside2() {
					return this._structArray.int16[this._pos2 + 2];
				}
			}
			ol.prototype.size = 6;
			class al extends fa {
				get(t$1) {
					return new ol(this, t$1);
				}
			}
			Qs(al, "FillExtrusionWallArray");
			const ll = ha([{
				name: "a_pos",
				components: 2,
				type: "Int16"
			}], 4), ul = ha([{
				name: "a_circle_z_offset",
				components: 1,
				type: "Float32"
			}], 4), cl = ha([{
				name: "a_pos_3",
				components: 3,
				type: "Int16"
			}, {
				name: "a_pos_normal_3",
				components: 3,
				type: "Int16"
			}]);
			class hl {
				constructor(t$1 = []) {
					this.segments = t$1;
				}
				_prepareSegment(t$1, e$1, r$1, n$1) {
					let i$1 = this.segments[this.segments.length - 1];
					return t$1 > hl.MAX_VERTEX_ARRAY_LENGTH && Xt(`Max vertices per segment is ${hl.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${t$1}`), (!i$1 || i$1.vertexLength + t$1 > hl.MAX_VERTEX_ARRAY_LENGTH || i$1.sortKey !== n$1) && (i$1 = {
						vertexOffset: e$1,
						primitiveOffset: r$1,
						vertexLength: 0,
						primitiveLength: 0
					}, void 0 !== n$1 && (i$1.sortKey = n$1), this.segments.push(i$1)), i$1;
				}
				prepareSegment(t$1, e$1, r$1, n$1) {
					return this._prepareSegment(t$1, e$1.length, r$1.length, n$1);
				}
				get() {
					return this.segments;
				}
				destroy() {
					for (const t$1 of this.segments) for (const e$1 in t$1.vaos) t$1.vaos[e$1].destroy();
				}
				static simpleSegment(t$1, e$1, r$1, n$1) {
					return new hl([{
						vertexOffset: t$1,
						primitiveOffset: e$1,
						vertexLength: r$1,
						primitiveLength: n$1,
						vaos: {},
						sortKey: 0
					}]);
				}
			}
			function pl(t$1, e$1) {
				return 256 * (t$1 = Ft(Math.floor(t$1), 0, 255)) + Ft(Math.floor(e$1), 0, 255);
			}
			hl.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, Qs(hl, "SegmentVector");
			const dl = ha([{
				name: "a_pattern",
				components: 4,
				type: "Uint16"
			}, {
				name: "a_pixel_ratio",
				components: 1,
				type: "Float32"
			}]), fl = ha([{
				name: "a_pattern_b",
				components: 4,
				type: "Uint16"
			}]), ml = ha([{
				name: "a_dash",
				components: 4,
				type: "Uint16"
			}]);
			class yl {
				constructor() {
					this.ids = [], this.uniqueIds = [], this.positions = [], this.indexed = !1;
				}
				add(t$1, e$1, r$1, n$1) {
					this.ids.push(gl(t$1)), this.positions.push(e$1, r$1, n$1);
				}
				eachPosition(t$1, e$1) {
					const r$1 = gl(t$1);
					let n$1 = 0, i$1 = this.ids.length - 1;
					for (; n$1 < i$1;) {
						const t$2 = n$1 + i$1 >> 1;
						this.ids[t$2] >= r$1 ? i$1 = t$2 : n$1 = t$2 + 1;
					}
					for (; this.ids[n$1] === r$1;) e$1(this.positions[3 * n$1], this.positions[3 * n$1 + 1], this.positions[3 * n$1 + 2]), n$1++;
				}
				static serialize(t$1, e$1) {
					const r$1 = new Float64Array(t$1.ids), n$1 = new Uint32Array(t$1.positions);
					return xl(r$1, n$1, 0, r$1.length - 1), e$1 && (e$1.add(r$1.buffer), e$1.add(n$1.buffer)), {
						ids: r$1,
						positions: n$1
					};
				}
				static deserialize(t$1) {
					const e$1 = new yl();
					let r$1;
					e$1.ids = t$1.ids, e$1.positions = t$1.positions;
					for (const t$2 of e$1.ids) t$2 !== r$1 && e$1.uniqueIds.push(t$2), r$1 = t$2;
					return e$1.indexed = !0, e$1;
				}
			}
			function gl(t$1) {
				const e$1 = +t$1;
				return Number.isSafeInteger(e$1) ? e$1 : Je(String(t$1));
			}
			function xl(t$1, e$1, r$1, n$1) {
				for (; r$1 < n$1;) {
					const i$1 = t$1[r$1 + n$1 >> 1];
					let s$1 = r$1 - 1, o$1 = n$1 + 1;
					for (;;) {
						do
							s$1++;
						while (t$1[s$1] < i$1);
						do
							o$1--;
						while (t$1[o$1] > i$1);
						if (s$1 >= o$1) break;
						vl(t$1, s$1, o$1), vl(e$1, 3 * s$1, 3 * o$1), vl(e$1, 3 * s$1 + 1, 3 * o$1 + 1), vl(e$1, 3 * s$1 + 2, 3 * o$1 + 2);
					}
					o$1 - r$1 < n$1 - o$1 ? (xl(t$1, e$1, r$1, o$1), r$1 = o$1 + 1) : (xl(t$1, e$1, o$1 + 1, n$1), n$1 = o$1);
				}
			}
			function vl(t$1, e$1, r$1) {
				const n$1 = t$1[e$1];
				t$1[e$1] = t$1[r$1], t$1[r$1] = n$1;
			}
			Qs(yl, "FeaturePositionMap");
			class bl {
				constructor(t$1) {
					this.gl = t$1.gl, this.initialized = !1;
				}
				fetchUniformLocation(t$1, e$1) {
					return this.location || this.initialized || (this.location = this.gl.getUniformLocation(t$1, e$1), this.initialized = !0), !!this.location;
				}
				set(t$1, e$1, r$1) {
					throw new Error("Uniform#set() must be implemented by each concrete Uniform");
				}
			}
			class wl extends bl {
				constructor(t$1) {
					super(t$1), this.current = 0;
				}
				set(t$1, e$1, r$1) {
					this.fetchUniformLocation(t$1, e$1) && this.current !== r$1 && (this.current = r$1, this.gl.uniform1i(this.location, r$1));
				}
			}
			class _l extends bl {
				constructor(t$1) {
					super(t$1), this.current = 0;
				}
				set(t$1, e$1, r$1) {
					this.fetchUniformLocation(t$1, e$1) && this.current !== r$1 && (this.current = r$1, this.gl.uniform1f(this.location, r$1));
				}
			}
			class Al extends bl {
				constructor(t$1) {
					super(t$1), this.current = [0, 0];
				}
				set(t$1, e$1, r$1) {
					this.fetchUniformLocation(t$1, e$1) && (r$1[0] === this.current[0] && r$1[1] === this.current[1] || (this.current = r$1, this.gl.uniform2f(this.location, r$1[0], r$1[1])));
				}
			}
			class Il extends bl {
				constructor(t$1) {
					super(t$1), this.current = [
						0,
						0,
						0
					];
				}
				set(t$1, e$1, r$1) {
					this.fetchUniformLocation(t$1, e$1) && (r$1[0] === this.current[0] && r$1[1] === this.current[1] && r$1[2] === this.current[2] || (this.current = r$1, this.gl.uniform3f(this.location, r$1[0], r$1[1], r$1[2])));
				}
			}
			class Ml extends bl {
				constructor(t$1) {
					super(t$1), this.current = [
						0,
						0,
						0,
						0
					];
				}
				set(t$1, e$1, r$1) {
					this.fetchUniformLocation(t$1, e$1) && (r$1[0] === this.current[0] && r$1[1] === this.current[1] && r$1[2] === this.current[2] && r$1[3] === this.current[3] || (this.current = r$1, this.gl.uniform4f(this.location, r$1[0], r$1[1], r$1[2], r$1[3])));
				}
			}
			class Sl extends bl {
				constructor(t$1) {
					super(t$1), this.current = lr.transparent.toPremultipliedRenderColor(null);
				}
				set(t$1, e$1, r$1) {
					this.fetchUniformLocation(t$1, e$1) && (r$1.r === this.current.r && r$1.g === this.current.g && r$1.b === this.current.b && r$1.a === this.current.a || (this.current = r$1, this.gl.uniform4f(this.location, r$1.r, r$1.g, r$1.b, r$1.a)));
				}
			}
			const Pl = new Float32Array(16);
			class kl extends bl {
				constructor(t$1) {
					super(t$1), this.current = Pl;
				}
				set(t$1, e$1, r$1) {
					if (this.fetchUniformLocation(t$1, e$1)) {
						if (r$1[12] !== this.current[12] || r$1[0] !== this.current[0]) return this.current = r$1, void this.gl.uniformMatrix4fv(this.location, !1, r$1);
						for (let t$2 = 1; t$2 < 16; t$2++) if (r$1[t$2] !== this.current[t$2]) {
							this.current = r$1, this.gl.uniformMatrix4fv(this.location, !1, r$1);
							break;
						}
					}
				}
			}
			const Bl = new Float32Array(9), zl = new Float32Array(4);
			class Tl extends bl {
				constructor(t$1) {
					super(t$1), this.current = zl;
				}
				set(t$1, e$1, r$1) {
					if (this.fetchUniformLocation(t$1, e$1)) {
						for (let t$2 = 0; t$2 < 4; t$2++) if (r$1[t$2] !== this.current[t$2]) {
							this.current = r$1, this.gl.uniformMatrix2fv(this.location, !1, r$1);
							break;
						}
					}
				}
			}
			function El(t$1) {
				return [pl(255 * t$1.r, 255 * t$1.g), pl(255 * t$1.b, 255 * t$1.a)];
			}
			function Vl(t$1, e$1, r$1, n$1, i$1, s$1, o$1, a$1) {
				return !!t$1 && ("composite" === t$1.kind || "source" === t$1.kind ? "none" === t$1.evaluate(new Io(0, {
					brightness: s$1,
					worldview: a$1
				}), e$1, r$1, i$1, n$1, o$1) : "none" === t$1.value);
			}
			class Fl {
				constructor(t$1, e$1, r$1, n$1) {
					this.value = t$1, this.uniformNames = e$1.map(((t$2) => `u_${t$2}`)), this.type = r$1, this.context = n$1;
				}
				setUniform(t$1, e$1, r$1, n$1, i$1) {
					const s$1 = n$1.constantOr(this.value);
					e$1.set(t$1, i$1, s$1 instanceof lr ? s$1.toPremultipliedRenderColor(this.lutExpression && "constant" === this.lutExpression.kind && "none" === this.lutExpression.value ? null : this.context.lut) : s$1);
				}
				getBinding(t$1, e$1) {
					return "color" === this.type ? new Sl(t$1) : new _l(t$1);
				}
			}
			class Cl {
				constructor(t$1, e$1) {
					this.uniformNames = e$1.map(((t$2) => `u_${t$2}`)), this.pattern = null, this.patternTransition = null, this.pixelRatio = 1;
				}
				setConstantPatternPositions(t$1, e$1) {
					this.pixelRatio = t$1.pixelRatio || 1, this.pattern = t$1.tl.concat(t$1.br), this.patternTransition = e$1 ? e$1.tl.concat(e$1.br) : this.pattern;
				}
				setUniform(t$1, e$1, r$1, n$1, i$1) {
					let s$1 = null;
					"u_pattern" !== i$1 && "u_dash" !== i$1 || (s$1 = this.pattern), "u_pattern_b" === i$1 && (s$1 = this.patternTransition), "u_pixel_ratio" === i$1 && (s$1 = this.pixelRatio), s$1 && e$1.set(t$1, i$1, s$1);
				}
				getBinding(t$1, e$1) {
					return "u_pattern" === e$1 || "u_pattern_b" === e$1 || "u_dash" === e$1 ? new Ml(t$1) : new _l(t$1);
				}
			}
			class Dl {
				constructor(t$1, e$1, r$1, n$1) {
					this.expression = t$1, this.type = r$1, this.maxValue = 0, this.paintVertexAttributes = e$1.map(((t$2) => ({
						name: `a_${t$2}`,
						type: "Float32",
						components: "color" === r$1 ? 2 : 1,
						offset: 0
					}))), this.paintVertexArray = new n$1();
				}
				populatePaintArray(t$1, e$1, r$1, n$1, i$1, s$1, o$1, a$1) {
					const l$1 = this.paintVertexArray.length, u$1 = "composite" === this.expression.kind || "source" === this.expression.kind ? this.expression.evaluate(new Io(0, {
						brightness: s$1,
						worldview: a$1
					}), e$1, {}, i$1, n$1, o$1) : "constant" === this.expression.kind && this.expression.value, c$1 = Vl(this.lutExpression, e$1, {}, n$1, i$1, s$1, o$1, a$1);
					this.paintVertexArray.resize(t$1), this._setPaintValue(l$1, t$1, u$1, c$1 ? null : this.context.lut);
				}
				updatePaintArray(t$1, e$1, r$1, n$1, i$1, s$1, o$1, a$1) {
					const l$1 = "composite" === this.expression.kind || "source" === this.expression.kind ? this.expression.evaluate({
						zoom: 0,
						brightness: o$1,
						worldview: a$1
					}, r$1, n$1, void 0, i$1) : "constant" === this.expression.kind && this.expression.value, u$1 = Vl(this.lutExpression, r$1, n$1, i$1, void 0, o$1, void 0, a$1);
					this._setPaintValue(t$1, e$1, l$1, u$1 ? null : this.context.lut);
				}
				_setPaintValue(t$1, e$1, r$1, n$1) {
					if ("color" === this.type) {
						const i$1 = El(r$1.toPremultipliedRenderColor(n$1));
						for (let r$2 = t$1; r$2 < e$1; r$2++) this.paintVertexArray.emplace(r$2, i$1[0], i$1[1]);
					} else {
						for (let n$2 = t$1; n$2 < e$1; n$2++) this.paintVertexArray.emplace(n$2, r$1);
						this.maxValue = Math.max(this.maxValue, Math.abs(r$1));
					}
				}
				upload(t$1) {
					this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t$1.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.lutExpression && "constant" !== this.lutExpression.kind && (this.lutExpression.isStateDependent || !this.lutExpression.isLightConstant) || "constant" !== this.expression.kind && (this.expression.isStateDependent || !this.expression.isLightConstant)));
				}
				destroy() {
					this.paintVertexBuffer && this.paintVertexBuffer.destroy();
				}
			}
			class Rl {
				constructor(t$1, e$1, r$1, n$1, i$1, s$1) {
					this.expression = t$1, this.uniformNames = e$1.map(((t$2) => `u_${t$2}_t`)), this.type = r$1, this.useIntegerZoom = n$1, this.context = i$1, this.maxValue = 0, this.paintVertexAttributes = e$1.map(((t$2) => ({
						name: `a_${t$2}`,
						type: "Float32",
						components: "color" === r$1 ? 4 : 2,
						offset: 0
					}))), this.paintVertexArray = new s$1();
				}
				populatePaintArray(t$1, e$1, r$1, n$1, i$1, s$1, o$1, a$1) {
					const l$1 = this.expression.evaluate(new Io(this.context.zoom, {
						brightness: s$1,
						worldview: a$1
					}), e$1, {}, i$1, n$1, o$1), u$1 = this.expression.evaluate(new Io(this.context.zoom + 1, {
						brightness: s$1,
						worldview: a$1
					}), e$1, {}, i$1, n$1, o$1), c$1 = Vl(this.lutExpression, e$1, {}, n$1, i$1, s$1, o$1, a$1), h$1 = this.paintVertexArray.length;
					this.paintVertexArray.resize(t$1), this._setPaintValue(h$1, t$1, l$1, u$1, c$1 ? null : this.context.lut);
				}
				updatePaintArray(t$1, e$1, r$1, n$1, i$1, s$1, o$1, a$1) {
					const l$1 = this.expression.evaluate({
						zoom: this.context.zoom,
						brightness: o$1,
						worldview: a$1
					}, r$1, n$1, void 0, i$1), u$1 = this.expression.evaluate({
						zoom: this.context.zoom + 1,
						brightness: o$1,
						worldview: a$1
					}, r$1, n$1, void 0, i$1), c$1 = Vl(this.lutExpression, r$1, n$1, i$1, void 0, o$1, void 0, a$1);
					this._setPaintValue(t$1, e$1, l$1, u$1, c$1 ? null : this.context.lut);
				}
				_setPaintValue(t$1, e$1, r$1, n$1, i$1) {
					if ("color" === this.type) {
						const n$2 = El(r$1.toPremultipliedRenderColor(i$1)), s$1 = El(r$1.toPremultipliedRenderColor(i$1));
						for (let r$2 = t$1; r$2 < e$1; r$2++) this.paintVertexArray.emplace(r$2, n$2[0], n$2[1], s$1[0], s$1[1]);
					} else {
						for (let i$2 = t$1; i$2 < e$1; i$2++) this.paintVertexArray.emplace(i$2, r$1, n$1);
						this.maxValue = Math.max(this.maxValue, Math.abs(r$1), Math.abs(n$1));
					}
				}
				upload(t$1) {
					this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t$1.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent || !this.expression.isLightConstant));
				}
				destroy() {
					this.paintVertexBuffer && this.paintVertexBuffer.destroy();
				}
				setUniform(t$1, e$1, r$1, n$1, i$1) {
					const s$1 = this.useIntegerZoom ? Math.floor(r$1.zoom) : r$1.zoom, o$1 = Ft(this.expression.interpolationFactor(s$1, this.context.zoom, this.context.zoom + 1), 0, 1);
					e$1.set(t$1, i$1, o$1);
				}
				getBinding(t$1, e$1) {
					return new _l(t$1);
				}
			}
			class Ll {
				constructor(t$1, e$1, r$1, n$1, i$1) {
					this.expression = t$1, this.layerId = i$1, this.paintVertexAttributes = ("array" === r$1 ? ml : dl).members;
					for (let t$2 = 0; t$2 < e$1.length; ++t$2);
					this.paintVertexArray = new n$1(), this.paintTransitionVertexArray = new Aa();
				}
				populatePaintArray(t$1, e$1, r$1, n$1) {
					const i$1 = this.paintVertexArray.length;
					this.paintVertexArray.resize(t$1), this._setPaintValues(i$1, t$1, e$1.patterns && e$1.patterns[this.layerId], r$1);
				}
				updatePaintArray(t$1, e$1, r$1, n$1, i$1, s$1, o$1) {
					this._setPaintValues(t$1, e$1, r$1.patterns && r$1.patterns[this.layerId], s$1);
				}
				_setPaintValues(t$1, e$1, r$1, n$1) {
					if (!n$1 || !r$1) return;
					const i$1 = n$1[r$1[0]], s$1 = n$1[r$1[1]];
					if (i$1) {
						if (i$1) {
							const { tl: r$2, br: n$2, pixelRatio: s$2 } = i$1;
							for (let i$2 = t$1; i$2 < e$1; i$2++) this.paintVertexArray.emplace(i$2, r$2[0], r$2[1], n$2[0], n$2[1], s$2);
						}
						if (s$1) {
							this.paintTransitionVertexArray.resize(this.paintVertexArray.length);
							const { tl: r$2, br: n$2 } = s$1;
							for (let i$2 = t$1; i$2 < e$1; i$2++) this.paintTransitionVertexArray.emplace(i$2, r$2[0], r$2[1], n$2[0], n$2[1]);
						}
					}
				}
				upload(t$1) {
					const e$1 = this.expression.isStateDependent || !this.expression.isLightConstant;
					this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer = t$1.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, e$1)), this.paintTransitionVertexArray && this.paintTransitionVertexArray.length && (this.paintTransitionVertexBuffer = t$1.createVertexBuffer(this.paintTransitionVertexArray, fl.members, e$1));
				}
				destroy() {
					this.paintVertexBuffer && this.paintVertexBuffer.destroy(), this.paintTransitionVertexBuffer && this.paintTransitionVertexBuffer.destroy();
				}
			}
			class Ol {
				constructor(t$1, e$1, r$1 = (() => !0)) {
					this.binders = {}, this._buffers = [], this.context = e$1;
					const n$1 = [];
					for (const i$1 in t$1.paint._values) {
						const s$1 = t$1.paint.get(i$1);
						if (i$1.endsWith("-use-theme")) continue;
						if (!r$1(i$1)) continue;
						if (!(s$1 instanceof To && ks(s$1.property.specification))) continue;
						const o$1 = jl(i$1, t$1.type), a$1 = s$1.value, l$1 = s$1.property.specification.type, u$1 = !!s$1.property.useIntegerZoom, c$1 = "line-dasharray" === i$1 || i$1.endsWith("pattern"), h$1 = t$1.paint.get(`${i$1}-use-theme`), p$1 = "line-dasharray" === i$1 && "constant" !== t$1.layout.get("line-cap").value.kind || h$1 && "constant" !== h$1.value.kind;
						if ("constant" !== a$1.kind || p$1) if ("source" === a$1.kind || p$1 || c$1) {
							const e$2 = ql(i$1, l$1, "source");
							this.binders[i$1] = c$1 ? new Ll(a$1, o$1, l$1, e$2, t$1.id) : new Dl(a$1, o$1, l$1, e$2), n$1.push(`/a_${i$1}`);
						} else {
							const t$2 = ql(i$1, l$1, "composite");
							this.binders[i$1] = new Rl(a$1, o$1, l$1, u$1, e$1, t$2), n$1.push(`/z_${i$1}`);
						}
						else this.binders[i$1] = c$1 ? new Cl(a$1.value, o$1) : new Fl(a$1.value, o$1, l$1, e$1), n$1.push(`/u_${i$1}`);
						h$1 && (this.binders[i$1].lutExpression = h$1.value);
					}
					this.cacheKey = n$1.sort().join("");
				}
				getMaxValue(t$1) {
					const e$1 = this.binders[t$1];
					return e$1 instanceof Dl || e$1 instanceof Rl ? e$1.maxValue : 0;
				}
				populatePaintArrays(t$1, e$1, r$1, n$1, i$1, s$1, o$1, a$1) {
					for (const l$1 in this.binders) {
						const u$1 = this.binders[l$1];
						u$1.context = this.context, (u$1 instanceof Dl || u$1 instanceof Rl || u$1 instanceof Ll) && u$1.populatePaintArray(t$1, e$1, r$1, n$1, i$1, s$1, o$1, a$1);
					}
				}
				setConstantPatternPositions(t$1, e$1) {
					for (const r$1 in this.binders) {
						const n$1 = this.binders[r$1];
						n$1 instanceof Cl && n$1.setConstantPatternPositions(t$1, e$1);
					}
				}
				getPatternTransitionVertexBuffer(t$1) {
					const e$1 = this.binders[t$1];
					return e$1 instanceof Ll ? e$1.paintTransitionVertexBuffer : null;
				}
				updatePaintArrays(t$1, e$1, r$1, n$1, i$1, s$1, o$1, a$1, l$1, u$1) {
					let c$1 = !1;
					const h$1 = Object.keys(t$1), p$1 = 0 !== h$1.length && !a$1, d$1 = p$1 ? h$1 : e$1.uniqueIds;
					this.context.lut = i$1.lut;
					for (const a$2 in this.binders) {
						const h$2 = this.binders[a$2];
						if (h$2.context = this.context, (h$2 instanceof Dl || h$2 instanceof Rl || h$2 instanceof Ll) && h$2.expression && h$2.expression.kind && "constant" !== h$2.expression.kind && (!0 === h$2.expression.isStateDependent || !1 === h$2.expression.isLightConstant)) {
							h$2.expression = i$1.paint.get(a$2).value;
							for (const r$2 of d$1) {
								const i$2 = t$1[r$2.toString()];
								e$1.eachPosition(r$2, ((t$2, e$2, r$3) => {
									const a$3 = n$1.feature(t$2);
									h$2.updatePaintArray(e$2, r$3, a$3, i$2, s$1, o$1, l$1, u$1);
								}));
							}
							if (!p$1) for (const e$2 of r$1.uniqueIds) {
								const i$2 = t$1[e$2.toString()];
								r$1.eachPosition(e$2, ((t$2, e$3, r$2) => {
									const a$3 = n$1.feature(t$2);
									h$2.updatePaintArray(e$3, r$2, a$3, i$2, s$1, o$1, l$1, u$1);
								}));
							}
							c$1 = !0;
						}
					}
					return c$1;
				}
				defines() {
					const t$1 = [];
					for (const e$1 in this.binders) {
						const r$1 = this.binders[e$1];
						(r$1 instanceof Fl || r$1 instanceof Cl) && t$1.push(...r$1.uniformNames.map(((t$2) => `#define HAS_UNIFORM_${t$2}`)));
					}
					return t$1;
				}
				getPaintVertexBuffers() {
					return this._buffers;
				}
				getUniforms(t$1) {
					const e$1 = [];
					for (const r$1 in this.binders) {
						const n$1 = this.binders[r$1];
						if (n$1 instanceof Fl || n$1 instanceof Cl || n$1 instanceof Rl) for (const i$1 of n$1.uniformNames) e$1.push({
							name: i$1,
							property: r$1,
							binding: n$1.getBinding(t$1, i$1)
						});
					}
					return e$1;
				}
				setUniforms(t$1, e$1, r$1, n$1, i$1) {
					for (const { name: e$2, property: s$1, binding: o$1 } of r$1) this.binders[s$1].setUniform(t$1, o$1, i$1, n$1.get(s$1), e$2);
				}
				updatePaintBuffers() {
					this._buffers = [];
					for (const t$1 in this.binders) {
						const e$1 = this.binders[t$1];
						(e$1 instanceof Dl || e$1 instanceof Rl || e$1 instanceof Ll) && e$1.paintVertexBuffer && this._buffers.push(e$1.paintVertexBuffer), e$1 instanceof Ll && e$1.paintTransitionVertexBuffer && this._buffers.push(e$1.paintTransitionVertexBuffer);
					}
				}
				upload(t$1) {
					for (const e$1 in this.binders) {
						const r$1 = this.binders[e$1];
						(r$1 instanceof Dl || r$1 instanceof Rl || r$1 instanceof Ll) && r$1.upload(t$1);
					}
					this.updatePaintBuffers();
				}
				destroy() {
					for (const t$1 in this.binders) {
						const e$1 = this.binders[t$1];
						(e$1 instanceof Dl || e$1 instanceof Rl || e$1 instanceof Ll) && e$1.destroy();
					}
				}
			}
			class Ul {
				constructor(t$1, e$1, r$1 = (() => !0)) {
					this.programConfigurations = {};
					for (const n$1 of t$1) this.programConfigurations[n$1.id] = new Ol(n$1, e$1, r$1);
					this.needsUpload = !1, this._featureMap = new yl(), this._featureMapWithoutIds = new yl(), this._bufferOffset = 0, this._idlessCounter = 0;
				}
				populatePaintArrays(t$1, e$1, r$1, n$1, i$1, s$1, o$1, a$1, l$1) {
					for (const r$2 in this.programConfigurations) this.programConfigurations[r$2].populatePaintArrays(t$1, e$1, n$1, i$1, s$1, o$1, a$1, l$1);
					void 0 !== e$1.id ? this._featureMap.add(e$1.id, r$1, this._bufferOffset, t$1) : (this._featureMapWithoutIds.add(this._idlessCounter, r$1, this._bufferOffset, t$1), this._idlessCounter += 1), this._bufferOffset = t$1, this.needsUpload = !0;
				}
				updatePaintArrays(t$1, e$1, r$1, n$1, i$1, s$1, o$1, a$1) {
					for (const l$1 of r$1) this.needsUpload = this.programConfigurations[l$1.id].updatePaintArrays(t$1, this._featureMap, this._featureMapWithoutIds, e$1, l$1, n$1, i$1, s$1, o$1 || 0, a$1) || this.needsUpload;
				}
				get(t$1) {
					return this.programConfigurations[t$1];
				}
				upload(t$1) {
					if (this.needsUpload) {
						for (const e$1 in this.programConfigurations) this.programConfigurations[e$1].upload(t$1);
						this.needsUpload = !1;
					}
				}
				destroy() {
					for (const t$1 in this.programConfigurations) this.programConfigurations[t$1].destroy();
				}
			}
			const Nl = {
				"text-opacity": ["opacity"],
				"icon-opacity": ["opacity"],
				"text-occlusion-opacity": ["occlusion_opacity"],
				"icon-occlusion-opacity": ["occlusion_opacity"],
				"text-color": ["fill_color"],
				"icon-color": ["fill_color"],
				"text-emissive-strength": ["emissive_strength"],
				"icon-emissive-strength": ["emissive_strength"],
				"text-halo-color": ["halo_color"],
				"icon-halo-color": ["halo_color"],
				"text-halo-blur": ["halo_blur"],
				"icon-halo-blur": ["halo_blur"],
				"text-halo-width": ["halo_width"],
				"icon-halo-width": ["halo_width"],
				"symbol-z-offset": ["z_offset"],
				"line-gap-width": ["gapwidth"],
				"line-pattern": [
					"pattern",
					"pixel_ratio",
					"pattern_b"
				],
				"fill-pattern": [
					"pattern",
					"pixel_ratio",
					"pattern_b"
				],
				"fill-extrusion-pattern": [
					"pattern",
					"pixel_ratio",
					"pattern_b"
				],
				"line-dasharray": ["dash"],
				"fill-bridge-guard-rail-color": ["structure_color"],
				"fill-tunnel-structure-color": ["structure_color"]
			};
			function jl(t$1, e$1) {
				return Nl[t$1] || [t$1.replace(`${e$1}-`, "").replace(/-/g, "_")];
			}
			const $l = {
				"line-pattern": {
					source: _a,
					composite: _a
				},
				"fill-pattern": {
					source: _a,
					composite: _a
				},
				"fill-extrusion-pattern": {
					source: _a,
					composite: _a
				},
				"line-dasharray": {
					source: Aa,
					composite: Aa
				}
			}, Gl = {
				color: {
					source: ja,
					composite: Pa
				},
				number: {
					source: ya,
					composite: ja
				}
			};
			function ql(t$1, e$1, r$1) {
				const n$1 = $l[t$1];
				return n$1 && n$1[r$1] || Gl[e$1][r$1];
			}
			Qs(Fl, "ConstantBinder"), Qs(Cl, "PatternConstantBinder"), Qs(Dl, "SourceExpressionBinder"), Qs(Ll, "PatternCompositeBinder"), Qs(Rl, "CompositeExpressionBinder"), Qs(Ol, "ProgramConfiguration", { omit: ["_buffers"] }), Qs(Ul, "ProgramConfigurationSet");
			const Hl = Un / Math.PI / 2, Xl = 5, Zl = 6, Wl = 16383, Yl = 64, Kl = [
				Yl,
				32,
				16
			], Jl = -Hl, Ql = Hl;
			function tu(t$1, e$1, r$1, n$1 = Hl) {
				return r$1 = kt(r$1), [
					t$1 * Math.sin(r$1) * n$1,
					-e$1 * n$1,
					t$1 * Math.cos(r$1) * n$1
				];
			}
			function eu(t$1, e$1, r$1) {
				return tu(Math.cos(kt(t$1)), Math.sin(kt(t$1)), e$1, r$1);
			}
			const ru = 6371008.8, nu = 2 * Math.PI * ru;
			class iu {
				constructor(t$1, e$1) {
					if (isNaN(t$1) || isNaN(e$1)) throw new Error(`Invalid LngLat object: (${t$1}, ${e$1})`);
					if (this.lng = +t$1, this.lat = +e$1, this.lat > 90 || this.lat < -90) throw new Error("Invalid LngLat latitude value: must be between -90 and 90");
				}
				wrap() {
					return new iu(Dt(this.lng, -180, 180), this.lat);
				}
				toArray() {
					return [this.lng, this.lat];
				}
				toString() {
					return `LngLat(${this.lng}, ${this.lat})`;
				}
				distanceTo(t$1) {
					const e$1 = Math.PI / 180, r$1 = this.lat * e$1, n$1 = t$1.lat * e$1, i$1 = Math.sin(r$1) * Math.sin(n$1) + Math.cos(r$1) * Math.cos(n$1) * Math.cos((t$1.lng - this.lng) * e$1);
					return ru * Math.acos(Math.min(i$1, 1));
				}
				toBounds(t$1 = 0) {
					const e$1 = 360 * t$1 / 40075017, r$1 = e$1 / Math.cos(Math.PI / 180 * this.lat);
					return new su({
						lng: this.lng - r$1,
						lat: this.lat - e$1
					}, {
						lng: this.lng + r$1,
						lat: this.lat + e$1
					});
				}
				toEcef(t$1) {
					return eu(this.lat, this.lng, Hl + t$1 * Hl / ru);
				}
				static convert(t$1) {
					if (t$1 instanceof iu) return t$1;
					if (Array.isArray(t$1) && (2 === t$1.length || 3 === t$1.length)) return new iu(Number(t$1[0]), Number(t$1[1]));
					if (!Array.isArray(t$1) && "object" == typeof t$1 && null !== t$1) return new iu(Number("lng" in t$1 ? t$1.lng : t$1.lon), Number(t$1.lat));
					throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]");
				}
			}
			class su {
				constructor(t$1, e$1) {
					t$1 && (e$1 ? this.setSouthWest(t$1).setNorthEast(e$1) : Array.isArray(t$1) && 4 === t$1.length ? this.setSouthWest([t$1[0], t$1[1]]).setNorthEast([t$1[2], t$1[3]]) : this.setSouthWest(t$1[0]).setNorthEast(t$1[1]));
				}
				setNorthEast(t$1) {
					return this._ne = t$1 instanceof iu ? new iu(t$1.lng, t$1.lat) : iu.convert(t$1), this;
				}
				setSouthWest(t$1) {
					return this._sw = t$1 instanceof iu ? new iu(t$1.lng, t$1.lat) : iu.convert(t$1), this;
				}
				extend(t$1) {
					const e$1 = this._sw, r$1 = this._ne;
					let n$1, i$1;
					if (t$1 instanceof iu) n$1 = t$1, i$1 = t$1;
					else {
						if (!(t$1 instanceof su)) return Array.isArray(t$1) ? 4 === t$1.length || t$1.every(Array.isArray) ? this.extend(su.convert(t$1)) : this.extend(iu.convert(t$1)) : "object" == typeof t$1 && null !== t$1 && t$1.hasOwnProperty("lat") && (t$1.hasOwnProperty("lon") || t$1.hasOwnProperty("lng")) ? this.extend(iu.convert(t$1)) : this;
						if (n$1 = t$1._sw, i$1 = t$1._ne, !n$1 || !i$1) return this;
					}
					return e$1 || r$1 ? (e$1.lng = Math.min(n$1.lng, e$1.lng), e$1.lat = Math.min(n$1.lat, e$1.lat), r$1.lng = Math.max(i$1.lng, r$1.lng), r$1.lat = Math.max(i$1.lat, r$1.lat)) : (this._sw = new iu(n$1.lng, n$1.lat), this._ne = new iu(i$1.lng, i$1.lat)), this;
				}
				getCenter() {
					return new iu((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
				}
				getSouthWest() {
					return this._sw;
				}
				getNorthEast() {
					return this._ne;
				}
				getNorthWest() {
					return new iu(this.getWest(), this.getNorth());
				}
				getSouthEast() {
					return new iu(this.getEast(), this.getSouth());
				}
				getWest() {
					return this._sw.lng;
				}
				getSouth() {
					return this._sw.lat;
				}
				getEast() {
					return this._ne.lng;
				}
				getNorth() {
					return this._ne.lat;
				}
				toArray() {
					return [this._sw.toArray(), this._ne.toArray()];
				}
				toString() {
					return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;
				}
				isEmpty() {
					return !(this._sw && this._ne);
				}
				contains(t$1) {
					const { lng: e$1, lat: r$1 } = iu.convert(t$1);
					let n$1 = this._sw.lng <= e$1 && e$1 <= this._ne.lng;
					return this._sw.lng > this._ne.lng && (n$1 = this._sw.lng >= e$1 && e$1 >= this._ne.lng), this._sw.lat <= r$1 && r$1 <= this._ne.lat && n$1;
				}
				static convert(t$1) {
					if (t$1) return t$1 instanceof su ? t$1 : new su(t$1);
				}
			}
			const ou = 0, au = 25.5;
			function lu(t$1) {
				return nu * Math.cos(t$1 * Math.PI / 180);
			}
			function uu(t$1) {
				return (180 + t$1) / 360;
			}
			function cu(t$1) {
				return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t$1 * Math.PI / 360))) / 360;
			}
			function hu(t$1, e$1) {
				return t$1 / lu(e$1);
			}
			function pu(t$1) {
				return 360 * t$1 - 180;
			}
			function du(t$1) {
				return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * t$1) * Math.PI / 180)) - 90;
			}
			function fu(t$1, e$1) {
				return t$1 * lu(du(e$1));
			}
			const mu = 85.051129;
			function yu(t$1) {
				return Math.cos(kt(Ft(t$1, -mu, mu)));
			}
			function gu(t$1, e$1) {
				const r$1 = Ft(e$1, ou, au), n$1 = Math.pow(2, r$1);
				return yu(t$1) * nu / (512 * n$1);
			}
			function xu(t$1) {
				return 1 / Math.cos(t$1 * Math.PI / 180);
			}
			function vu(t$1, e$1 = 0) {
				const r$1 = Math.exp(Math.PI * (1 - (t$1.y + e$1 / Un) / (1 << t$1.z) * 2));
				return 80150034 * r$1 / (r$1 * r$1 + 1) / Un / (1 << t$1.z);
			}
			class bu {
				constructor(t$1, e$1, r$1 = 0) {
					this.x = +t$1, this.y = +e$1, this.z = +r$1;
				}
				static fromLngLat(t$1, e$1 = 0) {
					const r$1 = iu.convert(t$1);
					return new bu(uu(r$1.lng), cu(r$1.lat), hu(e$1, r$1.lat));
				}
				toLngLat() {
					return new iu(pu(this.x), du(this.y));
				}
				toAltitude() {
					return fu(this.z, this.y);
				}
				meterInMercatorCoordinateUnits() {
					return 1 / nu * xu(du(this.y));
				}
			}
			function wu(t$1, e$1, r$1, n$1, i$1, s$1, o$1, a$1, l$1) {
				const u$1 = (e$1 + n$1) / 2, c$1 = (r$1 + i$1) / 2, h$1 = new It(u$1, c$1);
				a$1(h$1), function(t$2, e$2, r$2, n$2, i$2, s$2) {
					const o$2 = r$2 - i$2, a$2 = n$2 - s$2;
					return Math.abs((n$2 - e$2) * o$2 - (r$2 - t$2) * a$2) / Math.hypot(o$2, a$2);
				}(h$1.x, h$1.y, s$1.x, s$1.y, o$1.x, o$1.y) >= l$1 ? (wu(t$1, e$1, r$1, u$1, c$1, s$1, h$1, a$1, l$1), wu(t$1, u$1, c$1, n$1, i$1, h$1, o$1, a$1, l$1)) : t$1.push(o$1);
			}
			function _u(t$1, e$1, r$1) {
				let n$1 = t$1[0], i$1 = n$1.x, s$1 = n$1.y;
				e$1(n$1);
				const o$1 = [n$1];
				for (let a$1 = 1; a$1 < t$1.length; a$1++) {
					const l$1 = t$1[a$1], { x: u$1, y: c$1 } = l$1;
					e$1(l$1), wu(o$1, i$1, s$1, u$1, c$1, n$1, l$1, e$1, r$1), i$1 = u$1, s$1 = c$1, n$1 = l$1;
				}
				return o$1;
			}
			function Au(t$1, e$1, r$1, n$1) {
				if (n$1(e$1, r$1)) {
					const i$1 = e$1.add(r$1)._mult(.5);
					Au(t$1, e$1, i$1, n$1), Au(t$1, i$1, r$1, n$1);
				} else t$1.push(r$1);
			}
			function Iu(t$1, e$1) {
				let r$1 = t$1[0];
				const n$1 = [r$1];
				for (let i$1 = 1; i$1 < t$1.length; i$1++) {
					const s$1 = t$1[i$1];
					Au(n$1, r$1, s$1, e$1), r$1 = s$1;
				}
				return n$1;
			}
			const Mu = Math.pow(2, 14) - 1, Su = -Mu - 1;
			function Pu(t$1, e$1) {
				const r$1 = Math.round(t$1.x * e$1), n$1 = Math.round(t$1.y * e$1);
				return t$1.x = Ft(r$1, Su, Mu), t$1.y = Ft(n$1, Su, Mu), (r$1 < t$1.x || r$1 > t$1.x + 1 || n$1 < t$1.y || n$1 > t$1.y + 1) && Xt("Geometry exceeds allowed extent, reduce your vector tile buffer size"), t$1;
			}
			function ku(t$1, e$1, r$1) {
				const n$1 = t$1.loadGeometry(), i$1 = t$1.extent, s$1 = Un / i$1;
				if (e$1 && r$1 && r$1.projection.isReprojectedInTileSpace) {
					const s$2 = 1 << e$1.z, { scale: o$1, x: a$1, y: l$1, projection: u$1 } = r$1, c$1 = (t$2) => {
						const r$2 = pu((e$1.x + t$2.x / i$1) / s$2), n$2 = du((e$1.y + t$2.y / i$1) / s$2), c$2 = u$1.project(r$2, n$2);
						t$2.x = (c$2.x * o$1 - a$1) * i$1, t$2.y = (c$2.y * o$1 - l$1) * i$1;
					};
					for (let e$2 = 0; e$2 < n$1.length; e$2++) if (1 !== t$1.type) n$1[e$2] = _u(n$1[e$2], c$1, 1);
					else {
						const t$2 = [];
						for (const r$2 of n$1[e$2]) r$2.x < 0 || r$2.x >= i$1 || r$2.y < 0 || r$2.y >= i$1 || (c$1(r$2), t$2.push(r$2));
						n$1[e$2] = t$2;
					}
				}
				for (const t$2 of n$1) for (const e$2 of t$2) Pu(e$2, s$1);
				return n$1;
			}
			function Bu(t$1, e$1) {
				return {
					type: t$1.type,
					id: t$1.id,
					properties: t$1.properties,
					geometry: e$1 ? ku(t$1) : []
				};
			}
			class zu {
				constructor(t$1, e$1, r$1, n$1, i$1) {
					this.properties = {}, this.extent = r$1, this.type = 0, this.id = void 0, this._pbf = t$1, this._geometry = -1, this._keys = n$1, this._values = i$1, t$1.readFields(Tu, this, e$1);
				}
				loadGeometry() {
					const t$1 = this._pbf;
					t$1.pos = this._geometry;
					const e$1 = t$1.readVarint() + t$1.pos, r$1 = [];
					let n$1, i$1 = 1, s$1 = 0, o$1 = 0, a$1 = 0;
					for (; t$1.pos < e$1;) {
						if (s$1 <= 0) {
							const e$2 = t$1.readVarint();
							i$1 = 7 & e$2, s$1 = e$2 >> 3;
						}
						if (s$1--, 1 === i$1 || 2 === i$1) o$1 += t$1.readSVarint(), a$1 += t$1.readSVarint(), 1 === i$1 && (n$1 && r$1.push(n$1), n$1 = []), n$1 && n$1.push(new It(o$1, a$1));
						else {
							if (7 !== i$1) throw new Error(`unknown command ${i$1}`);
							n$1 && n$1.push(n$1[0].clone());
						}
					}
					return n$1 && r$1.push(n$1), r$1;
				}
				bbox() {
					const t$1 = this._pbf;
					t$1.pos = this._geometry;
					const e$1 = t$1.readVarint() + t$1.pos;
					let r$1 = 1, n$1 = 0, i$1 = 0, s$1 = 0, o$1 = Infinity, a$1 = -Infinity, l$1 = Infinity, u$1 = -Infinity;
					for (; t$1.pos < e$1;) {
						if (n$1 <= 0) {
							const e$2 = t$1.readVarint();
							r$1 = 7 & e$2, n$1 = e$2 >> 3;
						}
						if (n$1--, 1 === r$1 || 2 === r$1) i$1 += t$1.readSVarint(), s$1 += t$1.readSVarint(), i$1 < o$1 && (o$1 = i$1), i$1 > a$1 && (a$1 = i$1), s$1 < l$1 && (l$1 = s$1), s$1 > u$1 && (u$1 = s$1);
						else if (7 !== r$1) throw new Error(`unknown command ${r$1}`);
					}
					return [
						o$1,
						l$1,
						a$1,
						u$1
					];
				}
				toGeoJSON(t$1, e$1, r$1) {
					const n$1 = this.extent * Math.pow(2, r$1), i$1 = this.extent * t$1, s$1 = this.extent * e$1, o$1 = this.loadGeometry();
					function a$1(t$2) {
						return [360 * (t$2.x + i$1) / n$1 - 180, 360 / Math.PI * Math.atan(Math.exp((1 - 2 * (t$2.y + s$1) / n$1) * Math.PI)) - 90];
					}
					function l$1(t$2) {
						return t$2.map(a$1);
					}
					let u$1;
					if (1 === this.type) {
						const t$2 = [];
						for (const e$3 of o$1) t$2.push(e$3[0]);
						const e$2 = l$1(t$2);
						u$1 = 1 === t$2.length ? {
							type: "Point",
							coordinates: e$2[0]
						} : {
							type: "MultiPoint",
							coordinates: e$2
						};
					} else if (2 === this.type) {
						const t$2 = o$1.map(l$1);
						u$1 = 1 === t$2.length ? {
							type: "LineString",
							coordinates: t$2[0]
						} : {
							type: "MultiLineString",
							coordinates: t$2
						};
					} else {
						if (3 !== this.type) throw new Error("unknown feature type");
						{
							const t$2 = function(t$3) {
								const e$3 = t$3.length;
								if (e$3 <= 1) return [t$3];
								const r$2 = [];
								let n$2, i$2;
								for (let s$2 = 0; s$2 < e$3; s$2++) {
									const e$4 = Eu(t$3[s$2]);
									0 !== e$4 && (void 0 === i$2 && (i$2 = e$4 < 0), i$2 === e$4 < 0 ? (n$2 && r$2.push(n$2), n$2 = [t$3[s$2]]) : n$2 && n$2.push(t$3[s$2]));
								}
								return n$2 && r$2.push(n$2), r$2;
							}(o$1), e$2 = [];
							for (const r$2 of t$2) e$2.push(r$2.map(l$1));
							u$1 = 1 === e$2.length ? {
								type: "Polygon",
								coordinates: e$2[0]
							} : {
								type: "MultiPolygon",
								coordinates: e$2
							};
						}
					}
					const c$1 = {
						type: "Feature",
						geometry: u$1,
						properties: this.properties
					};
					return null != this.id && (c$1.id = this.id), c$1;
				}
			}
			function Tu(t$1, e$1, r$1) {
				1 === t$1 ? e$1.id = r$1.readVarint() : 2 === t$1 ? function(t$2, e$2) {
					const r$2 = t$2.readVarint() + t$2.pos;
					for (; t$2.pos < r$2;) {
						const r$3 = e$2._keys[t$2.readVarint()], n$1 = e$2._values[t$2.readVarint()];
						e$2.properties[r$3] = n$1;
					}
				}(r$1, e$1) : 3 === t$1 ? e$1.type = r$1.readVarint() : 4 === t$1 && (e$1._geometry = r$1.pos);
			}
			function Eu(t$1) {
				let e$1 = 0;
				for (let r$1, n$1, i$1 = 0, s$1 = t$1.length, o$1 = s$1 - 1; i$1 < s$1; o$1 = i$1++) r$1 = t$1[i$1], n$1 = t$1[o$1], e$1 += (n$1.x - r$1.x) * (r$1.y + n$1.y);
				return e$1;
			}
			zu.types = [
				"Unknown",
				"Point",
				"LineString",
				"Polygon"
			];
			class Vu {
				constructor(t$1, e$1) {
					this.version = 1, this.name = "", this.extent = 4096, this.length = 0, this._pbf = t$1, this._keys = [], this._values = [], this._features = [], t$1.readFields(Fu, this, e$1), this.length = this._features.length;
				}
				feature(t$1) {
					if (t$1 < 0 || t$1 >= this._features.length) throw new Error("feature index out of bounds");
					this._pbf.pos = this._features[t$1];
					const e$1 = this._pbf.readVarint() + this._pbf.pos;
					return new zu(this._pbf, e$1, this.extent, this._keys, this._values);
				}
			}
			function Fu(t$1, e$1, r$1) {
				15 === t$1 ? e$1.version = r$1.readVarint() : 1 === t$1 ? e$1.name = r$1.readString() : 5 === t$1 ? e$1.extent = r$1.readVarint() : 2 === t$1 ? e$1._features.push(r$1.pos) : 3 === t$1 ? e$1._keys.push(r$1.readString()) : 4 === t$1 && e$1._values.push(function(t$2) {
					let e$2 = null;
					const r$2 = t$2.readVarint() + t$2.pos;
					for (; t$2.pos < r$2;) {
						const r$3 = t$2.readVarint() >> 3;
						e$2 = 1 === r$3 ? t$2.readString() : 2 === r$3 ? t$2.readFloat() : 3 === r$3 ? t$2.readDouble() : 4 === r$3 ? t$2.readVarint64() : 5 === r$3 ? t$2.readVarint() : 6 === r$3 ? t$2.readSVarint() : 7 === r$3 ? t$2.readBoolean() : null;
					}
					if (null == e$2) throw new Error("unknown feature value");
					return e$2;
				}(r$1));
			}
			class Cu {
				constructor(t$1, e$1) {
					this.layers = t$1.readFields(Du, {}, e$1);
				}
			}
			function Du(t$1, e$1, r$1) {
				if (3 === t$1) {
					const t$2 = new Vu(r$1, r$1.readVarint() + r$1.pos);
					t$2.length && (e$1[t$2.name] = t$2);
				}
			}
			const Ru = "3d_elevation_id", Lu = "level";
			class Ou {
				constructor() {
					this._valid = !1;
				}
				reset(t$1) {
					return this.feature = t$1, this._valid = !0, this._geometry = t$1.loadGeometry(), 0 !== this._geometry.length && 0 !== this._geometry[0].length || (this._valid = !1), this;
				}
				geometry(t$1, e$1) {
					return this._valid && t$1(e$1(this._geometry)), this;
				}
				require(t$1, e$1, r$1) {
					return this.get(t$1, !0, e$1, r$1);
				}
				optional(t$1, e$1, r$1) {
					return this.get(t$1, !1, e$1, r$1);
				}
				success() {
					return this._valid;
				}
				get(t$1, e$1, r$1, n$1) {
					const i$1 = this.feature.properties.hasOwnProperty(t$1) ? +this.feature.properties[t$1] : void 0;
					return this._valid && void 0 !== i$1 && !Number.isNaN(i$1) ? r$1(n$1 ? n$1(i$1) : i$1) : e$1 && (this._valid = !1), this;
				}
			}
			class Uu {
				constructor(t$1, e$1) {
					this.featureFunc = t$1, this.vertexFunc = e$1;
				}
				parseFeature(t$1, e$1, r$1) {
					return this.featureFunc(t$1, e$1, r$1);
				}
				parseVertex(t$1, e$1, r$1) {
					return this.vertexFunc(t$1, e$1, r$1);
				}
			}
			const Nu = new Uu(((t$1, e$1, r$1) => t$1.reset(e$1).require(Ru, ((t$2) => {
				r$1.id = t$2;
			})).optional("fixed_height_relative", ((t$2) => {
				r$1.constantHeight = t$2;
			}), $u.decodeRelativeHeight).geometry(((t$2) => {
				r$1.bounds = t$2;
			}), xn).success()), ((t$1, e$1, r$1) => t$1.reset(e$1).require(Ru, ((t$2) => {
				r$1.id = t$2;
			})).require("elevation_idx", ((t$2) => {
				r$1.idx = t$2;
			})).require("extent", ((t$2) => {
				r$1.extent = t$2;
			})).require("height_relative", ((t$2) => {
				r$1.height = t$2;
			}), $u.decodeRelativeHeight).geometry(((t$2) => {
				r$1.position = t$2;
			}), $u.getPoint).success())), ju = new Uu(((t$1, e$1, r$1) => t$1.reset(e$1).require(Ru, ((t$2) => {
				r$1.id = t$2;
			})).optional("fixed_height", ((t$2) => {
				r$1.constantHeight = t$2;
			}), $u.decodeMetricHeight).geometry(((t$2) => {
				r$1.bounds = t$2;
			}), xn).success()), ((t$1, e$1, r$1) => t$1.reset(e$1).require(Ru, ((t$2) => {
				r$1.id = t$2;
			})).require("elevation_idx", ((t$2) => {
				r$1.idx = t$2;
			})).require("extent", ((t$2) => {
				r$1.extent = t$2;
			})).require("height", ((t$2) => {
				r$1.height = t$2;
			}), $u.decodeMetricHeight).geometry(((t$2) => {
				r$1.position = t$2;
			}), $u.getPoint).success()));
			class $u {
				static getPoint(t$1) {
					return ct(t$1[0][0].x, t$1[0][0].y);
				}
				static decodeRelativeHeight(t$1) {
					return 1e-4 * t$1 * 5;
				}
				static decodeMetricHeight(t$1) {
					return 1e-4 * t$1;
				}
				static getVersionSchema(t$1) {
					return t$1 ? "1.0.1" === t$1 ? ju : void 0 : Nu;
				}
				static parse(t$1) {
					const e$1 = [], r$1 = [], n$1 = t$1.length, i$1 = new Ou();
					for (let s$1 = 0; s$1 < n$1; s$1++) {
						const n$2 = t$1.feature(s$1), o$1 = n$2.properties.version, a$1 = $u.getVersionSchema(o$1);
						if (void 0 === a$1) {
							Xt(`Unknown elevation feature version number ${o$1 || "(unknown)"}`);
							continue;
						}
						const l$1 = n$2.properties.type;
						if (!l$1) continue;
						const u$1 = zu.types[n$2.type];
						if ("Point" === u$1 && "curve_point" === l$1) {
							const t$2 = {};
							a$1.parseVertex(i$1, n$2, t$2) && e$1.push(t$2);
						} else if ("Polygon" === u$1 && "curve_meta" === l$1) {
							const t$2 = {};
							a$1.parseFeature(i$1, n$2, t$2) && r$1.push(t$2);
						}
					}
					return {
						vertices: e$1,
						features: r$1
					};
				}
			}
			class Gu {
				constructor(t$1, e$1) {
					this.pos = t$1, this.dir = e$1;
				}
				intersectsPlane(t$1, e$1, r$1) {
					const n$1 = gt(e$1, this.dir);
					if (Math.abs(n$1) < 1e-6) return !1;
					const i$1 = ((t$1[0] - this.pos[0]) * e$1[0] + (t$1[1] - this.pos[1]) * e$1[1]) / n$1;
					return r$1[0] = this.pos[0] + this.dir[0] * i$1, r$1[1] = this.pos[1] + this.dir[1] * i$1, !0;
				}
			}
			class qu {
				constructor(t$1, e$1) {
					this.pos = t$1, this.dir = e$1;
				}
				intersectsPlane(t$1, e$1, r$1) {
					const n$1 = O(e$1, this.dir);
					if (Math.abs(n$1) < 1e-6) return !1;
					const i$1 = ((t$1[0] - this.pos[0]) * e$1[0] + (t$1[1] - this.pos[1]) * e$1[1] + (t$1[2] - this.pos[2]) * e$1[2]) / n$1;
					return r$1[0] = this.pos[0] + this.dir[0] * i$1, r$1[1] = this.pos[1] + this.dir[1] * i$1, r$1[2] = this.pos[2] + this.dir[2] * i$1, !0;
				}
				closestPointOnSphere(t$1, r$1, n$1) {
					if (function(t$2, r$2) {
						var n$2 = t$2[0], i$2 = t$2[1], s$2 = t$2[2], o$2 = r$2[0], a$2 = r$2[1], l$2 = r$2[2];
						return Math.abs(n$2 - o$2) <= e * Math.max(1, Math.abs(n$2), Math.abs(o$2)) && Math.abs(i$2 - a$2) <= e * Math.max(1, Math.abs(i$2), Math.abs(a$2)) && Math.abs(s$2 - l$2) <= e * Math.max(1, Math.abs(s$2), Math.abs(l$2));
					}(this.pos, t$1) || 0 === r$1) return n$1[0] = n$1[1] = n$1[2] = 0, !1;
					const [i$1, s$1, o$1] = this.dir, a$1 = this.pos[0] - t$1[0], l$1 = this.pos[1] - t$1[1], u$1 = this.pos[2] - t$1[2], c$1 = i$1 * i$1 + s$1 * s$1 + o$1 * o$1, h$1 = 2 * (a$1 * i$1 + l$1 * s$1 + u$1 * o$1), p$1 = h$1 * h$1 - 4 * c$1 * (a$1 * a$1 + l$1 * l$1 + u$1 * u$1 - r$1 * r$1);
					if (p$1 < 0) {
						const t$2 = Math.max(-h$1 / 2, 0), e$1 = a$1 + i$1 * t$2, c$2 = l$1 + s$1 * t$2, p$2 = u$1 + o$1 * t$2, d$1 = Math.hypot(e$1, c$2, p$2);
						return n$1[0] = e$1 * r$1 / d$1, n$1[1] = c$2 * r$1 / d$1, n$1[2] = p$2 * r$1 / d$1, !1;
					}
					{
						const t$2 = (-h$1 - Math.sqrt(p$1)) / (2 * c$1);
						if (t$2 < 0) {
							const t$3 = Math.hypot(a$1, l$1, u$1);
							return n$1[0] = a$1 * r$1 / t$3, n$1[1] = l$1 * r$1 / t$3, n$1[2] = u$1 * r$1 / t$3, !1;
						}
						return n$1[0] = a$1 + i$1 * t$2, n$1[1] = l$1 + s$1 * t$2, n$1[2] = u$1 + o$1 * t$2, !0;
					}
				}
			}
			class Hu {
				constructor(t$1, e$1, r$1, n$1, i$1) {
					this.TL = t$1, this.TR = e$1, this.BR = r$1, this.BL = n$1, this.horizon = i$1;
				}
				static fromInvProjectionMatrix(t$1, e$1, r$1) {
					const n$1 = [
						-1,
						1,
						1
					], i$1 = [
						1,
						1,
						1
					], s$1 = [
						1,
						-1,
						1
					], o$1 = [
						-1,
						-1,
						1
					];
					return new Hu(j(n$1, n$1, t$1), j(i$1, i$1, t$1), j(s$1, s$1, t$1), j(o$1, o$1, t$1), e$1 / r$1);
				}
			}
			function Xu(t$1, e$1, r$1) {
				let n$1 = Infinity, i$1 = -Infinity;
				const s$1 = [];
				for (const o$1 of t$1) {
					X(s$1, o$1, e$1);
					const t$2 = O(s$1, r$1);
					n$1 = Math.min(n$1, t$2), i$1 = Math.max(i$1, t$2);
				}
				return [n$1, i$1];
			}
			function Zu(t$1, e$1) {
				let r$1 = !0;
				for (let n$1 = 0; n$1 < t$1.planes.length; n$1++) {
					const i$1 = t$1.planes[n$1];
					let s$1 = 0;
					for (let t$2 = 0; t$2 < e$1.length; t$2++) s$1 += +(O(i$1, e$1[t$2]) + i$1[3] >= 0);
					if (0 === s$1) return 0;
					s$1 !== e$1.length && (r$1 = !1);
				}
				return r$1 ? 2 : 1;
			}
			function Wu(t$1, e$1) {
				for (const r$1 of t$1.projections) {
					const n$1 = Xu(e$1, t$1.points[0], r$1.axis);
					if (r$1.projection[1] < n$1[0] || r$1.projection[0] > n$1[1]) return 0;
				}
				return 1;
			}
			function Yu(t$1, e$1) {
				let r$1 = 0;
				const n$1 = [
					0,
					0,
					0,
					0
				];
				for (let o$1 = 0; o$1 < t$1.length; o$1++) n$1[0] = t$1[o$1][0], n$1[1] = t$1[o$1][1], n$1[2] = t$1[o$1][2], n$1[3] = 1, (i$1 = n$1)[0] * (s$1 = e$1)[0] + i$1[1] * s$1[1] + i$1[2] * s$1[2] + i$1[3] * s$1[3] >= 0 && r$1++;
				var i$1, s$1;
				return r$1;
			}
			class Ku {
				constructor(t$1, e$1) {
					this.points = t$1 || new Array(8).fill([
						0,
						0,
						0
					]), this.planes = e$1 || new Array(6).fill([
						0,
						0,
						0,
						0
					]), this.bounds = Ju.fromPoints(this.points), this.projections = [], this.frustumEdges = [
						X([], this.points[2], this.points[3]),
						X([], this.points[0], this.points[3]),
						X([], this.points[4], this.points[0]),
						X([], this.points[5], this.points[1]),
						X([], this.points[6], this.points[2]),
						X([], this.points[7], this.points[3])
					];
					for (const t$2 of this.frustumEdges) {
						const e$2 = [
							0,
							-t$2[2],
							t$2[1]
						], r$1 = [
							t$2[2],
							0,
							-t$2[0]
						];
						this.projections.push({
							axis: e$2,
							projection: Xu(this.points, this.points[0], e$2)
						}), this.projections.push({
							axis: r$1,
							projection: Xu(this.points, this.points[0], r$1)
						});
					}
				}
				static fromInvProjectionMatrix(t$1, e$1, r$1, n$1) {
					const i$1 = Math.pow(2, r$1), s$1 = [
						[
							-1,
							1,
							-1,
							1
						],
						[
							1,
							1,
							-1,
							1
						],
						[
							1,
							-1,
							-1,
							1
						],
						[
							-1,
							-1,
							-1,
							1
						],
						[
							-1,
							1,
							1,
							1
						],
						[
							1,
							1,
							1,
							1
						],
						[
							1,
							-1,
							1,
							1
						],
						[
							-1,
							-1,
							1,
							1
						]
					].map(((r$2) => {
						const s$2 = Q([], r$2, t$1), o$2 = 1 / s$2[3] / e$1 * i$1;
						return (a$2 = s$2)[0] = (l$1 = s$2)[0] * (u$1 = [
							o$2,
							o$2,
							n$1 ? 1 / s$2[3] : o$2,
							o$2
						])[0], a$2[1] = l$1[1] * u$1[1], a$2[2] = l$1[2] * u$1[2], a$2[3] = l$1[3] * u$1[3], a$2;
						var a$2, l$1, u$1;
					})), o$1 = [
						[
							0,
							1,
							2
						],
						[
							6,
							5,
							4
						],
						[
							0,
							3,
							7
						],
						[
							2,
							1,
							5
						],
						[
							3,
							2,
							6
						],
						[
							0,
							4,
							5
						]
					].map(((t$2) => {
						const e$2 = L([], U([], X([], s$1[t$2[0]], s$1[t$2[1]]), X([], s$1[t$2[2]], s$1[t$2[1]]))), r$2 = -O(e$2, s$1[t$2[1]]);
						return e$2.concat(r$2);
					})), a$1 = [];
					for (let t$2 = 0; t$2 < s$1.length; t$2++) a$1.push([
						s$1[t$2][0],
						s$1[t$2][1],
						s$1[t$2][2]
					]);
					return new Ku(a$1, o$1);
				}
				intersectsPrecise(t$1, e$1, r$1) {
					for (let r$2 = 0; r$2 < e$1.length; r$2++) if (!Yu(t$1, e$1[r$2])) return 0;
					for (let e$2 = 0; e$2 < this.planes.length; e$2++) if (!Yu(t$1, this.planes[e$2])) return 0;
					for (const e$2 of r$1) for (const r$2 of this.frustumEdges) {
						const n$1 = U([], e$2, r$2), i$1 = I(n$1);
						if (0 === i$1) continue;
						E(n$1, n$1, 1 / i$1);
						const s$1 = Xu(this.points, this.points[0], n$1), o$1 = Xu(t$1, this.points[0], n$1);
						if (s$1[0] > o$1[1] || o$1[0] > s$1[1]) return 0;
					}
					return 1;
				}
				containsPoint(t$1) {
					for (const e$1 of this.planes) {
						const r$1 = e$1[3];
						if (O([
							e$1[0],
							e$1[1],
							e$1[2]
						], t$1) + r$1 < 0) return !1;
					}
					return !0;
				}
			}
			class Ju {
				static fromPoints(t$1) {
					const e$1 = [
						Infinity,
						Infinity,
						Infinity
					], r$1 = [
						-Infinity,
						-Infinity,
						-Infinity
					];
					for (const n$1 of t$1) z(e$1, e$1, n$1), T(r$1, r$1, n$1);
					return new Ju(e$1, r$1);
				}
				static fromTileIdAndHeight(t$1, e$1, r$1) {
					const n$1 = 1 << t$1.canonical.z, i$1 = t$1.canonical.x, s$1 = t$1.canonical.y;
					return new Ju([
						i$1 / n$1,
						s$1 / n$1,
						e$1
					], [
						(i$1 + 1) / n$1,
						(s$1 + 1) / n$1,
						r$1
					]);
				}
				static applyTransform(t$1, e$1) {
					const r$1 = t$1.getCorners();
					for (let t$2 = 0; t$2 < r$1.length; ++t$2) j(r$1[t$2], r$1[t$2], e$1);
					return Ju.fromPoints(r$1);
				}
				static applyTransformFast(t$1, e$1) {
					const r$1 = [
						e$1[12],
						e$1[13],
						e$1[14]
					], n$1 = [...r$1];
					for (let i$1 = 0; i$1 < 3; i$1++) for (let s$1 = 0; s$1 < 3; s$1++) {
						const o$1 = e$1[4 * s$1 + i$1], a$1 = o$1 * t$1.min[s$1], l$1 = o$1 * t$1.max[s$1];
						r$1[i$1] += Math.min(a$1, l$1), n$1[i$1] += Math.max(a$1, l$1);
					}
					return new Ju(r$1, n$1);
				}
				static projectAabbCorners(t$1, e$1) {
					const r$1 = t$1.getCorners();
					for (let t$2 = 0; t$2 < r$1.length; ++t$2) j(r$1[t$2], r$1[t$2], e$1);
					return r$1;
				}
				constructor(t$1, e$1) {
					this.min = t$1, this.max = e$1, this.center = E([], P([], this.min, this.max), .5);
				}
				quadrant(t$1) {
					const e$1 = [t$1 % 2 == 0, t$1 < 2], r$1 = A(this.min), n$1 = A(this.max);
					for (let t$2 = 0; t$2 < e$1.length; t$2++) r$1[t$2] = e$1[t$2] ? this.min[t$2] : this.center[t$2], n$1[t$2] = e$1[t$2] ? this.center[t$2] : this.max[t$2];
					return n$1[2] = this.max[2], new Ju(r$1, n$1);
				}
				distanceX(t$1) {
					return Math.max(Math.min(this.max[0], t$1[0]), this.min[0]) - t$1[0];
				}
				distanceY(t$1) {
					return Math.max(Math.min(this.max[1], t$1[1]), this.min[1]) - t$1[1];
				}
				distanceZ(t$1) {
					return Math.max(Math.min(this.max[2], t$1[2]), this.min[2]) - t$1[2];
				}
				getCorners() {
					const t$1 = this.min, e$1 = this.max;
					return [
						[
							t$1[0],
							t$1[1],
							t$1[2]
						],
						[
							e$1[0],
							t$1[1],
							t$1[2]
						],
						[
							e$1[0],
							e$1[1],
							t$1[2]
						],
						[
							t$1[0],
							e$1[1],
							t$1[2]
						],
						[
							t$1[0],
							t$1[1],
							e$1[2]
						],
						[
							e$1[0],
							t$1[1],
							e$1[2]
						],
						[
							e$1[0],
							e$1[1],
							e$1[2]
						],
						[
							t$1[0],
							e$1[1],
							e$1[2]
						]
					];
				}
				intersects(t$1) {
					return this.intersectsAabb(t$1.bounds) ? Zu(t$1, this.getCorners()) : 0;
				}
				intersectsFlat(t$1) {
					return this.intersectsAabb(t$1.bounds) ? Zu(t$1, [
						[
							this.min[0],
							this.min[1],
							0
						],
						[
							this.max[0],
							this.min[1],
							0
						],
						[
							this.max[0],
							this.max[1],
							0
						],
						[
							this.min[0],
							this.max[1],
							0
						]
					]) : 0;
				}
				intersectsPrecise(t$1, e$1) {
					return e$1 || this.intersects(t$1) ? Wu(t$1, this.getCorners()) : 0;
				}
				intersectsPreciseFlat(t$1, e$1) {
					return e$1 || this.intersectsFlat(t$1) ? Wu(t$1, [
						[
							this.min[0],
							this.min[1],
							0
						],
						[
							this.max[0],
							this.min[1],
							0
						],
						[
							this.max[0],
							this.max[1],
							0
						],
						[
							this.min[0],
							this.max[1],
							0
						]
					]) : 0;
				}
				intersectsAabb(t$1) {
					for (let e$1 = 0; e$1 < 3; ++e$1) if (this.min[e$1] > t$1.max[e$1] || t$1.min[e$1] > this.max[e$1]) return !1;
					return !0;
				}
				intersectsAabbXY(t$1) {
					return !(this.min[0] > t$1.max[0] || t$1.min[0] > this.max[0] || this.min[1] > t$1.max[1] || t$1.min[1] > this.max[1]);
				}
				encapsulate(t$1) {
					for (let e$1 = 0; e$1 < 3; e$1++) this.min[e$1] = Math.min(this.min[e$1], t$1.min[e$1]), this.max[e$1] = Math.max(this.max[e$1], t$1.max[e$1]);
				}
				encapsulatePoint(t$1) {
					for (let e$1 = 0; e$1 < 3; e$1++) this.min[e$1] = Math.min(this.min[e$1], t$1[e$1]), this.max[e$1] = Math.max(this.max[e$1], t$1[e$1]);
				}
				closestPoint(t$1) {
					return [
						Math.max(Math.min(this.max[0], t$1[0]), this.min[0]),
						Math.max(Math.min(this.max[1], t$1[1]), this.min[1]),
						Math.max(Math.min(this.max[2], t$1[2]), this.min[2])
					];
				}
			}
			Qs(Ju, "Aabb");
			class Qu {
				constructor(t$1, e$1) {
					this.feature = t$1, this.metersToTile = e$1, this.index = 0;
				}
				get() {
					const t$1 = this.feature.vertices[this.index], e$1 = this.feature.vertexProps[this.index].dir, r$1 = e$1[1], n$1 = -e$1[0], i$1 = (t$1.extent + 1) * this.metersToTile;
					return [new It(Math.trunc(t$1.position[0] + r$1 * i$1), Math.trunc(t$1.position[1] + n$1 * i$1)), new It(Math.trunc(t$1.position[0] - r$1 * i$1), Math.trunc(t$1.position[1] - n$1 * i$1))];
				}
				next() {
					this.index++;
				}
				valid() {
					return this.index < this.feature.vertices.length;
				}
			}
			class tc {
				constructor(t$1, e$1, r$1, n$1, i$1, s$1) {
					if (this.vertices = new Array(), this.vertexProps = new Array(), this.edges = new Array(), this.edgeProps = new Array(), this._tmpVec2 = [
						ut(),
						ut(),
						ut(),
						ut(),
						ut(),
						ut(),
						ut()
					], this.id = t$1, this.heightRange = {
						min: r$1,
						max: r$1
					}, this.safeArea = e$1, this.constantHeight = r$1, null == this.constantHeight && (null != this.constantHeight || 0 !== n$1.length)) {
						this.vertices = n$1, this.edges = i$1, this.edges = this.edges.filter(((t$2) => {
							return t$2.a < this.vertices.length && t$2.b < this.vertices.length && !((e$2 = this.vertices[t$2.a].position)[0] === (r$2 = this.vertices[t$2.b].position)[0] && e$2[1] === r$2[1]);
							var e$2, r$2;
						})), this.heightRange = {
							min: Number.POSITIVE_INFINITY,
							max: Number.NEGATIVE_INFINITY
						};
						for (const t$2 of this.vertices) this.vertexProps.push({ dir: ct(0, 0) }), this.heightRange.min = Math.min(this.heightRange.min, t$2.height), this.heightRange.max = Math.max(this.heightRange.max, t$2.height);
						for (const t$2 of this.edges) {
							const e$2 = this.vertices[t$2.a].position, r$2 = this.vertices[t$2.b].position, n$2 = dt(ut(), r$2, e$2), i$2 = mt(n$2), s$2 = ft(ut(), n$2, 1 / i$2);
							this.edgeProps.push({
								vec: n$2,
								dir: s$2,
								len: i$2
							});
							const o$1 = this.vertexProps[t$2.a].dir, a$1 = this.vertexProps[t$2.b].dir;
							pt(o$1, o$1, s$2), pt(a$1, a$1, s$2);
						}
						for (const t$2 of this.vertexProps) 0 === t$2.dir[0] && 0 === t$2.dir[1] || yt(t$2.dir, t$2.dir);
						this.tessellate(s$1);
					}
				}
				pointElevation(t$1) {
					if (null != this.constantHeight) return this.constantHeight;
					const e$1 = this.getClosestEdge(t$1);
					if (null == e$1) return 0;
					const [r$1, n$1] = e$1;
					return pr(this.vertices[this.edges[r$1].a].height, this.vertices[this.edges[r$1].b].height, n$1);
				}
				computeSlopeNormal(t$1, e$1) {
					const r$1 = this.getClosestEdge(t$1);
					if (!r$1) return M(0, 0, 1);
					const n$1 = r$1[0], i$1 = this.edges[n$1], s$1 = this.edgeProps[n$1].vec, o$1 = M(s$1[0], s$1[1], (this.vertices[i$1.b].height - this.vertices[i$1.a].height) * e$1), a$1 = M(o$1[1], -o$1[0], 0);
					U(a$1, a$1, o$1);
					const l$1 = I(a$1);
					return l$1 > 0 ? E(a$1, a$1, 1 / l$1) : S(a$1, 0, 0, 1);
				}
				getSafeArea() {
					return this.safeArea;
				}
				isTunnel() {
					return this.heightRange.max <= -5;
				}
				getClosestEdge(t$1) {
					if (0 === this.edges.length) return;
					let e$1 = 0, r$1 = Number.POSITIVE_INFINITY, n$1 = 0;
					const [i$1, s$1, o$1, a$1, l$1, u$1, c$1] = this._tmpVec2;
					ht(c$1, t$1.x, t$1.y);
					const h$1 = new Gu(c$1, null);
					for (let t$2 = 0; t$2 < this.edges.length; t$2++) {
						const p$1 = this.edges[t$2], d$1 = this.edgeProps[t$2].dir;
						h$1.dir = d$1;
						const f$1 = this.vertices[p$1.a].position, m$1 = this.vertices[p$1.b].position, y$1 = h$1.intersectsPlane(f$1, this.vertexProps[p$1.a].dir, i$1), g$1 = h$1.intersectsPlane(m$1, this.vertexProps[p$1.b].dir, s$1);
						if (!y$1 || !g$1) continue;
						dt(o$1, s$1, i$1), dt(a$1, c$1, i$1);
						const x$1 = gt(o$1, o$1), v$1 = x$1 > 0 ? gt(a$1, o$1) / x$1 : 0, b$1 = Ft(v$1, 0, 1), w$1 = Math.abs((v$1 - b$1) * this.edgeProps[t$2].len);
						dt(l$1, c$1, f$1), ht(u$1, d$1[1], -d$1[0]);
						const _$1 = w$1 + Math.abs(gt(l$1, u$1));
						_$1 < r$1 && (e$1 = t$2, r$1 = _$1, n$1 = b$1);
					}
					return [e$1, n$1];
				}
				tessellate(t$1) {
					const e$1 = _(), r$1 = _(), n$1 = _(), i$1 = _();
					for (let s$1 = this.edges.length - 1; s$1 >= 0; --s$1) {
						const o$1 = this.edges[s$1].a, a$1 = this.edges[s$1].b, { position: l$1, height: u$1, extent: c$1 } = this.vertices[o$1], { position: h$1, height: p$1, extent: d$1 } = this.vertices[a$1], f$1 = this.vertexProps[o$1].dir, m$1 = this.vertexProps[a$1].dir;
						if (S(e$1, l$1[0] / t$1, l$1[1] / t$1, u$1), S(r$1, h$1[0] / t$1, h$1[1] / t$1, p$1), S(n$1, f$1[1], -f$1[0], 0), E(n$1, n$1, c$1), S(i$1, m$1[1], -m$1[0], 0), E(i$1, i$1, d$1), this.distSqLines(M(e$1[0] + .5 * n$1[0], e$1[1] + .5 * n$1[1], e$1[2] + .5 * n$1[2]), M(r$1[0] - .5 * i$1[0], r$1[1] - .5 * i$1[1], r$1[2] - .5 * i$1[2]), M(e$1[0] - .5 * n$1[0], e$1[1] - .5 * n$1[1], e$1[2] - .5 * n$1[2]), M(r$1[0] + .5 * i$1[0], r$1[1] + .5 * i$1[1], r$1[2] + .5 * i$1[2])) <= .0025000000000000005) continue;
						const y$1 = this.vertices.length, g$1 = pt(ut(), l$1, h$1);
						this.vertices.push({
							position: ft(g$1, g$1, .5),
							height: .5 * (u$1 + p$1),
							extent: .5 * (c$1 + d$1)
						});
						const x$1 = pt(ut(), f$1, m$1);
						this.vertexProps.push({ dir: yt(x$1, x$1) }), this.edges.splice(s$1, 1), this.edgeProps.splice(s$1, 1), this.edges.push({
							a: o$1,
							b: y$1
						}), this.edges.push({
							a: y$1,
							b: a$1
						});
						const v$1 = dt(ut(), this.vertices[y$1].position, l$1), b$1 = mt(v$1), w$1 = {
							vec: v$1,
							dir: ft(ut(), v$1, 1 / b$1),
							len: b$1
						};
						this.edgeProps.push(w$1), this.edgeProps.push(w$1);
					}
				}
				distSqLines(t$1, e$1, r$1, n$1) {
					const i$1 = k(_(), e$1, t$1), s$1 = k(_(), n$1, r$1), o$1 = k(_(), t$1, r$1), a$1 = O(i$1, i$1), l$1 = O(i$1, s$1), u$1 = O(i$1, o$1), c$1 = O(s$1, s$1), h$1 = O(s$1, o$1), p$1 = a$1 * c$1 - l$1 * l$1;
					if (0 === p$1) return C(N(i$1, r$1, n$1, O(o$1, s$1) / O(s$1, s$1)), t$1);
					const d$1 = (a$1 * h$1 - l$1 * u$1) / p$1;
					return C(N(i$1, t$1, e$1, (l$1 * h$1 - u$1 * c$1) / p$1), N(s$1, r$1, n$1, d$1));
				}
			}
			class ec {
				static parseFrom(t$1, e$1) {
					const r$1 = $u.parse(t$1);
					if (!r$1) return [];
					let { vertices: n$1, features: i$1 } = r$1;
					const s$1 = 1 / vu(e$1);
					i$1.sort(((t$2, e$2) => t$2.id - e$2.id)), n$1.sort(((t$2, e$2) => t$2.id - e$2.id || t$2.idx - e$2.idx)), n$1 = n$1.filter(((t$2, e$2, r$2) => e$2 === r$2.findIndex(((e$3) => e$3.id === t$2.id && e$3.idx === t$2.idx))));
					const o$1 = new Array();
					let a$1 = 0;
					const l$1 = n$1.length;
					for (const t$2 of i$1) {
						if (t$2.constantHeight) {
							o$1.push(new tc(t$2.id, t$2.bounds, t$2.constantHeight));
							continue;
						}
						for (; a$1 !== l$1 && n$1[a$1].id < t$2.id;) a$1++;
						if (a$1 === l$1 || n$1[a$1].id !== t$2.id) continue;
						const e$2 = new Array(), r$2 = new Array(), i$2 = a$1;
						for (; a$1 !== l$1 && n$1[a$1].id === t$2.id;) {
							const t$3 = n$1[a$1];
							if (e$2.push({
								position: t$3.position,
								height: t$3.height,
								extent: t$3.extent
							}), a$1 !== i$2 && n$1[a$1 - 1].idx === t$3.idx - 1) {
								const t$4 = a$1 - i$2;
								r$2.push({
									a: t$4 - 1,
									b: t$4
								});
							}
							a$1++;
						}
						o$1.push(new tc(t$2.id, t$2.bounds, void 0, e$2, r$2, s$1));
					}
					return o$1;
				}
				static getElevationFeature(t$1, e$1) {
					if (!e$1) return;
					const r$1 = +t$1.properties[Ru];
					return Number.isNaN(r$1) ? void 0 : e$1.find(((t$2) => t$2.id === r$1));
				}
			}
			class rc {
				constructor(t$1, e$1) {
					this.zScale = 1, this.xOffset = 0, this.yOffset = 0, t$1.equals(e$1) || (this.zScale = Math.pow(2, e$1.z - t$1.z), this.xOffset = (t$1.x * this.zScale - e$1.x) * Un, this.yOffset = (t$1.y * this.zScale - e$1.y) * Un);
				}
				constantElevation(t$1, e$1) {
					if (null != t$1.constantHeight) return this.computeBiasedHeight(t$1.constantHeight, e$1);
				}
				pointElevation(t$1, e$1, r$1) {
					const n$1 = this.constantElevation(e$1, r$1);
					return null != n$1 ? n$1 : (t$1.x = t$1.x * this.zScale + this.xOffset, t$1.y = t$1.y * this.zScale + this.yOffset, this.computeBiasedHeight(e$1.pointElevation(t$1), r$1));
				}
				computeBiasedHeight(t$1, e$1) {
					return e$1 <= 0 ? t$1 : t$1 + e$1 * Ct(0, e$1, t$1 >= 0 ? t$1 : Math.abs(.5 * t$1));
				}
			}
			Qs(tc, "ElevationFeature");
			class nc {
				constructor(t$1) {
					this.zoom = t$1.zoom, this.overscaling = t$1.overscaling, this.layers = t$1.layers, this.layerIds = this.layers.map(((t$2) => t$2.fqid)), this.index = t$1.index, this.hasPattern = !1, this.projection = t$1.projection, this.layoutVertexArray = new da(), this.indexArray = new Fa(), this.segments = new hl(), this.programConfigurations = new Ul(t$1.layers, {
						zoom: t$1.zoom,
						lut: t$1.lut
					}), this.stateDependentLayerIds = this.layers.filter(((t$2) => t$2.isStateDependent())).map(((t$2) => t$2.id)), this.elevationMode = this.layers[0].layout.get("circle-elevation-reference"), this.hasElevation = !1, "none" !== this.elevationMode && (this.elevatedLayoutVertexArray = new ya()), this.worldview = t$1.worldview, this.hasAppearances = null;
				}
				updateFootprints(t$1, e$1) {}
				updateAppearances(t$1, e$1, r$1, n$1) {}
				populate(t$1, e$1, r$1, n$1) {
					const i$1 = this.layers[0], s$1 = [];
					let o$1 = null;
					"circle" === i$1.type && (o$1 = i$1.layout.get("circle-sort-key"));
					for (const { feature: i$2, id: a$2, index: l$1, sourceLayerIndex: u$1 } of t$1) {
						const t$2 = this.layers[0]._featureFilter.needGeometry, c$1 = Bu(i$2, t$2);
						if (!this.layers[0]._featureFilter.filter(new Io(this.zoom, {
							worldview: this.worldview,
							activeFloors: e$1.activeFloors
						}), c$1, r$1)) continue;
						const h$1 = o$1 ? o$1.evaluate(c$1, {}, r$1) : void 0, p$1 = {
							id: a$2,
							properties: i$2.properties,
							type: i$2.type,
							sourceLayerIndex: u$1,
							index: l$1,
							geometry: t$2 ? c$1.geometry : ku(i$2, r$1, n$1),
							patterns: {},
							sortKey: h$1
						};
						s$1.push(p$1);
					}
					o$1 && s$1.sort(((t$2, e$2) => t$2.sortKey - e$2.sortKey));
					let a$1 = null;
					"globe" === n$1.projection.name && (this.globeExtVertexArray = new Ia(), a$1 = n$1.projection);
					for (const n$2 of s$1) {
						const { geometry: i$2, index: s$2, sourceLayerIndex: o$2 } = n$2, l$1 = t$1[s$2].feature;
						this.addFeature(n$2, i$2, s$2, e$1.availableImages, r$1, a$1, e$1.brightness, e$1.elevationFeatures), e$1.featureIndex.insert(l$1, i$2, s$2, o$2, this.index);
					}
					this.hasElevation || (this.elevatedLayoutVertexArray = void 0);
				}
				update(t$1, e$1, r$1, n$1, i$1, s$1, o$1) {
					this.programConfigurations.updatePaintArrays(t$1, e$1, i$1, r$1, n$1, s$1, o$1, this.worldview);
				}
				isEmpty() {
					return 0 === this.layoutVertexArray.length;
				}
				uploadPending() {
					return !this.uploaded || this.programConfigurations.needsUpload;
				}
				upload(t$1) {
					this.uploaded || (this.layoutVertexBuffer = t$1.createVertexBuffer(this.layoutVertexArray, ll.members), this.indexBuffer = t$1.createIndexBuffer(this.indexArray), this.globeExtVertexArray && (this.globeExtVertexBuffer = t$1.createVertexBuffer(this.globeExtVertexArray, cl.members)), this.elevatedLayoutVertexArray && (this.elevatedLayoutVertexBuffer = t$1.createVertexBuffer(this.elevatedLayoutVertexArray, ul.members))), this.programConfigurations.upload(t$1), this.uploaded = !0;
				}
				destroy() {
					this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.globeExtVertexBuffer && this.globeExtVertexBuffer.destroy(), this.elevatedLayoutVertexBuffer && this.elevatedLayoutVertexBuffer.destroy());
				}
				addFeature(t$1, e$1, r$1, n$1, i$1, s$1, o$1, a$1) {
					let l$1;
					"none" !== this.elevationMode && (l$1 = ec.getElevationFeature(t$1, a$1));
					for (const r$2 of e$1) for (const e$2 of r$2) {
						const r$3 = e$2.x, n$2 = e$2.y;
						if (r$3 < 0 || r$3 >= Un || n$2 < 0 || n$2 >= Un) continue;
						if (s$1) {
							const t$2 = s$1.projectTilePoint(r$3, n$2, i$1), e$3 = s$1.upVector(i$1, r$3, n$2);
							this.addGlobeExtVertex(t$2, e$3), this.addGlobeExtVertex(t$2, e$3), this.addGlobeExtVertex(t$2, e$3), this.addGlobeExtVertex(t$2, e$3);
						}
						const o$2 = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray, t$1.sortKey), a$2 = o$2.vertexLength;
						if (this.addCircleVertex(r$3, n$2, -1, -1), this.addCircleVertex(r$3, n$2, 1, -1), this.addCircleVertex(r$3, n$2, 1, 1), this.addCircleVertex(r$3, n$2, -1, 1), "none" !== this.elevationMode) {
							const t$2 = l$1 ? l$1.pointElevation(new It(r$3, n$2)) : 0;
							this.hasElevation = this.hasElevation || 0 !== t$2;
							for (let e$3 = 0; e$3 < 4; e$3++) this.elevatedLayoutVertexArray.emplaceBack(t$2);
						}
						this.indexArray.emplaceBack(a$2, a$2 + 1, a$2 + 2), this.indexArray.emplaceBack(a$2, a$2 + 2, a$2 + 3), o$2.vertexLength += 4, o$2.primitiveLength += 2;
					}
					this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t$1, r$1, {}, n$1, i$1, o$1, void 0, this.worldview);
				}
				addCircleVertex(t$1, e$1, r$1, n$1) {
					this.layoutVertexArray.emplaceBack(2 * t$1 + (r$1 + 1) / 2, 2 * e$1 + (n$1 + 1) / 2);
				}
				addGlobeExtVertex(t$1, e$1) {
					const r$1 = 16384;
					this.globeExtVertexArray.emplaceBack(t$1.x, t$1.y, t$1.z, e$1[0] * r$1, e$1[1] * r$1, e$1[2] * r$1);
				}
			}
			function ic(t$1, e$1) {
				for (let r$1 = 0; r$1 < t$1.length; r$1++) if (mc(e$1, t$1[r$1])) return !0;
				for (let r$1 = 0; r$1 < e$1.length; r$1++) if (mc(t$1, e$1[r$1])) return !0;
				return !!lc(t$1, e$1);
			}
			function sc(t$1, e$1, r$1) {
				return !!mc(t$1, e$1) || !!pc(e$1, t$1, r$1);
			}
			function oc(t$1, e$1) {
				if (1 === t$1.length) return fc(e$1, t$1[0]);
				for (let r$1 = 0; r$1 < e$1.length; r$1++) {
					const n$1 = e$1[r$1];
					for (let e$2 = 0; e$2 < n$1.length; e$2++) if (mc(t$1, n$1[e$2])) return !0;
				}
				for (let r$1 = 0; r$1 < t$1.length; r$1++) if (fc(e$1, t$1[r$1])) return !0;
				for (let r$1 = 0; r$1 < e$1.length; r$1++) if (lc(t$1, e$1[r$1])) return !0;
				return !1;
			}
			function ac(t$1, e$1, r$1) {
				if (t$1.length > 1) {
					if (lc(t$1, e$1)) return !0;
					for (let n$1 = 0; n$1 < e$1.length; n$1++) if (pc(e$1[n$1], t$1, r$1)) return !0;
				}
				for (let n$1 = 0; n$1 < t$1.length; n$1++) if (pc(t$1[n$1], e$1, r$1)) return !0;
				return !1;
			}
			function lc(t$1, e$1) {
				if (0 === t$1.length || 0 === e$1.length) return !1;
				for (let r$1 = 0; r$1 < t$1.length - 1; r$1++) {
					const n$1 = t$1[r$1], i$1 = t$1[r$1 + 1];
					for (let t$2 = 0; t$2 < e$1.length - 1; t$2++) if (uc(n$1, i$1, e$1[t$2], e$1[t$2 + 1])) return !0;
				}
				return !1;
			}
			function uc(t$1, e$1, r$1, n$1) {
				return Zt(t$1, r$1, n$1) !== Zt(e$1, r$1, n$1) && Zt(t$1, e$1, r$1) !== Zt(t$1, e$1, n$1);
			}
			function cc(t$1, e$1, r$1) {
				return (t$1.x - r$1.x) * (e$1.y - r$1.y) - (t$1.y - r$1.y) * (e$1.x - r$1.x);
			}
			function hc(t$1, e$1, r$1, n$1) {
				const i$1 = cc(t$1, e$1, n$1), s$1 = cc(t$1, e$1, r$1);
				if (Math.sign(i$1) === Math.sign(s$1)) return;
				const o$1 = cc(r$1, n$1, t$1), a$1 = o$1 + s$1 - i$1;
				return Math.sign(o$1) !== Math.sign(a$1) ? [o$1 / (o$1 - a$1), s$1 / (s$1 - i$1)] : void 0;
			}
			function pc(t$1, e$1, r$1) {
				const n$1 = r$1 * r$1;
				if (1 === e$1.length) return t$1.distSqr(e$1[0]) < n$1;
				for (let r$2 = 1; r$2 < e$1.length; r$2++) if (dc(t$1, e$1[r$2 - 1], e$1[r$2]) < n$1) return !0;
				return !1;
			}
			function dc(t$1, e$1, r$1) {
				const n$1 = e$1.distSqr(r$1);
				if (0 === n$1) return t$1.distSqr(e$1);
				const i$1 = ((t$1.x - e$1.x) * (r$1.x - e$1.x) + (t$1.y - e$1.y) * (r$1.y - e$1.y)) / n$1;
				return t$1.distSqr(i$1 < 0 ? e$1 : i$1 > 1 ? r$1 : r$1.sub(e$1)._mult(i$1)._add(e$1));
			}
			function fc(t$1, e$1) {
				let r$1, n$1, i$1, s$1 = !1;
				for (let o$1 = 0; o$1 < t$1.length; o$1++) {
					r$1 = t$1[o$1];
					for (let t$2 = 0, o$2 = r$1.length - 1; t$2 < r$1.length; o$2 = t$2++) n$1 = r$1[t$2], i$1 = r$1[o$2], n$1.y > e$1.y != i$1.y > e$1.y && e$1.x < (i$1.x - n$1.x) * (e$1.y - n$1.y) / (i$1.y - n$1.y) + n$1.x && (s$1 = !s$1);
				}
				return s$1;
			}
			function mc(t$1, e$1) {
				let r$1 = !1;
				for (let n$1 = 0, i$1 = t$1.length - 1; n$1 < t$1.length; i$1 = n$1++) {
					const s$1 = t$1[n$1], o$1 = t$1[i$1];
					s$1.y > e$1.y != o$1.y > e$1.y && e$1.x < (o$1.x - s$1.x) * (e$1.y - s$1.y) / (o$1.y - s$1.y) + s$1.x && (r$1 = !r$1);
				}
				return r$1;
			}
			function yc(t$1, e$1, r$1, n$1, i$1) {
				for (const s$2 of t$1) if (e$1 <= s$2.x && r$1 <= s$2.y && n$1 >= s$2.x && i$1 >= s$2.y) return !0;
				const s$1 = [
					new It(e$1, r$1),
					new It(e$1, i$1),
					new It(n$1, i$1),
					new It(n$1, r$1)
				];
				if (t$1.length > 2) {
					for (const e$2 of s$1) if (mc(t$1, e$2)) return !0;
				}
				for (let e$2 = 0; e$2 < t$1.length - 1; e$2++) if (gc(t$1[e$2], t$1[e$2 + 1], s$1)) return !0;
				return !1;
			}
			function gc(t$1, e$1, r$1) {
				const n$1 = r$1[0], i$1 = r$1[2];
				if (t$1.x < n$1.x && e$1.x < n$1.x || t$1.x > i$1.x && e$1.x > i$1.x || t$1.y < n$1.y && e$1.y < n$1.y || t$1.y > i$1.y && e$1.y > i$1.y) return !1;
				const s$1 = Zt(t$1, e$1, r$1[0]);
				return s$1 !== Zt(t$1, e$1, r$1[1]) || s$1 !== Zt(t$1, e$1, r$1[2]) || s$1 !== Zt(t$1, e$1, r$1[3]);
			}
			function xc(t$1, e$1, r$1, n$1, i$1, s$1) {
				let o$1 = e$1.y - t$1.y, a$1 = t$1.x - e$1.x;
				if (s$1 = s$1 || 0) {
					const t$2 = o$1 * o$1 + a$1 * a$1;
					if (0 === t$2) return !0;
					const e$2 = Math.sqrt(t$2);
					o$1 /= e$2, a$1 /= e$2;
				}
				return !((r$1.x - t$1.x) * o$1 + (r$1.y - t$1.y) * a$1 - s$1 < 0 || (n$1.x - t$1.x) * o$1 + (n$1.y - t$1.y) * a$1 - s$1 < 0 || (i$1.x - t$1.x) * o$1 + (i$1.y - t$1.y) * a$1 - s$1 < 0);
			}
			function vc(t$1, e$1, r$1, n$1, i$1, s$1, o$1) {
				return !(xc(t$1, e$1, n$1, i$1, s$1, o$1) || xc(e$1, r$1, n$1, i$1, s$1, o$1) || xc(r$1, t$1, n$1, i$1, s$1, o$1) || xc(n$1, i$1, t$1, e$1, r$1, o$1) || xc(i$1, s$1, t$1, e$1, r$1, o$1) || xc(s$1, n$1, t$1, e$1, r$1, o$1));
			}
			function bc(t$1, e$1, r$1) {
				const n$1 = e$1.paint.get(t$1).value;
				return "constant" === n$1.kind ? n$1.value : r$1.programConfigurations.get(e$1.id).getMaxValue(t$1);
			}
			function wc(t$1) {
				return Math.sqrt(t$1[0] * t$1[0] + t$1[1] * t$1[1]);
			}
			function _c(t$1, e$1, r$1, n$1, i$1) {
				if (!e$1[0] && !e$1[1]) return t$1;
				const s$1 = It.convert(e$1)._mult(i$1);
				"viewport" === r$1 && s$1._rotate(-n$1);
				const o$1 = [];
				for (let e$2 = 0; e$2 < t$1.length; e$2++) o$1.push(t$1[e$2].sub(s$1));
				return o$1;
			}
			function Ac(t$1, e$1, r$1, n$1) {
				const i$1 = It.convert(t$1)._mult(n$1);
				return "viewport" === e$1 && i$1._rotate(-r$1), i$1;
			}
			let Ic, Mc;
			function Sc(t$1, e$1, r$1) {
				var n$1 = 2 * Math.PI * 6378137 / 256 / Math.pow(2, r$1);
				return [t$1 * n$1 - 2 * Math.PI * 6378137 / 2, e$1 * n$1 - 2 * Math.PI * 6378137 / 2];
			}
			Qs(nc, "CircleBucket", { omit: ["layers"] });
			class Pc {
				constructor(t$1, e$1, r$1) {
					this.z = t$1, this.x = e$1, this.y = r$1, this.key = zc(0, t$1, t$1, e$1, r$1);
				}
				equals(t$1) {
					return this.z === t$1.z && this.x === t$1.x && this.y === t$1.y;
				}
				isChildOf(t$1) {
					const e$1 = this.z - t$1.z;
					return 0 === t$1.z || t$1.z < this.z && t$1.x === this.x >> e$1 && t$1.y === this.y >> e$1;
				}
				url(t$1, e$1) {
					const r$1 = function(t$2, e$2, r$2) {
						var n$2 = Sc(256 * t$2, 256 * (e$2 = Math.pow(2, r$2) - e$2 - 1), r$2), i$1 = Sc(256 * (t$2 + 1), 256 * (e$2 + 1), r$2);
						return n$2[0] + "," + n$2[1] + "," + i$1[0] + "," + i$1[1];
					}(this.x, this.y, this.z), n$1 = function(t$2, e$2, r$2) {
						let n$2, i$1 = "";
						for (let s$1 = t$2; s$1 > 0; s$1--) n$2 = 1 << s$1 - 1, i$1 += (e$2 & n$2 ? 1 : 0) + (r$2 & n$2 ? 2 : 0);
						return i$1;
					}(this.z, this.x, this.y);
					return t$1[(this.x + this.y) % t$1.length].replace("{prefix}", (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String("tms" === e$1 ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace("{quadkey}", n$1).replace("{bbox-epsg-3857}", r$1);
				}
				toString() {
					return `${this.z}/${this.x}/${this.y}`;
				}
			}
			class kc {
				constructor(t$1, e$1) {
					this.wrap = t$1, this.canonical = e$1, this.key = zc(t$1, e$1.z, e$1.z, e$1.x, e$1.y);
				}
			}
			class Bc {
				constructor(t$1, e$1, r$1, n$1, i$1) {
					this.overscaledZ = t$1, this.wrap = e$1, this.canonical = new Pc(r$1, +n$1, +i$1), this.key = 0 === e$1 && t$1 === r$1 ? this.canonical.key : zc(e$1, t$1, r$1, n$1, i$1);
				}
				equals(t$1) {
					return this.overscaledZ === t$1.overscaledZ && this.wrap === t$1.wrap && this.canonical.equals(t$1.canonical);
				}
				scaledTo(t$1) {
					const e$1 = this.canonical.z - t$1;
					return t$1 > this.canonical.z ? new Bc(t$1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new Bc(t$1, this.wrap, t$1, this.canonical.x >> e$1, this.canonical.y >> e$1);
				}
				calculateScaledKey(t$1, e$1 = !0) {
					if (this.overscaledZ === t$1 && e$1) return this.key;
					if (t$1 > this.canonical.z) return zc(this.wrap * +e$1, t$1, this.canonical.z, this.canonical.x, this.canonical.y);
					{
						const r$1 = this.canonical.z - t$1;
						return zc(this.wrap * +e$1, t$1, t$1, this.canonical.x >> r$1, this.canonical.y >> r$1);
					}
				}
				isChildOf(t$1) {
					if (t$1.wrap !== this.wrap) return !1;
					const e$1 = this.canonical.z - t$1.canonical.z;
					return 0 === t$1.overscaledZ || t$1.overscaledZ < this.overscaledZ && t$1.canonical.z < this.canonical.z && t$1.canonical.x === this.canonical.x >> e$1 && t$1.canonical.y === this.canonical.y >> e$1;
				}
				children(t$1) {
					if (this.overscaledZ >= t$1) return [new Bc(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];
					const e$1 = this.canonical.z + 1, r$1 = 2 * this.canonical.x, n$1 = 2 * this.canonical.y;
					return [
						new Bc(e$1, this.wrap, e$1, r$1, n$1),
						new Bc(e$1, this.wrap, e$1, r$1 + 1, n$1),
						new Bc(e$1, this.wrap, e$1, r$1, n$1 + 1),
						new Bc(e$1, this.wrap, e$1, r$1 + 1, n$1 + 1)
					];
				}
				isLessThan(t$1) {
					return this.wrap < t$1.wrap || !(this.wrap > t$1.wrap) && (this.overscaledZ < t$1.overscaledZ || !(this.overscaledZ > t$1.overscaledZ) && (this.canonical.x < t$1.canonical.x || !(this.canonical.x > t$1.canonical.x) && this.canonical.y < t$1.canonical.y));
				}
				wrapped() {
					return new Bc(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);
				}
				unwrapTo(t$1) {
					return new Bc(this.overscaledZ, t$1, this.canonical.z, this.canonical.x, this.canonical.y);
				}
				overscaleFactor() {
					return Math.pow(2, this.overscaledZ - this.canonical.z);
				}
				toUnwrapped() {
					return new kc(this.wrap, this.canonical);
				}
				toString() {
					return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;
				}
			}
			function zc(t$1, e$1, r$1, n$1, i$1) {
				const s$1 = 1 << Math.min(r$1, 22);
				let o$1 = s$1 * (i$1 % s$1) + n$1 % s$1;
				return t$1 && r$1 < 22 && (o$1 += s$1 * s$1 * ((t$1 < 0 ? -2 * t$1 - 1 : 2 * t$1) % (1 << 2 * (22 - r$1)))), 16 * (32 * o$1 + r$1) + (e$1 - r$1);
			}
			const Tc = [
				(t$1) => {
					let e$1 = t$1.canonical.x - 1, r$1 = t$1.wrap;
					return e$1 < 0 && (e$1 = (1 << t$1.canonical.z) - 1, r$1--), new Bc(t$1.overscaledZ, r$1, t$1.canonical.z, e$1, t$1.canonical.y);
				},
				(t$1) => {
					let e$1 = t$1.canonical.x + 1, r$1 = t$1.wrap;
					return e$1 === 1 << t$1.canonical.z && (e$1 = 0, r$1++), new Bc(t$1.overscaledZ, r$1, t$1.canonical.z, e$1, t$1.canonical.y);
				},
				(t$1) => new Bc(t$1.overscaledZ, t$1.wrap, t$1.canonical.z, t$1.canonical.x, (0 === t$1.canonical.y ? 1 << t$1.canonical.z : t$1.canonical.y) - 1),
				(t$1) => new Bc(t$1.overscaledZ, t$1.wrap, t$1.canonical.z, t$1.canonical.x, t$1.canonical.y === (1 << t$1.canonical.z) - 1 ? 0 : t$1.canonical.y + 1)
			];
			Qs(Pc, "CanonicalTileID"), Qs(Bc, "OverscaledTileID", { omit: ["projMatrix", "expandedProjMatrix"] });
			const { members: Vc } = ha([{
				type: "Float32",
				name: "a_globe_pos",
				components: 3
			}, {
				type: "Float32",
				name: "a_uv",
				components: 2
			}]), Fc = ha([{
				name: "a_pos_3",
				components: 3,
				type: "Int16"
			}]);
			var Cc = ha([{
				name: "a_pos",
				type: "Int16",
				components: 2
			}]);
			function Dc(t$1) {
				return t$1 * Hl / ru;
			}
			const Rc = [
				new Ju([
					Jl,
					Jl,
					Jl
				], [
					Ql,
					Ql,
					Ql
				]),
				new Ju([
					Jl,
					Jl,
					Jl
				], [
					0,
					0,
					Ql
				]),
				new Ju([
					0,
					Jl,
					Jl
				], [
					Ql,
					0,
					Ql
				]),
				new Ju([
					Jl,
					0,
					Jl
				], [
					0,
					Ql,
					Ql
				]),
				new Ju([
					0,
					0,
					Jl
				], [
					Ql,
					Ql,
					Ql
				])
			];
			function Lc(t$1, e$1, r$1, n$1 = !0) {
				const i$1 = E([], t$1._camera.position, t$1.worldSize), s$1 = [
					e$1,
					r$1,
					1,
					1
				];
				Q(s$1, s$1, t$1.pixelMatrixInverse), K(s$1, s$1, 1 / s$1[3]);
				const o$1 = L([], X([], s$1, i$1)), a$1 = t$1.globeMatrix, l$1 = [
					a$1[12],
					a$1[13],
					a$1[14]
				], u$1 = X([], l$1, i$1), c$1 = I(u$1), h$1 = L([], u$1), p$1 = t$1.worldSize / (2 * Math.PI), d$1 = O(h$1, o$1), f$1 = Math.asin(p$1 / c$1);
				if (f$1 < Math.acos(d$1)) {
					if (!n$1) return null;
					const t$2 = [], e$2 = [];
					E(t$2, o$1, c$1 / d$1), L(e$2, X(e$2, t$2, u$1)), L(o$1, P(o$1, u$1, E(o$1, e$2, Math.tan(f$1) * c$1)));
				}
				const m$1 = [];
				new qu(i$1, o$1).closestPointOnSphere(l$1, p$1, m$1);
				const y$1 = L([], te(a$1, 0)), g$1 = L([], te(a$1, 1)), x$1 = L([], te(a$1, 2)), v$1 = O(y$1, m$1), b$1 = O(g$1, m$1), w$1 = O(x$1, m$1), _$1 = Bt(Math.asin(-b$1 / p$1));
				let A$1 = Bt(Math.atan2(v$1, w$1));
				A$1 = t$1.center.lng + function(t$2, e$2) {
					const r$2 = (e$2 - t$2 + 180) % 360 - 180;
					return r$2 < -180 ? r$2 + 360 : r$2;
				}(t$1.center.lng, A$1);
				return new bu(uu(A$1), Ft(cu(_$1), 0, 1));
			}
			class Oc {
				constructor(t$1, e$1, r$1) {
					this.a = X([], t$1, r$1), this.b = X([], e$1, r$1), this.center = r$1;
					const n$1 = L([], this.a), i$1 = L([], this.b);
					this.angle = Math.acos(O(n$1, i$1));
				}
			}
			function Uc(t$1, e$1) {
				if (0 === t$1.angle) return null;
				let r$1;
				return r$1 = 0 === t$1.a[e$1] ? 1 / t$1.angle * .5 * Math.PI : 1 / t$1.angle * Math.atan(t$1.b[e$1] / t$1.a[e$1] / Math.sin(t$1.angle) - 1 / Math.tan(t$1.angle)), r$1 < 0 || r$1 > 1 ? null : function(t$2, e$2, r$2, n$1) {
					const i$1 = Math.sin(r$2);
					return t$2 * (Math.sin((1 - n$1) * r$2) / i$1) + e$2 * (Math.sin(n$1 * r$2) / i$1);
				}(t$1.a[e$1], t$1.b[e$1], t$1.angle, Ft(r$1, 0, 1)) + t$1.center[e$1];
			}
			function Nc(t$1) {
				if (t$1.z <= 1) return Rc[t$1.z + 2 * t$1.y + t$1.x];
				const e$1 = Hc(qc(t$1));
				return Ju.fromPoints(e$1);
			}
			function jc(t$1, e$1, r$1) {
				return E(t$1, t$1, 1 - r$1), V(t$1, t$1, e$1, r$1);
			}
			function $c(t$1, e$1, r$1) {
				for (const n$1 of t$1) j(n$1, n$1, e$1), E(n$1, n$1, r$1);
			}
			function Gc(t$1, e$1, r$1, n$1) {
				const i$1 = e$1 / t$1.worldSize, s$1 = t$1.globeMatrix;
				if (r$1.z <= 1) {
					const t$2 = Nc(r$1).getCorners();
					return $c(t$2, s$1, i$1), Ju.fromPoints(t$2);
				}
				const o$1 = qc(r$1, n$1), a$1 = Hc(o$1, Hl + Dc(t$1._tileCoverLift));
				$c(a$1, s$1, i$1);
				const l$1 = Number.MAX_VALUE, u$1 = [
					-l$1,
					-l$1,
					-l$1
				], c$1 = [
					l$1,
					l$1,
					l$1
				];
				if (o$1.contains(t$1.center)) {
					for (const t$2 of a$1) z(c$1, c$1, t$2), T(u$1, u$1, t$2);
					u$1[2] = 0;
					const e$2 = t$1.point, r$2 = [
						e$2.x * i$1,
						e$2.y * i$1,
						0
					];
					return z(c$1, c$1, r$2), T(u$1, u$1, r$2), new Ju(c$1, u$1);
				}
				if (t$1._tileCoverLift > 0) {
					for (const t$2 of a$1) z(c$1, c$1, t$2), T(u$1, u$1, t$2);
					return new Ju(c$1, u$1);
				}
				const h$1 = [
					s$1[12] * i$1,
					s$1[13] * i$1,
					s$1[14] * i$1
				], p$1 = o$1.getCenter(), d$1 = Ft(t$1.center.lat, -mu, mu), f$1 = Ft(p$1.lat, -mu, mu), m$1 = uu(t$1.center.lng), y$1 = cu(d$1);
				let g$1 = m$1 - uu(p$1.lng);
				const x$1 = y$1 - cu(f$1);
				g$1 > .5 ? g$1 -= 1 : g$1 < -.5 && (g$1 += 1);
				let v$1 = 0;
				Math.abs(g$1) > Math.abs(x$1) ? v$1 = g$1 >= 0 ? 1 : 3 : (v$1 = x$1 >= 0 ? 0 : 2, V(h$1, h$1, [
					s$1[4] * i$1,
					s$1[5] * i$1,
					s$1[6] * i$1
				], -Math.sin(kt(x$1 >= 0 ? o$1.getSouth() : o$1.getNorth())) * Hl));
				const b$1 = a$1[v$1], w$1 = a$1[(v$1 + 1) % 4], _$1 = new Oc(b$1, w$1, h$1), A$1 = [
					Uc(_$1, 0) || b$1[0],
					Uc(_$1, 1) || b$1[1],
					Uc(_$1, 2) || b$1[2]
				], I$1 = eh(t$1.zoom);
				if (I$1 > 0) {
					const n$2 = function({ x: t$2, y: e$2, z: r$2 }, n$3, i$3, s$2, o$2) {
						const a$2 = 1 / (1 << r$2);
						let l$2 = t$2 * a$2, u$2 = l$2 + a$2, c$2 = e$2 * a$2, h$2 = c$2 + a$2, p$2 = 0;
						const d$2 = (l$2 + u$2) / 2 - s$2;
						return d$2 > .5 ? p$2 = -1 : d$2 < -.5 && (p$2 = 1), l$2 = ((l$2 + p$2) * n$3 - (s$2 *= n$3)) * i$3 + s$2, u$2 = ((u$2 + p$2) * n$3 - s$2) * i$3 + s$2, c$2 = (c$2 * n$3 - (o$2 *= n$3)) * i$3 + o$2, h$2 = (h$2 * n$3 - o$2) * i$3 + o$2, [
							[
								l$2,
								h$2,
								0
							],
							[
								u$2,
								h$2,
								0
							],
							[
								u$2,
								c$2,
								0
							],
							[
								l$2,
								c$2,
								0
							]
						];
					}(r$1, e$1, t$1._pixelsPerMercatorPixel, m$1, y$1);
					for (let t$2 = 0; t$2 < a$1.length; t$2++) jc(a$1[t$2], n$2[t$2], I$1);
					const i$2 = P([], n$2[v$1], n$2[(v$1 + 1) % 4]);
					E(i$2, i$2, .5), jc(A$1, i$2, I$1);
				}
				for (const t$2 of a$1) z(c$1, c$1, t$2), T(u$1, u$1, t$2);
				return c$1[2] = Math.min(b$1[2], w$1[2]), z(c$1, c$1, A$1), T(u$1, u$1, A$1), new Ju(c$1, u$1);
			}
			function qc({ x: t$1, y: e$1, z: r$1 }, n$1 = !1) {
				const i$1 = 1 / (1 << r$1);
				return new su(new iu(pu(t$1 * i$1), e$1 === (1 << r$1) - 1 && n$1 ? -90 : du((e$1 + 1) * i$1)), new iu(pu((t$1 + 1) * i$1), 0 === e$1 && n$1 ? 90 : du(e$1 * i$1)));
			}
			function Hc(t$1, e$1 = Hl) {
				const r$1 = kt(t$1.getNorth()), n$1 = kt(t$1.getSouth()), i$1 = Math.cos(r$1), s$1 = Math.cos(n$1), o$1 = Math.sin(r$1), a$1 = Math.sin(n$1), l$1 = t$1.getWest(), u$1 = t$1.getEast();
				return [
					tu(s$1, a$1, l$1, e$1),
					tu(s$1, a$1, u$1, e$1),
					tu(i$1, o$1, u$1, e$1),
					tu(i$1, o$1, l$1, e$1)
				];
			}
			function Xc(t$1, e$1, r$1, n$1) {
				const i$1 = 1 << r$1.z, s$1 = (t$1 / Un + r$1.x) / i$1;
				return eu(du((e$1 / Un + r$1.y) / i$1), pu(s$1), n$1);
			}
			function Zc({ min: t$1, max: e$1 }) {
				return Wl / Math.max(e$1[0] - t$1[0], e$1[1] - t$1[1], e$1[2] - t$1[2]);
			}
			const Wc = new Float64Array(16);
			function Yc(t$1) {
				const e$1 = Zc(t$1), r$1 = g(Wc, [
					e$1,
					e$1,
					e$1
				]);
				return p(r$1, r$1, R([], t$1.min));
			}
			function Kc(t$1) {
				const e$1 = (n$1 = t$1.min, (r$1 = Wc)[0] = 1, r$1[1] = 0, r$1[2] = 0, r$1[3] = 0, r$1[4] = 0, r$1[5] = 1, r$1[6] = 0, r$1[7] = 0, r$1[8] = 0, r$1[9] = 0, r$1[10] = 1, r$1[11] = 0, r$1[12] = n$1[0], r$1[13] = n$1[1], r$1[14] = n$1[2], r$1[15] = 1, r$1);
				var r$1, n$1;
				const i$1 = 1 / Zc(t$1);
				return d(e$1, e$1, [
					i$1,
					i$1,
					i$1
				]);
			}
			function Jc(t$1) {
				const e$1 = Un / (2 * Math.PI);
				return t$1 / (2 * Math.PI) / e$1;
			}
			function Qc(t$1, e$1) {
				return Un / (512 * Math.pow(2, t$1)) * Zc(Nc(e$1));
			}
			function th(t$1, e$1, r$1, n$1, i$1) {
				const s$1 = Jc(r$1), o$1 = [
					t$1,
					e$1,
					-r$1 / (2 * Math.PI)
				], a$1 = u(new Float64Array(16));
				return p(a$1, a$1, o$1), d(a$1, a$1, [
					s$1,
					s$1,
					s$1
				]), f(a$1, a$1, kt(-i$1)), m(a$1, a$1, kt(-n$1)), a$1;
			}
			function eh(t$1) {
				return Ct(Xl, Zl, t$1);
			}
			function rh(t$1, e$1) {
				const r$1 = eu(e$1.lat, e$1.lng);
				return o$1 = (i$1 = k([], function(t$2) {
					const e$2 = eu(t$2._center.lat, t$2._center.lng);
					let r$2 = U([], M(0, 1, 0), e$2);
					const n$1 = x([], -t$2.angle, e$2);
					r$2 = j(r$2, r$2, n$1), x(n$1, -t$2._pitch, r$2);
					const i$2 = L([], e$2);
					return E(i$2, i$2, Dc(t$2.cameraToCenterDistance / t$2.pixelsPerMeter)), j(i$2, i$2, n$1), P([], e$2, i$2);
				}(t$1), r$1))[0], a$1 = i$1[1], l$1 = i$1[2], u$1 = (s$1 = r$1)[0], c$1 = s$1[1], h$1 = s$1[2], d$1 = (p$1 = Math.sqrt((o$1 * o$1 + a$1 * a$1 + l$1 * l$1) * (u$1 * u$1 + c$1 * c$1 + h$1 * h$1))) && O(i$1, s$1) / p$1, Math.acos(Math.min(Math.max(d$1, -1), 1));
				var i$1, s$1, o$1, a$1, l$1, u$1, c$1, h$1, p$1, d$1;
			}
			function nh(t$1, e$1) {
				return rh(t$1, e$1) > Math.PI / 2 * 1.01;
			}
			const ih = kt(85), sh = Math.cos(ih), oh = Math.sin(ih), ah = a(), lh = (t$1) => {
				const e$1 = [];
				return "map" === t$1.paint.get("circle-pitch-alignment") && e$1.push("PITCH_WITH_MAP"), "map" === t$1.paint.get("circle-pitch-scale") && e$1.push("SCALE_WITH_MAP"), e$1;
			};
			function uh(t$1, e$1, r$1, n$1, i$1, s$1, o$1, a$1, l$1) {
				if (s$1 && t$1.queryGeometry.isAboveHorizon) return !1;
				s$1 && (l$1 *= t$1.pixelToTileUnitsFactor);
				const u$1 = t$1.tileID.canonical, c$1 = r$1.projection.upVectorScale(u$1, r$1.center.lat, r$1.worldSize).metersToTile;
				for (const h$1 of e$1) for (const e$2 of h$1) {
					const h$2 = e$2.add(a$1), p$1 = i$1 && r$1.elevation ? r$1.elevation.exaggeration() * i$1.getElevationAt(h$2.x, h$2.y, !0) : 0, d$1 = r$1.projection.projectTilePoint(h$2.x, h$2.y, u$1);
					if (p$1 > 0) {
						const t$2 = r$1.projection.upVector(u$1, h$2.x, h$2.y);
						d$1.x += t$2[0] * c$1 * p$1, d$1.y += t$2[1] * c$1 * p$1, d$1.z += t$2[2] * c$1 * p$1;
					}
					const f$1 = s$1 ? h$2 : ch(d$1.x, d$1.y, d$1.z, n$1), m$1 = s$1 ? t$1.tilespaceRays.map(((t$2) => dh(t$2, p$1))) : t$1.queryGeometry.screenGeometry, y$1 = Q([], [
						d$1.x,
						d$1.y,
						d$1.z,
						1
					], n$1);
					if (!o$1 && s$1 ? l$1 *= y$1[3] / r$1.cameraToCenterDistance : o$1 && !s$1 && (l$1 *= r$1.cameraToCenterDistance / y$1[3]), s$1) {
						const t$2 = du((e$2.y / Un + u$1.y) / (1 << u$1.z));
						l$1 /= r$1.projection.pixelsPerMeter(t$2, 1) / hu(1, t$2);
					}
					if (sc(m$1, f$1, l$1)) return !0;
				}
				return !1;
			}
			function ch(t$1, e$1, r$1, n$1) {
				const i$1 = Q([], [
					t$1,
					e$1,
					r$1,
					1
				], n$1);
				return new It(i$1[0] / i$1[3], i$1[1] / i$1[3]);
			}
			const hh = M(0, 0, 0), ph = M(0, 0, 1);
			function dh(t$1, e$1) {
				const r$1 = _();
				return hh[2] = e$1, t$1.intersectsPlane(hh, ph, r$1), new It(r$1[0], r$1[1]);
			}
			class fh extends nc {}
			let mh, yh, gh, xh;
			function vh(t$1, { width: e$1, height: r$1 }, n$1, i$1) {
				if (i$1) {
					if (i$1 instanceof Uint8ClampedArray) i$1 = new Uint8Array(i$1.buffer);
					else if (i$1.length !== e$1 * r$1 * n$1) throw new RangeError("mismatched image size");
				} else i$1 = new Uint8Array(e$1 * r$1 * n$1);
				return t$1.width = e$1, t$1.height = r$1, t$1.data = i$1, t$1;
			}
			function bh(t$1, e$1, r$1) {
				const { width: n$1, height: i$1 } = e$1;
				n$1 === t$1.width && i$1 === t$1.height || (wh(t$1, e$1, {
					x: 0,
					y: 0
				}, {
					x: 0,
					y: 0
				}, {
					width: Math.min(t$1.width, n$1),
					height: Math.min(t$1.height, i$1)
				}, r$1, null), t$1.width = n$1, t$1.height = i$1, t$1.data = e$1.data);
			}
			function wh(t$1, e$1, r$1, n$1, i$1, s$1, o$1, a$1) {
				if (0 === i$1.width || 0 === i$1.height) return e$1;
				if (i$1.width > t$1.width || i$1.height > t$1.height || r$1.x > t$1.width - i$1.width || r$1.y > t$1.height - i$1.height) throw new RangeError("out of range source coordinates for image copy");
				if (i$1.width > e$1.width || i$1.height > e$1.height || n$1.x > e$1.width - i$1.width || n$1.y > e$1.height - i$1.height) throw new RangeError("out of range destination coordinates for image copy");
				const l$1 = t$1.data, u$1 = e$1.data, c$1 = 4 === s$1 && a$1;
				for (let a$2 = 0; a$2 < i$1.height; a$2++) {
					const h$1 = ((r$1.y + a$2) * t$1.width + r$1.x) * s$1, p$1 = ((n$1.y + a$2) * e$1.width + n$1.x) * s$1;
					if (c$1) for (let t$2 = 0; t$2 < i$1.width; t$2++) {
						const e$2 = h$1 + t$2 * s$1 + 3, r$2 = p$1 + t$2 * s$1;
						u$1[r$2 + 0] = 255, u$1[r$2 + 1] = 255, u$1[r$2 + 2] = 255, u$1[r$2 + 3] = l$1[e$2];
					}
					else if (o$1) for (let t$2 = 0; t$2 < i$1.width; t$2++) {
						const e$2 = h$1 + t$2 * s$1, r$2 = p$1 + t$2 * s$1, n$2 = new lr(l$1[e$2 + 0] / 255, l$1[e$2 + 1] / 255, l$1[e$2 + 2] / 255, l$1[e$2 + 3]).toNonPremultipliedRenderColor(o$1).toArray();
						u$1[r$2 + 0] = n$2[0], u$1[r$2 + 1] = n$2[1], u$1[r$2 + 2] = n$2[2], u$1[r$2 + 3] = n$2[3];
					}
					else for (let t$2 = 0; t$2 < i$1.width * s$1; t$2++) u$1[p$1 + t$2] = l$1[h$1 + t$2];
				}
				return e$1;
			}
			Qs(fh, "HeatmapBucket", { omit: ["layers"] });
			class _h {
				constructor(t$1, e$1) {
					vh(this, t$1, 1, e$1);
				}
				resize(t$1) {
					bh(this, new _h(t$1), 1);
				}
				clone() {
					return new _h({
						width: this.width,
						height: this.height
					}, new Uint8Array(this.data));
				}
				static copy(t$1, e$1, r$1, n$1, i$1) {
					wh(t$1, e$1, r$1, n$1, i$1, 1, null);
				}
			}
			class Ah {
				constructor(t$1, e$1) {
					vh(this, t$1, 4, e$1);
				}
				resize(t$1) {
					bh(this, new Ah(t$1), 4);
				}
				replace(t$1, e$1) {
					e$1 ? this.data.set(t$1) : this.data = t$1 instanceof Uint8ClampedArray ? new Uint8Array(t$1.buffer) : t$1;
				}
				clone() {
					return new Ah({
						width: this.width,
						height: this.height
					}, new Uint8Array(this.data));
				}
				static copy(t$1, e$1, r$1, n$1, i$1, s$1, o$1) {
					wh(t$1, e$1, r$1, n$1, i$1, 4, s$1, o$1);
				}
			}
			class Ih {
				constructor(t$1, e$1) {
					this.width = t$1.width, this.height = t$1.height, this.data = e$1 instanceof Uint8Array ? new Float32Array(e$1.buffer) : e$1;
				}
			}
			function Mh(t$1) {
				const e$1 = {}, r$1 = t$1.resolution || 256, n$1 = t$1.clips ? t$1.clips.length : 1, i$1 = t$1.image || new Ah({
					width: r$1,
					height: n$1
				}), s$1 = (r$2, n$2, s$2) => {
					e$1[t$1.evaluationKey] = s$2;
					const o$1 = t$1.expression.evaluate(e$1), a$1 = o$1 ? o$1.toNonPremultipliedRenderColor(null) : null;
					a$1 && (i$1.data[r$2 + n$2 + 0] = Math.floor(255 * a$1.r), i$1.data[r$2 + n$2 + 1] = Math.floor(255 * a$1.g), i$1.data[r$2 + n$2 + 2] = Math.floor(255 * a$1.b), i$1.data[r$2 + n$2 + 3] = Math.floor(255 * a$1.a));
				};
				if (t$1.clips) for (let e$2 = 0, i$2 = 0; e$2 < n$1; ++e$2, i$2 += 4 * r$1) for (let n$2 = 0, o$1 = 0; n$2 < r$1; n$2++, o$1 += 4) {
					const a$1 = n$2 / (r$1 - 1), { start: l$1, end: u$1 } = t$1.clips[e$2];
					s$1(i$2, o$1, l$1 * (1 - a$1) + u$1 * a$1);
				}
				else for (let t$2 = 0, e$2 = 0; t$2 < r$1; t$2++, e$2 += 4) s$1(0, e$2, t$2 / (r$1 - 1));
				return i$1;
			}
			Qs(_h, "AlphaImage"), Qs(Ah, "RGBAImage");
			const Sh = ha([{
				name: "a_pos",
				components: 2,
				type: "Int16"
			}], 4), Ph = ha([{
				name: "a_road_z_offset",
				components: 1,
				type: "Float32"
			}], 4), kh = ha([{
				name: "a_pos",
				components: 2,
				type: "Int16"
			}, {
				name: "a_height",
				components: 1,
				type: "Float32"
			}], 4), Bh = ha([{
				name: "a_pos_normal_3",
				components: 3,
				type: "Int16"
			}], 4);
			function zh(t$1, e$1, r$1 = 2) {
				const n$1 = e$1 && e$1.length, i$1 = n$1 ? e$1[0] * r$1 : t$1.length;
				let s$1 = Th(t$1, 0, i$1, r$1, !0);
				const o$1 = [];
				if (!s$1 || s$1.next === s$1.prev) return o$1;
				let a$1, l$1, u$1;
				if (n$1 && (s$1 = function(t$2, e$2, r$2, n$2) {
					const i$2 = [];
					for (let r$3 = 0, s$2 = e$2.length; r$3 < s$2; r$3++) {
						const o$2 = Th(t$2, e$2[r$3] * n$2, r$3 < s$2 - 1 ? e$2[r$3 + 1] * n$2 : t$2.length, n$2, !1);
						o$2 === o$2.next && (o$2.steiner = !0), i$2.push(jh(o$2));
					}
					i$2.sort(Lh);
					for (let t$3 = 0; t$3 < i$2.length; t$3++) r$2 = Oh(i$2[t$3], r$2);
					return r$2;
				}(t$1, e$1, s$1, r$1)), t$1.length > 80 * r$1) {
					a$1 = t$1[0], l$1 = t$1[1];
					let e$2 = a$1, n$2 = l$1;
					for (let s$2 = r$1; s$2 < i$1; s$2 += r$1) {
						const r$2 = t$1[s$2], i$2 = t$1[s$2 + 1];
						r$2 < a$1 && (a$1 = r$2), i$2 < l$1 && (l$1 = i$2), r$2 > e$2 && (e$2 = r$2), i$2 > n$2 && (n$2 = i$2);
					}
					u$1 = Math.max(e$2 - a$1, n$2 - l$1), u$1 = 0 !== u$1 ? 32767 / u$1 : 0;
				}
				return Vh(s$1, o$1, r$1, a$1, l$1, u$1, 0), o$1;
			}
			function Th(t$1, e$1, r$1, n$1, i$1) {
				let s$1;
				if (i$1 === function(t$2, e$2, r$2, n$2) {
					let i$2 = 0;
					for (let s$2 = e$2, o$1 = r$2 - n$2; s$2 < r$2; s$2 += n$2) i$2 += (t$2[o$1] - t$2[s$2]) * (t$2[s$2 + 1] + t$2[o$1 + 1]), o$1 = s$2;
					return i$2;
				}(t$1, e$1, r$1, n$1) > 0) for (let i$2 = e$1; i$2 < r$1; i$2 += n$1) s$1 = Qh(i$2 / n$1 | 0, t$1[i$2], t$1[i$2 + 1], s$1);
				else for (let i$2 = r$1 - n$1; i$2 >= e$1; i$2 -= n$1) s$1 = Qh(i$2 / n$1 | 0, t$1[i$2], t$1[i$2 + 1], s$1);
				return s$1 && Xh(s$1, s$1.next) && (tp(s$1), s$1 = s$1.next), s$1;
			}
			function Eh(t$1, e$1) {
				if (!t$1) return t$1;
				e$1 || (e$1 = t$1);
				let r$1, n$1 = t$1;
				do
					if (r$1 = !1, n$1.steiner || !Xh(n$1, n$1.next) && 0 !== Hh(n$1.prev, n$1, n$1.next)) n$1 = n$1.next;
					else {
						if (tp(n$1), n$1 = e$1 = n$1.prev, n$1 === n$1.next) break;
						r$1 = !0;
					}
				while (r$1 || n$1 !== e$1);
				return e$1;
			}
			function Vh(t$1, e$1, r$1, n$1, i$1, s$1, o$1) {
				if (!t$1) return;
				!o$1 && s$1 && function(t$2, e$2, r$2, n$2) {
					let i$2 = t$2;
					do
						0 === i$2.z && (i$2.z = Nh(i$2.x, i$2.y, e$2, r$2, n$2)), i$2.prevZ = i$2.prev, i$2.nextZ = i$2.next, i$2 = i$2.next;
					while (i$2 !== t$2);
					i$2.prevZ.nextZ = null, i$2.prevZ = null, function(t$3) {
						let e$3, r$3 = 1;
						do {
							let n$3, i$3 = t$3;
							t$3 = null;
							let s$2 = null;
							for (e$3 = 0; i$3;) {
								e$3++;
								let o$2 = i$3, a$2 = 0;
								for (let t$4 = 0; t$4 < r$3 && (a$2++, o$2 = o$2.nextZ, o$2); t$4++);
								let l$1 = r$3;
								for (; a$2 > 0 || l$1 > 0 && o$2;) 0 !== a$2 && (0 === l$1 || !o$2 || i$3.z <= o$2.z) ? (n$3 = i$3, i$3 = i$3.nextZ, a$2--) : (n$3 = o$2, o$2 = o$2.nextZ, l$1--), s$2 ? s$2.nextZ = n$3 : t$3 = n$3, n$3.prevZ = s$2, s$2 = n$3;
								i$3 = o$2;
							}
							s$2.nextZ = null, r$3 *= 2;
						} while (e$3 > 1);
					}(i$2);
				}(t$1, n$1, i$1, s$1);
				let a$1 = t$1;
				for (; t$1.prev !== t$1.next;) {
					const l$1 = t$1.prev, u$1 = t$1.next;
					if (s$1 ? Ch(t$1, n$1, i$1, s$1) : Fh(t$1)) e$1.push(l$1.i, t$1.i, u$1.i), tp(t$1), t$1 = u$1.next, a$1 = u$1.next;
					else if ((t$1 = u$1) === a$1) {
						o$1 ? 1 === o$1 ? Vh(t$1 = Dh(Eh(t$1), e$1), e$1, r$1, n$1, i$1, s$1, 2) : 2 === o$1 && Rh(t$1, e$1, r$1, n$1, i$1, s$1) : Vh(Eh(t$1), e$1, r$1, n$1, i$1, s$1, 1);
						break;
					}
				}
			}
			function Fh(t$1) {
				const e$1 = t$1.prev, r$1 = t$1, n$1 = t$1.next;
				if (Hh(e$1, r$1, n$1) >= 0) return !1;
				const i$1 = e$1.x, s$1 = r$1.x, o$1 = n$1.x, a$1 = e$1.y, l$1 = r$1.y, u$1 = n$1.y, c$1 = Math.min(i$1, s$1, o$1), h$1 = Math.min(a$1, l$1, u$1), p$1 = Math.max(i$1, s$1, o$1), d$1 = Math.max(a$1, l$1, u$1);
				let f$1 = n$1.next;
				for (; f$1 !== e$1;) {
					if (f$1.x >= c$1 && f$1.x <= p$1 && f$1.y >= h$1 && f$1.y <= d$1 && Gh(i$1, a$1, s$1, l$1, o$1, u$1, f$1.x, f$1.y) && Hh(f$1.prev, f$1, f$1.next) >= 0) return !1;
					f$1 = f$1.next;
				}
				return !0;
			}
			function Ch(t$1, e$1, r$1, n$1) {
				const i$1 = t$1.prev, s$1 = t$1, o$1 = t$1.next;
				if (Hh(i$1, s$1, o$1) >= 0) return !1;
				const a$1 = i$1.x, l$1 = s$1.x, u$1 = o$1.x, c$1 = i$1.y, h$1 = s$1.y, p$1 = o$1.y, d$1 = Math.min(a$1, l$1, u$1), f$1 = Math.min(c$1, h$1, p$1), m$1 = Math.max(a$1, l$1, u$1), y$1 = Math.max(c$1, h$1, p$1), g$1 = Nh(d$1, f$1, e$1, r$1, n$1), x$1 = Nh(m$1, y$1, e$1, r$1, n$1);
				let v$1 = t$1.prevZ, b$1 = t$1.nextZ;
				for (; v$1 && v$1.z >= g$1 && b$1 && b$1.z <= x$1;) {
					if (v$1.x >= d$1 && v$1.x <= m$1 && v$1.y >= f$1 && v$1.y <= y$1 && v$1 !== i$1 && v$1 !== o$1 && Gh(a$1, c$1, l$1, h$1, u$1, p$1, v$1.x, v$1.y) && Hh(v$1.prev, v$1, v$1.next) >= 0) return !1;
					if (v$1 = v$1.prevZ, b$1.x >= d$1 && b$1.x <= m$1 && b$1.y >= f$1 && b$1.y <= y$1 && b$1 !== i$1 && b$1 !== o$1 && Gh(a$1, c$1, l$1, h$1, u$1, p$1, b$1.x, b$1.y) && Hh(b$1.prev, b$1, b$1.next) >= 0) return !1;
					b$1 = b$1.nextZ;
				}
				for (; v$1 && v$1.z >= g$1;) {
					if (v$1.x >= d$1 && v$1.x <= m$1 && v$1.y >= f$1 && v$1.y <= y$1 && v$1 !== i$1 && v$1 !== o$1 && Gh(a$1, c$1, l$1, h$1, u$1, p$1, v$1.x, v$1.y) && Hh(v$1.prev, v$1, v$1.next) >= 0) return !1;
					v$1 = v$1.prevZ;
				}
				for (; b$1 && b$1.z <= x$1;) {
					if (b$1.x >= d$1 && b$1.x <= m$1 && b$1.y >= f$1 && b$1.y <= y$1 && b$1 !== i$1 && b$1 !== o$1 && Gh(a$1, c$1, l$1, h$1, u$1, p$1, b$1.x, b$1.y) && Hh(b$1.prev, b$1, b$1.next) >= 0) return !1;
					b$1 = b$1.nextZ;
				}
				return !0;
			}
			function Dh(t$1, e$1) {
				let r$1 = t$1;
				do {
					const n$1 = r$1.prev, i$1 = r$1.next.next;
					!Xh(n$1, i$1) && Zh(n$1, r$1, r$1.next, i$1) && Kh(n$1, i$1) && Kh(i$1, n$1) && (e$1.push(n$1.i, r$1.i, i$1.i), tp(r$1), tp(r$1.next), r$1 = t$1 = i$1), r$1 = r$1.next;
				} while (r$1 !== t$1);
				return Eh(r$1);
			}
			function Rh(t$1, e$1, r$1, n$1, i$1, s$1) {
				let o$1 = t$1;
				do {
					let t$2 = o$1.next.next;
					for (; t$2 !== o$1.prev;) {
						if (o$1.i !== t$2.i && qh(o$1, t$2)) {
							let a$1 = Jh(o$1, t$2);
							o$1 = Eh(o$1, o$1.next), a$1 = Eh(a$1, a$1.next), Vh(o$1, e$1, r$1, n$1, i$1, s$1, 0), Vh(a$1, e$1, r$1, n$1, i$1, s$1, 0);
							return;
						}
						t$2 = t$2.next;
					}
					o$1 = o$1.next;
				} while (o$1 !== t$1);
			}
			function Lh(t$1, e$1) {
				let r$1 = t$1.x - e$1.x;
				return 0 === r$1 && (r$1 = t$1.y - e$1.y, 0 === r$1) && (r$1 = (t$1.next.y - t$1.y) / (t$1.next.x - t$1.x) - (e$1.next.y - e$1.y) / (e$1.next.x - e$1.x)), r$1;
			}
			function Oh(t$1, e$1) {
				const r$1 = function(t$2, e$2) {
					let r$2 = e$2;
					const n$2 = t$2.x, i$1 = t$2.y;
					let s$1, o$1 = -Infinity;
					if (Xh(t$2, r$2)) return r$2;
					do {
						if (Xh(t$2, r$2.next)) return r$2.next;
						if (i$1 <= r$2.y && i$1 >= r$2.next.y && r$2.next.y !== r$2.y) {
							const t$3 = r$2.x + (i$1 - r$2.y) * (r$2.next.x - r$2.x) / (r$2.next.y - r$2.y);
							if (t$3 <= n$2 && t$3 > o$1 && (o$1 = t$3, s$1 = r$2.x < r$2.next.x ? r$2 : r$2.next, t$3 === n$2)) return s$1;
						}
						r$2 = r$2.next;
					} while (r$2 !== e$2);
					if (!s$1) return null;
					const a$1 = s$1, l$1 = s$1.x, u$1 = s$1.y;
					let c$1 = Infinity;
					r$2 = s$1;
					do {
						if (n$2 >= r$2.x && r$2.x >= l$1 && n$2 !== r$2.x && $h(i$1 < u$1 ? n$2 : o$1, i$1, l$1, u$1, i$1 < u$1 ? o$1 : n$2, i$1, r$2.x, r$2.y)) {
							const e$3 = Math.abs(i$1 - r$2.y) / (n$2 - r$2.x);
							Kh(r$2, t$2) && (e$3 < c$1 || e$3 === c$1 && (r$2.x > s$1.x || r$2.x === s$1.x && Uh(s$1, r$2))) && (s$1 = r$2, c$1 = e$3);
						}
						r$2 = r$2.next;
					} while (r$2 !== a$1);
					return s$1;
				}(t$1, e$1);
				if (!r$1) return e$1;
				const n$1 = Jh(r$1, t$1);
				return Eh(n$1, n$1.next), Eh(r$1, r$1.next);
			}
			function Uh(t$1, e$1) {
				return Hh(t$1.prev, t$1, e$1.prev) < 0 && Hh(e$1.next, t$1, t$1.next) < 0;
			}
			function Nh(t$1, e$1, r$1, n$1, i$1) {
				return (t$1 = 1431655765 & ((t$1 = 858993459 & ((t$1 = 252645135 & ((t$1 = 16711935 & ((t$1 = (t$1 - r$1) * i$1 | 0) | t$1 << 8)) | t$1 << 4)) | t$1 << 2)) | t$1 << 1)) | (e$1 = 1431655765 & ((e$1 = 858993459 & ((e$1 = 252645135 & ((e$1 = 16711935 & ((e$1 = (e$1 - n$1) * i$1 | 0) | e$1 << 8)) | e$1 << 4)) | e$1 << 2)) | e$1 << 1)) << 1;
			}
			function jh(t$1) {
				let e$1 = t$1, r$1 = t$1;
				do
					(e$1.x < r$1.x || e$1.x === r$1.x && e$1.y < r$1.y) && (r$1 = e$1), e$1 = e$1.next;
				while (e$1 !== t$1);
				return r$1;
			}
			function $h(t$1, e$1, r$1, n$1, i$1, s$1, o$1, a$1) {
				return (i$1 - o$1) * (e$1 - a$1) >= (t$1 - o$1) * (s$1 - a$1) && (t$1 - o$1) * (n$1 - a$1) >= (r$1 - o$1) * (e$1 - a$1) && (r$1 - o$1) * (s$1 - a$1) >= (i$1 - o$1) * (n$1 - a$1);
			}
			function Gh(t$1, e$1, r$1, n$1, i$1, s$1, o$1, a$1) {
				return !(t$1 === o$1 && e$1 === a$1) && $h(t$1, e$1, r$1, n$1, i$1, s$1, o$1, a$1);
			}
			function qh(t$1, e$1) {
				return t$1.next.i !== e$1.i && t$1.prev.i !== e$1.i && !function(t$2, e$2) {
					let r$1 = t$2;
					do {
						if (r$1.i !== t$2.i && r$1.next.i !== t$2.i && r$1.i !== e$2.i && r$1.next.i !== e$2.i && Zh(r$1, r$1.next, t$2, e$2)) return !0;
						r$1 = r$1.next;
					} while (r$1 !== t$2);
					return !1;
				}(t$1, e$1) && (Kh(t$1, e$1) && Kh(e$1, t$1) && function(t$2, e$2) {
					let r$1 = t$2, n$1 = !1;
					const i$1 = (t$2.x + e$2.x) / 2, s$1 = (t$2.y + e$2.y) / 2;
					do
						r$1.y > s$1 != r$1.next.y > s$1 && r$1.next.y !== r$1.y && i$1 < (r$1.next.x - r$1.x) * (s$1 - r$1.y) / (r$1.next.y - r$1.y) + r$1.x && (n$1 = !n$1), r$1 = r$1.next;
					while (r$1 !== t$2);
					return n$1;
				}(t$1, e$1) && (Hh(t$1.prev, t$1, e$1.prev) || Hh(t$1, e$1.prev, e$1)) || Xh(t$1, e$1) && Hh(t$1.prev, t$1, t$1.next) > 0 && Hh(e$1.prev, e$1, e$1.next) > 0);
			}
			function Hh(t$1, e$1, r$1) {
				return (e$1.y - t$1.y) * (r$1.x - e$1.x) - (e$1.x - t$1.x) * (r$1.y - e$1.y);
			}
			function Xh(t$1, e$1) {
				return t$1.x === e$1.x && t$1.y === e$1.y;
			}
			function Zh(t$1, e$1, r$1, n$1) {
				const i$1 = Yh(Hh(t$1, e$1, r$1)), s$1 = Yh(Hh(t$1, e$1, n$1)), o$1 = Yh(Hh(r$1, n$1, t$1)), a$1 = Yh(Hh(r$1, n$1, e$1));
				return i$1 !== s$1 && o$1 !== a$1 || !(0 !== i$1 || !Wh(t$1, r$1, e$1)) || !(0 !== s$1 || !Wh(t$1, n$1, e$1)) || !(0 !== o$1 || !Wh(r$1, t$1, n$1)) || !(0 !== a$1 || !Wh(r$1, e$1, n$1));
			}
			function Wh(t$1, e$1, r$1) {
				return e$1.x <= Math.max(t$1.x, r$1.x) && e$1.x >= Math.min(t$1.x, r$1.x) && e$1.y <= Math.max(t$1.y, r$1.y) && e$1.y >= Math.min(t$1.y, r$1.y);
			}
			function Yh(t$1) {
				return t$1 > 0 ? 1 : t$1 < 0 ? -1 : 0;
			}
			function Kh(t$1, e$1) {
				return Hh(t$1.prev, t$1, t$1.next) < 0 ? Hh(t$1, e$1, t$1.next) >= 0 && Hh(t$1, t$1.prev, e$1) >= 0 : Hh(t$1, e$1, t$1.prev) < 0 || Hh(t$1, t$1.next, e$1) < 0;
			}
			function Jh(t$1, e$1) {
				const r$1 = ep(t$1.i, t$1.x, t$1.y), n$1 = ep(e$1.i, e$1.x, e$1.y), i$1 = t$1.next, s$1 = e$1.prev;
				return t$1.next = e$1, e$1.prev = t$1, r$1.next = i$1, i$1.prev = r$1, n$1.next = r$1, r$1.prev = n$1, s$1.next = n$1, n$1.prev = s$1, n$1;
			}
			function Qh(t$1, e$1, r$1, n$1) {
				const i$1 = ep(t$1, e$1, r$1);
				return n$1 ? (i$1.next = n$1.next, i$1.prev = n$1, n$1.next.prev = i$1, n$1.next = i$1) : (i$1.prev = i$1, i$1.next = i$1), i$1;
			}
			function tp(t$1) {
				t$1.next.prev = t$1.prev, t$1.prev.next = t$1.next, t$1.prevZ && (t$1.prevZ.nextZ = t$1.nextZ), t$1.nextZ && (t$1.nextZ.prevZ = t$1.prevZ);
			}
			function ep(t$1, e$1, r$1) {
				return {
					i: t$1,
					x: e$1,
					y: r$1,
					prev: null,
					next: null,
					z: 0,
					prevZ: null,
					nextZ: null,
					steiner: !1
				};
			}
			function rp(t$1, e$1) {
				const r$1 = t$1.length;
				if (r$1 <= 1) return [t$1];
				const n$1 = [];
				let i$1, s$1;
				for (let e$2 = 0; e$2 < r$1; e$2++) {
					const r$2 = Wt(t$1[e$2]);
					0 !== r$2 && (t$1[e$2].area = Math.abs(r$2), void 0 === s$1 && (s$1 = r$2 < 0), s$1 === r$2 < 0 ? (i$1 && n$1.push(i$1), i$1 = [t$1[e$2]]) : i$1.push(t$1[e$2]));
				}
				if (i$1 && n$1.push(i$1), e$1 > 1) for (let t$2 = 0; t$2 < n$1.length; t$2++) n$1[t$2].length <= e$1 || (ln(n$1[t$2], e$1, 1, n$1[t$2].length - 1, np), n$1[t$2] = n$1[t$2].slice(0, e$1));
				return n$1;
			}
			function np(t$1, e$1) {
				return e$1.area - t$1.area;
			}
			function ip(t$1, e$1, r$1 = 1) {
				if (!t$1) return null;
				const n$1 = "string" == typeof t$1 ? Lr.from(t$1).getPrimary() : t$1.getPrimary(), i$1 = "string" == typeof t$1 ? null : t$1.getSecondary();
				for (const t$2 of [n$1, i$1]) {
					if (!t$2) continue;
					const n$2 = t$2.id.toString();
					e$1.has(n$2) || e$1.set(n$2, []), t$2.scaleSelf(r$1), e$1.get(n$2).push(t$2);
				}
				return {
					primary: n$1.toString(),
					secondary: i$1 ? i$1.toString() : null
				};
			}
			function sp(t$1, e$1, r$1, n$1) {
				const i$1 = n$1.patternDependencies;
				let s$1 = !1;
				for (const n$2 of e$1) {
					const e$2 = n$2.paint.get(`${t$1}-pattern`);
					e$2.isConstant() || (s$1 = !0), ip(e$2.constantOr(null), i$1, r$1) && (s$1 = !0);
				}
				return s$1;
			}
			function op(t$1, e$1, r$1, n$1, i$1, s$1) {
				const o$1 = s$1.patternDependencies;
				for (const a$1 of e$1) {
					const e$2 = a$1.paint.get(`${t$1}-pattern`).value;
					if ("constant" !== e$2.kind) {
						let t$2 = e$2.evaluate({ zoom: n$1 }, r$1, {}, s$1.availableImages);
						t$2 = t$2 && t$2.name ? t$2.name : t$2;
						const l$1 = ip(t$2, o$1, i$1);
						if (!l$1) continue;
						const { primary: u$1, secondary: c$1 } = l$1;
						u$1 && (r$1.patterns[a$1.id] = [u$1, c$1].filter(Boolean));
					}
				}
				return r$1;
			}
			class ap {
				constructor() {
					this.polygons = /* @__PURE__ */ new Map();
				}
				add(t$1, ...e$1) {
					const r$1 = this.polygons.get(t$1);
					r$1 ? r$1.push(...e$1) : this.polygons.set(t$1, e$1);
				}
				merge(t$1) {
					for (const [e$1, r$1] of t$1.polygons) this.add(e$1, ...r$1);
				}
			}
			class lp {
				constructor() {
					this.portals = [];
				}
				static isOnBorder(t$1, e$1) {
					return t$1 <= 0 && e$1 <= 0 || t$1 >= Un && e$1 >= Un;
				}
				static evaluate(t$1) {
					if (0 === t$1.length) return new lp();
					let e$1 = [];
					for (const r$2 of t$1) e$1.push(...r$2.portals);
					if (0 === e$1.length) return new lp();
					for (const t$2 of e$1) {
						const e$2 = t$2.va, r$2 = t$2.vb;
						(lp.isOnBorder(e$2.x, r$2.x) || lp.isOnBorder(e$2.y, r$2.y)) && (t$2.type = "border");
					}
					const r$1 = e$1.filter(((t$2) => "unevaluated" !== t$2.type)), n$1 = e$1.filter(((t$2) => "unevaluated" === t$2.type));
					if (0 === n$1.length) return new lp();
					n$1.sort(((t$2, e$2) => t$2.hash === e$2.hash ? t$2.isTunnel === e$2.isTunnel ? 0 : t$2.isTunnel ? -1 : 1 : t$2.hash < e$2.hash ? 1 : -1)), e$1 = r$1.concat(n$1);
					let i$1 = r$1.length, s$1 = i$1, o$1 = i$1;
					do
						if (s$1++, s$1 === e$1.length || e$1[i$1].hash !== e$1[s$1].hash) {
							if (s$1 - i$1 == 2) {
								o$1 < i$1 && (e$1[o$1] = e$1[i$1], e$1[i$1] = null);
								const t$2 = e$1[o$1], r$2 = e$1[s$1 - 1];
								t$2.type = t$2.isTunnel !== r$2.isTunnel ? "tunnel" : "polygon", t$2.connection = {
									a: t$2.connection.a,
									b: r$2.connection.a
								}, o$1++;
							}
							i$1 = s$1;
						}
					while (i$1 !== e$1.length);
					return e$1.splice(o$1), e$1.sort(((t$2, e$2) => t$2.hash < e$2.hash ? 1 : -1)), { portals: e$1 };
				}
			}
			Qs(lp, "ElevationPortalGraph"), Qs(ap, "ElevationPolygons");
			class up {
				constructor(t$1, e$1, r$1) {
					this.outPositions = t$1, this.outNormals = e$1, this.outIndices = r$1, this.vertexLookup = /* @__PURE__ */ new Map();
				}
				addVertex(t$1, e$1, r$1) {
					let n$1 = t$1[2];
					null != r$1 && (n$1 *= r$1);
					const i$1 = `${t$1[0]},${t$1[1]},${t$1[2]},${e$1[0]},${e$1[1]},${e$1[2]}`, s$1 = this.vertexLookup.get(i$1);
					if (null != s$1) return s$1;
					const o$1 = this.outPositions.length;
					this.vertexLookup.set(i$1, o$1);
					const a$1 = Math.trunc(16384 * e$1[0]), l$1 = Math.trunc(16384 * e$1[1]), u$1 = Math.trunc(16384 * e$1[2]);
					return this.outPositions.emplaceBack(t$1[0], t$1[1], n$1), this.outNormals.emplaceBack(a$1, l$1, u$1), o$1;
				}
				addTriangle(t$1, e$1, r$1) {
					this.outIndices.emplaceBack(t$1, e$1, r$1);
				}
				addTriangles(t$1, e$1, r$1) {
					if (0 === t$1.length) return;
					const n$1 = 1 === r$1.length, i$1 = _(), s$1 = _();
					for (let o$1 = 0; o$1 < t$1.length; o$1 += 3) {
						const a$1 = e$1[t$1[o$1 + 0]], l$1 = e$1[t$1[o$1 + 1]], u$1 = e$1[t$1[o$1 + 2]], c$1 = n$1 ? r$1[0] : r$1[t$1[o$1 + 1]], h$1 = n$1 ? r$1[0] : r$1[t$1[o$1 + 2]];
						S(i$1, a$1.x, a$1.y, n$1 ? r$1[0] : r$1[t$1[o$1 + 0]]);
						const p$1 = this.addVertex(i$1, s$1);
						S(i$1, l$1.x, l$1.y, c$1);
						const d$1 = this.addVertex(i$1, s$1);
						S(i$1, u$1.x, u$1.y, h$1);
						const f$1 = this.addVertex(i$1, s$1);
						this.outIndices.emplaceBack(p$1, d$1, f$1);
					}
				}
				addQuad(t$1, e$1, r$1, n$1, i$1, s$1) {
					const o$1 = this.addVertex(t$1, i$1, s$1), a$1 = this.addVertex(e$1, i$1, s$1), l$1 = this.addVertex(r$1, i$1, s$1), u$1 = this.addVertex(n$1, i$1, s$1);
					this.addTriangle(o$1, a$1, l$1), this.addTriangle(l$1, u$1, o$1);
				}
				getVertexCount() {
					return this.outPositions.length;
				}
				clearVertexLookup() {
					this.vertexLookup.clear();
				}
			}
			class cp {
				constructor(t$1, e$1, r$1, n$1) {
					this.unevaluatedPortals = new lp(), this.portalPolygons = new ap(), this.bridgeFeatureSections = [], this.tunnelFeatureSections = [], this.vertexHashLookup = /* @__PURE__ */ new Map(), this.unevalVertices = [], this.unevalHeights = [], this.unevalTriangles = [], this.unevalTunnelTriangles = [], this.unevalEdges = [], this.vertexPositions = new ga(), this.vertexNormals = new xa(), this.indexArray = new Fa(), this.tileToMeters = vu(t$1), this.bridgeProgramConfigurations = new Ul(e$1, {
						zoom: r$1,
						lut: n$1
					}, ((t$2) => "fill-tunnel-structure-color" !== t$2)), this.tunnelProgramConfigurations = new Ul(e$1, {
						zoom: r$1,
						lut: n$1
					}, ((t$2) => "fill-bridge-guard-rail-color" !== t$2));
				}
				addVertices(t$1, e$1) {
					const r$1 = this.unevalVertices.length;
					for (let r$2 = 0; r$2 < t$1.length; r$2++) this.unevalVertices.push(t$1[r$2]), this.unevalHeights.push(e$1[r$2]);
					return r$1;
				}
				addTriangles(t$1, e$1, r$1) {
					const n$1 = r$1 ? this.unevalTunnelTriangles : this.unevalTriangles;
					for (const r$2 of t$1) n$1.push(r$2 + e$1);
				}
				addRenderableRing(t$1, e$1, r$1, n$1, i$1, s$1) {
					const o$1 = [
						new It(i$1.min.x, i$1.min.y),
						new It(i$1.max.x, i$1.min.y),
						new It(i$1.max.x, i$1.max.y),
						new It(i$1.min.x, i$1.max.y)
					];
					for (let a$1 = 0; a$1 < r$1 - 1; a$1++) {
						const r$2 = e$1 + a$1, l$1 = r$2 + 1, u$1 = this.unevalVertices[r$2], c$1 = this.unevalVertices[l$1];
						if (!(u$1.x >= i$1.min.x && u$1.x <= i$1.max.x && u$1.y >= i$1.min.y && u$1.y <= i$1.max.y || c$1.x >= i$1.min.x && c$1.x <= i$1.max.x && c$1.y >= i$1.min.y && c$1.y <= i$1.max.y || gc(u$1, c$1, o$1))) continue;
						if (this.isOnBorder(u$1.x, c$1.x) || this.isOnBorder(u$1.y, c$1.y)) continue;
						const h$1 = cp.computeEdgeHash(this.unevalVertices[r$2], this.unevalVertices[l$1]);
						let p$1, d$1 = this.vertexHashLookup.get(cp.computePosHash(u$1));
						null != d$1 ? p$1 = d$1.next : (d$1 = this.vertexHashLookup.get(cp.computePosHash(c$1)), p$1 = null != d$1 ? d$1.prev : h$1), this.unevalEdges.push({
							polygonIdx: t$1,
							a: r$2,
							b: l$1,
							hash: h$1,
							portalHash: p$1,
							isTunnel: n$1,
							type: "unevaluated",
							featureInfo: s$1
						});
					}
				}
				addPortalCandidates(t$1, e$1, r$1, n$1, i$1) {
					if (0 === e$1.length) return;
					this.portalPolygons.add(t$1, {
						geometry: e$1,
						zLevel: i$1
					});
					const s$1 = e$1[0];
					this.vertexHashLookup.clear();
					let o$1 = cp.computeEdgeHash(s$1[s$1.length - 2], s$1[s$1.length - 1]);
					for (let e$2 = 0; e$2 < s$1.length - 1; e$2++) {
						const i$2 = s$1[e$2 + 0], a$1 = s$1[e$2 + 1], l$1 = ct(a$1.x - i$2.x, a$1.y - i$2.y), u$1 = mt(l$1);
						if (0 === u$1) continue;
						let c$1 = "unevaluated";
						const h$1 = n$1.pointElevation(i$2), p$1 = n$1.pointElevation(a$1);
						Math.abs(h$1) < .01 && Math.abs(p$1) < .01 ? c$1 = "entrance" : (this.isOnBorder(i$2.x, a$1.x) || this.isOnBorder(i$2.y, a$1.y)) && (c$1 = "border");
						const d$1 = cp.computeEdgeHash(i$2, a$1);
						this.unevaluatedPortals.portals.push({
							connection: {
								a: t$1,
								b: void 0
							},
							va: i$2,
							vb: a$1,
							vab: l$1,
							length: u$1,
							hash: d$1,
							isTunnel: r$1,
							type: c$1
						});
						const f$1 = cp.computePosHash(i$2);
						this.vertexHashLookup.set(f$1, {
							prev: o$1,
							next: d$1
						}), o$1 = d$1;
					}
				}
				construct(t$1) {
					if (0 === this.unevalVertices.length) return;
					const e$1 = () => ({
						vertexOffset: 0,
						primitiveOffset: this.indexArray.length
					}), r$1 = (t$2) => {
						t$2.primitiveLength = this.indexArray.length - t$2.primitiveOffset;
					}, n$1 = new up(this.vertexPositions, this.vertexNormals, this.indexArray);
					this.prepareEdges(t$1.portals, this.unevalEdges);
					const i$1 = e$1(), s$1 = e$1(), o$1 = e$1(), a$1 = (t$2, e$2) => {
						t$2.sort(((t$3, r$3) => t$3.type === e$2 && r$3.type !== e$2 ? -1 : t$3.type !== e$2 && r$3.type === e$2 ? 1 : 0));
						const r$2 = t$2.findIndex(((t$3) => t$3.type !== e$2));
						return r$2 >= 0 ? r$2 : t$2.length;
					};
					let l$1 = 0;
					this.unevalEdges.length > 0 && (l$1 = a$1(this.unevalEdges, "none"), this.constructBridgeStructures(n$1, this.unevalVertices, this.unevalHeights, this.unevalEdges, {
						min: 0,
						max: l$1
					}, this.tileToMeters)), r$1(o$1);
					const u$1 = e$1(), c$1 = e$1();
					if (this.unevalEdges.length > 0) {
						const t$2 = this.unevalEdges.splice(l$1), e$2 = a$1(t$2, "tunnel") + l$1;
						this.unevalEdges.push(...t$2), this.constructTunnelStructures(n$1, this.unevalVertices, this.unevalHeights, this.unevalEdges, {
							min: 0,
							max: l$1
						}, {
							min: l$1,
							max: e$2
						});
					}
					r$1(u$1), n$1.addTriangles(this.unevalTriangles, this.unevalVertices, this.unevalHeights), r$1(c$1), n$1.addTriangles(this.unevalTunnelTriangles, this.unevalVertices, this.unevalHeights), r$1(s$1), n$1.addTriangles(this.unevalTunnelTriangles, this.unevalVertices, [-.1]), r$1(i$1), this.maskSegments = hl.simpleSegment(0, c$1.primitiveOffset, 0, c$1.primitiveLength), this.depthSegments = hl.simpleSegment(0, s$1.primitiveOffset, 0, s$1.primitiveLength), this.renderableBridgeSegments = hl.simpleSegment(0, o$1.primitiveOffset, 0, o$1.primitiveLength), this.renderableTunnelSegments = hl.simpleSegment(0, u$1.primitiveOffset, 0, u$1.primitiveLength), this.shadowCasterSegments = hl.simpleSegment(0, i$1.primitiveOffset, 0, i$1.primitiveLength);
				}
				update(t$1, e$1, r$1, n$1, i$1, s$1, o$1, a$1) {
					this.bridgeProgramConfigurations.updatePaintArrays(t$1, e$1, i$1, r$1, n$1, s$1, o$1, a$1), this.tunnelProgramConfigurations.updatePaintArrays(t$1, e$1, i$1, r$1, n$1, s$1, o$1, a$1);
				}
				upload(t$1) {
					this.vertexBuffer || 0 === this.vertexPositions.length || 0 === this.vertexNormals.length || 0 === this.indexArray.length || (this.vertexBuffer = t$1.createVertexBuffer(this.vertexPositions, kh.members), this.vertexBufferNormal = t$1.createVertexBuffer(this.vertexNormals, Bh.members), this.indexBuffer = t$1.createIndexBuffer(this.indexArray), this.bridgeProgramConfigurations.upload(t$1), this.tunnelProgramConfigurations.upload(t$1));
				}
				destroy() {
					this.vertexBuffer && (this.vertexBuffer.destroy(), this.vertexBufferNormal.destroy(), this.indexBuffer.destroy()), this.maskSegments && (this.maskSegments.destroy(), this.depthSegments.destroy(), this.renderableBridgeSegments.destroy(), this.renderableTunnelSegments.destroy(), this.shadowCasterSegments.destroy()), this.bridgeProgramConfigurations.destroy(), this.tunnelProgramConfigurations.destroy();
				}
				populatePaintArrays(t$1, e$1, r$1, n$1, i$1) {
					const s$1 = (s$2, o$1) => {
						for (let a$1 = 0; a$1 < o$1.length - 1; a$1++) {
							const l$1 = o$1[a$1].featureIndex, u$1 = o$1[a$1 + 1].vertexStart, c$1 = t$1.feature(l$1);
							s$2.populatePaintArrays(u$1, c$1, l$1, {}, r$1, e$1, n$1, void 0, i$1);
						}
					};
					s$1(this.bridgeProgramConfigurations, this.bridgeFeatureSections), s$1(this.tunnelProgramConfigurations, this.tunnelFeatureSections);
				}
				computeVertexConnections(t$1, e$1, r$1, n$1, i$1) {
					const s$1 = /* @__PURE__ */ new Map();
					for (let o$1 = n$1; o$1 < i$1; o$1++) {
						const n$2 = r$1[o$1], i$2 = n$2.a, a$1 = n$2.b, l$1 = cp.computePosHash(t$1[i$2]), u$1 = cp.computePosHash(t$1[a$1]);
						let c$1 = s$1.get(l$1);
						c$1 || (c$1 = {}, s$1.set(l$1, c$1));
						let h$1 = s$1.get(u$1);
						h$1 || (h$1 = {}, s$1.set(u$1, h$1)), e$1[i$2] <= 0 && e$1[a$1] <= 0 || (c$1.to = a$1, h$1.from = i$2);
					}
					return s$1;
				}
				isTerminalVertex(t$1, e$1) {
					const r$1 = cp.computePosHash(this.unevalVertices[t$1]), n$1 = e$1.get(r$1);
					return !n$1 || !n$1.from || !n$1.to;
				}
				constructBridgeStructures(t$1, e$1, r$1, n$1, i$1, s$1) {
					t$1.clearVertexLookup();
					const o$1 = this.computeVertexConnections(e$1, r$1, n$1, i$1.min, i$1.max), a$1 = 1 / s$1, l$1 = .5 * a$1, u$1 = (t$2, n$2) => S(t$2, e$1[n$2].x, e$1[n$2].y, r$1[n$2] * a$1), c$1 = _(), h$1 = _(), p$1 = _(), d$1 = _(), f$1 = _(), m$1 = (t$2, r$2) => {
						const n$2 = o$1.get(cp.computePosHash(e$1[r$2])), i$2 = n$2.from, s$2 = n$2.to;
						if (!i$2 || !s$2) return;
						u$1(c$1, i$2), u$1(h$1, r$2), u$1(p$1, s$2), q(d$1), H(c$1, h$1) || (X(f$1, h$1, c$1), L(d$1, f$1)), H(p$1, h$1) || (X(f$1, p$1, h$1), P(d$1, d$1, L(f$1, f$1)));
						const a$2 = W(d$1);
						return a$2 > 0 ? E(t$2, d$1, 1 / a$2) : void 0;
					};
					let y$1 = Number.POSITIVE_INFINITY;
					this.sortSubarray(n$1, i$1.min, i$1.max, ((t$2, e$2) => t$2.featureInfo.featureIndex - e$2.featureInfo.featureIndex));
					const g$1 = _(), x$1 = _(), v$1 = _(), b$1 = _(), w$1 = _(), A$1 = _(), I$1 = _(), M$1 = _(), k$1 = _(), B$1 = [
						_(),
						_(),
						_(),
						_()
					], z$1 = [
						_(),
						_(),
						_(),
						_()
					], T$1 = [{
						coord: new It(0, 0),
						height: 0
					}, {
						coord: new It(0, 0),
						height: 0
					}], V$1 = (t$2, e$2) => t$2 > e$2;
					for (let u$2 = i$1.min; u$2 < i$1.max; u$2++) {
						const i$2 = n$1[u$2];
						if (!i$2.featureInfo.guardRailEnabled) continue;
						if (!this.prepareEdgePoints(T$1, e$1, r$1, i$2, V$1)) continue;
						const [c$2, h$2] = T$1;
						if (S(g$1, c$2.coord.x, c$2.coord.y, a$1 * c$2.height), S(x$1, h$2.coord.x, h$2.coord.y, a$1 * h$2.height), H(g$1, x$1)) continue;
						X(v$1, x$1, g$1), L(v$1, v$1);
						const p$2 = m$1(M$1, i$2.a) || v$1, d$2 = m$1(k$1, i$2.b) || v$1;
						S(b$1, p$2[1], -p$2[0], 0), L(b$1, b$1), S(w$1, d$2[1], -d$2[0], 0), L(w$1, w$1), U(M$1, b$1, p$2), L(A$1, M$1), U(M$1, w$1, d$2), L(I$1, M$1), P(B$1[0], g$1, E(M$1, X(M$1, b$1, A$1), l$1)), P(B$1[1], g$1, E(M$1, P(M$1, b$1, A$1), l$1)), P(B$1[2], g$1, E(M$1, A$1, l$1)), B$1[3] = g$1, P(z$1[0], x$1, E(M$1, X(M$1, w$1, I$1), l$1)), P(z$1[1], x$1, E(M$1, P(M$1, w$1, I$1), l$1)), P(z$1[2], x$1, E(M$1, I$1, l$1)), z$1[3] = x$1, y$1 = this.addFeatureSection(i$2.featureInfo.featureIndex, y$1, this.bridgeFeatureSections, t$1);
						const f$2 = t$1.addVertex(B$1[0], b$1, s$1), _$1 = t$1.addVertex(B$1[1], b$1, s$1), F$1 = t$1.addVertex(z$1[0], w$1, s$1), C$1 = t$1.addVertex(z$1[1], w$1, s$1);
						t$1.addTriangle(f$2, _$1, F$1), t$1.addTriangle(_$1, C$1, F$1);
						const D$1 = t$1.addVertex(B$1[1], A$1, s$1), O$1 = t$1.addVertex(B$1[2], A$1, s$1), N$1 = t$1.addVertex(z$1[1], I$1, s$1), j$1 = t$1.addVertex(z$1[2], I$1, s$1);
						t$1.addTriangle(D$1, O$1, N$1), t$1.addTriangle(O$1, j$1, N$1), R(b$1, b$1), R(w$1, w$1);
						const $$1 = t$1.addVertex(B$1[2], b$1, s$1), G$1 = t$1.addVertex(B$1[3], b$1, s$1), q$1 = t$1.addVertex(z$1[2], w$1, s$1), Z$1 = t$1.addVertex(z$1[3], w$1, s$1);
						t$1.addTriangle($$1, G$1, q$1), t$1.addTriangle(G$1, Z$1, q$1);
						const W$1 = this.isTerminalVertex(i$2.a, o$1), Y$1 = this.isTerminalVertex(i$2.b, o$1);
						c$2.height < .01 && W$1 && t$1.addQuad(B$1[3], B$1[2], B$1[1], B$1[0], R(p$2, p$2), s$1), h$2.height < .01 && Y$1 && t$1.addQuad(z$1[0], z$1[1], z$1[2], z$1[3], d$2, s$1);
					}
					this.bridgeFeatureSections.push({
						featureIndex: Number.POSITIVE_INFINITY,
						vertexStart: t$1.getVertexCount()
					});
				}
				constructTunnelStructures(t$1, e$1, r$1, n$1, i$1, s$1) {
					t$1.clearVertexLookup();
					let o$1 = Number.POSITIVE_INFINITY;
					const a$1 = (t$2, e$2) => t$2.featureInfo.featureIndex - e$2.featureInfo.featureIndex;
					this.sortSubarray(n$1, i$1.min, i$1.max, a$1), this.sortSubarray(n$1, s$1.min, s$1.max, a$1);
					const l$1 = (t$2) => L(t$2, t$2), u$1 = [{
						coord: new It(0, 0),
						height: 0
					}, {
						coord: new It(0, 0),
						height: 0
					}], c$1 = (t$2, e$2) => t$2 < e$2, h$1 = _(), p$1 = _(), d$1 = _(), f$1 = _(), m$1 = _();
					for (let s$2 = i$1.min; s$2 < i$1.max; s$2++) {
						if (!this.prepareEdgePoints(u$1, e$1, r$1, n$1[s$2], c$1)) continue;
						const [i$2, a$2] = u$1, y$1 = l$1(S(m$1, -(a$2.coord.y - i$2.coord.y), a$2.coord.x - i$2.coord.x, 0));
						o$1 = this.addFeatureSection(n$1[s$2].featureInfo.featureIndex, o$1, this.tunnelFeatureSections, t$1), t$1.addQuad(S(h$1, i$2.coord.x, i$2.coord.y, i$2.height), S(p$1, a$2.coord.x, a$2.coord.y, a$2.height), S(d$1, a$2.coord.x, a$2.coord.y, n$1[s$2].isTunnel ? -.1 : 0), S(f$1, i$2.coord.x, i$2.coord.y, n$1[s$2].isTunnel ? -.1 : 0), y$1);
					}
					for (let i$2 = s$1.min; i$2 < s$1.max; i$2++) {
						const s$2 = n$1[i$2];
						s$2.isTunnel && ([s$2.a, s$2.b] = [s$2.b, s$2.a]);
						const a$2 = e$1[s$2.a], u$2 = e$1[s$2.b], c$2 = l$1(S(m$1, -(u$2.y - a$2.y), u$2.x - a$2.x, 0));
						o$1 = this.addFeatureSection(s$2.featureInfo.featureIndex, o$1, this.tunnelFeatureSections, t$1), t$1.addQuad(S(h$1, u$2.x, u$2.y, 0), S(p$1, a$2.x, a$2.y, 0), S(d$1, a$2.x, a$2.y, r$1[s$2.a] + 4), S(f$1, u$2.x, u$2.y, r$1[s$2.b] + 4), c$2), t$1.addQuad(S(h$1, a$2.x, a$2.y, 0), S(p$1, u$2.x, u$2.y, 0), S(d$1, u$2.x, u$2.y, r$1[s$2.b] + 4), S(f$1, a$2.x, a$2.y, r$1[s$2.a] + 4), c$2);
					}
					this.tunnelFeatureSections.push({
						featureIndex: Number.POSITIVE_INFINITY,
						vertexStart: t$1.getVertexCount()
					});
				}
				setElevatedPoint(t$1, e$1, r$1, n$1) {
					t$1.coord.x = e$1, t$1.coord.y = r$1, t$1.height = n$1;
				}
				prepareEdgePoints(t$1, e$1, r$1, n$1, i$1) {
					let s$1 = e$1[n$1.a].x, o$1 = e$1[n$1.a].y, a$1 = e$1[n$1.b].x, l$1 = e$1[n$1.b].y, u$1 = r$1[n$1.a], c$1 = r$1[n$1.b];
					const h$1 = i$1(u$1, 0), p$1 = i$1(c$1, 0);
					if (h$1 && p$1) return this.setElevatedPoint(t$1[0], s$1, o$1, u$1), this.setElevatedPoint(t$1[1], a$1, l$1, c$1), !0;
					if (!h$1 && !p$1) return !1;
					if (h$1) {
						if (!p$1) {
							const t$2 = c$1 / (c$1 - u$1);
							a$1 = pr(a$1, s$1, t$2), l$1 = pr(l$1, o$1, t$2), c$1 = pr(c$1, u$1, t$2);
						}
					} else {
						const t$2 = u$1 / (u$1 - c$1);
						s$1 = pr(s$1, a$1, t$2), o$1 = pr(o$1, l$1, t$2), u$1 = pr(u$1, c$1, t$2);
					}
					return this.setElevatedPoint(t$1[0], s$1, o$1, u$1), this.setElevatedPoint(t$1[1], a$1, l$1, c$1), !0;
				}
				prepareEdges(t$1, e$1) {
					if (0 === e$1.length) return;
					e$1.sort(((t$2, e$2) => t$2.hash === e$2.hash ? e$2.polygonIdx - t$2.polygonIdx : e$2.hash > t$2.hash ? 1 : -1));
					let r$1 = 0, n$1 = 0, i$1 = 0, s$1 = e$1[r$1].polygonIdx;
					do
						n$1++, (n$1 === e$1.length || e$1[r$1].hash !== e$1[n$1].hash) && ((1 == n$1 - r$1 || e$1[n$1 - 1].polygonIdx !== s$1) && (i$1 < r$1 && (e$1[i$1] = e$1[r$1], e$1[r$1] = null), e$1[i$1].type = "none", i$1++), r$1 = n$1, r$1 !== e$1.length && (s$1 = e$1[r$1].polygonIdx));
					while (r$1 !== e$1.length);
					if (e$1.splice(i$1), 0 !== e$1.length && 0 !== t$1.length) {
						e$1.sort(((t$2, e$2) => t$2.portalHash < e$2.portalHash ? 1 : -1));
						let r$2 = 0, n$2 = 0;
						for (; r$2 !== e$1.length && n$2 !== t$1.length;) {
							const i$2 = e$1[r$2], s$2 = t$1[n$2];
							i$2.portalHash > s$2.hash ? r$2++ : s$2.hash > i$2.portalHash ? n$2++ : (i$2.type = s$2.type, r$2++);
						}
					}
				}
				isOnBorder(t$1, e$1) {
					return t$1 <= 0 && e$1 <= 0 || t$1 >= Un && e$1 >= Un;
				}
				addFeatureSection(t$1, e$1, r$1, n$1) {
					return t$1 !== e$1 && (e$1 = t$1, r$1.push({
						featureIndex: t$1,
						vertexStart: n$1.getVertexCount()
					}), n$1.clearVertexLookup()), e$1;
				}
				sortSubarray(t$1, e$1, r$1, n$1) {
					const i$1 = t$1.slice(e$1, r$1);
					i$1.sort(n$1), t$1.splice(e$1, i$1.length, ...i$1);
				}
				static computeEdgeHash(t$1, e$1) {
					return (t$1.y === e$1.y && t$1.x > e$1.x || t$1.y > e$1.y) && ([t$1, e$1] = [e$1, t$1]), BigInt(cp.computePosHash(t$1)) << 32n | BigInt(cp.computePosHash(e$1));
				}
				static computePosHash(t$1) {
					return ((65535 & t$1.x) << 16 | 65535 & t$1.y) >>> 0;
				}
			}
			var hp, pp = { exports: {} }, dp = (hp || (hp = 1, function(t$1) {
				function e$1(t$2, e$2) {
					return t$2 > e$2 ? 1 : t$2 < e$2 ? -1 : 0;
				}
				var r$1 = function(t$2, r$2) {
					void 0 === t$2 && (t$2 = e$1), void 0 === r$2 && (r$2 = !1), this._compare = t$2, this._root = null, this._size = 0, this._noDuplicates = !!r$2;
				}, n$1 = { size: { configurable: !0 } };
				function i$1(t$2, e$2, r$2, n$2, s$2) {
					var o$2 = s$2 - n$2;
					if (o$2 > 0) {
						var a$2 = n$2 + Math.floor(o$2 / 2), l$2 = {
							key: e$2[a$2],
							data: r$2[a$2],
							parent: t$2
						};
						return l$2.left = i$1(l$2, e$2, r$2, n$2, a$2), l$2.right = i$1(l$2, e$2, r$2, a$2 + 1, s$2), l$2;
					}
					return null;
				}
				function s$1(t$2, e$2, r$2, n$2, i$2) {
					if (!(r$2 >= n$2)) {
						for (var o$2 = t$2[r$2 + n$2 >> 1], a$2 = r$2 - 1, l$2 = n$2 + 1;;) {
							do
								a$2++;
							while (i$2(t$2[a$2], o$2) < 0);
							do
								l$2--;
							while (i$2(t$2[l$2], o$2) > 0);
							if (a$2 >= l$2) break;
							var u$2 = t$2[a$2];
							t$2[a$2] = t$2[l$2], t$2[l$2] = u$2, u$2 = e$2[a$2], e$2[a$2] = e$2[l$2], e$2[l$2] = u$2;
						}
						s$1(t$2, e$2, r$2, l$2, i$2), s$1(t$2, e$2, l$2 + 1, n$2, i$2);
					}
				}
				r$1.prototype.rotateLeft = function(t$2) {
					var e$2 = t$2.right;
					e$2 && (t$2.right = e$2.left, e$2.left && (e$2.left.parent = t$2), e$2.parent = t$2.parent), t$2.parent ? t$2 === t$2.parent.left ? t$2.parent.left = e$2 : t$2.parent.right = e$2 : this._root = e$2, e$2 && (e$2.left = t$2), t$2.parent = e$2;
				}, r$1.prototype.rotateRight = function(t$2) {
					var e$2 = t$2.left;
					e$2 && (t$2.left = e$2.right, e$2.right && (e$2.right.parent = t$2), e$2.parent = t$2.parent), t$2.parent ? t$2 === t$2.parent.left ? t$2.parent.left = e$2 : t$2.parent.right = e$2 : this._root = e$2, e$2 && (e$2.right = t$2), t$2.parent = e$2;
				}, r$1.prototype._splay = function(t$2) {
					for (; t$2.parent;) {
						var e$2 = t$2.parent;
						e$2.parent ? e$2.left === t$2 && e$2.parent.left === e$2 ? (this.rotateRight(e$2.parent), this.rotateRight(e$2)) : e$2.right === t$2 && e$2.parent.right === e$2 ? (this.rotateLeft(e$2.parent), this.rotateLeft(e$2)) : e$2.left === t$2 && e$2.parent.right === e$2 ? (this.rotateRight(e$2), this.rotateLeft(e$2)) : (this.rotateLeft(e$2), this.rotateRight(e$2)) : e$2.left === t$2 ? this.rotateRight(e$2) : this.rotateLeft(e$2);
					}
				}, r$1.prototype.splay = function(t$2) {
					for (var e$2, r$2, n$2, i$2, s$2; t$2.parent;) (r$2 = (e$2 = t$2.parent).parent) && r$2.parent ? ((n$2 = r$2.parent).left === r$2 ? n$2.left = t$2 : n$2.right = t$2, t$2.parent = n$2) : (t$2.parent = null, this._root = t$2), i$2 = t$2.left, s$2 = t$2.right, t$2 === e$2.left ? (r$2 && (r$2.left === e$2 ? (e$2.right ? (r$2.left = e$2.right, r$2.left.parent = r$2) : r$2.left = null, e$2.right = r$2, r$2.parent = e$2) : (i$2 ? (r$2.right = i$2, i$2.parent = r$2) : r$2.right = null, t$2.left = r$2, r$2.parent = t$2)), s$2 ? (e$2.left = s$2, s$2.parent = e$2) : e$2.left = null, t$2.right = e$2, e$2.parent = t$2) : (r$2 && (r$2.right === e$2 ? (e$2.left ? (r$2.right = e$2.left, r$2.right.parent = r$2) : r$2.right = null, e$2.left = r$2, r$2.parent = e$2) : (s$2 ? (r$2.left = s$2, s$2.parent = r$2) : r$2.left = null, t$2.right = r$2, r$2.parent = t$2)), i$2 ? (e$2.right = i$2, i$2.parent = e$2) : e$2.right = null, t$2.left = e$2, e$2.parent = t$2);
				}, r$1.prototype.replace = function(t$2, e$2) {
					t$2.parent ? t$2 === t$2.parent.left ? t$2.parent.left = e$2 : t$2.parent.right = e$2 : this._root = e$2, e$2 && (e$2.parent = t$2.parent);
				}, r$1.prototype.minNode = function(t$2) {
					if (void 0 === t$2 && (t$2 = this._root), t$2) for (; t$2.left;) t$2 = t$2.left;
					return t$2;
				}, r$1.prototype.maxNode = function(t$2) {
					if (void 0 === t$2 && (t$2 = this._root), t$2) for (; t$2.right;) t$2 = t$2.right;
					return t$2;
				}, r$1.prototype.insert = function(t$2, e$2) {
					var r$2 = this._root, n$2 = null, i$2 = this._compare;
					if (this._noDuplicates) for (; r$2;) {
						if (n$2 = r$2, 0 === i$2(r$2.key, t$2)) return;
						r$2 = i$2(r$2.key, t$2) < 0 ? r$2.right : r$2.left;
					}
					else for (; r$2;) n$2 = r$2, r$2 = i$2(r$2.key, t$2) < 0 ? r$2.right : r$2.left;
					return r$2 = {
						key: t$2,
						data: e$2,
						left: null,
						right: null,
						parent: n$2
					}, n$2 ? i$2(n$2.key, r$2.key) < 0 ? n$2.right = r$2 : n$2.left = r$2 : this._root = r$2, this.splay(r$2), this._size++, r$2;
				}, r$1.prototype.find = function(t$2) {
					for (var e$2 = this._root, r$2 = this._compare; e$2;) {
						var n$2 = r$2(e$2.key, t$2);
						if (n$2 < 0) e$2 = e$2.right;
						else {
							if (!(n$2 > 0)) return e$2;
							e$2 = e$2.left;
						}
					}
					return null;
				}, r$1.prototype.contains = function(t$2) {
					for (var e$2 = this._root, r$2 = this._compare; e$2;) {
						var n$2 = r$2(t$2, e$2.key);
						if (0 === n$2) return !0;
						e$2 = n$2 < 0 ? e$2.left : e$2.right;
					}
					return !1;
				}, r$1.prototype.remove = function(t$2) {
					var e$2 = this.find(t$2);
					if (!e$2) return !1;
					if (this.splay(e$2), e$2.left) if (e$2.right) {
						var r$2 = this.minNode(e$2.right);
						r$2.parent !== e$2 && (this.replace(r$2, r$2.right), r$2.right = e$2.right, r$2.right.parent = r$2), this.replace(e$2, r$2), r$2.left = e$2.left, r$2.left.parent = r$2;
					} else this.replace(e$2, e$2.left);
					else this.replace(e$2, e$2.right);
					return this._size--, !0;
				}, r$1.prototype.removeNode = function(t$2) {
					if (!t$2) return !1;
					if (this.splay(t$2), t$2.left) if (t$2.right) {
						var e$2 = this.minNode(t$2.right);
						e$2.parent !== t$2 && (this.replace(e$2, e$2.right), e$2.right = t$2.right, e$2.right.parent = e$2), this.replace(t$2, e$2), e$2.left = t$2.left, e$2.left.parent = e$2;
					} else this.replace(t$2, t$2.left);
					else this.replace(t$2, t$2.right);
					return this._size--, !0;
				}, r$1.prototype.erase = function(t$2) {
					var e$2 = this.find(t$2);
					if (e$2) {
						this.splay(e$2);
						var r$2 = e$2.left, n$2 = e$2.right, i$2 = null;
						r$2 && (r$2.parent = null, i$2 = this.maxNode(r$2), this.splay(i$2), this._root = i$2), n$2 && (r$2 ? i$2.right = n$2 : this._root = n$2, n$2.parent = i$2), this._size--;
					}
				}, r$1.prototype.pop = function() {
					var t$2 = this._root, e$2 = null;
					if (t$2) {
						for (; t$2.left;) t$2 = t$2.left;
						e$2 = {
							key: t$2.key,
							data: t$2.data
						}, this.remove(t$2.key);
					}
					return e$2;
				}, r$1.prototype.next = function(t$2) {
					var e$2 = t$2;
					if (e$2) if (e$2.right) for (e$2 = e$2.right; e$2 && e$2.left;) e$2 = e$2.left;
					else for (e$2 = t$2.parent; e$2 && e$2.right === t$2;) t$2 = e$2, e$2 = e$2.parent;
					return e$2;
				}, r$1.prototype.prev = function(t$2) {
					var e$2 = t$2;
					if (e$2) if (e$2.left) for (e$2 = e$2.left; e$2 && e$2.right;) e$2 = e$2.right;
					else for (e$2 = t$2.parent; e$2 && e$2.left === t$2;) t$2 = e$2, e$2 = e$2.parent;
					return e$2;
				}, r$1.prototype.forEach = function(t$2) {
					for (var e$2 = this._root, r$2 = [], n$2 = !1, i$2 = 0; !n$2;) e$2 ? (r$2.push(e$2), e$2 = e$2.left) : r$2.length > 0 ? (t$2(e$2 = r$2.pop(), i$2++), e$2 = e$2.right) : n$2 = !0;
					return this;
				}, r$1.prototype.range = function(t$2, e$2, r$2, n$2) {
					for (var i$2 = [], s$2 = this._compare, o$2 = this._root; 0 !== i$2.length || o$2;) if (o$2) i$2.push(o$2), o$2 = o$2.left;
					else {
						if (s$2((o$2 = i$2.pop()).key, e$2) > 0) break;
						if (s$2(o$2.key, t$2) >= 0 && r$2.call(n$2, o$2)) return this;
						o$2 = o$2.right;
					}
					return this;
				}, r$1.prototype.keys = function() {
					for (var t$2 = this._root, e$2 = [], r$2 = [], n$2 = !1; !n$2;) t$2 ? (e$2.push(t$2), t$2 = t$2.left) : e$2.length > 0 ? (t$2 = e$2.pop(), r$2.push(t$2.key), t$2 = t$2.right) : n$2 = !0;
					return r$2;
				}, r$1.prototype.values = function() {
					for (var t$2 = this._root, e$2 = [], r$2 = [], n$2 = !1; !n$2;) t$2 ? (e$2.push(t$2), t$2 = t$2.left) : e$2.length > 0 ? (t$2 = e$2.pop(), r$2.push(t$2.data), t$2 = t$2.right) : n$2 = !0;
					return r$2;
				}, r$1.prototype.at = function(t$2) {
					for (var e$2 = this._root, r$2 = [], n$2 = !1, i$2 = 0; !n$2;) if (e$2) r$2.push(e$2), e$2 = e$2.left;
					else if (r$2.length > 0) {
						if (e$2 = r$2.pop(), i$2 === t$2) return e$2;
						i$2++, e$2 = e$2.right;
					} else n$2 = !0;
					return null;
				}, r$1.prototype.load = function(t$2, e$2, r$2) {
					if (void 0 === t$2 && (t$2 = []), void 0 === e$2 && (e$2 = []), void 0 === r$2 && (r$2 = !1), 0 !== this._size) throw new Error("bulk-load: tree is not empty");
					var n$2 = t$2.length;
					return r$2 && s$1(t$2, e$2, 0, n$2 - 1, this._compare), this._root = i$1(null, t$2, e$2, 0, n$2), this._size = n$2, this;
				}, r$1.prototype.min = function() {
					var t$2 = this.minNode(this._root);
					return t$2 ? t$2.key : null;
				}, r$1.prototype.max = function() {
					var t$2 = this.maxNode(this._root);
					return t$2 ? t$2.key : null;
				}, r$1.prototype.isEmpty = function() {
					return null === this._root;
				}, n$1.size.get = function() {
					return this._size;
				}, r$1.createTree = function(t$2, e$2, n$2, i$2, s$2) {
					return new r$1(n$2, s$2).load(t$2, e$2, i$2);
				}, Object.defineProperties(r$1.prototype, n$1);
				var o$1 = 0, a$1 = 1, l$1 = 2, u$1 = 3, c$1 = 0, h$1 = 1, p$1 = 2, d$1 = 3;
				function f$1(t$2, e$2, r$2) {
					null === e$2 ? (t$2.inOut = !1, t$2.otherInOut = !0) : (t$2.isSubject === e$2.isSubject ? (t$2.inOut = !e$2.inOut, t$2.otherInOut = e$2.otherInOut) : (t$2.inOut = !e$2.otherInOut, t$2.otherInOut = e$2.isVertical() ? !e$2.inOut : e$2.inOut), e$2 && (t$2.prevInResult = !m$1(e$2, r$2) || e$2.isVertical() ? e$2.prevInResult : e$2));
					t$2.resultTransition = m$1(t$2, r$2) ? function(t$3, e$3) {
						var r$3, n$2 = !t$3.inOut, i$2 = !t$3.otherInOut;
						switch (e$3) {
							case c$1:
								r$3 = n$2 && i$2;
								break;
							case h$1:
								r$3 = n$2 || i$2;
								break;
							case d$1:
								r$3 = n$2 ^ i$2;
								break;
							case p$1: r$3 = t$3.isSubject ? n$2 && !i$2 : i$2 && !n$2;
						}
						return r$3 ? 1 : -1;
					}(t$2, r$2) : 0;
				}
				function m$1(t$2, e$2) {
					switch (t$2.type) {
						case o$1:
							switch (e$2) {
								case c$1: return !t$2.otherInOut;
								case h$1: return t$2.otherInOut;
								case p$1: return t$2.isSubject && t$2.otherInOut || !t$2.isSubject && !t$2.otherInOut;
								case d$1: return !0;
							}
							break;
						case l$1: return e$2 === c$1 || e$2 === h$1;
						case u$1: return e$2 === p$1;
						case a$1: return !1;
					}
					return !1;
				}
				var y$1 = function(t$2, e$2, r$2, n$2, i$2) {
					this.left = e$2, this.point = t$2, this.otherEvent = r$2, this.isSubject = n$2, this.type = i$2 || o$1, this.inOut = !1, this.otherInOut = !1, this.prevInResult = null, this.resultTransition = 0, this.otherPos = -1, this.outputContourId = -1, this.isExteriorRing = !0;
				}, g$1 = { inResult: { configurable: !0 } };
				function x$1(t$2, e$2) {
					return t$2[0] === e$2[0] && t$2[1] === e$2[1];
				}
				y$1.prototype.isBelow = function(t$2) {
					var e$2 = this.point, r$2 = this.otherEvent.point;
					return this.left ? (e$2[0] - t$2[0]) * (r$2[1] - t$2[1]) - (r$2[0] - t$2[0]) * (e$2[1] - t$2[1]) > 0 : (r$2[0] - t$2[0]) * (e$2[1] - t$2[1]) - (e$2[0] - t$2[0]) * (r$2[1] - t$2[1]) > 0;
				}, y$1.prototype.isAbove = function(t$2) {
					return !this.isBelow(t$2);
				}, y$1.prototype.isVertical = function() {
					return this.point[0] === this.otherEvent.point[0];
				}, g$1.inResult.get = function() {
					return 0 !== this.resultTransition;
				}, y$1.prototype.clone = function() {
					var t$2 = new y$1(this.point, this.left, this.otherEvent, this.isSubject, this.type);
					return t$2.contourId = this.contourId, t$2.resultTransition = this.resultTransition, t$2.prevInResult = this.prevInResult, t$2.isExteriorRing = this.isExteriorRing, t$2.inOut = this.inOut, t$2.otherInOut = this.otherInOut, t$2;
				}, Object.defineProperties(y$1.prototype, g$1);
				var v$1 = 11102230246251565e-32, b$1 = 134217729, w$1 = (3 + 8 * v$1) * v$1;
				function _$1(t$2, e$2, r$2, n$2, i$2) {
					var s$2, o$2, a$2, l$2, u$2 = e$2[0], c$2 = n$2[0], h$2 = 0, p$2 = 0;
					c$2 > u$2 == c$2 > -u$2 ? (s$2 = u$2, u$2 = e$2[++h$2]) : (s$2 = c$2, c$2 = n$2[++p$2]);
					var d$2 = 0;
					if (h$2 < t$2 && p$2 < r$2) for (c$2 > u$2 == c$2 > -u$2 ? (a$2 = s$2 - ((o$2 = u$2 + s$2) - u$2), u$2 = e$2[++h$2]) : (a$2 = s$2 - ((o$2 = c$2 + s$2) - c$2), c$2 = n$2[++p$2]), s$2 = o$2, 0 !== a$2 && (i$2[d$2++] = a$2); h$2 < t$2 && p$2 < r$2;) c$2 > u$2 == c$2 > -u$2 ? (a$2 = s$2 - ((o$2 = s$2 + u$2) - (l$2 = o$2 - s$2)) + (u$2 - l$2), u$2 = e$2[++h$2]) : (a$2 = s$2 - ((o$2 = s$2 + c$2) - (l$2 = o$2 - s$2)) + (c$2 - l$2), c$2 = n$2[++p$2]), s$2 = o$2, 0 !== a$2 && (i$2[d$2++] = a$2);
					for (; h$2 < t$2;) a$2 = s$2 - ((o$2 = s$2 + u$2) - (l$2 = o$2 - s$2)) + (u$2 - l$2), u$2 = e$2[++h$2], s$2 = o$2, 0 !== a$2 && (i$2[d$2++] = a$2);
					for (; p$2 < r$2;) a$2 = s$2 - ((o$2 = s$2 + c$2) - (l$2 = o$2 - s$2)) + (c$2 - l$2), c$2 = n$2[++p$2], s$2 = o$2, 0 !== a$2 && (i$2[d$2++] = a$2);
					return 0 === s$2 && 0 !== d$2 || (i$2[d$2++] = s$2), d$2;
				}
				function A$1(t$2) {
					return new Float64Array(t$2);
				}
				var I$1 = 33306690738754716e-32, M$1 = 22204460492503146e-32, S$1 = 11093356479670487e-47, P$1 = A$1(4), k$1 = A$1(8), B$1 = A$1(12), z$1 = A$1(16), T$1 = A$1(4);
				function E$1(t$2, e$2, r$2) {
					var n$2 = function(t$3, e$3, r$3, n$3, i$2, s$2) {
						var o$2 = (e$3 - s$2) * (r$3 - i$2), a$2 = (t$3 - i$2) * (n$3 - s$2), l$2 = o$2 - a$2;
						if (0 === o$2 || 0 === a$2 || o$2 > 0 != a$2 > 0) return l$2;
						var u$2 = Math.abs(o$2 + a$2);
						return Math.abs(l$2) >= I$1 * u$2 ? l$2 : -function(t$4, e$4, r$4, n$4, i$3, s$3, o$3) {
							var a$3, l$3, u$3, c$2, h$2, p$2, d$2, f$2, m$2, y$2, g$2, x$2, v$2, A$2, I$2, E$2, V$2, F$2, C$2 = t$4 - i$3, D$2 = r$4 - i$3, R$2 = e$4 - s$3, L$2 = n$4 - s$3;
							P$1[0] = (I$2 = (f$2 = C$2 - (d$2 = (p$2 = b$1 * C$2) - (p$2 - C$2))) * (y$2 = L$2 - (m$2 = (p$2 = b$1 * L$2) - (p$2 - L$2))) - ((A$2 = C$2 * L$2) - d$2 * m$2 - f$2 * m$2 - d$2 * y$2)) - ((g$2 = I$2 - (V$2 = (f$2 = R$2 - (d$2 = (p$2 = b$1 * R$2) - (p$2 - R$2))) * (y$2 = D$2 - (m$2 = (p$2 = b$1 * D$2) - (p$2 - D$2))) - ((E$2 = R$2 * D$2) - d$2 * m$2 - f$2 * m$2 - d$2 * y$2))) + (h$2 = I$2 - g$2)) + (h$2 - V$2), P$1[1] = (v$2 = A$2 - ((x$2 = A$2 + g$2) - (h$2 = x$2 - A$2)) + (g$2 - h$2)) - ((g$2 = v$2 - E$2) + (h$2 = v$2 - g$2)) + (h$2 - E$2), P$1[2] = x$2 - ((F$2 = x$2 + g$2) - (h$2 = F$2 - x$2)) + (g$2 - h$2), P$1[3] = F$2;
							var O$2 = function(t$5, e$5) {
								for (var r$5 = e$5[0], n$5 = 1; n$5 < 4; n$5++) r$5 += e$5[n$5];
								return r$5;
							}(0, P$1), U$2 = M$1 * o$3;
							if (O$2 >= U$2 || -O$2 >= U$2) return O$2;
							if (a$3 = t$4 - (C$2 + (h$2 = t$4 - C$2)) + (h$2 - i$3), u$3 = r$4 - (D$2 + (h$2 = r$4 - D$2)) + (h$2 - i$3), l$3 = e$4 - (R$2 + (h$2 = e$4 - R$2)) + (h$2 - s$3), c$2 = n$4 - (L$2 + (h$2 = n$4 - L$2)) + (h$2 - s$3), 0 === a$3 && 0 === l$3 && 0 === u$3 && 0 === c$2) return O$2;
							if (U$2 = S$1 * o$3 + w$1 * Math.abs(O$2), (O$2 += C$2 * c$2 + L$2 * a$3 - (R$2 * u$3 + D$2 * l$3)) >= U$2 || -O$2 >= U$2) return O$2;
							T$1[0] = (I$2 = (f$2 = a$3 - (d$2 = (p$2 = b$1 * a$3) - (p$2 - a$3))) * (y$2 = L$2 - (m$2 = (p$2 = b$1 * L$2) - (p$2 - L$2))) - ((A$2 = a$3 * L$2) - d$2 * m$2 - f$2 * m$2 - d$2 * y$2)) - ((g$2 = I$2 - (V$2 = (f$2 = l$3 - (d$2 = (p$2 = b$1 * l$3) - (p$2 - l$3))) * (y$2 = D$2 - (m$2 = (p$2 = b$1 * D$2) - (p$2 - D$2))) - ((E$2 = l$3 * D$2) - d$2 * m$2 - f$2 * m$2 - d$2 * y$2))) + (h$2 = I$2 - g$2)) + (h$2 - V$2), T$1[1] = (v$2 = A$2 - ((x$2 = A$2 + g$2) - (h$2 = x$2 - A$2)) + (g$2 - h$2)) - ((g$2 = v$2 - E$2) + (h$2 = v$2 - g$2)) + (h$2 - E$2), T$1[2] = x$2 - ((F$2 = x$2 + g$2) - (h$2 = F$2 - x$2)) + (g$2 - h$2), T$1[3] = F$2;
							var N$2 = _$1(4, P$1, 4, T$1, k$1);
							T$1[0] = (I$2 = (f$2 = C$2 - (d$2 = (p$2 = b$1 * C$2) - (p$2 - C$2))) * (y$2 = c$2 - (m$2 = (p$2 = b$1 * c$2) - (p$2 - c$2))) - ((A$2 = C$2 * c$2) - d$2 * m$2 - f$2 * m$2 - d$2 * y$2)) - ((g$2 = I$2 - (V$2 = (f$2 = R$2 - (d$2 = (p$2 = b$1 * R$2) - (p$2 - R$2))) * (y$2 = u$3 - (m$2 = (p$2 = b$1 * u$3) - (p$2 - u$3))) - ((E$2 = R$2 * u$3) - d$2 * m$2 - f$2 * m$2 - d$2 * y$2))) + (h$2 = I$2 - g$2)) + (h$2 - V$2), T$1[1] = (v$2 = A$2 - ((x$2 = A$2 + g$2) - (h$2 = x$2 - A$2)) + (g$2 - h$2)) - ((g$2 = v$2 - E$2) + (h$2 = v$2 - g$2)) + (h$2 - E$2), T$1[2] = x$2 - ((F$2 = x$2 + g$2) - (h$2 = F$2 - x$2)) + (g$2 - h$2), T$1[3] = F$2;
							var j$2 = _$1(N$2, k$1, 4, T$1, B$1);
							T$1[0] = (I$2 = (f$2 = a$3 - (d$2 = (p$2 = b$1 * a$3) - (p$2 - a$3))) * (y$2 = c$2 - (m$2 = (p$2 = b$1 * c$2) - (p$2 - c$2))) - ((A$2 = a$3 * c$2) - d$2 * m$2 - f$2 * m$2 - d$2 * y$2)) - ((g$2 = I$2 - (V$2 = (f$2 = l$3 - (d$2 = (p$2 = b$1 * l$3) - (p$2 - l$3))) * (y$2 = u$3 - (m$2 = (p$2 = b$1 * u$3) - (p$2 - u$3))) - ((E$2 = l$3 * u$3) - d$2 * m$2 - f$2 * m$2 - d$2 * y$2))) + (h$2 = I$2 - g$2)) + (h$2 - V$2), T$1[1] = (v$2 = A$2 - ((x$2 = A$2 + g$2) - (h$2 = x$2 - A$2)) + (g$2 - h$2)) - ((g$2 = v$2 - E$2) + (h$2 = v$2 - g$2)) + (h$2 - E$2), T$1[2] = x$2 - ((F$2 = x$2 + g$2) - (h$2 = F$2 - x$2)) + (g$2 - h$2), T$1[3] = F$2;
							return z$1[_$1(j$2, B$1, 4, T$1, z$1) - 1];
						}(t$3, e$3, r$3, n$3, i$2, s$2, u$2);
					}(t$2[0], t$2[1], e$2[0], e$2[1], r$2[0], r$2[1]);
					return n$2 > 0 ? -1 : n$2 < 0 ? 1 : 0;
				}
				function V$1(t$2, e$2) {
					var r$2 = t$2.point, n$2 = e$2.point;
					return r$2[0] > n$2[0] ? 1 : r$2[0] < n$2[0] ? -1 : r$2[1] !== n$2[1] ? r$2[1] > n$2[1] ? 1 : -1 : function(t$3, e$3, r$3, n$3) {
						return t$3.left !== e$3.left ? t$3.left ? 1 : -1 : 0 !== E$1(r$3, t$3.otherEvent.point, e$3.otherEvent.point) ? t$3.isBelow(e$3.otherEvent.point) ? -1 : 1 : !t$3.isSubject && e$3.isSubject ? 1 : -1;
					}(t$2, e$2, r$2);
				}
				function F$1(t$2, e$2, r$2) {
					var n$2 = new y$1(e$2, !1, t$2, t$2.isSubject), i$2 = new y$1(e$2, !0, t$2.otherEvent, t$2.isSubject);
					return x$1(t$2.point, t$2.otherEvent.point) && console.warn("what is that, a collapsed segment?", t$2), n$2.contourId = i$2.contourId = t$2.contourId, V$1(i$2, t$2.otherEvent) > 0 && (t$2.otherEvent.left = !0, i$2.left = !1), t$2.otherEvent.otherEvent = i$2, t$2.otherEvent = n$2, r$2.push(i$2), r$2.push(n$2), r$2;
				}
				function C$1(t$2, e$2) {
					return t$2[0] * e$2[1] - t$2[1] * e$2[0];
				}
				function D$1(t$2, e$2) {
					return t$2[0] * e$2[0] + t$2[1] * e$2[1];
				}
				function R$1(t$2, e$2, r$2) {
					var n$2 = function(t$3, e$3, r$3, n$3, i$3) {
						var s$3 = [e$3[0] - t$3[0], e$3[1] - t$3[1]], o$3 = [n$3[0] - r$3[0], n$3[1] - r$3[1]];
						function a$2(t$4, e$4, r$4) {
							return [t$4[0] + e$4 * r$4[0], t$4[1] + e$4 * r$4[1]];
						}
						var l$2 = [r$3[0] - t$3[0], r$3[1] - t$3[1]], u$2 = C$1(s$3, o$3), c$3 = u$2 * u$2, h$2 = D$1(s$3, s$3);
						if (c$3 > 0) {
							var p$2 = C$1(l$2, o$3) / u$2;
							if (p$2 < 0 || p$2 > 1) return null;
							var d$2 = C$1(l$2, s$3) / u$2;
							return d$2 < 0 || d$2 > 1 ? null : 0 === p$2 || 1 === p$2 ? [a$2(t$3, p$2, s$3)] : 0 === d$2 || 1 === d$2 ? [a$2(r$3, d$2, o$3)] : [a$2(t$3, p$2, s$3)];
						}
						if ((c$3 = (u$2 = C$1(l$2, s$3)) * u$2) > 0) return null;
						var f$2 = D$1(s$3, l$2) / h$2, m$2 = f$2 + D$1(s$3, o$3) / h$2, y$2 = Math.min(f$2, m$2), g$2 = Math.max(f$2, m$2);
						return y$2 <= 1 && g$2 >= 0 ? 1 === y$2 ? [a$2(t$3, y$2 > 0 ? y$2 : 0, s$3)] : 0 === g$2 ? [a$2(t$3, g$2 < 1 ? g$2 : 1, s$3)] : [a$2(t$3, y$2 > 0 ? y$2 : 0, s$3), a$2(t$3, g$2 < 1 ? g$2 : 1, s$3)] : null;
					}(t$2.point, t$2.otherEvent.point, e$2.point, e$2.otherEvent.point), i$2 = n$2 ? n$2.length : 0;
					if (0 === i$2) return 0;
					if (1 === i$2 && (x$1(t$2.point, e$2.point) || x$1(t$2.otherEvent.point, e$2.otherEvent.point))) return 0;
					if (2 === i$2 && t$2.isSubject === e$2.isSubject) return 0;
					if (1 === i$2) return x$1(t$2.point, n$2[0]) || x$1(t$2.otherEvent.point, n$2[0]) || F$1(t$2, n$2[0], r$2), x$1(e$2.point, n$2[0]) || x$1(e$2.otherEvent.point, n$2[0]) || F$1(e$2, n$2[0], r$2), 1;
					var s$2 = [], o$2 = !1, c$2 = !1;
					return x$1(t$2.point, e$2.point) ? o$2 = !0 : 1 === V$1(t$2, e$2) ? s$2.push(e$2, t$2) : s$2.push(t$2, e$2), x$1(t$2.otherEvent.point, e$2.otherEvent.point) ? c$2 = !0 : 1 === V$1(t$2.otherEvent, e$2.otherEvent) ? s$2.push(e$2.otherEvent, t$2.otherEvent) : s$2.push(t$2.otherEvent, e$2.otherEvent), o$2 && c$2 || o$2 ? (e$2.type = a$1, t$2.type = e$2.inOut === t$2.inOut ? l$1 : u$1, o$2 && !c$2 && F$1(s$2[1].otherEvent, s$2[0].point, r$2), 2) : c$2 ? (F$1(s$2[0], s$2[1].point, r$2), 3) : s$2[0] !== s$2[3].otherEvent ? (F$1(s$2[0], s$2[1].point, r$2), F$1(s$2[1], s$2[2].point, r$2), 3) : (F$1(s$2[0], s$2[1].point, r$2), F$1(s$2[3].otherEvent, s$2[2].point, r$2), 3);
				}
				function L$1(t$2, e$2) {
					if (t$2 === e$2) return 0;
					if (0 !== E$1(t$2.point, t$2.otherEvent.point, e$2.point) || 0 !== E$1(t$2.point, t$2.otherEvent.point, e$2.otherEvent.point)) return x$1(t$2.point, e$2.point) ? t$2.isBelow(e$2.otherEvent.point) ? -1 : 1 : t$2.point[0] === e$2.point[0] ? t$2.point[1] < e$2.point[1] ? -1 : 1 : 1 === V$1(t$2, e$2) ? e$2.isAbove(t$2.point) ? -1 : 1 : t$2.isBelow(e$2.point) ? -1 : 1;
					if (t$2.isSubject !== e$2.isSubject) return t$2.isSubject ? -1 : 1;
					var r$2 = t$2.point, n$2 = e$2.point;
					return r$2[0] === n$2[0] && r$2[1] === n$2[1] ? (r$2 = t$2.otherEvent.point)[0] === (n$2 = e$2.otherEvent.point)[0] && r$2[1] === n$2[1] ? 0 : t$2.contourId > e$2.contourId ? 1 : -1 : 1 === V$1(t$2, e$2) ? 1 : -1;
				}
				var O$1 = function() {
					this.points = [], this.holeIds = [], this.holeOf = null, this.depth = null;
				};
				function U$1(t$2, e$2, r$2, n$2) {
					var i$2, s$2 = t$2 + 1, o$2 = e$2[t$2].point, a$2 = e$2.length;
					for (s$2 < a$2 && (i$2 = e$2[s$2].point); s$2 < a$2 && i$2[0] === o$2[0] && i$2[1] === o$2[1];) {
						if (!r$2[s$2]) return s$2;
						++s$2 < a$2 && (i$2 = e$2[s$2].point);
					}
					for (s$2 = t$2 - 1; r$2[s$2] && s$2 > n$2;) s$2--;
					return s$2;
				}
				O$1.prototype.isExterior = function() {
					return null == this.holeOf;
				};
				var N$1 = $$1, j$1 = $$1;
				function $$1(t$2, e$2) {
					if (!(this instanceof $$1)) return new $$1(t$2, e$2);
					if (this.data = t$2 || [], this.length = this.data.length, this.compare = e$2 || G$1, this.length > 0) for (var r$2 = (this.length >> 1) - 1; r$2 >= 0; r$2--) this._down(r$2);
				}
				function G$1(t$2, e$2) {
					return t$2 < e$2 ? -1 : t$2 > e$2 ? 1 : 0;
				}
				$$1.prototype = {
					push: function(t$2) {
						this.data.push(t$2), this.length++, this._up(this.length - 1);
					},
					pop: function() {
						if (0 !== this.length) {
							var t$2 = this.data[0];
							return this.length--, this.length > 0 && (this.data[0] = this.data[this.length], this._down(0)), this.data.pop(), t$2;
						}
					},
					peek: function() {
						return this.data[0];
					},
					_up: function(t$2) {
						for (var e$2 = this.data, r$2 = this.compare, n$2 = e$2[t$2]; t$2 > 0;) {
							var i$2 = t$2 - 1 >> 1, s$2 = e$2[i$2];
							if (r$2(n$2, s$2) >= 0) break;
							e$2[t$2] = s$2, t$2 = i$2;
						}
						e$2[t$2] = n$2;
					},
					_down: function(t$2) {
						for (var e$2 = this.data, r$2 = this.compare, n$2 = this.length >> 1, i$2 = e$2[t$2]; t$2 < n$2;) {
							var s$2 = 1 + (t$2 << 1), o$2 = s$2 + 1, a$2 = e$2[s$2];
							if (o$2 < this.length && r$2(e$2[o$2], a$2) < 0 && (s$2 = o$2, a$2 = e$2[o$2]), r$2(a$2, i$2) >= 0) break;
							e$2[t$2] = a$2, t$2 = s$2;
						}
						e$2[t$2] = i$2;
					}
				}, N$1.default = j$1;
				var q$1 = Math.max, H$1 = Math.min, X$1 = 0;
				function Z$1(t$2, e$2, r$2, n$2, i$2, s$2) {
					var o$2, a$2, l$2, u$2, c$2, h$2;
					for (o$2 = 0, a$2 = t$2.length - 1; o$2 < a$2; o$2++) if (u$2 = t$2[o$2 + 1], c$2 = new y$1(l$2 = t$2[o$2], !1, void 0, e$2), h$2 = new y$1(u$2, !1, c$2, e$2), c$2.otherEvent = h$2, l$2[0] !== u$2[0] || l$2[1] !== u$2[1]) {
						c$2.contourId = h$2.contourId = r$2, s$2 || (c$2.isExteriorRing = !1, h$2.isExteriorRing = !1), V$1(c$2, h$2) > 0 ? h$2.left = !0 : c$2.left = !0;
						var p$2 = l$2[0], d$2 = l$2[1];
						i$2[0] = H$1(i$2[0], p$2), i$2[1] = H$1(i$2[1], d$2), i$2[2] = q$1(i$2[2], p$2), i$2[3] = q$1(i$2[3], d$2), n$2.push(c$2), n$2.push(h$2);
					}
				}
				var W$1 = [];
				function Y$1(t$2, e$2, n$2) {
					"number" == typeof t$2[0][0][0] && (t$2 = [t$2]), "number" == typeof e$2[0][0][0] && (e$2 = [e$2]);
					var i$2 = function(t$3, e$3, r$2) {
						var n$3 = null;
						return t$3.length * e$3.length == 0 && (r$2 === c$1 ? n$3 = W$1 : r$2 === p$1 ? n$3 = t$3 : r$2 !== h$1 && r$2 !== d$1 || (n$3 = 0 === t$3.length ? e$3 : t$3)), n$3;
					}(t$2, e$2, n$2);
					if (i$2) return i$2 === W$1 ? null : i$2;
					var s$2 = [
						Infinity,
						Infinity,
						-Infinity,
						-Infinity
					], o$2 = [
						Infinity,
						Infinity,
						-Infinity,
						-Infinity
					], a$2 = function(t$3, e$3, r$2, n$3, i$3) {
						var s$3, o$3, a$3, l$3, u$3, c$2, h$2 = new N$1(null, V$1);
						for (a$3 = 0, l$3 = t$3.length; a$3 < l$3; a$3++) for (u$3 = 0, c$2 = (s$3 = t$3[a$3]).length; u$3 < c$2; u$3++) (o$3 = 0 === u$3) && X$1++, Z$1(s$3[u$3], !0, X$1, h$2, r$2, o$3);
						for (a$3 = 0, l$3 = e$3.length; a$3 < l$3; a$3++) for (u$3 = 0, c$2 = (s$3 = e$3[a$3]).length; u$3 < c$2; u$3++) o$3 = 0 === u$3, i$3 === p$1 && (o$3 = !1), o$3 && X$1++, Z$1(s$3[u$3], !1, X$1, h$2, n$3, o$3);
						return h$2;
					}(t$2, e$2, s$2, o$2, n$2);
					if (i$2 = function(t$3, e$3, r$2, n$3, i$3) {
						var s$3 = null;
						return (r$2[0] > n$3[2] || n$3[0] > r$2[2] || r$2[1] > n$3[3] || n$3[1] > r$2[3]) && (i$3 === c$1 ? s$3 = W$1 : i$3 === p$1 ? s$3 = t$3 : i$3 !== h$1 && i$3 !== d$1 || (s$3 = t$3.concat(e$3))), s$3;
					}(t$2, e$2, s$2, o$2, n$2)) return i$2 === W$1 ? null : i$2;
					for (var l$2 = function(t$3) {
						var e$3, r$2, n$3 = function(t$4) {
							var e$4, r$3, n$4, i$4, s$4 = [];
							for (r$3 = 0, n$4 = t$4.length; r$3 < n$4; r$3++) ((e$4 = t$4[r$3]).left && e$4.inResult || !e$4.left && e$4.otherEvent.inResult) && s$4.push(e$4);
							for (var o$4 = !1; !o$4;) for (o$4 = !0, r$3 = 0, n$4 = s$4.length; r$3 < n$4; r$3++) r$3 + 1 < n$4 && 1 === V$1(s$4[r$3], s$4[r$3 + 1]) && (i$4 = s$4[r$3], s$4[r$3] = s$4[r$3 + 1], s$4[r$3 + 1] = i$4, o$4 = !1);
							for (r$3 = 0, n$4 = s$4.length; r$3 < n$4; r$3++) (e$4 = s$4[r$3]).otherPos = r$3;
							for (r$3 = 0, n$4 = s$4.length; r$3 < n$4; r$3++) (e$4 = s$4[r$3]).left || (i$4 = e$4.otherPos, e$4.otherPos = e$4.otherEvent.otherPos, e$4.otherEvent.otherPos = i$4);
							return s$4;
						}(t$3), i$3 = {}, s$3 = [], o$3 = function() {
							if (!i$3[e$3]) {
								var t$4 = s$3.length, r$3 = function(t$5, e$4, r$4) {
									var n$4 = new O$1();
									if (null != t$5.prevInResult) {
										var i$4 = t$5.prevInResult, s$4 = i$4.outputContourId;
										if (i$4.resultTransition > 0) {
											var o$5 = e$4[s$4];
											if (null != o$5.holeOf) {
												var a$4 = o$5.holeOf;
												e$4[a$4].holeIds.push(r$4), n$4.holeOf = a$4, n$4.depth = e$4[s$4].depth;
											} else e$4[s$4].holeIds.push(r$4), n$4.holeOf = s$4, n$4.depth = e$4[s$4].depth + 1;
										} else n$4.holeOf = null, n$4.depth = e$4[s$4].depth;
									} else n$4.holeOf = null, n$4.depth = 0;
									return n$4;
								}(n$3[e$3], s$3, t$4), o$4 = function(e$4) {
									i$3[e$4] = !0, e$4 < n$3.length && n$3[e$4] && (n$3[e$4].outputContourId = t$4);
								}, a$3 = e$3, l$3 = e$3;
								for (r$3.points.push(n$3[e$3].point); o$4(a$3), o$4(a$3 = n$3[a$3].otherPos), r$3.points.push(n$3[a$3].point), !((a$3 = U$1(a$3, n$3, i$3, l$3)) == l$3 || a$3 >= n$3.length) && n$3[a$3];);
								s$3.push(r$3);
							}
						};
						for (e$3 = 0, r$2 = n$3.length; e$3 < r$2; e$3++) o$3();
						return s$3;
					}(function(t$3, e$3, n$3, i$3, s$3, o$3) {
						for (var a$3, l$3, u$3, h$2 = new r$1(L$1), d$2 = [], m$3 = Math.min(i$3[2], s$3[2]); 0 !== t$3.length;) {
							var y$3 = t$3.pop();
							if (d$2.push(y$3), o$3 === c$1 && y$3.point[0] > m$3 || o$3 === p$1 && y$3.point[0] > i$3[2]) break;
							if (y$3.left) {
								l$3 = a$3 = h$2.insert(y$3), a$3 = a$3 !== (u$3 = h$2.minNode()) ? h$2.prev(a$3) : null, l$3 = h$2.next(l$3);
								var g$3 = a$3 ? a$3.key : null;
								if (f$1(y$3, g$3, o$3), l$3 && 2 === R$1(y$3, l$3.key, t$3) && (f$1(y$3, g$3, o$3), f$1(l$3.key, y$3, o$3)), a$3 && 2 === R$1(a$3.key, y$3, t$3)) {
									var x$3 = a$3;
									f$1(g$3, (x$3 = x$3 !== u$3 ? h$2.prev(x$3) : null) ? x$3.key : null, o$3), f$1(y$3, g$3, o$3);
								}
							} else l$3 = a$3 = h$2.find(y$3 = y$3.otherEvent), a$3 && l$3 && (a$3 = a$3 !== u$3 ? h$2.prev(a$3) : null, l$3 = h$2.next(l$3), h$2.remove(y$3), l$3 && a$3 && R$1(a$3.key, l$3.key, t$3));
						}
						return d$2;
					}(a$2, 0, 0, s$2, o$2, n$2)), u$2 = [], m$2 = 0; m$2 < l$2.length; m$2++) {
						var y$2 = l$2[m$2];
						if (y$2.isExterior()) {
							for (var g$2 = [y$2.points], x$2 = 0; x$2 < y$2.holeIds.length; x$2++) g$2.push(l$2[y$2.holeIds[x$2]].points);
							u$2.push(g$2);
						}
					}
					return u$2;
				}
				var K$1 = {
					UNION: h$1,
					DIFFERENCE: p$1,
					INTERSECTION: c$1,
					XOR: d$1
				};
				t$1.diff = function(t$2, e$2) {
					return Y$1(t$2, e$2, p$1);
				}, t$1.intersection = function(t$2, e$2) {
					return Y$1(t$2, e$2, c$1);
				}, t$1.operations = K$1, t$1.union = function(t$2, e$2) {
					return Y$1(t$2, e$2, h$1);
				}, t$1.xor = function(t$2, e$2) {
					return Y$1(t$2, e$2, d$1);
				}, Object.defineProperty(t$1, "__esModule", { value: !0 });
			}(pp.exports)), pp.exports);
			/**
			* martinez v0.7.4
			* Martinez polygon clipping algorithm, does boolean operation on polygons (multipolygons, polygons with holes etc): intersection, union, difference, xor
			*
			* @author Alex Milevski <info@w8r.name>
			* @license MIT
			* @preserve
			*/ function fp(t$1, e$1, r$1, n$1) {
				const i$1 = [], s$1 = 0 === n$1 ? (t$2, e$2, r$2, n$2, i$2, s$2) => {
					t$2.push(new It(s$2, r$2 + (s$2 - e$2) / (n$2 - e$2) * (i$2 - r$2)));
				} : (t$2, e$2, r$2, n$2, i$2, s$2) => {
					t$2.push(new It(e$2 + (s$2 - r$2) / (i$2 - r$2) * (n$2 - e$2), s$2));
				};
				for (const o$1 of t$1) {
					const t$2 = [];
					for (const i$2 of o$1) {
						if (i$2.length <= 2) continue;
						const o$2 = [];
						for (let t$3 = 0; t$3 < i$2.length - 1; t$3++) {
							const a$2 = i$2[t$3].x, l$2 = i$2[t$3].y, u$1 = i$2[t$3 + 1].x, c$1 = i$2[t$3 + 1].y, h$1 = 0 === n$1 ? a$2 : l$2, p$1 = 0 === n$1 ? u$1 : c$1;
							h$1 < e$1 ? p$1 > e$1 && s$1(o$2, a$2, l$2, u$1, c$1, e$1) : h$1 > r$1 ? p$1 < r$1 && s$1(o$2, a$2, l$2, u$1, c$1, r$1) : o$2.push(i$2[t$3]), p$1 < e$1 && h$1 >= e$1 && s$1(o$2, a$2, l$2, u$1, c$1, e$1), p$1 > r$1 && h$1 <= r$1 && s$1(o$2, a$2, l$2, u$1, c$1, r$1);
						}
						let a$1 = i$2[i$2.length - 1];
						const l$1 = 0 === n$1 ? a$1.x : a$1.y;
						l$1 >= e$1 && l$1 <= r$1 && o$2.push(a$1), o$2.length && (a$1 = o$2[o$2.length - 1], o$2[0].x === a$1.x && o$2[0].y === a$1.y || o$2.push(o$2[0]), t$2.push(o$2));
					}
					t$2.length && i$1.push(t$2);
				}
				return i$1;
			}
			function mp(t$1, e$1) {
				const r$1 = gp(t$1), n$1 = gp([e$1]), i$1 = dp.intersection(r$1, n$1);
				return null == i$1 ? [] : xp(i$1);
			}
			function yp(t$1, e$1) {
				const r$1 = 65536;
				let n$1 = gp(t$1, r$1);
				const i$1 = [];
				for (; e$1.valid(); e$1.next()) {
					const [t$2, n$2] = e$1.get(), s$1 = t$2.x * r$1, o$1 = t$2.y * r$1, a$1 = n$2.x * r$1, l$1 = n$2.y * r$1, u$1 = a$1 - s$1, c$1 = l$1 - o$1, h$1 = Math.hypot(u$1, c$1);
					if (0 === h$1) continue;
					const p$1 = Math.trunc(c$1 / h$1 * 3), d$1 = -Math.trunc(u$1 / h$1 * 3);
					i$1.push([[
						[s$1, o$1],
						[a$1, l$1],
						[a$1 + p$1, l$1 + d$1],
						[s$1 + p$1, o$1 + d$1],
						[s$1, o$1]
					]]);
				}
				return i$1.length > 0 && (n$1 = dp.diff(n$1, i$1)), xp(n$1, 1 / r$1);
			}
			function gp(t$1, e$1 = 1) {
				return [t$1.map(((t$2) => t$2.map(((t$3) => [t$3.x * e$1, t$3.y * e$1]))))];
			}
			function xp(t$1, e$1 = 1) {
				return t$1.map(((t$2) => t$2.map(((t$3, r$1) => {
					const n$1 = t$3.map(((t$4) => new It(t$4[0] * e$1, t$4[1] * e$1).round()));
					return r$1 > 0 && n$1.reverse(), n$1;
				}))));
			}
			class vp {
				constructor(t$1, e$1) {
					this.layoutVertexArray = new da(), this.indexArray = new Fa(), this.lineIndexArray = new Ba(), this.triangleSegments = new hl(), this.lineSegments = new hl(), this.programConfigurations = new Ul(t$1.layers, {
						zoom: t$1.zoom,
						lut: t$1.lut
					}), this.uploaded = !1, e$1 && (this.elevatedLayoutVertexArray = new ya());
				}
				update(t$1, e$1, r$1, n$1, i$1, s$1, o$1, a$1) {
					this.programConfigurations.updatePaintArrays(t$1, e$1, i$1, r$1, n$1, s$1, o$1, a$1);
				}
				isEmpty() {
					return 0 === this.layoutVertexArray.length;
				}
				needsUpload() {
					return this.programConfigurations.needsUpload;
				}
				upload(t$1) {
					this.uploaded || (this.layoutVertexBuffer = t$1.createVertexBuffer(this.layoutVertexArray, Sh.members), this.indexBuffer = t$1.createIndexBuffer(this.indexArray), this.lineIndexBuffer = t$1.createIndexBuffer(this.lineIndexArray), this.elevatedLayoutVertexArray && this.elevatedLayoutVertexArray.length > 0 && (this.elevatedLayoutVertexBuffer = t$1.createVertexBuffer(this.elevatedLayoutVertexArray, Ph.members))), this.programConfigurations.upload(t$1), this.uploaded = !0;
				}
				destroy() {
					this.layoutVertexBuffer && (this.elevatedLayoutVertexBuffer && this.elevatedLayoutVertexBuffer.destroy(), this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.lineIndexBuffer.destroy(), this.programConfigurations.destroy(), this.triangleSegments.destroy(), this.lineSegments.destroy());
				}
				populatePaintArrays(t$1, e$1, r$1, n$1, i$1, s$1, o$1) {
					this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t$1, e$1, r$1, n$1, i$1, s$1, void 0, o$1);
				}
			}
			class bp {
				constructor(t$1) {
					this.zoom = t$1.zoom, this.pixelRatio = t$1.pixelRatio, this.overscaling = t$1.overscaling, this.layers = t$1.layers, this.layerIds = this.layers.map(((t$2) => t$2.fqid)), this.index = t$1.index, this.hasPattern = !1, this.patternFeatures = [], this.lut = t$1.lut, this.bufferData = new vp(t$1, !1), this.elevationBufferData = new vp(t$1, !0), this.stateDependentLayerIds = this.layers.filter(((t$2) => t$2.isStateDependent())).map(((t$2) => t$2.id)), this.projection = t$1.projection, this.elevationMode = this.layers[0].layout.get("fill-elevation-reference"), this.sourceLayerIndex = t$1.sourceLayerIndex, this.worldview = t$1.worldview, this.hasAppearances = null;
				}
				updateFootprints(t$1, e$1) {}
				updateAppearances(t$1, e$1, r$1, n$1) {}
				populate(t$1, e$1, r$1, n$1) {
					this.hasPattern = sp("fill", this.layers, this.pixelRatio, e$1);
					const i$1 = this.layers[0].layout.get("fill-sort-key"), s$1 = [];
					for (const { feature: o$1, id: a$1, index: l$1, sourceLayerIndex: u$1 } of t$1) {
						const t$2 = this.layers[0]._featureFilter.needGeometry, c$1 = Bu(o$1, t$2);
						if (!this.layers[0]._featureFilter.filter(new Io(this.zoom, {
							worldview: this.worldview,
							activeFloors: e$1.activeFloors
						}), c$1, r$1)) continue;
						const h$1 = i$1 ? i$1.evaluate(c$1, {}, r$1, e$1.availableImages) : void 0, p$1 = {
							id: a$1,
							properties: o$1.properties,
							type: o$1.type,
							sourceLayerIndex: u$1,
							index: l$1,
							geometry: t$2 ? c$1.geometry : ku(o$1, r$1, n$1),
							patterns: {},
							sortKey: h$1
						};
						s$1.push(p$1);
					}
					i$1 && s$1.sort(((t$2, e$2) => t$2.sortKey - e$2.sortKey));
					for (const n$2 of s$1) {
						const { geometry: i$2, index: s$2, sourceLayerIndex: o$1 } = n$2;
						if (this.hasPattern) {
							const t$2 = op("fill", this.layers, n$2, this.zoom, this.pixelRatio, e$1);
							this.patternFeatures.push(t$2);
						} else this.addFeature(n$2, i$2, s$2, r$1, {}, e$1.availableImages, e$1.brightness, e$1.elevationFeatures);
						e$1.featureIndex.insert(t$1[s$2].feature, i$2, s$2, o$1, this.index);
					}
				}
				update(t$1, e$1, r$1, n$1, i$1, s$1, o$1) {
					this.bufferData.update(t$1, e$1, r$1, n$1, i$1, s$1, o$1, this.worldview), this.elevationBufferData.update(t$1, e$1, r$1, n$1, i$1, s$1, o$1, this.worldview), this.elevatedStructures && this.elevatedStructures.update(t$1, e$1, r$1, n$1, i$1, s$1, o$1, this.worldview);
				}
				addFeatures(t$1, e$1, r$1, n$1, i$1, s$1) {
					for (const i$2 of this.patternFeatures) this.addFeature(i$2, i$2.geometry, i$2.index, e$1, r$1, n$1, s$1, t$1.elevationFeatures);
				}
				isEmpty() {
					return this.bufferData.isEmpty() && this.elevationBufferData.isEmpty();
				}
				uploadPending() {
					return !this.uploaded || this.bufferData.needsUpload() || this.elevationBufferData.needsUpload();
				}
				upload(t$1) {
					this.bufferData.upload(t$1), this.elevationBufferData.upload(t$1), this.elevatedStructures && this.elevatedStructures.upload(t$1);
				}
				destroy() {
					this.bufferData.destroy(), this.elevationBufferData.destroy(), this.elevatedStructures && this.elevatedStructures.destroy();
				}
				addFeature(t$1, e$1, r$1, n$1, i$1, s$1 = [], o$1, a$1) {
					const l$1 = rp(e$1, 500);
					"none" !== this.elevationMode ? this.addElevatedRoadFeature(t$1, l$1, n$1, r$1, a$1) : this.addGeometry(l$1, this.bufferData), this.bufferData.populatePaintArrays(t$1, r$1, i$1, s$1, n$1, o$1, this.worldview), this.elevationBufferData.populatePaintArrays(t$1, r$1, i$1, s$1, n$1, o$1, this.worldview);
				}
				getUnevaluatedPortalGraph() {
					return this.elevatedStructures ? this.elevatedStructures.unevaluatedPortals : void 0;
				}
				getElevationPolygons() {
					return this.elevatedStructures ? this.elevatedStructures.portalPolygons : void 0;
				}
				setEvaluatedPortalGraph(t$1, e$1, r$1, n$1, i$1) {
					this.elevatedStructures && (this.elevatedStructures.construct(t$1), this.elevatedStructures.populatePaintArrays(e$1, r$1, n$1, i$1, this.worldview));
				}
				addElevatedRoadFeature(t$1, e$1, r$1, n$1, i$1) {
					const s$1 = new Array(), o$1 = ec.getElevationFeature(t$1, i$1);
					if (!o$1) return void this.addGeometry(e$1, this.bufferData);
					{
						const t$2 = this.clipPolygonsToTile(e$1, 1);
						t$2.length > 0 && s$1.push({
							polygons: t$2,
							elevationFeature: o$1,
							elevationTileID: r$1
						});
					}
					const a$1 = {
						guardRailEnabled: this.layers[0].layout.get("fill-construct-bridge-guard-rail").evaluate(t$1, {}, r$1),
						featureIndex: n$1
					};
					for (const e$2 of s$1) if (e$2.elevationFeature) {
						if ("hd-road-base" === this.elevationMode) {
							this.elevatedStructures || (this.elevatedStructures = new cp(e$2.elevationTileID, this.layers, this.zoom, this.lut));
							const r$2 = e$2.elevationFeature.isTunnel();
							let n$2 = 0;
							t$1.properties.hasOwnProperty(Lu) && (n$2 = +t$1.properties[Lu]);
							for (const t$2 of e$2.polygons) this.elevatedStructures.addPortalCandidates(e$2.elevationFeature.id, t$2, r$2, e$2.elevationFeature, n$2);
						}
						e$2.elevationFeature.constantHeight ?? (e$2.polygons = this.prepareElevatedPolygons(e$2.polygons, e$2.elevationFeature, e$2.elevationTileID));
						const i$2 = new rc(r$1, e$2.elevationTileID);
						this.addElevatedGeometry(e$2.polygons, i$2, e$2.elevationFeature, "hd-road-base" === this.elevationMode ? 0 : .05, n$1, a$1);
					}
				}
				addElevatedGeometry(t$1, e$1, r$1, n$1, i$1, s$1) {
					const o$1 = {
						elevation: r$1,
						elevationSampler: e$1,
						bias: n$1,
						index: i$1,
						featureInfo: s$1
					}, [a$1, l$1] = this.addGeometry(t$1, this.elevationBufferData, o$1);
					null == this.elevationBufferData.heightRange ? this.elevationBufferData.heightRange = {
						min: a$1,
						max: l$1
					} : (this.elevationBufferData.heightRange.min = Math.min(this.elevationBufferData.heightRange.min, a$1), this.elevationBufferData.heightRange.max = Math.max(this.elevationBufferData.heightRange.max, l$1));
				}
				addGeometry(t$1, e$1, r$1) {
					let n$1 = Number.POSITIVE_INFINITY, i$1 = Number.NEGATIVE_INFINITY, s$1 = null;
					r$1 && (s$1 = r$1.elevationSampler.constantElevation(r$1.elevation, r$1.bias), null != s$1 && (n$1 = s$1, i$1 = s$1));
					const o$1 = (t$2, o$2, a$1) => {
						if (null != r$1) if (o$2.push(t$2), null != s$1) e$1.elevatedLayoutVertexArray.emplaceBack(s$1), a$1.push(s$1);
						else {
							const s$2 = r$1.elevationSampler.pointElevation(t$2, r$1.elevation, r$1.bias);
							e$1.elevatedLayoutVertexArray.emplaceBack(s$2), a$1.push(s$2), n$1 = Math.min(n$1, s$2), i$1 = Math.max(i$1, s$2);
						}
					};
					for (const n$2 of t$1) {
						let t$2 = 0;
						for (const e$2 of n$2) t$2 += e$2.length;
						const i$2 = e$1.triangleSegments.prepareSegment(t$2, e$1.layoutVertexArray, e$1.indexArray), s$2 = i$2.vertexLength, a$1 = [], l$1 = [], u$1 = [], c$1 = [], h$1 = [], p$1 = e$1.layoutVertexArray.length;
						for (const t$3 of n$2) {
							if (0 === t$3.length) continue;
							t$3 !== n$2[0] && l$1.push(a$1.length / 2);
							const i$3 = e$1.lineSegments.prepareSegment(t$3.length, e$1.layoutVertexArray, e$1.lineIndexArray), s$3 = i$3.vertexLength;
							r$1 && h$1.push(e$1.layoutVertexArray.length - p$1), o$1(t$3[0], u$1, c$1), e$1.layoutVertexArray.emplaceBack(t$3[0].x, t$3[0].y), e$1.lineIndexArray.emplaceBack(s$3 + t$3.length - 1, s$3), a$1.push(t$3[0].x), a$1.push(t$3[0].y);
							for (let r$2 = 1; r$2 < t$3.length; r$2++) o$1(t$3[r$2], u$1, c$1), e$1.layoutVertexArray.emplaceBack(t$3[r$2].x, t$3[r$2].y), e$1.lineIndexArray.emplaceBack(s$3 + r$2 - 1, s$3 + r$2), a$1.push(t$3[r$2].x), a$1.push(t$3[r$2].y);
							i$3.vertexLength += t$3.length, i$3.primitiveLength += t$3.length;
						}
						const d$1 = zh(a$1, l$1);
						for (let t$3 = 0; t$3 < d$1.length; t$3 += 3) e$1.indexArray.emplaceBack(s$2 + d$1[t$3], s$2 + d$1[t$3 + 1], s$2 + d$1[t$3 + 2]);
						if (d$1.length > 0 && r$1 && "hd-road-base" === this.elevationMode) {
							const t$3 = r$1.elevation.isTunnel(), e$2 = r$1.elevation.safeArea, n$3 = this.elevatedStructures.addVertices(u$1, c$1);
							this.elevatedStructures.addTriangles(d$1, n$3, t$3);
							const i$3 = h$1.length;
							if (i$3 > 0) {
								for (let s$3 = 0; s$3 < i$3 - 1; s$3++) this.elevatedStructures.addRenderableRing(r$1.index, h$1[s$3] + n$3, h$1[s$3 + 1] - h$1[s$3], t$3, e$2, r$1.featureInfo);
								this.elevatedStructures.addRenderableRing(r$1.index, h$1[i$3 - 1] + n$3, u$1.length - h$1[i$3 - 1], t$3, e$2, r$1.featureInfo);
							}
						}
						i$2.vertexLength += t$2, i$2.primitiveLength += d$1.length / 3;
					}
					return [n$1, i$1];
				}
				prepareElevatedPolygons(t$1, e$1, r$1) {
					const n$1 = 1 / vu(r$1), i$1 = [];
					for (const r$2 of t$1) {
						const t$2 = yp(r$2, new Qu(e$1, n$1));
						i$1.push(...t$2);
					}
					return i$1;
				}
				clipPolygonsToTile(t$1, e$1) {
					const r$1 = -e$1, n$1 = -e$1, i$1 = Un + e$1, s$1 = Un + e$1;
					let o$1 = 0;
					const a$1 = [], l$1 = [];
					for (; o$1 < t$1.length; o$1++) {
						const e$2 = t$1[o$1], u$2 = xn(e$2);
						(u$2.min.x >= r$1 && u$2.max.x <= i$1 && u$2.min.y >= n$1 && u$2.max.y <= s$1 ? a$1 : l$1).push(e$2);
					}
					if (a$1.length === t$1.length) return t$1;
					const u$1 = [
						new It(r$1, n$1),
						new It(i$1, n$1),
						new It(i$1, s$1),
						new It(r$1, s$1),
						new It(r$1, n$1)
					], c$1 = a$1;
					for (const t$2 of l$1) c$1.push(...mp(t$2, u$1));
					return c$1;
				}
			}
			let wp, _p, Ap, Ip;
			Qs(bp, "FillBucket", { omit: ["layers", "patternFeatures"] }), Qs(vp, "FillBufferData"), Qs(cp, "ElevatedStructures");
			class Mp {
				constructor(t$1, e$1, r$1, n$1) {
					if (this.triangleCount = e$1.length / 3, this.min = new It(0, 0), this.max = new It(0, 0), this.xScale = 0, this.yScale = 0, this.cellsX = 0, this.cellsY = 0, this.cells = [], this.payload = [], 0 === this.triangleCount || 0 === t$1.length) return;
					const [i$1, s$1] = [t$1[0].clone(), t$1[0].clone()];
					for (let e$2 = 1; e$2 < t$1.length; ++e$2) {
						const r$2 = t$1[e$2];
						i$1.x = Math.min(i$1.x, r$2.x), i$1.y = Math.min(i$1.y, r$2.y), s$1.x = Math.max(s$1.x, r$2.x), s$1.y = Math.max(s$1.y, r$2.y);
					}
					if (n$1) {
						const t$2 = Math.ceil(Math.max(s$1.x - i$1.x, s$1.y - i$1.y) / n$1);
						r$1 = Math.max(r$1, t$2);
					}
					if (0 === r$1) return;
					this.min = i$1, this.max = s$1;
					const o$1 = this.max.sub(this.min);
					o$1.x = Math.max(o$1.x, 1), o$1.y = Math.max(o$1.y, 1);
					const a$1 = Math.max(o$1.x, o$1.y) / r$1;
					this.cellsX = Math.max(1, Math.ceil(o$1.x / a$1)), this.cellsY = Math.max(1, Math.ceil(o$1.y / a$1)), this.xScale = 1 / a$1, this.yScale = 1 / a$1;
					const l$1 = [];
					for (let r$2 = 0; r$2 < this.triangleCount; r$2++) {
						const n$2 = t$1[e$1[3 * r$2 + 0]].sub(this.min), i$2 = t$1[e$1[3 * r$2 + 1]].sub(this.min), s$2 = t$1[e$1[3 * r$2 + 2]].sub(this.min), o$2 = Sp(Math.floor(Math.min(n$2.x, i$2.x, s$2.x)), this.xScale, this.cellsX), u$2 = Sp(Math.floor(Math.max(n$2.x, i$2.x, s$2.x)), this.xScale, this.cellsX), c$1 = Sp(Math.floor(Math.min(n$2.y, i$2.y, s$2.y)), this.yScale, this.cellsY), h$1 = Sp(Math.floor(Math.max(n$2.y, i$2.y, s$2.y)), this.yScale, this.cellsY), p$1 = new It(0, 0), d$1 = new It(0, 0), f$1 = new It(0, 0), m$1 = new It(0, 0);
						for (let t$2 = c$1; t$2 <= h$1; ++t$2) {
							p$1.y = d$1.y = t$2 * a$1, f$1.y = m$1.y = (t$2 + 1) * a$1;
							for (let e$2 = o$2; e$2 <= u$2; ++e$2) p$1.x = f$1.x = e$2 * a$1, d$1.x = m$1.x = (e$2 + 1) * a$1, (vc(n$2, i$2, s$2, p$1, d$1, m$1) || vc(n$2, i$2, s$2, p$1, m$1, f$1)) && l$1.push({
								cellIdx: t$2 * this.cellsX + e$2,
								triIdx: r$2
							});
						}
					}
					if (0 === l$1.length) return;
					l$1.sort(((t$2, e$2) => t$2.cellIdx - e$2.cellIdx || t$2.triIdx - e$2.triIdx));
					let u$1 = 0;
					for (; u$1 < l$1.length;) {
						const t$2 = l$1[u$1].cellIdx, e$2 = {
							start: this.payload.length,
							len: 0
						};
						for (; u$1 < l$1.length && l$1[u$1].cellIdx === t$2;) ++e$2.len, this.payload.push(l$1[u$1++].triIdx);
						this.cells[t$2] = e$2;
					}
				}
				_lazyInitLookup() {
					this.lookup || (this.lookup = new Uint8Array(Math.ceil(this.triangleCount / 8))), this.lookup.fill(0);
				}
				queryPoint(t$1, e$1) {
					if (0 === this.triangleCount || 0 === this.cells.length) return;
					if (t$1.x > this.max.x || this.min.x > t$1.x || t$1.y > this.max.y || this.min.y > t$1.y) return;
					const r$1 = Sp(t$1.x - this.min.x, this.xScale, this.cellsX), n$1 = Sp(t$1.y - this.min.y, this.yScale, this.cellsY), i$1 = this.cells[n$1 * this.cellsX + r$1];
					if (i$1) {
						this._lazyInitLookup();
						for (let t$2 = 0; t$2 < i$1.len; t$2++) {
							const r$2 = this.payload[i$1.start + t$2], n$2 = Math.floor(r$2 / 8), s$1 = 1 << r$2 % 8;
							if (!(this.lookup[n$2] & s$1) && (this.lookup[n$2] |= s$1, e$1.push(r$2), e$1.length === this.triangleCount)) return;
						}
					}
				}
				query(t$1, e$1, r$1) {
					if (0 === this.triangleCount || 0 === this.cells.length) return;
					if (t$1.x > this.max.x || this.min.x > e$1.x) return;
					if (t$1.y > this.max.y || this.min.y > e$1.y) return;
					this._lazyInitLookup();
					const n$1 = Sp(t$1.x - this.min.x, this.xScale, this.cellsX), i$1 = Sp(e$1.x - this.min.x, this.xScale, this.cellsX), s$1 = Sp(t$1.y - this.min.y, this.yScale, this.cellsY), o$1 = Sp(e$1.y - this.min.y, this.yScale, this.cellsY);
					for (let t$2 = s$1; t$2 <= o$1; t$2++) for (let e$2 = n$1; e$2 <= i$1; e$2++) {
						const n$2 = this.cells[t$2 * this.cellsX + e$2];
						if (n$2) for (let t$3 = 0; t$3 < n$2.len; t$3++) {
							const e$3 = this.payload[n$2.start + t$3], i$2 = Math.floor(e$3 / 8), s$2 = 1 << e$3 % 8;
							if (!(this.lookup[i$2] & s$2) && (this.lookup[i$2] |= s$2, r$1.push(e$3), r$1.length === this.triangleCount)) return;
						}
					}
				}
			}
			function Sp(t$1, e$1, r$1) {
				return Math.max(0, Math.min(r$1 - 1, Math.floor(t$1 * e$1)));
			}
			Qs(Mp, "TriangleGridIndex");
			class Pp {
				constructor(t$1) {
					this.zoom = t$1.zoom, this.layers = t$1.layers, this.layerIds = this.layers.map(((t$2) => t$2.fqid)), this.index = t$1.index, this.hasPattern = !1, this.stateDependentLayerIds = this.layers.filter(((t$2) => t$2.isStateDependent())).map(((t$2) => t$2.id)), this.footprints = [], this.worldview = t$1.worldview, this.hasAppearances = null;
				}
				updateFootprints(t$1, e$1) {
					for (const r$1 of this.footprints) e$1.push({
						footprint: r$1,
						id: t$1
					});
				}
				updateAppearances(t$1, e$1, r$1, n$1) {}
				populate(t$1, e$1, r$1, n$1) {
					const i$1 = [];
					for (const { feature: s$1, id: o$1, index: a$1, sourceLayerIndex: l$1 } of t$1) {
						const t$2 = this.layers[0]._featureFilter.needGeometry, u$1 = Bu(s$1, t$2);
						if (!this.layers[0]._featureFilter.filter(new Io(this.zoom, {
							worldview: this.worldview,
							activeFloors: e$1.activeFloors
						}), u$1, r$1)) continue;
						const c$1 = {
							id: o$1,
							properties: s$1.properties,
							type: s$1.type,
							sourceLayerIndex: l$1,
							index: a$1,
							geometry: t$2 ? u$1.geometry : ku(s$1, r$1, n$1),
							patterns: {}
						};
						i$1.push(c$1);
					}
					for (const n$2 of i$1) {
						const { geometry: i$2, index: s$1, sourceLayerIndex: o$1 } = n$2;
						this.addFeature(n$2, i$2, s$1, r$1, {}, e$1.availableImages, e$1.brightness), e$1.featureIndex.insert(t$1[s$1].feature, i$2, s$1, o$1, this.index);
					}
				}
				isEmpty() {
					return 0 === this.footprints.length;
				}
				uploadPending() {
					return !1;
				}
				upload(t$1) {}
				update(t$1, e$1, r$1, n$1, i$1, s$1, o$1) {}
				destroy() {}
				addFeature(t$1, e$1, r$1, n$1, i$1, s$1 = [], o$1) {
					for (const t$2 of rp(e$1, 2)) {
						const e$2 = [], r$2 = [], n$2 = [], i$2 = new It(Infinity, Infinity), s$2 = new It(-Infinity, -Infinity);
						for (const o$3 of t$2) if (0 !== o$3.length) {
							o$3 !== t$2[0] && n$2.push(r$2.length / 2);
							for (let t$3 = 0; t$3 < o$3.length; t$3++) r$2.push(o$3[t$3].x), r$2.push(o$3[t$3].y), e$2.push(o$3[t$3]), i$2.x = Math.min(i$2.x, o$3[t$3].x), i$2.y = Math.min(i$2.y, o$3[t$3].y), s$2.x = Math.max(s$2.x, o$3[t$3].x), s$2.y = Math.max(s$2.y, o$3[t$3].y);
						}
						const o$2 = zh(r$2, n$2), a$1 = new Mp(e$2, o$2, 8, 256);
						this.footprints.push({
							vertices: e$2,
							indices: o$2,
							grid: a$1,
							min: i$2,
							max: s$2
						});
					}
				}
			}
			Qs(Pp, "ClipBucket", { omit: ["layers"] });
			const kp = ha([{
				name: "a_pos_normal_ed",
				components: 4,
				type: "Int16"
			}]), Bp = ha([{
				name: "a_pos_end",
				components: 4,
				type: "Int16"
			}, {
				name: "a_angular_offset_factor",
				components: 1,
				type: "Int16"
			}]), zp = ha([{
				name: "a_flood_light_ground_radius",
				components: 1,
				type: "Float32"
			}]), Tp = ha([{
				name: "a_centroid_pos",
				components: 2,
				type: "Uint16"
			}]), Ep = ha([{
				name: "a_join_normal_inside",
				components: 3,
				type: "Int16"
			}]), Vp = ha([{
				name: "a_hidden_by_landmark",
				components: 1,
				type: "Uint8"
			}]), Fp = ha([{
				name: "a_pos_3",
				components: 3,
				type: "Int16"
			}, {
				name: "a_pos_normal_3",
				components: 3,
				type: "Int16"
			}]), { members: Cp } = kp, Dp = Number.MAX_SAFE_INTEGER, Rp = Dp - 1;
			function Lp(t$1, e$1, r$1, n$1) {
				return t$1.order < e$1 || t$1.order === Dp || !(t$1.clipMask & r$1) || function(t$2, e$2) {
					return 0 !== e$2.length && void 0 === e$2.find(((e$3) => e$3 === t$2));
				}(n$1, t$1.clipScope);
			}
			function Op(t$1, e$1) {
				return t$1.x - e$1.x || t$1.y - e$1.y;
			}
			function Up(t$1, e$1) {
				return 0 === Op(t$1.min, e$1.min) && 0 === Op(t$1.max, e$1.max);
			}
			function Np(t$1, e$1) {
				return !(t$1.min.x > e$1.max.x || t$1.max.x < e$1.min.x || t$1.min.y > e$1.max.y || t$1.max.y < e$1.min.y);
			}
			function jp(t$1, e$1) {
				if (t$1.length !== e$1.length) return !1;
				for (let r$1 = 0; r$1 < t$1.length; r$1++) if (t$1[r$1].sourceId !== e$1[r$1].sourceId || !Up(t$1[r$1], e$1[r$1]) || t$1[r$1].order !== e$1[r$1].order || t$1[r$1].clipMask !== e$1[r$1].clipMask || !Mt(t$1[r$1].clipScope, e$1[r$1].clipScope)) return !1;
				return !0;
			}
			function $p(t$1, e$1, r$1) {
				const n$1 = 1 / Un, i$1 = 1 / (1 << r$1.canonical.z), s$1 = (e$1.x * n$1 + r$1.canonical.x) * i$1 + r$1.wrap, o$1 = (e$1.y * n$1 + r$1.canonical.y) * i$1;
				return {
					min: new It((t$1.x * n$1 + r$1.canonical.x) * i$1 + r$1.wrap, (t$1.y * n$1 + r$1.canonical.y) * i$1),
					max: new It(s$1, o$1)
				};
			}
			function Gp(t$1, e$1, r$1) {
				const n$1 = 1 << r$1.canonical.z, i$1 = ((e$1.x - r$1.wrap) * n$1 - r$1.canonical.x) * Un, s$1 = (e$1.y * n$1 - r$1.canonical.y) * Un;
				return {
					min: new It(((t$1.x - r$1.wrap) * n$1 - r$1.canonical.x) * Un, (t$1.y * n$1 - r$1.canonical.y) * Un),
					max: new It(i$1, s$1)
				};
			}
			function qp(t$1, e$1, r$1, n$1, i$1, s$1, o$1) {
				const a$1 = t$1.indices, l$1 = t$1.vertices, u$1 = [];
				for (let c$1 = n$1; c$1 < n$1 + i$1; c$1 += 3) {
					const n$2 = e$1[r$1[c$1 + 0] + s$1], i$2 = e$1[r$1[c$1 + 1] + s$1], h$1 = e$1[r$1[c$1 + 2] + s$1], p$1 = Math.min(n$2.x, i$2.x, h$1.x), d$1 = Math.max(n$2.x, i$2.x, h$1.x), f$1 = Math.min(n$2.y, i$2.y, h$1.y), m$1 = Math.max(n$2.y, i$2.y, h$1.y);
					u$1.length = 0, t$1.grid.query(new It(p$1, f$1), new It(d$1, m$1), u$1);
					for (let t$2 = 0; t$2 < u$1.length; t$2++) {
						const e$2 = u$1[t$2];
						if (vc(l$1[a$1[3 * e$2 + 0]], l$1[a$1[3 * e$2 + 1]], l$1[a$1[3 * e$2 + 2]], n$2, i$2, h$1, o$1)) return !0;
					}
				}
				return !1;
			}
			function Hp(t$1, e$1, r$1, n$1) {
				if (!t$1 || !r$1) return !1;
				let i$1 = t$1.vertices;
				if (!e$1.canonical.equals(n$1.canonical) || e$1.wrap !== n$1.wrap) {
					if (r$1.vertices.length < t$1.vertices.length) return Hp(r$1, n$1, t$1, e$1);
					const s$1 = e$1.canonical, o$1 = n$1.canonical, a$1 = Math.pow(2, o$1.z - s$1.z);
					i$1 = t$1.vertices.map(((t$2) => new It((t$2.x + s$1.x * Un) * a$1 - o$1.x * Un, (t$2.y + s$1.y * Un) * a$1 - o$1.y * Un)));
				}
				return qp(r$1, i$1, t$1.indices, 0, t$1.indices.length, 0, 0);
			}
			function Xp(t$1, e$1, r$1, n$1) {
				const i$1 = Math.pow(2, n$1.z - r$1.z);
				return new It((t$1 + r$1.x * Un) * i$1 - n$1.x * Un, (e$1 + r$1.y * Un) * i$1 - n$1.y * Un);
			}
			function Zp(t$1, e$1) {
				const r$1 = [];
				e$1.grid.queryPoint(t$1, r$1);
				const n$1 = e$1.indices, i$1 = e$1.vertices;
				for (let e$2 = 0; e$2 < r$1.length; e$2++) {
					const s$1 = r$1[e$2];
					if (mc([
						i$1[n$1[3 * s$1 + 0]],
						i$1[n$1[3 * s$1 + 1]],
						i$1[n$1[3 * s$1 + 2]]
					], t$1)) return !0;
				}
				return !1;
			}
			const Wp = [
				new It(0, 0),
				new It(Un, 0),
				new It(Un, Un),
				new It(0, Un)
			];
			function Yp(t$1, e$1) {
				const r$1 = [];
				let n$1 = [];
				if (!e$1 || t$1.length < 2) return [t$1];
				if (2 === t$1.length) return gc(t$1[0], t$1[1], Wp) ? [t$1] : [];
				for (let e$2 = 0; e$2 < t$1.length + 2; e$2++) {
					const i$1 = t$1[e$2 % t$1.length], s$1 = t$1[(e$2 + 1) % t$1.length], o$1 = gc(0 === e$2 ? t$1[t$1.length - 1] : t$1[(e$2 - 1) % t$1.length], i$1, Wp), a$1 = gc(i$1, s$1, Wp), l$1 = o$1 || a$1;
					l$1 && n$1.push(i$1), l$1 && a$1 || n$1.length > 0 && (n$1.length > 1 && r$1.push(n$1), n$1 = []);
				}
				return n$1.length > 1 && r$1.push(n$1), r$1;
			}
			const Kp = zu.types, Jp = [
				"fill-extrusion-base",
				"fill-extrusion-height",
				"fill-extrusion-color",
				"fill-extrusion-pattern",
				"fill-extrusion-flood-light-wall-radius",
				"fill-extrusion-line-width",
				"fill-extrusion-emissive-strength"
			], Qp = ["fill-extrusion-flood-light-ground-radius"], td = Math.pow(2, 13), ed = Math.pow(2, 15) - 1, rd = new It(0, 1), nd = 2147483648, id = 7, sd = 450;
			function od(t$1, e$1, r$1, n$1, i$1, s$1, o$1, a$1) {
				t$1.emplaceBack((e$1 << 1) + o$1, (r$1 << 1) + s$1, (Math.floor(n$1 * td) << 1) + i$1, Math.round(a$1));
			}
			function ad(t$1, e$1, r$1) {
				t$1.emplaceBack(e$1.x * Un, e$1.y * Un, r$1 ? 1 : 0);
			}
			function ld(t$1, e$1, r$1, n$1, i$1, s$1) {
				t$1.emplaceBack(e$1.x, e$1.y, (r$1.x << 1) + n$1, (r$1.y << 1) + i$1, s$1);
			}
			function ud(t$1, e$1, r$1) {
				const n$1 = 16384;
				t$1.emplaceBack(e$1.x, e$1.y, e$1.z, r$1[0] * n$1, r$1[1] * n$1, r$1[2] * n$1);
			}
			class cd {
				constructor() {
					this.vertexOffset = 0, this.vertexCount = 0, this.indexOffset = 0, this.indexCount = 0;
				}
			}
			class hd {
				constructor() {
					this.centroidXY = new It(0, 0), this.vertexArrayOffset = 0, this.vertexCount = 0, this.groundVertexArrayOffset = 0, this.groundVertexCount = 0, this.flags = 0, this.footprintSegIdx = -1, this.footprintSegLen = 0, this.polygonSegIdx = -1, this.polygonSegLen = 0, this.min = new It(Number.MAX_VALUE, Number.MAX_VALUE), this.max = new It(-Number.MAX_VALUE, -Number.MAX_VALUE), this.height = 0, this.buildingId = 0;
				}
				span() {
					return new It(this.max.x - this.min.x, this.max.y - this.min.y);
				}
			}
			class pd {
				constructor() {
					this.acc = new It(0, 0), this.accCount = 0, this.centroidDataIndex = 0;
				}
				startRing(t$1, e$1) {
					t$1.min.x === Number.MAX_VALUE && (t$1.min.x = t$1.max.x = e$1.x, t$1.min.y = t$1.max.y = e$1.y);
				}
				appendEdge(t$1, e$1, r$1) {
					this.accCount++, this.acc._add(e$1);
					let n$1 = !!this.borders;
					e$1.x < t$1.min.x ? (t$1.min.x = e$1.x, n$1 = !0) : e$1.x > t$1.max.x && (t$1.max.x = e$1.x, n$1 = !0), e$1.y < t$1.min.y ? (t$1.min.y = e$1.y, n$1 = !0) : e$1.y > t$1.max.y && (t$1.max.y = e$1.y, n$1 = !0), ((0 === e$1.x || e$1.x === Un) && e$1.x === r$1.x) != ((0 === e$1.y || e$1.y === Un) && e$1.y === r$1.y) && this.processBorderOverlap(e$1, r$1), n$1 && this.checkBorderIntersection(e$1, r$1);
				}
				checkBorderIntersection(t$1, e$1) {
					e$1.x < 0 != t$1.x < 0 && this.addBorderIntersection(0, pr(e$1.y, t$1.y, (0 - e$1.x) / (t$1.x - e$1.x))), e$1.x > Un != t$1.x > Un && this.addBorderIntersection(1, pr(e$1.y, t$1.y, (Un - e$1.x) / (t$1.x - e$1.x))), e$1.y < 0 != t$1.y < 0 && this.addBorderIntersection(2, pr(e$1.x, t$1.x, (0 - e$1.y) / (t$1.y - e$1.y))), e$1.y > Un != t$1.y > Un && this.addBorderIntersection(3, pr(e$1.x, t$1.x, (Un - e$1.y) / (t$1.y - e$1.y)));
				}
				addBorderIntersection(t$1, e$1) {
					this.borders || (this.borders = [
						[Number.MAX_VALUE, -Number.MAX_VALUE],
						[Number.MAX_VALUE, -Number.MAX_VALUE],
						[Number.MAX_VALUE, -Number.MAX_VALUE],
						[Number.MAX_VALUE, -Number.MAX_VALUE]
					]);
					const r$1 = this.borders[t$1];
					e$1 < r$1[0] && (r$1[0] = e$1), e$1 > r$1[1] && (r$1[1] = e$1);
				}
				processBorderOverlap(t$1, e$1) {
					if (t$1.x === e$1.x) {
						if (t$1.y === e$1.y) return;
						const r$1 = 0 === t$1.x ? 0 : 1;
						this.addBorderIntersection(r$1, e$1.y), this.addBorderIntersection(r$1, t$1.y);
					} else {
						const r$1 = 0 === t$1.y ? 2 : 3;
						this.addBorderIntersection(r$1, e$1.x), this.addBorderIntersection(r$1, t$1.x);
					}
				}
				centroid() {
					return 0 === this.accCount ? new It(0, 0) : new It(Math.floor(Math.max(0, this.acc.x) / this.accCount), Math.floor(Math.max(0, this.acc.y) / this.accCount));
				}
				intersectsCount() {
					return this.borders ? this.borders.reduce(((t$1, e$1) => t$1 + +(e$1[0] !== Number.MAX_VALUE)), 0) : 0;
				}
			}
			function dd(t$1, e$1) {
				const r$1 = t$1.add(e$1)._unit(), n$1 = Ft(t$1.x * r$1.x + t$1.y * r$1.y, -1, 1);
				var i$1, s$1, o$1;
				return i$1 = Math.acos(n$1), Math.min(4, Math.max(-4, Math.tan(i$1))) / 4 * ed * ((s$1 = t$1).x * (o$1 = e$1).y - s$1.y * o$1.x < 0 ? -1 : 1);
			}
			const fd = [
				(t$1) => t$1.x < 0,
				(t$1) => t$1.x > Un,
				(t$1) => t$1.y < 0,
				(t$1) => t$1.y > Un
			];
			function md(t$1, e$1, r$1, n$1) {
				const i$1 = [4];
				if (0 === n$1) return i$1;
				r$1._mult(n$1);
				const a$1 = [
					t$1,
					e$1,
					t$1.sub(r$1),
					e$1.sub(r$1)
				];
				for (let t$2 = 0; t$2 < 4; t$2++) for (const e$2 of a$1) if (fd[t$2](e$2)) {
					i$1.push(t$2);
					break;
				}
				return i$1;
			}
			class yd {
				constructor(t$1) {
					this.groundRadiusArray = null, this.groundRadiusBuffer = null, this.vertexArray = new va(), this.indexArray = new Fa(), this.programConfigurations = new Ul(t$1.layers, {
						zoom: t$1.zoom,
						lut: t$1.lut
					}, ((t$2) => Qp.includes(t$2))), this._segments = new hl(), this.hiddenByLandmarkVertexArray = new Za(), this._segmentToGroundQuads = {}, this._segmentToGroundQuads[0] = [], this._segmentToRegionTriCounts = {}, this._segmentToRegionTriCounts[0] = [
						0,
						0,
						0,
						0,
						0
					], this.regionSegments = {}, this.regionSegments[4] = new hl();
				}
				getDefaultSegment() {
					return this.regionSegments[4];
				}
				hasData() {
					return 0 !== this.vertexArray.length;
				}
				addData(t$1, e$1, r$1, n$1 = !1) {
					const i$1 = t$1.length;
					if (i$1 > 2) {
						let s$1 = Math.max(0, this._segments.get().length - 1);
						const o$1 = this._segments._prepareSegment(4 * i$1, this.vertexArray.length, 2 * this._segmentToGroundQuads[s$1].length);
						let a$1;
						s$1 !== this._segments.get().length - 1 && (s$1++, this._segmentToGroundQuads[s$1] = [], this._segmentToRegionTriCounts[s$1] = [
							0,
							0,
							0,
							0,
							0
						]);
						{
							const e$2 = t$1[0], r$2 = t$1[1];
							a$1 = dd(e$2.sub(t$1[i$1 - 1])._perp()._unit(), r$2.sub(e$2)._perp()._unit());
						}
						for (let l$1 = 0; l$1 < i$1; l$1++) {
							const u$1 = l$1 === i$1 - 1 ? 0 : l$1 + 1, c$1 = t$1[l$1], h$1 = t$1[u$1], p$1 = t$1[u$1 === i$1 - 1 ? 0 : u$1 + 1], d$1 = h$1.sub(c$1)._perp()._unit(), f$1 = dd(d$1, p$1.sub(h$1)._perp()._unit()), m$1 = a$1, y$1 = f$1;
							if (wd(c$1, h$1, e$1) || n$1 && _d(c$1, e$1) && _d(h$1, e$1)) {
								a$1 = f$1;
								continue;
							}
							const g$1 = o$1.vertexLength;
							ld(this.vertexArray, c$1, h$1, 1, 1, m$1), ld(this.vertexArray, c$1, h$1, 1, 0, m$1), ld(this.vertexArray, c$1, h$1, 0, 1, y$1), ld(this.vertexArray, c$1, h$1, 0, 0, y$1), o$1.vertexLength += 4;
							const x$1 = md(c$1, h$1, d$1, r$1);
							for (const t$2 of x$1) this._segmentToGroundQuads[s$1].push({
								id: g$1,
								region: t$2
							}), this._segmentToRegionTriCounts[s$1][t$2] += 2, o$1.primitiveLength += 2;
							a$1 = f$1;
						}
					}
				}
				prepareBorderSegments() {
					if (!this.hasData()) return;
					const t$1 = this._segments.get(), e$1 = t$1.length;
					for (let t$2 = 0; t$2 < e$1; t$2++) this._segmentToGroundQuads[t$2].sort(((t$3, e$2) => t$3.region - e$2.region));
					for (let r$1 = 0; r$1 < e$1; r$1++) {
						const e$2 = this._segmentToGroundQuads[r$1], n$1 = t$1[r$1], i$1 = this._segmentToRegionTriCounts[r$1];
						i$1.reduce(((t$2, e$3) => t$2 + e$3), 0);
						let s$1 = 0;
						for (let t$2 = 0; t$2 <= 4; t$2++) {
							const e$3 = i$1[t$2];
							if (0 !== e$3) {
								let r$2 = this.regionSegments[t$2];
								r$2 || (r$2 = this.regionSegments[t$2] = new hl());
								const i$2 = {
									vertexOffset: n$1.vertexOffset,
									primitiveOffset: n$1.primitiveOffset + s$1,
									vertexLength: n$1.vertexLength,
									primitiveLength: e$3
								};
								r$2.get().push(i$2);
							}
							s$1 += e$3;
						}
						for (let t$2 = 0; t$2 < e$2.length; t$2++) {
							const r$2 = e$2[t$2].id;
							this.indexArray.emplaceBack(r$2, r$2 + 1, r$2 + 3), this.indexArray.emplaceBack(r$2, r$2 + 3, r$2 + 2);
						}
					}
					this._segmentToGroundQuads = null, this._segmentToRegionTriCounts = null, this._segments.destroy(), this._segments = null;
				}
				addPaintPropertiesData(t$1, e$1, r$1, n$1, i$1, s$1, o$1) {
					this.hasData() && this.programConfigurations.populatePaintArrays(this.vertexArray.length, t$1, e$1, r$1, n$1, i$1, s$1, void 0, o$1);
				}
				upload(t$1) {
					this.hasData() && (this.vertexBuffer = t$1.createVertexBuffer(this.vertexArray, Bp.members), this.indexBuffer = t$1.createIndexBuffer(this.indexArray), null != this.groundRadiusArray && (this.groundRadiusBuffer = t$1.createVertexBuffer(this.groundRadiusArray, zp.members)));
				}
				uploadPaintProperties(t$1) {
					this.hasData() && this.programConfigurations.upload(t$1);
				}
				update(t$1, e$1, r$1, n$1, i$1, s$1, o$1, a$1) {
					this.hasData() && this.programConfigurations.updatePaintArrays(t$1, e$1, r$1, n$1, i$1, s$1, o$1, a$1);
				}
				updateHiddenByLandmark(t$1) {
					this.updateHiddenByLandmarkRange(t$1.groundVertexArrayOffset, t$1.groundVertexCount, !!(t$1.flags & nd));
				}
				updateHiddenByLandmarkRange(t$1, e$1, r$1) {
					if (!this.hasData()) return;
					const n$1 = e$1 + t$1;
					if (0 !== e$1) {
						for (let e$2 = t$1; e$2 < n$1; ++e$2) this.hiddenByLandmarkVertexArray.emplace(e$2, r$1 ? 1 : 0);
						this._needsHiddenByLandmarkUpdate = !0;
					}
				}
				uploadHiddenByLandmark(t$1) {
					this.hasData() && this._needsHiddenByLandmarkUpdate && (!this.hiddenByLandmarkVertexBuffer && this.hiddenByLandmarkVertexArray.length > 0 ? this.hiddenByLandmarkVertexBuffer = t$1.createVertexBuffer(this.hiddenByLandmarkVertexArray, Vp.members, !0) : this.hiddenByLandmarkVertexBuffer && this.hiddenByLandmarkVertexBuffer.updateData(this.hiddenByLandmarkVertexArray), this._needsHiddenByLandmarkUpdate = !1);
				}
				destroy() {
					if (this.vertexBuffer) {
						this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.hiddenByLandmarkVertexBuffer && this.hiddenByLandmarkVertexBuffer.destroy(), this.groundRadiusBuffer && this.groundRadiusBuffer.destroy(), this._segments && this._segments.destroy(), this.programConfigurations.destroy();
						for (let t$1 = 0; t$1 <= 4; t$1++) {
							const e$1 = this.regionSegments[t$1];
							e$1 && e$1.destroy();
						}
					}
				}
			}
			class gd {
				constructor(t$1) {
					this.zoom = t$1.zoom, this.canonical = t$1.canonical, this.overscaling = t$1.overscaling, this.layers = t$1.layers, this.pixelRatio = t$1.pixelRatio, this.layerIds = this.layers.map(((t$2) => t$2.fqid)), this.index = t$1.index, this.hasPattern = !1, this.edgeRadius = 0, this.projection = t$1.projection, this.activeReplacements = [], this.replacementUpdateTime = 0, this.centroidData = [], this.footprintIndices = new Fa(), this.footprintVertices = new da(), this.footprintSegments = [], this.layoutVertexArray = new ma(), this.centroidVertexArray = new sl(), this.wallVertexArray = new al(), this.indexArray = new Fa(), this.programConfigurations = new Ul(t$1.layers, {
						zoom: t$1.zoom,
						lut: t$1.lut
					}, ((t$2) => Jp.includes(t$2))), this.segments = new hl(), this.stateDependentLayerIds = this.layers.filter(((t$2) => t$2.isStateDependent())).map(((t$2) => t$2.id)), this.groundEffect = new yd(t$1), this.maxHeight = 0, this.partLookup = {}, this.triangleSubSegments = [], this.polygonSegments = [], this.worldview = t$1.worldview, this.hasAppearances = null;
				}
				updateFootprints(t$1, e$1) {}
				updateAppearances(t$1, e$1, r$1, n$1) {}
				populate(t$1, e$1, r$1, n$1) {
					this.features = [], this.hasPattern = sp("fill-extrusion", this.layers, this.pixelRatio, e$1), this.featuresOnBorder = [], this.borderFeatureIndices = [
						[],
						[],
						[],
						[]
					], this.borderDoneWithNeighborZ = [
						-1,
						-1,
						-1,
						-1
					], this.selfDEMTileTimestamp = Number.MAX_VALUE, this.borderDEMTileTimestamp = [
						Number.MAX_VALUE,
						Number.MAX_VALUE,
						Number.MAX_VALUE,
						Number.MAX_VALUE
					], this.tileToMeter = vu(r$1), this.edgeRadius = this.layers[0].layout.get("fill-extrusion-edge-radius") / this.tileToMeter, this.wallMode = 0 !== this.layers[0].paint.get("fill-extrusion-line-width").constantOr(1);
					for (const { feature: i$1, id: s$1, index: o$1, sourceLayerIndex: a$1 } of t$1) {
						const t$2 = this.layers[0]._featureFilter.needGeometry, l$1 = Bu(i$1, t$2);
						if (!this.layers[0]._featureFilter.filter(new Io(this.zoom, {
							worldview: this.worldview,
							activeFloors: e$1.activeFloors
						}), l$1, r$1)) continue;
						const u$1 = {
							id: s$1,
							sourceLayerIndex: a$1,
							index: o$1,
							geometry: t$2 ? l$1.geometry : ku(i$1, r$1, n$1),
							properties: i$1.properties,
							type: i$1.type,
							patterns: {}
						}, c$1 = this.layoutVertexArray.length, h$1 = "Polygon" === Kp[u$1.type];
						if (this.hasPattern) this.features.push({
							featureId: i$1.id,
							feature: op("fill-extrusion", this.layers, u$1, this.zoom, this.pixelRatio, e$1)
						});
						else if (this.wallMode) for (const t$3 of u$1.geometry) for (const s$2 of Yp(t$3, h$1)) this.addFeature(i$1.id, u$1, [s$2], o$1, r$1, {}, e$1.availableImages, n$1, e$1.brightness);
						else this.addFeature(i$1.id, u$1, u$1.geometry, o$1, r$1, {}, e$1.availableImages, n$1, e$1.brightness);
						e$1.featureIndex.insert(i$1, u$1.geometry, o$1, a$1, this.index, c$1);
					}
					this.sortBorders(), "mercator" === this.projection.name && this.splitToSubtiles(), this.groundEffect.prepareBorderSegments(), this.polygonSegments.length = 0;
				}
				addFeatures(t$1, e$1, r$1, n$1, i$1, s$1) {
					for (const { featureId: t$2, feature: o$1 } of this.features) {
						const a$1 = "Polygon" === Kp[o$1.type], { geometry: l$1 } = o$1;
						if (this.wallMode) for (const u$1 of l$1) for (const l$2 of Yp(u$1, a$1)) this.addFeature(t$2, o$1, [l$2], o$1.index, e$1, r$1, n$1, i$1, s$1);
						else this.addFeature(t$2, o$1, l$1, o$1.index, e$1, r$1, n$1, i$1, s$1);
					}
					this.sortBorders(), "mercator" === this.projection.name && this.splitToSubtiles();
				}
				update(t$1, e$1, r$1, n$1, i$1, s$1, o$1) {
					this.programConfigurations.updatePaintArrays(t$1, e$1, i$1, r$1, n$1, s$1, o$1, this.worldview), this.groundEffect.update(t$1, e$1, i$1, r$1, n$1, s$1, o$1, this.worldview);
				}
				isEmpty() {
					return 0 === this.layoutVertexArray.length;
				}
				uploadPending() {
					return !this.uploaded || this.programConfigurations.needsUpload || this.groundEffect.programConfigurations.needsUpload;
				}
				upload(t$1) {
					this.uploaded || (this.layoutVertexBuffer = t$1.createVertexBuffer(this.layoutVertexArray, Cp), this.indexBuffer = t$1.createIndexBuffer(this.indexArray), this.wallVertexBuffer = t$1.createVertexBuffer(this.wallVertexArray, Ep.members), this.layoutVertexExtArray && (this.layoutVertexExtBuffer = t$1.createVertexBuffer(this.layoutVertexExtArray, Fp.members, !0)), this.groundEffect.upload(t$1)), this.groundEffect.uploadPaintProperties(t$1), this.programConfigurations.upload(t$1), this.uploaded = !0;
				}
				uploadCentroid(t$1) {
					this.groundEffect.uploadHiddenByLandmark(t$1), this.needsCentroidUpdate && (!this.centroidVertexBuffer && this.centroidVertexArray.length > 0 ? this.centroidVertexBuffer = t$1.createVertexBuffer(this.centroidVertexArray, Tp.members, !0) : this.centroidVertexBuffer && this.centroidVertexBuffer.updateData(this.centroidVertexArray), this.needsCentroidUpdate = !1);
				}
				destroy() {
					this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.centroidVertexBuffer && this.centroidVertexBuffer.destroy(), this.layoutVertexExtBuffer && this.layoutVertexExtBuffer.destroy(), this.groundEffect.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
				}
				addFeature(t$1, e$1, r$1, n$1, i$1, s$1, o$1, a$1, l$1) {
					const u$1 = this.layers[0].paint.get("fill-extrusion-flood-light-ground-radius").evaluate(e$1, {}) / this.tileToMeter, c$1 = [new It(0, 0), new It(Un, Un)], h$1 = a$1.projection, p$1 = "globe" === h$1.name, d$1 = this.wallMode || "Polygon" === Kp[e$1.type], f$1 = new pd();
					f$1.centroidDataIndex = this.centroidData.length;
					const m$1 = new hd();
					m$1.buildingId = t$1, e$1.properties && e$1.properties.hasOwnProperty("building_id") && (m$1.buildingId = e$1.properties.building_id);
					const y$1 = this.layers[0].paint.get("fill-extrusion-base").evaluate(e$1, {}, i$1) <= 0, g$1 = this.layers[0].paint.get("fill-extrusion-height").evaluate(e$1, {}, i$1);
					let x$1;
					if (m$1.height = g$1, m$1.vertexArrayOffset = this.layoutVertexArray.length, m$1.groundVertexArrayOffset = this.groundEffect.vertexArray.length, p$1 && !this.layoutVertexExtArray && (this.layoutVertexExtArray = new Ia()), this.wallMode) {
						if (p$1) return void Xt("Non zero fill-extrusion-line-width is not yet supported on globe.");
						if (1 !== r$1.length) return;
						x$1 = function(t$2) {
							const e$2 = t$2[0].x === t$2[t$2.length - 1].x && t$2[0].y === t$2[t$2.length - 1].y;
							(function(t$3) {
								let e$3 = 0;
								const r$2 = t$3.length;
								for (let n$3 = 0; n$3 < r$2; n$3++) e$3 += (t$3[(n$3 + 1) % r$2].x - t$3[n$3].x) * (t$3[(n$3 + 1) % r$2].y + t$3[n$3].y);
								return e$3 >= 0;
							})(t$2) || (t$2 = t$2.reverse());
							const n$2 = {
								geometry: [],
								joinNormals: [],
								indices: []
							}, i$2 = [], s$2 = [], o$2 = [];
							let a$2 = t$2.length;
							for (; a$2 >= 2 && t$2[a$2 - 1].equals(t$2[a$2 - 2]);) a$2--;
							if (a$2 < (e$2 ? 3 : 2)) return n$2;
							let l$2, u$2, c$2, h$2, p$2, d$2 = 0;
							for (; d$2 < a$2 - 1 && t$2[d$2].equals(t$2[d$2 + 1]);) d$2++;
							e$2 && (l$2 = t$2[a$2 - 2], p$2 = t$2[d$2].sub(l$2)._unit()._perp());
							for (let r$2 = d$2; r$2 < a$2; r$2++) {
								if (c$2 = r$2 === a$2 - 1 ? e$2 ? t$2[d$2 + 1] : void 0 : t$2[r$2 + 1], c$2 && t$2[r$2].equals(c$2)) continue;
								p$2 && (h$2 = p$2), l$2 && (u$2 = l$2), l$2 = t$2[r$2], p$2 = c$2 ? c$2.sub(l$2)._unit()._perp() : h$2, h$2 = h$2 || p$2;
								let n$3 = h$2.add(p$2);
								0 === n$3.x && 0 === n$3.y || n$3._unit();
								const f$3 = n$3.x * p$2.x + n$3.y * p$2.y, m$2 = 0 !== f$3 ? 1 / f$3 : Infinity, y$2 = h$2.x * p$2.y - h$2.y * p$2.x > 0;
								let g$2 = "miter";
								const x$2 = 2;
								"miter" === g$2 && m$2 > x$2 && (g$2 = "bevel"), "bevel" === g$2 && (m$2 > 100 && (g$2 = "flipbevel"), m$2 < x$2 && (g$2 = "miter"));
								const v$2 = (t$3, e$3, r$3, n$4) => {
									const a$3 = new It(t$3.x, t$3.y), l$3 = new It(t$3.x, t$3.y);
									a$3.x += e$3.x * n$4, a$3.y += e$3.y * n$4, l$3.x -= e$3.x * Math.max(r$3, 1), l$3.y -= e$3.y * Math.max(r$3, 1), o$2.push(e$3), i$2.push(a$3), s$2.push(l$3);
								};
								if ("miter" === g$2) n$3._mult(m$2), v$2(l$2, n$3, 0, 0);
								else if ("flipbevel" === g$2) n$3 = p$2.mult(-1), v$2(l$2, n$3, 0, 0), v$2(l$2, n$3.mult(-1), 0, 0);
								else {
									const t$3 = -Math.sqrt(m$2 * m$2 - 1), e$3 = y$2 ? t$3 : 0, r$3 = y$2 ? 0 : t$3;
									u$2 && v$2(l$2, h$2, e$3, r$3), c$2 && v$2(l$2, p$2, e$3, r$3);
								}
							}
							n$2.geometry = [
								...i$2,
								...s$2.reverse(),
								i$2[0]
							], n$2.joinNormals = [
								...o$2,
								...o$2.reverse(),
								o$2[o$2.length - 1]
							];
							const f$2 = n$2.geometry.length - 1;
							for (let t$3 = 0; t$3 < f$2 / 2; t$3++) if (t$3 + 1 < f$2 / 2) {
								let e$3 = t$3, r$2 = t$3 + 1, i$3 = f$2 - 1 - t$3, s$3 = f$2 - 2 - t$3;
								e$3 = 0 === e$3 ? f$2 - 1 : e$3 - 1, r$2 = 0 === r$2 ? f$2 - 1 : r$2 - 1, i$3 = 0 === i$3 ? f$2 - 1 : i$3 - 1, s$3 = 0 === s$3 ? f$2 - 1 : s$3 - 1, n$2.indices.push(i$3), n$2.indices.push(r$2), n$2.indices.push(e$3), n$2.indices.push(i$3), n$2.indices.push(s$3), n$2.indices.push(r$2);
							}
							return n$2;
						}(r$1[0]), r$1 = [x$1.geometry];
					}
					const v$1 = (t$2, e$2) => t$2 < (e$2.length - 1) / 2 || t$2 === e$2.length - 1, b$1 = this.wallMode ? [r$1] : rp(r$1, 500);
					for (let t$2 = b$1.length - 1; t$2 >= 0; t$2--) {
						const e$2 = b$1[t$2];
						(0 === e$2.length || (w$1 = e$2[0]).every(((t$3) => t$3.x <= 0)) || w$1.every(((t$3) => t$3.x >= Un)) || w$1.every(((t$3) => t$3.y <= 0)) || w$1.every(((t$3) => t$3.y >= Un))) && b$1.splice(t$2, 1);
					}
					var w$1;
					let _$1;
					if (p$1) _$1 = Sd(b$1, c$1, i$1);
					else {
						_$1 = [];
						for (const t$2 of b$1) _$1.push({
							polygon: t$2,
							bounds: c$1
						});
					}
					const A$1 = d$1 ? this.edgeRadius : 0, I$1 = A$1 > 0 && this.zoom < 17, M$1 = (t$2, e$2) => {
						if (0 === t$2.length) return !1;
						const r$2 = t$2[t$2.length - 1];
						return e$2.x === r$2.x && e$2.y === r$2.y;
					};
					for (const { polygon: t$2, bounds: e$2 } of _$1) {
						let r$2 = 0, n$2 = 0;
						for (const e$3 of t$2) d$1 && !e$3[0].equals(e$3[e$3.length - 1]) && e$3.push(e$3[0]), n$2 += d$1 ? e$3.length - 1 : e$3.length;
						const s$2 = this.segments.prepareSegment((d$1 ? 5 : 4) * n$2, this.layoutVertexArray, this.indexArray);
						m$1.footprintSegIdx < 0 && (m$1.footprintSegIdx = this.footprintSegments.length), m$1.polygonSegIdx < 0 && (m$1.polygonSegIdx = this.polygonSegments.length);
						const o$2 = {
							triangleArrayOffset: this.indexArray.length,
							triangleCount: 0,
							triangleSegIdx: this.segments.segments.length - 1
						}, a$2 = new cd();
						if (a$2.vertexOffset = this.footprintVertices.length, a$2.indexOffset = 3 * this.footprintIndices.length, a$2.ringIndices = [], d$1) {
							const n$3 = [], o$3 = [];
							r$2 = s$2.vertexLength;
							for (let r$3 = 0; r$3 < t$2.length; r$3++) {
								const l$3 = t$2[r$3];
								l$3.length && 0 !== r$3 && o$3.push(n$3.length / 2);
								const c$2 = [];
								let d$2, f$2;
								d$2 = l$3[1].sub(l$3[0])._perp()._unit(), a$2.ringIndices.push(l$3.length - 1);
								for (let t$3 = 1; t$3 < l$3.length; t$3++) {
									const e$3 = l$3[t$3], r$4 = l$3[t$3 === l$3.length - 1 ? 1 : t$3 + 1], o$4 = e$3.clone();
									if (A$1) {
										f$2 = r$4.sub(e$3)._perp()._unit();
										const t$4 = d$2.add(f$2)._unit(), n$4 = A$1 * Math.min(4, 1 / (d$2.x * t$4.x + d$2.y * t$4.y));
										o$4.x += n$4 * t$4.x, o$4.y += n$4 * t$4.y, o$4.x = Math.round(o$4.x), o$4.y = Math.round(o$4.y), d$2 = f$2;
									}
									if (!y$1 || 0 !== A$1 && !I$1 || M$1(c$2, o$4) || c$2.push(o$4), od(this.layoutVertexArray, o$4.x, o$4.y, 0, 0, 1, 1, 0), this.wallMode) {
										const e$4 = v$1(t$3, l$3);
										ad(this.wallVertexArray, x$1.joinNormals[t$3], !e$4);
									}
									s$2.vertexLength++, this.footprintVertices.emplaceBack(e$3.x, e$3.y), n$3.push(e$3.x, e$3.y), p$1 && ud(this.layoutVertexExtArray, h$1.projectTilePoint(o$4.x, o$4.y, i$1), h$1.upVector(i$1, o$4.x, o$4.y));
								}
								y$1 && (0 === A$1 || I$1) && (0 !== c$2.length && M$1(c$2, c$2[0]) && c$2.pop(), this.groundEffect.addData(c$2, e$2, u$1));
							}
							const l$2 = this.wallMode ? x$1.indices : zh(n$3, o$3);
							for (let t$3 = 0; t$3 < l$2.length; t$3 += 3) this.footprintIndices.emplaceBack(a$2.vertexOffset + l$2[t$3 + 0], a$2.vertexOffset + l$2[t$3 + 1], a$2.vertexOffset + l$2[t$3 + 2]), this.indexArray.emplaceBack(r$2 + l$2[t$3], r$2 + l$2[t$3 + 2], r$2 + l$2[t$3 + 1]), s$2.primitiveLength++;
							a$2.indexCount += l$2.length, a$2.vertexCount += this.footprintVertices.length - a$2.vertexOffset;
						}
						for (let n$3 = 0; n$3 < t$2.length; n$3++) {
							const o$3 = t$2[n$3];
							f$1.startRing(m$1, o$3[0]);
							let a$3 = o$3.length > 4 && Ad(o$3[o$3.length - 2], o$3[0], o$3[1]), l$2 = A$1 ? vd(o$3[o$3.length - 2], o$3[0], o$3[1], A$1) : 0;
							const c$2 = [];
							let g$2, b$2, w$2;
							b$2 = o$3[1].sub(o$3[0])._perp()._unit();
							let _$2 = !0;
							for (let t$3 = 1, n$4 = 0; t$3 < o$3.length; t$3++) {
								let u$2 = o$3[t$3 - 1], d$2 = o$3[t$3];
								const I$2 = o$3[t$3 === o$3.length - 1 ? 1 : t$3 + 1];
								if (f$1.appendEdge(m$1, d$2, u$2), wd(d$2, u$2, e$2)) {
									A$1 && (b$2 = I$2.sub(d$2)._perp()._unit(), _$2 = !_$2);
									continue;
								}
								const S$1 = d$2.sub(u$2)._perp(), P$1 = S$1.x / (Math.abs(S$1.x) + Math.abs(S$1.y)), k$1 = S$1.y > 0 ? 1 : 0, B$1 = u$2.dist(d$2);
								if (n$4 + B$1 > 32768 && (n$4 = 0), A$1) {
									w$2 = I$2.sub(d$2)._perp()._unit();
									let t$4 = bd(u$2, d$2, I$2, xd(b$2, w$2), A$1);
									isNaN(t$4) && (t$4 = 0);
									const e$3 = d$2.sub(u$2)._unit();
									u$2 = u$2.add(e$3.mult(l$2))._round(), d$2 = d$2.add(e$3.mult(-t$4))._round(), l$2 = t$4, b$2 = w$2, y$1 && this.zoom >= 17 && (M$1(c$2, u$2) || c$2.push(u$2), M$1(c$2, d$2) || c$2.push(d$2));
								}
								const z$1 = s$2.vertexLength, T$1 = o$3.length > 4 && Ad(u$2, d$2, I$2);
								let E$1 = Id(n$4, a$3, _$2);
								if (od(this.layoutVertexArray, u$2.x, u$2.y, P$1, k$1, 0, 0, E$1), od(this.layoutVertexArray, u$2.x, u$2.y, P$1, k$1, 0, 1, E$1), this.wallMode) {
									const e$3 = v$1(t$3 - 1, o$3), r$3 = x$1.joinNormals[t$3 - 1];
									ad(this.wallVertexArray, r$3, e$3), ad(this.wallVertexArray, r$3, e$3);
								}
								if (n$4 += B$1, E$1 = Id(n$4, T$1, !_$2), a$3 = T$1, od(this.layoutVertexArray, d$2.x, d$2.y, P$1, k$1, 0, 0, E$1), od(this.layoutVertexArray, d$2.x, d$2.y, P$1, k$1, 0, 1, E$1), this.wallMode) {
									const e$3 = v$1(t$3, o$3), r$3 = x$1.joinNormals[t$3];
									ad(this.wallVertexArray, r$3, e$3), ad(this.wallVertexArray, r$3, e$3);
								}
								if (s$2.vertexLength += 4, this.indexArray.emplaceBack(z$1 + 0, z$1 + 1, z$1 + 2), this.indexArray.emplaceBack(z$1 + 1, z$1 + 3, z$1 + 2), s$2.primitiveLength += 2, A$1) {
									const n$5 = r$2 + (1 === t$3 ? o$3.length - 2 : t$3 - 2), i$2 = 1 === t$3 ? r$2 : n$5 + 1;
									if (this.indexArray.emplaceBack(z$1 + 1, n$5, z$1 + 3), this.indexArray.emplaceBack(n$5, i$2, z$1 + 3), s$2.primitiveLength += 2, void 0 === g$2 && (g$2 = z$1), !wd(I$2, o$3[t$3], e$2)) {
										const e$3 = t$3 === o$3.length - 1 ? g$2 : s$2.vertexLength;
										this.indexArray.emplaceBack(z$1 + 2, z$1 + 3, e$3), this.indexArray.emplaceBack(z$1 + 3, e$3 + 1, e$3), this.indexArray.emplaceBack(z$1 + 3, i$2, e$3 + 1), s$2.primitiveLength += 3;
									}
									_$2 = !_$2;
								}
								if (p$1) {
									const t$4 = this.layoutVertexExtArray, e$3 = h$1.projectTilePoint(u$2.x, u$2.y, i$1), r$3 = h$1.projectTilePoint(d$2.x, d$2.y, i$1), n$5 = h$1.upVector(i$1, u$2.x, u$2.y), s$3 = h$1.upVector(i$1, d$2.x, d$2.y);
									ud(t$4, e$3, n$5), ud(t$4, e$3, n$5), ud(t$4, r$3, s$3), ud(t$4, r$3, s$3);
								}
							}
							d$1 && (r$2 += o$3.length - 1), y$1 && A$1 && this.zoom >= 17 && (0 !== c$2.length && M$1(c$2, c$2[0]) && c$2.pop(), this.groundEffect.addData(c$2, e$2, u$1, A$1 > 0));
						}
						this.footprintSegments.push(a$2), o$2.triangleCount = this.indexArray.length - o$2.triangleArrayOffset, this.polygonSegments.push(o$2), ++m$1.footprintSegLen, ++m$1.polygonSegLen;
					}
					if (m$1.vertexCount = this.layoutVertexArray.length - m$1.vertexArrayOffset, m$1.groundVertexCount = this.groundEffect.vertexArray.length - m$1.groundVertexArrayOffset, 0 !== m$1.vertexCount) {
						if (m$1.centroidXY = f$1.borders ? rd : this.encodeCentroid(f$1, m$1), this.centroidData.push(m$1), f$1.borders) {
							this.featuresOnBorder.push(f$1);
							const t$2 = this.featuresOnBorder.length - 1;
							for (let e$2 = 0; e$2 < f$1.borders.length; e$2++) f$1.borders[e$2][0] !== Number.MAX_VALUE && this.borderFeatureIndices[e$2].push(t$2);
						}
						this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e$1, n$1, s$1, o$1, i$1, l$1, void 0, this.worldview), this.groundEffect.addPaintPropertiesData(e$1, n$1, s$1, o$1, i$1, l$1, this.worldview), this.maxHeight = Math.max(this.maxHeight, g$1);
					}
				}
				sortBorders() {
					for (let t$1 = 0; t$1 < this.borderFeatureIndices.length; t$1++) this.borderFeatureIndices[t$1].sort(((e$1, r$1) => this.featuresOnBorder[e$1].borders[t$1][0] - this.featuresOnBorder[r$1].borders[t$1][0]));
				}
				splitToSubtiles() {
					const t$1 = [];
					for (let e$2 = 0; e$2 < this.centroidData.length; e$2++) {
						const r$2 = this.centroidData[e$2], n$2 = +(r$2.min.y + r$2.max.y > Un), i$2 = 2 * n$2 + (+(r$2.min.x + r$2.max.x > Un) ^ n$2);
						for (let n$3 = 0; n$3 < r$2.polygonSegLen; n$3++) {
							const s$2 = r$2.polygonSegIdx + n$3;
							t$1.push({
								centroidIdx: e$2,
								subtile: i$2,
								polygonSegmentIdx: s$2,
								triangleSegmentIdx: this.polygonSegments[s$2].triangleSegIdx
							});
						}
					}
					const e$1 = new Fa();
					t$1.sort(((t$2, e$2) => t$2.triangleSegmentIdx === e$2.triangleSegmentIdx ? t$2.subtile - e$2.subtile : t$2.triangleSegmentIdx - e$2.triangleSegmentIdx));
					let r$1 = 0, n$1 = 0, i$1 = 0;
					for (const e$2 of t$1) {
						if (e$2.triangleSegmentIdx !== r$1) break;
						i$1++;
					}
					const s$1 = t$1.length;
					for (; n$1 !== t$1.length;) {
						r$1 = t$1[n$1].triangleSegmentIdx;
						let o$1 = 0, a$1 = n$1, l$1 = n$1;
						for (let e$2 = a$1; e$2 < i$1 && t$1[e$2].subtile === o$1; e$2++) l$1++;
						for (; a$1 !== i$1;) {
							const n$2 = t$1[a$1];
							o$1 = n$2.subtile;
							const s$2 = this.centroidData[n$2.centroidIdx].min.clone(), u$1 = this.centroidData[n$2.centroidIdx].max.clone(), c$1 = {
								vertexOffset: this.segments.segments[r$1].vertexOffset,
								primitiveOffset: e$1.length,
								vertexLength: this.segments.segments[r$1].vertexLength,
								primitiveLength: 0,
								sortKey: void 0,
								vaos: {}
							};
							for (let r$2 = a$1; r$2 < l$1; r$2++) {
								const n$3 = t$1[r$2], i$2 = this.polygonSegments[n$3.polygonSegmentIdx], o$2 = this.centroidData[n$3.centroidIdx].min, a$2 = this.centroidData[n$3.centroidIdx].max, l$2 = this.indexArray.uint16;
								for (let t$2 = i$2.triangleArrayOffset; t$2 < i$2.triangleArrayOffset + i$2.triangleCount; t$2++) e$1.emplaceBack(l$2[3 * t$2], l$2[3 * t$2 + 1], l$2[3 * t$2 + 2]);
								c$1.primitiveLength += i$2.triangleCount, s$2.x = Math.min(s$2.x, o$2.x), s$2.y = Math.min(s$2.y, o$2.y), u$1.x = Math.max(u$1.x, a$2.x), u$1.y = Math.max(u$1.y, a$2.y);
							}
							c$1.primitiveLength > 0 && this.triangleSubSegments.push({
								segment: c$1,
								min: s$2,
								max: u$1
							}), a$1 = l$1;
							for (let e$2 = a$1; e$2 < i$1 && t$1[e$2].subtile === t$1[a$1].subtile; e$2++) l$1++;
						}
						n$1 = i$1;
						for (let e$2 = n$1; e$2 < s$1 && t$1[e$2].triangleSegmentIdx === t$1[n$1].triangleSegmentIdx; e$2++) i$1++;
					}
					e$1._trim(), this.indexArray = e$1;
				}
				getVisibleSegments(t$1, e$1, r$1) {
					const n$1 = new hl();
					if (this.wallMode) {
						for (const t$2 of this.triangleSubSegments) n$1.segments.push(t$2.segment);
						return n$1;
					}
					let i$1 = 0, s$1 = 0;
					const o$1 = 1 << t$1.canonical.z;
					if (e$1) {
						const r$2 = e$1.getMinMaxForTile(t$1);
						r$2 && (i$1 = r$2.min, s$1 = r$2.max);
					}
					s$1 += this.maxHeight;
					const a$1 = t$1.toUnwrapped();
					let l$1;
					const u$1 = [a$1.canonical.x / o$1 + a$1.wrap, a$1.canonical.y / o$1], c$1 = [(a$1.canonical.x + 1) / o$1 + a$1.wrap, (a$1.canonical.y + 1) / o$1], h$1 = (t$2, e$2, r$2) => [t$2[0] * (1 - r$2[0]) + e$2[0] * r$2[0], t$2[1] * (1 - r$2[1]) + e$2[1] * r$2[1]], p$1 = [], d$1 = [];
					for (const t$2 of this.triangleSubSegments) {
						p$1[0] = t$2.min.x / Un, p$1[1] = t$2.min.y / Un, d$1[0] = t$2.max.x / Un, d$1[1] = t$2.max.y / Un;
						const e$2 = h$1(u$1, c$1, p$1), o$2 = h$1(u$1, c$1, d$1);
						if (0 === new Ju([
							e$2[0],
							e$2[1],
							i$1
						], [
							o$2[0],
							o$2[1],
							s$1
						]).intersectsPrecise(r$1)) {
							l$1 && (n$1.segments.push(l$1), l$1 = void 0);
							continue;
						}
						const a$2 = t$2.segment;
						l$1 && l$1.vertexOffset !== a$2.vertexOffset && (n$1.segments.push(l$1), l$1 = void 0), l$1 ? (l$1.vertexLength += a$2.vertexLength, l$1.primitiveLength += a$2.primitiveLength) : l$1 = {
							vertexOffset: a$2.vertexOffset,
							primitiveLength: a$2.primitiveLength,
							vertexLength: a$2.vertexLength,
							primitiveOffset: a$2.primitiveOffset,
							sortKey: void 0,
							vaos: {}
						};
					}
					return l$1 && n$1.segments.push(l$1), n$1;
				}
				encodeCentroid(t$1, e$1) {
					const r$1 = t$1.centroid(), n$1 = e$1.span(), i$1 = Math.min(7, Math.round(n$1.x * this.tileToMeter / 10)), s$1 = Math.min(7, Math.round(n$1.y * this.tileToMeter / 10));
					return new It(Ft(r$1.x, 1, Un - 1) << 3 | i$1, Ft(r$1.y, 1, Un - 1) << 3 | s$1);
				}
				encodeBorderCentroid(t$1) {
					if (!t$1.borders) return new It(0, 0);
					const e$1 = t$1.borders, r$1 = Number.MAX_VALUE;
					if (e$1[0][0] !== r$1 || e$1[1][0] !== r$1) {
						const t$2 = e$1[0][0] !== r$1 ? 0 : 1;
						return new It(6 | (e$1[0][0] !== r$1 ? 0 : 65528), (e$1[t$2][0] + e$1[t$2][1]) / 2 << 3 | 6);
					}
					{
						const t$2 = e$1[2][0] !== r$1 ? 2 : 3;
						return new It((e$1[t$2][0] + e$1[t$2][1]) / 2 << 3 | 6, 6 | (e$1[2][0] !== r$1 ? 0 : 65528));
					}
				}
				showCentroid(t$1) {
					const e$1 = this.centroidData[t$1.centroidDataIndex];
					e$1.flags &= 2147483647, e$1.centroidXY.x = 0, e$1.centroidXY.y = 0, this.writeCentroidToBuffer(e$1);
				}
				writeCentroidToBuffer(t$1) {
					this.groundEffect.updateHiddenByLandmark(t$1);
					const e$1 = t$1.vertexArrayOffset, r$1 = t$1.vertexCount + t$1.vertexArrayOffset, n$1 = t$1.flags & nd ? rd : t$1.centroidXY, i$1 = this.centroidVertexArray.geta_centroid_pos0(e$1);
					if (this.centroidVertexArray.geta_centroid_pos1(e$1) !== n$1.y || i$1 !== n$1.x) {
						for (let t$2 = e$1; t$2 < r$1; ++t$2) this.centroidVertexArray.emplace(t$2, n$1.x, n$1.y);
						this.needsCentroidUpdate = !0;
					}
				}
				createCentroidsBuffer() {
					this.centroidVertexArray.resize(this.layoutVertexArray.length), this.groundEffect.hiddenByLandmarkVertexArray.resize(this.groundEffect.vertexArray.length);
					for (const t$1 of this.centroidData) this.writeCentroidToBuffer(t$1);
				}
				updateReplacement(t$1, e$1, r$1) {
					if (e$1.updateTime === this.replacementUpdateTime) return;
					this.replacementUpdateTime = e$1.updateTime;
					const n$1 = e$1.getReplacementRegionsForTile(t$1.toUnwrapped());
					if (jp(this.activeReplacements, n$1)) return;
					if (this.activeReplacements = n$1, 0 === this.centroidVertexArray.length) this.createCentroidsBuffer();
					else for (const t$2 of this.centroidData) t$2.flags &= 2147483647;
					const i$1 = [];
					for (const e$2 of this.activeReplacements) {
						if (e$2.order < r$1) continue;
						const n$2 = Math.max(1, Math.pow(2, e$2.footprintTileId.canonical.z - t$1.canonical.z));
						if (e$2.footprint.buildingIds) for (const t$2 of this.centroidData) t$2.flags & nd || e$2.min.x > t$2.max.x || t$2.min.x > e$2.max.x || e$2.min.y > t$2.max.y || t$2.min.y > e$2.max.y || e$2.footprint.buildingIds.has(t$2.buildingId) && (t$2.flags |= nd);
						else for (const r$2 of this.centroidData) if (!(r$2.flags & nd || e$2.min.x > r$2.max.x || r$2.min.x > e$2.max.x || e$2.min.y > r$2.max.y || r$2.min.y > e$2.max.y)) for (let s$1 = 0; s$1 < r$2.footprintSegLen; s$1++) {
							const o$1 = this.footprintSegments[r$2.footprintSegIdx + s$1];
							if (i$1.length = 0, Pd(this.footprintVertices, o$1.vertexOffset, o$1.vertexCount, e$2.footprintTileId.canonical, t$1.canonical, i$1), qp(e$2.footprint, i$1, this.footprintIndices.uint16, o$1.indexOffset, o$1.indexCount, -o$1.vertexOffset, -n$2)) {
								r$2.flags |= nd;
								break;
							}
						}
					}
					for (const t$2 of this.centroidData) this.writeCentroidToBuffer(t$2);
					this.borderDoneWithNeighborZ = [
						-1,
						-1,
						-1,
						-1
					];
				}
				footprintContainsPoint(t$1, e$1, r$1) {
					let n$1 = !1;
					for (let i$1 = 0; i$1 < r$1.footprintSegLen; i$1++) {
						const s$1 = this.footprintSegments[r$1.footprintSegIdx + i$1];
						let o$1 = 0;
						for (const r$2 of s$1.ringIndices) {
							for (let i$2 = o$1, a$1 = r$2 + o$1 - 1; i$2 < r$2 + o$1; a$1 = i$2++) {
								const r$3 = this.footprintVertices.int16[2 * (i$2 + s$1.vertexOffset) + 0], o$2 = this.footprintVertices.int16[2 * (i$2 + s$1.vertexOffset) + 1], l$1 = this.footprintVertices.int16[2 * (a$1 + s$1.vertexOffset) + 1];
								o$2 > e$1 != l$1 > e$1 && t$1 < (this.footprintVertices.int16[2 * (a$1 + s$1.vertexOffset) + 0] - r$3) * (e$1 - o$2) / (l$1 - o$2) + r$3 && (n$1 = !n$1);
							}
							o$1 = r$2;
						}
					}
					return n$1;
				}
				getHeightAtTileCoord(t$1, e$1) {
					let r$1 = Number.NEGATIVE_INFINITY, n$1 = !0;
					const i$1 = 4 * (t$1 + Un) * Un + (e$1 + Un);
					if (this.partLookup.hasOwnProperty(i$1)) {
						const t$2 = this.partLookup[i$1];
						return t$2 ? {
							height: t$2.height,
							hidden: !!(t$2.flags & nd)
						} : void 0;
					}
					for (const s$1 of this.centroidData) t$1 > s$1.max.x || s$1.min.x > t$1 || e$1 > s$1.max.y || s$1.min.y > e$1 || s$1.height <= r$1 || this.footprintContainsPoint(t$1, e$1, s$1) && (r$1 = s$1.height, this.partLookup[i$1] = s$1, n$1 = !!(s$1.flags & nd));
					if (r$1 !== Number.NEGATIVE_INFINITY) return {
						height: r$1,
						hidden: n$1
					};
					this.partLookup[i$1] = void 0;
				}
			}
			function xd(t$1, e$1) {
				const r$1 = t$1.add(e$1)._unit();
				return t$1.x * r$1.x + t$1.y * r$1.y;
			}
			function vd(t$1, e$1, r$1, n$1) {
				return bd(t$1, e$1, r$1, xd(e$1.sub(t$1)._perp()._unit(), r$1.sub(e$1)._perp()._unit()), n$1);
			}
			function bd(t$1, e$1, r$1, n$1, i$1) {
				const s$1 = Math.sqrt(1 - n$1 * n$1);
				return Math.min(t$1.dist(e$1) / 3, e$1.dist(r$1) / 3, i$1 * s$1 / n$1);
			}
			function wd(t$1, e$1, r$1) {
				return t$1.x < r$1[0].x && e$1.x < r$1[0].x || t$1.x > r$1[1].x && e$1.x > r$1[1].x || t$1.y < r$1[0].y && e$1.y < r$1[0].y || t$1.y > r$1[1].y && e$1.y > r$1[1].y;
			}
			function _d(t$1, e$1) {
				return t$1.x < e$1[0].x || t$1.x > e$1[1].x || t$1.y < e$1[0].y || t$1.y > e$1[1].y;
			}
			function Ad(t$1, e$1, r$1) {
				if (t$1.x < 0 || t$1.x >= Un || e$1.x < 0 || e$1.x >= Un || r$1.x < 0 || r$1.x >= Un) return !1;
				const n$1 = r$1.sub(e$1), i$1 = n$1.perp(), s$1 = t$1.sub(e$1);
				return (n$1.x * s$1.x + n$1.y * s$1.y) / Math.sqrt((n$1.x * n$1.x + n$1.y * n$1.y) * (s$1.x * s$1.x + s$1.y * s$1.y)) > -.866 && i$1.x * s$1.x + i$1.y * s$1.y < 0;
			}
			function Id(t$1, e$1, r$1) {
				const n$1 = e$1 ? 2 | t$1 : -3 & t$1;
				return r$1 ? 1 | n$1 : -2 & n$1;
			}
			function Md() {
				const t$1 = Math.PI / 32, e$1 = Math.tan(t$1), r$1 = ru;
				return r$1 * Math.sqrt(1 + 2 * e$1 * e$1) - r$1;
			}
			function Sd(t$1, e$1, r$1) {
				const n$1 = 1 << r$1.z, i$1 = pu(r$1.x / n$1), s$1 = pu((r$1.x + 1) / n$1), o$1 = du(r$1.y / n$1), a$1 = du((r$1.y + 1) / n$1);
				return function(t$2, e$2, r$2, n$2, i$2 = 0, s$2) {
					const o$2 = [];
					if (!t$2.length || !r$2 || !n$2) return o$2;
					const a$2 = (t$3, e$3) => {
						for (const r$3 of t$3) o$2.push({
							polygon: r$3,
							bounds: e$3
						});
					}, l$1 = Math.ceil(Math.log2(r$2)), u$1 = Math.ceil(Math.log2(n$2)), c$1 = l$1 - u$1, h$1 = [];
					for (let t$3 = 0; t$3 < Math.abs(c$1); t$3++) h$1.push(c$1 > 0 ? 0 : 1);
					for (let t$3 = 0; t$3 < Math.min(l$1, u$1); t$3++) h$1.push(0), h$1.push(1);
					let p$1 = t$2;
					if (p$1 = fp(p$1, e$2[0].y - i$2, e$2[1].y + i$2, 1), p$1 = fp(p$1, e$2[0].x - i$2, e$2[1].x + i$2, 0), !p$1.length) return o$2;
					const d$1 = [];
					for (h$1.length ? d$1.push({
						polygons: p$1,
						bounds: e$2,
						depth: 0
					}) : a$2(p$1, e$2); d$1.length;) {
						const t$3 = d$1.pop(), e$3 = t$3.depth, r$3 = h$1[e$3], n$3 = t$3.bounds[0], o$3 = t$3.bounds[1], l$2 = 0 === r$3 ? n$3.x : n$3.y, u$2 = 0 === r$3 ? o$3.x : o$3.y, c$2 = s$2 ? s$2(r$3, l$2, u$2) : .5 * (l$2 + u$2), p$2 = fp(t$3.polygons, l$2 - i$2, c$2 + i$2, r$3), f$1 = fp(t$3.polygons, c$2 - i$2, u$2 + i$2, r$3);
						if (p$2.length) {
							const t$4 = [n$3, new It(0 === r$3 ? c$2 : o$3.x, 1 === r$3 ? c$2 : o$3.y)];
							h$1.length > e$3 + 1 ? d$1.push({
								polygons: p$2,
								bounds: t$4,
								depth: e$3 + 1
							}) : a$2(p$2, t$4);
						}
						if (f$1.length) {
							const t$4 = [new It(0 === r$3 ? c$2 : n$3.x, 1 === r$3 ? c$2 : n$3.y), o$3];
							h$1.length > e$3 + 1 ? d$1.push({
								polygons: f$1,
								bounds: t$4,
								depth: e$3 + 1
							}) : a$2(f$1, t$4);
						}
					}
					return o$2;
				}(t$1, e$1, Math.ceil((s$1 - i$1) / 11.25), Math.ceil((o$1 - a$1) / 11.25), 1, ((t$2, e$2, i$2) => {
					if (0 === t$2) return .5 * (e$2 + i$2);
					{
						const t$3 = du((r$1.y + e$2 / Un) / n$1);
						return (cu(.5 * (du((r$1.y + i$2 / Un) / n$1) + t$3)) * n$1 - r$1.y) * Un;
					}
				}));
			}
			function Pd(t$1, e$1, r$1, n$1, i$1, s$1) {
				const o$1 = Math.pow(2, n$1.z - i$1.z);
				for (let a$1 = 0; a$1 < r$1; a$1++) {
					let r$2 = t$1.int16[2 * (a$1 + e$1) + 0], l$1 = t$1.int16[2 * (a$1 + e$1) + 1];
					r$2 = (r$2 + i$1.x * Un) * o$1 - n$1.x * Un, l$1 = (l$1 + i$1.y * Un) * o$1 - n$1.y * Un, s$1.push(new It(r$2, l$1));
				}
			}
			let kd, Bd;
			Qs(gd, "FillExtrusionBucket", { omit: ["layers", "features"] }), Qs(hd, "PartData"), Qs(cd, "FootprintSegment"), Qs(pd, "BorderCentroidData"), Qs(yd, "GroundEffect");
			class zd extends It {
				constructor(t$1, e$1, r$1) {
					super(t$1, e$1), this.z = r$1;
				}
			}
			class Td extends zd {
				constructor(t$1, e$1, r$1, n$1) {
					super(t$1, e$1, r$1), this.w = n$1;
				}
			}
			function Ed(t$1, e$1, r$1, n$1) {
				const i$1 = "x" === r$1 ? "y" : "x", s$1 = (n$1 - t$1[r$1]) / (e$1[r$1] - t$1[r$1]);
				t$1[i$1] = Math.round(t$1[i$1] + (e$1[i$1] - t$1[i$1]) * s$1), t$1[r$1] = n$1, t$1.hasOwnProperty("z") && (t$1.z = pr(t$1.z, e$1.z, s$1)), t$1.hasOwnProperty("w") && (t$1.w = pr(t$1.w, e$1.w, s$1));
			}
			function Vd(t$1, e$1, r$1, n$1) {
				const i$1 = r$1, s$1 = n$1;
				for (const r$2 of ["x", "y"]) {
					let n$2 = t$1, o$1 = e$1;
					n$2[r$2] >= o$1[r$2] && (n$2 = e$1, o$1 = t$1), n$2[r$2] < i$1 && o$1[r$2] > i$1 && Ed(n$2, o$1, r$2, i$1), n$2[r$2] < s$1 && o$1[r$2] > s$1 && Ed(o$1, n$2, r$2, s$1);
				}
			}
			function Fd(t$1, e$1, r$1, n$1, i$1, s$1) {
				const o$1 = [];
				for (let a$1 = 0; a$1 < t$1.length; a$1++) {
					const l$1 = t$1[a$1];
					let u$1;
					const c$1 = o$1.length;
					let h$1 = 0;
					for (let t$2 = 0; t$2 < l$1.length - 1; t$2++) {
						let c$2 = l$1[t$2], p$1 = l$1[t$2 + 1], d$1 = 0;
						const f$1 = h$1;
						let m$1, y$1;
						s$1 && (d$1 = Math.hypot(p$1.x - c$2.x, p$1.y - c$2.y), h$1 += d$1, m$1 = c$2, y$1 = p$1), c$2.x < e$1 && p$1.x < e$1 || (c$2.x < e$1 ? c$2 = new It(e$1, c$2.y + (e$1 - c$2.x) / (p$1.x - c$2.x) * (p$1.y - c$2.y))._round() : p$1.x < e$1 && (p$1 = new It(e$1, c$2.y + (e$1 - c$2.x) / (p$1.x - c$2.x) * (p$1.y - c$2.y))._round()), c$2.y < r$1 && p$1.y < r$1 || (c$2.y < r$1 ? c$2 = new It(c$2.x + (r$1 - c$2.y) / (p$1.y - c$2.y) * (p$1.x - c$2.x), r$1)._round() : p$1.y < r$1 && (p$1 = new It(c$2.x + (r$1 - c$2.y) / (p$1.y - c$2.y) * (p$1.x - c$2.x), r$1)._round()), c$2.x >= n$1 && p$1.x >= n$1 || (c$2.x >= n$1 ? c$2 = new It(n$1, c$2.y + (n$1 - c$2.x) / (p$1.x - c$2.x) * (p$1.y - c$2.y))._round() : p$1.x >= n$1 && (p$1 = new It(n$1, c$2.y + (n$1 - c$2.x) / (p$1.x - c$2.x) * (p$1.y - c$2.y))._round()), c$2.y >= i$1 && p$1.y >= i$1 || (c$2.y >= i$1 ? c$2 = new It(c$2.x + (i$1 - c$2.y) / (p$1.y - c$2.y) * (p$1.x - c$2.x), i$1)._round() : p$1.y >= i$1 && (p$1 = new It(c$2.x + (i$1 - c$2.y) / (p$1.y - c$2.y) * (p$1.x - c$2.x), i$1)._round()), u$1 && c$2.equals(u$1[u$1.length - 1]) || (u$1 = [c$2], o$1.push(u$1), s$1 && s$1.push({
							progress: {
								min: f$1 + Dd(m$1, y$1, c$2) * d$1,
								max: 1
							},
							parentIndex: a$1,
							prevPoint: m$1,
							nextPoint: y$1
						})), u$1.push(p$1), s$1 && (s$1[s$1.length - 1].progress.max = f$1 + Dd(m$1, y$1, p$1) * d$1, s$1[s$1.length - 1].nextPoint = y$1)))));
					}
					if (s$1 && h$1 > 0) for (let t$2 = c$1; t$2 < o$1.length; t$2++) s$1[t$2].progress.min /= h$1, s$1[t$2].progress.max /= h$1;
				}
				return o$1;
			}
			function Cd(t$1, e$1, r$1, n$1, i$1) {
				if (t$1.length < 2) return void n$1.push(t$1);
				const s$1 = [];
				for (; e$1.valid();) {
					const [r$2, n$2] = e$1.get();
					for (let e$2 = 0; e$2 < t$1.length - 1; e$2++) {
						const i$2 = t$1[e$2], o$2 = t$1[e$2 + 1], a$2 = hc(i$2, o$2, r$2, n$2);
						if (a$2) {
							const [t$2] = a$2, r$3 = new It(pr(i$2.x, o$2.x, t$2), pr(i$2.y, o$2.y, t$2));
							s$1.push({
								t: e$2 + t$2,
								distance: 0,
								point: r$3
							});
						}
					}
					e$1.next();
				}
				if (0 === s$1.length) return void n$1.push(t$1);
				s$1.sort(((t$2, e$2) => t$2.t - e$2.t));
				let o$1 = 0, a$1 = 0, l$1 = [];
				for (n$1.push(l$1); o$1 !== t$1.length;) {
					if (a$1 === s$1.length) {
						for (; o$1 !== t$1.length;) 0 !== l$1.length && l$1[l$1.length - 1].equals(t$1[o$1]) || l$1.push(t$1[o$1]), o$1++;
						break;
					}
					s$1[a$1].t <= o$1 ? (0 !== l$1.length && l$1[l$1.length - 1].equals(s$1[a$1].point) || l$1.push(s$1[a$1].point), Math.trunc(s$1[a$1].t), a$1++) : (0 !== l$1.length && l$1[l$1.length - 1].equals(t$1[o$1]) || l$1.push(t$1[o$1]), o$1++);
				}
			}
			function Dd(t$1, e$1, r$1) {
				return t$1.x !== e$1.x ? (r$1.x - t$1.x) / (e$1.x - t$1.x) : t$1.y !== e$1.y ? (r$1.y - t$1.y) / (e$1.y - t$1.y) : 0;
			}
			function Rd(t$1, e$1) {
				return t$1.x * e$1.x + t$1.y * e$1.y;
			}
			function Ld(t$1, e$1) {
				if (1 === t$1.length) {
					let r$1 = 0;
					const n$1 = e$1[r$1++];
					let i$1;
					for (; !i$1 || n$1.equals(i$1);) if (i$1 = e$1[r$1++], !i$1) return Infinity;
					for (; r$1 < e$1.length; r$1++) {
						const s$1 = e$1[r$1], o$1 = t$1[0], a$1 = i$1.sub(n$1), l$1 = s$1.sub(n$1), u$1 = o$1.sub(n$1), c$1 = Rd(a$1, a$1), h$1 = Rd(a$1, l$1), p$1 = Rd(l$1, l$1), d$1 = Rd(u$1, a$1), f$1 = Rd(u$1, l$1), m$1 = c$1 * p$1 - h$1 * h$1, y$1 = (p$1 * d$1 - h$1 * f$1) / m$1, g$1 = (c$1 * f$1 - h$1 * d$1) / m$1, x$1 = n$1.z * (1 - y$1 - g$1) + i$1.z * y$1 + s$1.z * g$1;
						if (isFinite(x$1)) return x$1;
					}
					return Infinity;
				}
				{
					let t$2 = Infinity;
					for (const r$1 of e$1) t$2 = Math.min(t$2, r$1.z);
					return t$2;
				}
			}
			function Od(t$1, e$1, r$1) {
				let n$1 = Infinity;
				oc(r$1, e$1) && (n$1 = Ld(r$1, e$1[0]));
				for (let i$1 = 0; i$1 < e$1.length; i$1++) {
					const s$1 = e$1[i$1], o$1 = t$1[i$1];
					for (let t$2 = 0; t$2 < s$1.length - 1; t$2++) {
						const e$2 = s$1[t$2], i$2 = [
							e$2,
							s$1[t$2 + 1],
							o$1[t$2 + 1],
							o$1[t$2],
							e$2
						];
						ic(r$1, i$2) && (n$1 = Math.min(n$1, Ld(r$1, i$2)));
					}
				}
				return n$1 !== Infinity && n$1;
			}
			function Ud(t$1, e$1, r$1, n$1, i$1, s$1, o$1, a$1, l$1, u$1, c$1) {
				return "globe" === t$1.projection.name ? function(t$2, e$2, r$2, n$2, i$2, s$2, o$2, a$2, l$2, u$2, c$2) {
					const h$1 = [], p$1 = [], d$1 = t$2.projection.upVectorScale(c$2, t$2.center.lat, t$2.worldSize).metersToTile, f$1 = [
						0,
						0,
						0,
						1
					], m$1 = [
						0,
						0,
						0,
						1
					], y$1 = (t$3, e$3, r$3, n$3) => {
						t$3[0] = e$3, t$3[1] = r$3, t$3[2] = n$3, t$3[3] = 1;
					}, g$1 = Md();
					r$2 > 0 && (r$2 += g$1), n$2 += g$1;
					for (const g$2 of e$2) {
						const e$3 = [], x$1 = [];
						for (const h$2 of g$2) {
							const p$2 = h$2.x + i$2.x, g$3 = h$2.y + i$2.y, v$1 = t$2.projection.projectTilePoint(p$2, g$3, c$2), b$1 = t$2.projection.upVector(c$2, h$2.x, h$2.y);
							let w$1 = r$2, _$1 = n$2;
							if (o$2) {
								const t$3 = Nd(p$2, g$3, r$2, n$2, o$2, a$2, l$2, u$2);
								w$1 += t$3.base, _$1 += t$3.top;
							}
							0 !== r$2 ? y$1(f$1, v$1.x + b$1[0] * d$1 * w$1, v$1.y + b$1[1] * d$1 * w$1, v$1.z + b$1[2] * d$1 * w$1) : y$1(f$1, v$1.x, v$1.y, v$1.z), y$1(m$1, v$1.x + b$1[0] * d$1 * _$1, v$1.y + b$1[1] * d$1 * _$1, v$1.z + b$1[2] * d$1 * _$1), j(f$1, f$1, s$2), j(m$1, m$1, s$2), e$3.push(new zd(f$1[0], f$1[1], f$1[2])), x$1.push(new zd(m$1[0], m$1[1], m$1[2]));
						}
						h$1.push(e$3), p$1.push(x$1);
					}
					return [h$1, p$1];
				}(t$1, e$1, r$1, n$1, i$1, s$1, o$1, a$1, l$1, u$1, c$1) : o$1 ? function(t$2, e$2, r$2, n$2, i$2, s$2, o$2, a$2, l$2) {
					const u$2 = [], c$2 = [], h$1 = [
						0,
						0,
						0,
						1
					];
					for (const p$1 of t$2) {
						const t$3 = [], d$1 = [];
						for (const u$3 of p$1) {
							const c$3 = u$3.x + n$2.x, p$2 = u$3.y + n$2.y, f$1 = Nd(c$3, p$2, e$2, r$2, s$2, o$2, a$2, l$2);
							h$1[0] = c$3, h$1[1] = p$2, h$1[2] = f$1.base, h$1[3] = 1, Q(h$1, h$1, i$2), h$1[3] = Math.max(h$1[3], 1e-5);
							const m$1 = new zd(h$1[0] / h$1[3], h$1[1] / h$1[3], h$1[2] / h$1[3]);
							h$1[0] = c$3, h$1[1] = p$2, h$1[2] = f$1.top, h$1[3] = 1, Q(h$1, h$1, i$2), h$1[3] = Math.max(h$1[3], 1e-5);
							const y$1 = new zd(h$1[0] / h$1[3], h$1[1] / h$1[3], h$1[2] / h$1[3]);
							t$3.push(m$1), d$1.push(y$1);
						}
						u$2.push(t$3), c$2.push(d$1);
					}
					return [u$2, c$2];
				}(e$1, r$1, n$1, i$1, s$1, o$1, a$1, l$1, u$1) : function(t$2, e$2, r$2, n$2, i$2) {
					const s$2 = [], o$2 = [], a$2 = i$2[8] * e$2, l$2 = i$2[9] * e$2, u$2 = i$2[10] * e$2, c$2 = i$2[11] * e$2, h$1 = i$2[8] * r$2, p$1 = i$2[9] * r$2, d$1 = i$2[10] * r$2, f$1 = i$2[11] * r$2;
					for (const e$3 of t$2) {
						const t$3 = [], r$3 = [];
						for (const s$3 of e$3) {
							const e$4 = s$3.x + n$2.x, o$3 = s$3.y + n$2.y, m$1 = i$2[0] * e$4 + i$2[4] * o$3 + i$2[12], y$1 = i$2[1] * e$4 + i$2[5] * o$3 + i$2[13], g$1 = i$2[2] * e$4 + i$2[6] * o$3 + i$2[14], x$1 = i$2[3] * e$4 + i$2[7] * o$3 + i$2[15], v$1 = m$1 + a$2, b$1 = y$1 + l$2, w$1 = g$1 + u$2, _$1 = Math.max(x$1 + c$2, 1e-5), A$1 = m$1 + h$1, I$1 = y$1 + p$1, M$1 = g$1 + d$1, S$1 = Math.max(x$1 + f$1, 1e-5);
							t$3.push(new zd(v$1 / _$1, b$1 / _$1, w$1 / _$1)), r$3.push(new zd(A$1 / S$1, I$1 / S$1, M$1 / S$1));
						}
						s$2.push(t$3), o$2.push(r$3);
					}
					return [s$2, o$2];
				}(e$1, r$1, n$1, i$1, s$1);
			}
			function Nd(t$1, e$1, r$1, n$1, i$1, s$1, o$1, a$1) {
				const l$1 = o$1 * i$1.getElevationAt(t$1, e$1, !0, !0), u$1 = 0 !== s$1[0], c$1 = u$1 ? 0 === s$1[1] ? o$1 * (s$1[0] / id - sd) : o$1 * function(t$2, e$2, r$2) {
					const n$2 = Math.floor(e$2[0] / 8), i$2 = Math.floor(e$2[1] / 8), s$2 = 10 * (e$2[0] - 8 * n$2), o$2 = 10 * (e$2[1] - 8 * i$2), a$2 = t$2.getElevationAt(n$2, i$2, !0, !0), l$2 = t$2.getMeterToDEM(r$2), u$2 = Math.floor(.5 * (s$2 * l$2 - 1)), c$2 = Math.floor(.5 * (o$2 * l$2 - 1)), h$1 = t$2.tileCoordToPixel(n$2, i$2), p$1 = 2 * u$2 + 1, d$1 = 2 * c$2 + 1, f$1 = function(t$3, e$3, r$3, n$3, i$3) {
						return [
							t$3.getElevationAtPixel(e$3, r$3, !0),
							t$3.getElevationAtPixel(e$3 + i$3, r$3, !0),
							t$3.getElevationAtPixel(e$3, r$3 + i$3, !0),
							t$3.getElevationAtPixel(e$3 + n$3, r$3 + i$3, !0)
						];
					}(t$2, h$1.x - u$2, h$1.y - c$2, p$1, d$1), m$1 = Math.abs(f$1[0] - f$1[1]), y$1 = Math.abs(f$1[2] - f$1[3]), g$1 = Math.abs(f$1[0] - f$1[2]) + Math.abs(f$1[1] - f$1[3]), x$1 = Math.min(.25, .5 * l$2 * (m$1 + y$1) / p$1), v$1 = Math.min(.25, .5 * l$2 * g$1 / d$1);
					return a$2 + Math.max(x$1 * s$2, v$1 * o$2);
				}(i$1, s$1, a$1) : l$1;
				return {
					base: l$1 + (0 === r$1 ? -1 : r$1),
					top: u$1 ? Math.max(c$1 + n$1, l$1 + r$1 + 2) : l$1 + n$1
				};
			}
			class jd {
				constructor(t$1) {
					this._callback = t$1, this._triggered = !1, "undefined" != typeof MessageChannel && (this._channel = new MessageChannel(), this._channel.port2.onmessage = () => {
						this._triggered = !1, this._callback();
					});
				}
				trigger() {
					this._triggered || (this._triggered = !0, this._channel ? this._channel.port1.postMessage(!0) : setTimeout((() => {
						this._triggered = !1, this._callback();
					}), 0));
				}
				remove() {
					this._channel = void 0, this._callback = () => {};
				}
			}
			class $d {
				constructor() {
					this.tasks = {}, this.taskQueue = [], Nt(["process"], this), this.invoker = new jd(this.process), this.nextId = 0;
				}
				add(t$1, e$1) {
					const r$1 = this.nextId++, n$1 = function({ type: t$2, isSymbolTile: e$2, zoom: r$2 }) {
						return r$2 = r$2 || 0, "message" === t$2 ? 0 : "maybePrepare" !== t$2 || e$2 ? "parseTile" !== t$2 || e$2 ? "parseTile" === t$2 && e$2 ? 300 - r$2 : "maybePrepare" === t$2 && e$2 ? 400 - r$2 : 500 : 200 - r$2 : 100 - r$2;
					}(e$1);
					if (0 === n$1) {
						try {
							t$1();
						} finally {}
						return null;
					}
					return this.tasks[r$1] = {
						fn: t$1,
						metadata: e$1,
						priority: n$1,
						id: r$1
					}, this.taskQueue.push(r$1), this.invoker.trigger(), { cancel: () => {
						delete this.tasks[r$1];
					} };
				}
				process() {
					try {
						if (this.taskQueue = this.taskQueue.filter(((t$2) => !!this.tasks[t$2])), !this.taskQueue.length) return;
						const t$1 = this.pick();
						if (null === t$1) return;
						const e$1 = this.tasks[t$1];
						if (delete this.tasks[t$1], this.taskQueue.length && this.invoker.trigger(), !e$1) return;
						e$1.fn();
					} finally {}
				}
				pick() {
					let t$1 = null, e$1 = Infinity;
					for (let r$2 = 0; r$2 < this.taskQueue.length; r$2++) {
						const n$1 = this.tasks[this.taskQueue[r$2]];
						n$1.priority < e$1 && (e$1 = n$1.priority, t$1 = r$2);
					}
					if (null === t$1) return null;
					const r$1 = this.taskQueue[t$1];
					return this.taskQueue.splice(t$1, 1), r$1;
				}
				remove() {
					this.invoker.remove();
				}
			}
			class Gd {
				constructor(t$1, e$1, r$1) {
					this.target = t$1, this.parent = e$1, this.mapId = r$1, this.callbacks = {}, this.cancelCallbacks = {}, Nt(["receive"], this), this.target.addEventListener("message", this.receive, !1), this.scheduler = new $d();
				}
				send(t$1, e$1, r$1, n$1, i$1 = !1, s$1) {
					const o$1 = Math.round(0xde0b6b3a7640000 * Math.random()).toString(36).substring(0, 10);
					r$1 && (r$1.metadata = s$1, this.callbacks[o$1] = r$1);
					const a$1 = /* @__PURE__ */ new Set();
					return this.target.postMessage({
						id: o$1,
						type: t$1,
						hasCallback: !!r$1,
						targetMapId: n$1,
						mustQueue: i$1,
						sourceMapId: this.mapId,
						data: eo(e$1, a$1)
					}, a$1), { cancel: () => {
						r$1 && delete this.callbacks[o$1], this.target.postMessage({
							id: o$1,
							type: "<cancel>",
							targetMapId: n$1,
							sourceMapId: this.mapId
						});
					} };
				}
				receive(t$1) {
					const e$1 = t$1.data;
					if (!e$1) return;
					const r$1 = e$1.id;
					if (r$1 && (!e$1.targetMapId || this.mapId === e$1.targetMapId)) if ("<cancel>" === e$1.type) {
						const t$2 = this.cancelCallbacks[r$1];
						delete this.cancelCallbacks[r$1], t$2 && t$2.cancel();
					} else if (e$1.mustQueue || Kt(self)) {
						const t$2 = this.callbacks[r$1], n$1 = this.scheduler.add((() => this.processTask(r$1, e$1)), t$2 && t$2.metadata || { type: "message" });
						n$1 && (this.cancelCallbacks[r$1] = n$1);
					} else this.processTask(r$1, e$1);
				}
				processTask(t$1, e$1) {
					if (delete this.cancelCallbacks[t$1], "<response>" === e$1.type) {
						const r$1 = this.callbacks[t$1];
						delete this.callbacks[t$1], r$1 && (e$1.error ? r$1(ro(e$1.error)) : r$1(null, ro(e$1.data)));
					} else {
						const r$1 = /* @__PURE__ */ new Set(), n$1 = e$1.hasCallback ? (e$2, n$2) => {
							this.target.postMessage({
								id: t$1,
								type: "<response>",
								sourceMapId: this.mapId,
								error: e$2 ? eo(e$2) : null,
								data: eo(n$2, r$1)
							}, r$1);
						} : () => {}, i$1 = ro(e$1.data);
						if (this.parent[e$1.type]) this.parent[e$1.type](e$1.sourceMapId, i$1, n$1);
						else if (this.parent.getWorkerSource) {
							const t$2 = e$1.type.split("."), { source: r$2, scope: s$1 } = i$1;
							this.parent.getWorkerSource(e$1.sourceMapId, t$2[0], r$2, s$1)[t$2[1]](i$1, n$1);
						} else n$1(/* @__PURE__ */ new Error(`Could not find function ${e$1.type}`));
					}
				}
				remove() {
					this.scheduler.remove(), this.target.removeEventListener("message", this.receive, !1);
				}
			}
			var qd = {
				workerUrl: "",
				workerClass: null,
				workerParams: void 0
			};
			const Hd = "mapboxgl_preloaded_worker_pool";
			class Xd {
				constructor(t$1) {
					this.active = {}, this.name = t$1;
				}
				acquire(t$1, e$1 = Xd.workerCount) {
					if (!this.workers) for (this.workers = []; this.workers.length < e$1;) {
						const e$2 = (r$1 = `${this.name || ""}WorkerPool: ${t$1}-${this.workers.length}`, null != qd.workerClass ? new qd.workerClass() : new self.Worker(qd.workerUrl, Object.assign({ name: r$1 }, qd.workerParams)));
						this.workers.push(e$2);
					}
					var r$1;
					return this.active[t$1] = !0, this.workers.slice();
				}
				release(t$1) {
					delete this.active[t$1], this.workers && 0 === this.numActive() && (this.workers.forEach(((t$2) => {
						t$2.terminate();
					})), this.workers = null);
				}
				isPreloaded() {
					return !!this.active[Hd];
				}
				numActive() {
					return Object.keys(this.active).length;
				}
			}
			Xd.workerCount = 2;
			class Zd {
				constructor(t$1, e$1, r$1 = "Worker", n$1 = Xd.workerCount) {
					this.workerPool = t$1, this.actors = [], this.currentActor = 0, this.id = Ot();
					const i$1 = this.workerPool.acquire(this.id, n$1);
					for (let t$2 = 0; t$2 < i$1.length; t$2++) {
						const n$2 = new Zd.Actor(i$1[t$2], e$1, this.id);
						n$2.name = `${r$1} ${t$2}`, this.actors.push(n$2);
					}
					this.ready = !1, this.broadcast("checkIfReady", null, (() => {
						this.ready = !0;
					}));
				}
				broadcast(t$1, e$1, r$1) {
					Rt(this.actors, ((r$2, n$1) => {
						r$2.send(t$1, e$1, n$1);
					}), r$1 = r$1 || function() {});
				}
				getActor() {
					return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];
				}
				remove() {
					this.actors.forEach(((t$1) => {
						t$1.remove();
					})), this.actors = [], this.workerPool.release(this.id);
				}
			}
			let Wd, Yd;
			function Kd() {
				return Wd || (Wd = new Xd()), Wd;
			}
			Zd.Actor = Gd;
			const Jd = 4096;
			class Qd {
				constructor(t$1) {
					this.module = t$1, this.memoryStack = this.module.malloc(Jd), this.memoryStackNextFree = this.memoryStack;
				}
				createIntArray(t$1) {
					const e$1 = this.memoryStackNextFree;
					return this.memoryStackNextFree += t$1.length * Int32Array.BYTES_PER_ELEMENT, this.memoryStackNextFree - this.memoryStack > Jd ? -1 : (new Int32Array(this.module.heap32.buffer, e$1, t$1.length).set(t$1), e$1);
				}
				createFloatArray(t$1) {
					const e$1 = this.memoryStackNextFree;
					return this.memoryStackNextFree += t$1.length * Float32Array.BYTES_PER_ELEMENT, this.memoryStackNextFree - this.memoryStack > Jd ? -1 : (new Float32Array(this.module.heapF32.buffer, e$1, t$1.length).set(t$1), e$1);
				}
				readStringBuffer(t$1) {
					let e$1 = "";
					for (; 0 !== this.module.heapU8[t$1];) e$1 += String.fromCharCode(this.module.heapU8[t$1]), ++t$1;
					return e$1;
				}
				setStyle(t$1) {
					const e$1 = t$1.normalScale;
					this.module.setStyle(e$1[0], e$1[1], e$1[2], t$1.tileToMeters);
				}
				setAOOptions(t$1, e$1) {
					this.module.setAOOptions(t$1 ? 1 : 0, e$1);
				}
				setMetricOptions(t$1, e$1) {
					this.module.setMetricOptions(t$1 ? 1 : 0, e$1);
				}
				setStructuralOptions(t$1) {
					this.module.setStructuralOptions(t$1 ? 1 : 0);
				}
				setFacadeOptions(t$1, e$1) {
					this.module.setFacadeOptions(t$1, e$1 ? 1 : 0);
				}
				setFauxFacadeOptions(t$1, e$1, r$1) {
					this.module.setFauxFacadeOptions(t$1 ? 1 : 0, e$1 ? 1 : 0, r$1);
				}
				setFacadeClassifierOptions(t$1) {
					this.module.setFacadeClassifierOptions(t$1);
				}
				generateMesh(t$1, e$1) {
					this.memoryStackNextFree = this.memoryStack;
					for (const e$2 of t$1) {
						const t$2 = this.createIntArray(e$2.ringIndices), r$2 = this.createFloatArray(e$2.coordinates);
						if (-1 === t$2 || -1 === r$2) return `building_gen: Out of stack memory: ${this.memoryStackNextFree - this.memoryStack}/4096`;
						this.module.addFeature(e$2.id, e$2.sourceId, e$2.minHeight, e$2.height, e$2.roofType, r$2, t$2, e$2.ringIndices.length - 1);
					}
					for (const t$2 of e$1) {
						let e$2;
						e$2 = t$2.entrances ? JSON.parse(t$2.entrances) : [];
						const r$2 = this.createFloatArray(e$2), n$2 = this.createFloatArray(t$2.coordinates);
						if (-1 === r$2 || -1 === n$2) return `building_gen: Out of stack memory: ${this.memoryStackNextFree - this.memoryStack}/4096`;
						this.module.addFacade(t$2.sourceId, t$2.crossPerc, t$2.distanceToRoad, r$2, e$2.length, n$2, t$2.coordinates.length);
					}
					if (!this.module.generateMesh()) {
						const t$2 = this.module.getLastError();
						return this.readStringBuffer(t$2);
					}
					const r$1 = this.module.getMeshCount(), n$1 = new Array(r$1);
					for (let t$2 = 0; t$2 < r$1; t$2++) {
						const e$2 = this.module.getPositionsPtr(t$2), r$2 = this.module.getPositionsLength(t$2), i$2 = new Float32Array(this.module.heapF32.buffer, e$2, r$2), s$2 = this.module.getNormalsPtr(t$2), o$1 = this.module.getNormalsLength(t$2), a$1 = new Float32Array(this.module.heapF32.buffer, s$2, o$1), l$1 = this.module.getAOPtr(t$2), u$1 = this.module.getAOLength(t$2), c$1 = new Float32Array(this.module.heapF32.buffer, l$1, u$1), h$1 = this.module.getUVPtr(t$2), p$1 = this.module.getUVLength(t$2), d$1 = new Float32Array(this.module.heapF32.buffer, h$1, p$1), f$1 = this.module.getFauxFacadePtr(t$2), m$1 = this.module.getFauxFacadeLength(t$2), y$1 = new Uint8Array(this.module.heapU8.buffer, f$1, m$1), g$1 = this.module.getIndicesPtr(t$2), x$1 = this.module.getIndicesLength(t$2);
						n$1[t$2] = {
							positions: i$2,
							normals: a$1,
							ao: c$1,
							uv: d$1,
							isFauxFacade: y$1,
							indices: new Int16Array(this.module.heap16.buffer, g$1, x$1),
							buildingPart: this.module.getBuildingPart(t$2)
						};
					}
					const i$1 = this.module.getRingCount(), s$1 = [];
					for (let t$2 = 0; t$2 < i$1; t$2++) {
						const e$2 = this.module.getRingPtr(t$2), r$2 = this.module.getRingLength(t$2), n$2 = new Float32Array(this.module.heapF32.buffer, e$2, r$2);
						s$1.push(n$2);
					}
					return {
						meshes: n$1,
						outerRingLength: this.module.getOuterRingLength(),
						modifiedPolygonRings: s$1
					};
				}
			}
			let tf, ef, rf, nf, sf, of = null, af = null, lf = null, uf = null;
			function cf() {
				return Kt(self) && self.worker.dracoUrl ? self.worker.dracoUrl : ef || oe.DRACO_URL;
			}
			function hf() {
				if (Kt(self) && self.worker.meshoptUrl) return self.worker.meshoptUrl;
				if (nf) return nf;
				const t$1 = new Uint8Array([
					0,
					97,
					115,
					109,
					1,
					0,
					0,
					0,
					1,
					4,
					1,
					96,
					0,
					0,
					3,
					3,
					2,
					0,
					0,
					5,
					3,
					1,
					0,
					1,
					12,
					1,
					0,
					10,
					22,
					2,
					12,
					0,
					65,
					0,
					65,
					0,
					65,
					0,
					252,
					10,
					0,
					0,
					11,
					7,
					0,
					65,
					0,
					253,
					15,
					26,
					11
				]);
				if ("object" != typeof WebAssembly) throw new Error("WebAssembly not supported, cannot instantiate meshoptimizer");
				return nf = WebAssembly.validate(t$1) ? oe.MESHOPT_SIMD_URL : oe.MESHOPT_URL, nf;
			}
			function pf() {
				return uf;
			}
			const df = {
				5120: Int8Array,
				5121: Uint8Array,
				5122: Int16Array,
				5123: Uint16Array,
				5125: Uint32Array,
				5126: Float32Array
			}, ff = {
				5120: "DT_INT8",
				5121: "DT_UINT8",
				5122: "DT_INT16",
				5123: "DT_UINT16",
				5125: "DT_UINT32",
				5126: "DT_FLOAT32"
			}, mf = {
				SCALAR: 1,
				VEC2: 2,
				VEC3: 3,
				VEC4: 4,
				MAT2: 4,
				MAT3: 9,
				MAT4: 16
			};
			function yf(t$1, e$1, r$1) {
				const n$1 = r$1.json.bufferViews.length, i$1 = r$1.buffers.length;
				e$1.bufferView = n$1, r$1.json.bufferViews[n$1] = {
					buffer: i$1,
					byteLength: t$1.byteLength
				}, r$1.buffers[i$1] = t$1;
			}
			const gf = "KHR_draco_mesh_compression";
			function xf(t$1, e$1) {
				const r$1 = t$1.extensions && t$1.extensions[gf];
				if (!r$1) return;
				const n$1 = new rf.Decoder(), i$1 = Mf(e$1, r$1.bufferView), s$1 = new rf.Mesh();
				if (!n$1.DecodeArrayToMesh(i$1, i$1.byteLength, s$1)) throw new Error("Failed to decode Draco mesh");
				const o$1 = e$1.json.accessors[t$1.indices], a$1 = df[o$1.componentType], l$1 = o$1.count * a$1.BYTES_PER_ELEMENT, u$1 = rf._malloc(l$1);
				a$1 === Uint16Array ? n$1.GetTrianglesUInt16Array(s$1, l$1, u$1) : n$1.GetTrianglesUInt32Array(s$1, l$1, u$1), yf(rf.memory.buffer.slice(u$1, u$1 + l$1), o$1, e$1), rf._free(u$1);
				for (const i$2 of Object.keys(r$1.attributes)) {
					const o$2 = n$1.GetAttributeByUniqueId(s$1, r$1.attributes[i$2]), a$2 = e$1.json.accessors[t$1.attributes[i$2]], l$2 = ff[a$2.componentType], u$2 = a$2.count * mf[a$2.type] * df[a$2.componentType].BYTES_PER_ELEMENT, c$1 = rf._malloc(u$2);
					n$1.GetAttributeDataArrayForAllPoints(s$1, o$2, rf[l$2], u$2, c$1), yf(rf.memory.buffer.slice(c$1, c$1 + u$2), a$2, e$1), rf._free(c$1);
				}
				n$1.destroy(), s$1.destroy(), delete t$1.extensions[gf];
			}
			const vf = "EXT_meshopt_compression";
			function bf(t$1, e$1) {
				if (!t$1.extensions || !t$1.extensions[vf]) return;
				const r$1 = t$1.extensions[vf], n$1 = new Uint8Array(e$1.buffers[r$1.buffer], r$1.byteOffset || 0, r$1.byteLength || 0), i$1 = new Uint8Array(r$1.count * r$1.byteStride);
				sf.decodeGltfBuffer(i$1, r$1.count, r$1.byteStride, n$1, r$1.mode, r$1.filter), t$1.buffer = e$1.buffers.length, t$1.byteOffset = 0, e$1.buffers[t$1.buffer] = i$1.buffer, delete t$1.extensions[vf];
			}
			const wf = 1179937895, _f = new TextDecoder("utf8");
			function Af(t$1, e$1) {
				return new URL(t$1, e$1).href;
			}
			function If(t$1, e$1, r$1, n$1) {
				return fetch(Af(t$1.uri, n$1)).then(((t$2) => t$2.arrayBuffer())).then(((t$2) => {
					e$1.buffers[r$1] = t$2;
				}));
			}
			function Mf(t$1, e$1) {
				const r$1 = t$1.json.bufferViews[e$1];
				return new Uint8Array(t$1.buffers[r$1.buffer], r$1.byteOffset || 0, r$1.byteLength);
			}
			function Sf(t$1, e$1, r$1, n$1) {
				if (t$1.uri) {
					const i$1 = Af(t$1.uri, n$1);
					return fetch(i$1).then(((t$2) => t$2.blob())).then(((t$2) => createImageBitmap(t$2))).then(((t$2) => {
						e$1.images[r$1] = t$2;
					}));
				}
				if (void 0 !== t$1.bufferView) {
					const n$2 = Mf(e$1, t$1.bufferView), i$1 = new Blob([n$2], { type: t$1.mimeType });
					return createImageBitmap(i$1).then(((t$2) => {
						e$1.images[r$1] = t$2;
					}));
				}
			}
			function Pf(t$1, e$1 = 0, r$1) {
				const n$1 = {
					json: null,
					images: [],
					buffers: []
				};
				if (new Uint32Array(t$1, e$1, 1)[0] === wf) {
					const r$2 = new Uint32Array(t$1, e$1);
					let i$2 = 2;
					const s$2 = (r$2[i$2++] >> 2) - 3, o$2 = r$2[i$2++] >> 2;
					if (i$2++, n$1.json = JSON.parse(_f.decode(r$2.subarray(i$2, i$2 + o$2))), i$2 += o$2, i$2 < s$2) {
						const s$3 = r$2[i$2++];
						i$2++;
						const o$3 = e$1 + (i$2 << 2);
						n$1.buffers[0] = t$1.slice(o$3, o$3 + s$3);
					}
				} else n$1.json = JSON.parse(_f.decode(new Uint8Array(t$1, e$1)));
				const { buffers: i$1, images: s$1, meshes: o$1, extensionsUsed: a$1, bufferViews: l$1 } = n$1.json;
				let u$1 = Promise.resolve();
				if (i$1) {
					const t$2 = [];
					for (let e$2 = 0; e$2 < i$1.length; e$2++) {
						const s$2 = i$1[e$2];
						s$2.uri ? t$2.push(If(s$2, n$1, e$2, r$1)) : n$1.buffers[e$2] || (n$1.buffers[e$2] = null);
					}
					u$1 = Promise.all(t$2);
				}
				return u$1.then((() => {
					const t$2 = [], e$2 = a$1 && a$1.includes(gf), i$2 = a$1 && a$1.includes(vf);
					if (e$2 && t$2.push(function() {
						if (!rf) return null != tf ? tf : (tf = function(t$3) {
							let e$3, r$2 = null;
							function n$2() {
								e$3 = new Uint8Array(r$2.buffer);
							}
							function i$3() {
								throw new Error("Unexpected Draco error.");
							}
							const s$2 = { a: {
								a: i$3,
								d: function(t$4, r$3, n$3) {
									return e$3.copyWithin(t$4, r$3, r$3 + n$3);
								},
								c: function(t$4) {
									const i$4 = e$3.length, s$3 = Math.max(t$4 >>> 0, Math.ceil(1.2 * i$4)), o$2 = Math.ceil((s$3 - i$4) / 65536);
									try {
										return r$2.grow(o$2), n$2(), !0;
									} catch (t$5) {
										return !1;
									}
								},
								b: i$3
							} };
							return (WebAssembly.instantiateStreaming ? WebAssembly.instantiateStreaming(t$3, s$2) : t$3.then(((t$4) => t$4.arrayBuffer())).then(((t$4) => WebAssembly.instantiate(t$4, s$2)))).then(((t$4) => {
								const { Rb: i$4, Qb: s$3, P: o$2, T: a$2, X: l$2, Ja: u$2, La: c$1, Qa: h$1, Va: p$1, Wa: d$1, eb: f$1, jb: m$1, f: y$1, e: g$1, yb: x$1, zb: v$1, Ab: b$1, Bb: w$1, Db: _$1, Gb: A$1 } = t$4.instance.exports;
								r$2 = g$1;
								const I$1 = (() => {
									let t$5 = 0, r$3 = 0, n$3 = 0, o$3 = 0;
									return (a$3) => {
										n$3 && (i$4(o$3), i$4(t$5), r$3 += n$3, n$3 = t$5 = 0), t$5 || (r$3 += 128, t$5 = s$3(r$3));
										const l$3 = a$3.length + 7 & -8;
										let u$3 = t$5;
										l$3 >= r$3 && (n$3 = l$3, u$3 = o$3 = s$3(l$3));
										for (let t$6 = 0; t$6 < a$3.length; t$6++) e$3[u$3 + t$6] = a$3[t$6];
										return u$3;
									};
								})();
								return n$2(), y$1(), {
									memory: g$1,
									_free: i$4,
									_malloc: s$3,
									Mesh: class {
										constructor() {
											this.ptr = o$2();
										}
										destroy() {
											a$2(this.ptr);
										}
									},
									Decoder: class {
										constructor() {
											this.ptr = u$2();
										}
										destroy() {
											m$1(this.ptr);
										}
										DecodeArrayToMesh(t$5, e$4, r$3) {
											const n$3 = I$1(t$5);
											return !!l$2(c$1(this.ptr, n$3, e$4, r$3.ptr));
										}
										GetAttributeByUniqueId(t$5, e$4) {
											return { ptr: h$1(this.ptr, t$5.ptr, e$4) };
										}
										GetTrianglesUInt16Array(t$5, e$4, r$3) {
											p$1(this.ptr, t$5.ptr, e$4, r$3);
										}
										GetTrianglesUInt32Array(t$5, e$4, r$3) {
											d$1(this.ptr, t$5.ptr, e$4, r$3);
										}
										GetAttributeDataArrayForAllPoints(t$5, e$4, r$3, n$3, i$5) {
											f$1(this.ptr, t$5.ptr, e$4.ptr, r$3, n$3, i$5);
										}
									},
									DT_INT8: x$1(),
									DT_UINT8: v$1(),
									DT_INT16: b$1(),
									DT_UINT16: w$1(),
									DT_UINT32: _$1(),
									DT_FLOAT32: A$1()
								};
							}));
						}(fetch(cf())), tf.then(((t$3) => {
							rf = t$3, tf = void 0;
						})));
					}()), i$2 && t$2.push(function() {
						if (sf) return;
						const t$3 = function(t$4) {
							let e$3;
							const r$2 = WebAssembly.instantiateStreaming(t$4, {}).then(((t$5) => {
								e$3 = t$5.instance, e$3.exports.__wasm_call_ctors();
							})), n$2 = {
								NONE: "",
								OCTAHEDRAL: "meshopt_decodeFilterOct",
								QUATERNION: "meshopt_decodeFilterQuat",
								EXPONENTIAL: "meshopt_decodeFilterExp"
							}, i$3 = {
								ATTRIBUTES: "meshopt_decodeVertexBuffer",
								TRIANGLES: "meshopt_decodeIndexBuffer",
								INDICES: "meshopt_decodeIndexSequence"
							};
							return {
								ready: r$2,
								supported: !0,
								decodeGltfBuffer(t$5, r$3, s$2, o$2, a$2, l$2) {
									(function(t$6, e$4, r$4, n$3, i$4, s$3, o$3) {
										const a$3 = t$6.exports.sbrk, l$3 = n$3 + 3 & -4, u$2 = a$3(l$3 * i$4), c$1 = a$3(s$3.length), h$1 = new Uint8Array(t$6.exports.memory.buffer);
										h$1.set(s$3, c$1);
										const p$1 = e$4(u$2, n$3, i$4, c$1, s$3.length);
										if (0 === p$1 && o$3 && o$3(u$2, l$3, i$4), r$4.set(h$1.subarray(u$2, u$2 + n$3 * i$4)), a$3(u$2 - a$3(0)), 0 !== p$1) throw new Error(`Malformed buffer data: ${p$1}`);
									})(e$3, e$3.exports[i$3[a$2]], t$5, r$3, s$2, o$2, e$3.exports[n$2[l$2]]);
								}
							};
						}(fetch(hf()));
						return t$3.ready.then((() => {
							sf = t$3;
						}));
					}()), s$1) for (let e$3 = 0; e$3 < s$1.length; e$3++) t$2.push(Sf(s$1[e$3], n$1, e$3, r$1));
					return (t$2.length ? Promise.all(t$2) : Promise.resolve()).then((() => {
						if (e$2 && o$1) for (const { primitives: t$3 } of o$1) for (const e$3 of t$3) xf(e$3, n$1);
						if (i$2 && o$1 && l$1) for (const t$3 of l$1) bf(t$3, n$1);
						return n$1;
					}));
				}));
			}
			function kf(t$1) {
				return fetch(t$1).then(((t$2) => t$2.arrayBuffer())).then(((e$1) => Pf(e$1, 0, t$1)));
			}
			function Bf(t$1) {
				switch (t$1) {
					case WebGL2RenderingContext.RGBA8: return WebGL2RenderingContext.RGBA;
					case WebGL2RenderingContext.DEPTH_COMPONENT16: return WebGL2RenderingContext.DEPTH_COMPONENT;
					case WebGL2RenderingContext.DEPTH24_STENCIL8: return WebGL2RenderingContext.DEPTH_STENCIL;
					case WebGL2RenderingContext.R8:
					case WebGL2RenderingContext.R32F: return WebGL2RenderingContext.RED;
				}
			}
			function zf(t$1) {
				switch (t$1) {
					case WebGL2RenderingContext.RGBA8: return WebGL2RenderingContext.UNSIGNED_BYTE;
					case WebGL2RenderingContext.DEPTH_COMPONENT16: return WebGL2RenderingContext.UNSIGNED_SHORT;
					case WebGL2RenderingContext.DEPTH24_STENCIL8: return WebGL2RenderingContext.UNSIGNED_INT_24_8;
					case WebGL2RenderingContext.R8: return WebGL2RenderingContext.UNSIGNED_BYTE;
					case WebGL2RenderingContext.R32F: return WebGL2RenderingContext.FLOAT;
				}
			}
			class Tf {
				constructor(t$1, e$1, r$1, n$1) {
					this.context = t$1, this.format = r$1, this.useMipmap = n$1 && n$1.useMipmap, this.texture = t$1.gl.createTexture(), this.update(e$1, { premultiply: n$1 && n$1.premultiply });
				}
				update(t$1, e$1) {
					const r$1 = t$1 && t$1 instanceof HTMLVideoElement && 0 === t$1.width ? t$1.videoWidth : t$1.width, n$1 = t$1 && t$1 instanceof HTMLVideoElement && 0 === t$1.height ? t$1.videoHeight : t$1.height, { context: i$1 } = this, { gl: s$1 } = i$1, { x: o$1, y: a$1 } = e$1 && e$1.position ? e$1.position : {
						x: 0,
						y: 0
					}, l$1 = o$1 + r$1, u$1 = a$1 + n$1;
					!this.size || this.size[0] === l$1 && this.size[1] === u$1 || (s$1.bindTexture(s$1.TEXTURE_2D, null), s$1.deleteTexture(this.texture), this.texture = s$1.createTexture(), this.size = null), s$1.bindTexture(s$1.TEXTURE_2D, this.texture), i$1.pixelStoreUnpackFlipY.set(!1), i$1.pixelStoreUnpack.set(1), i$1.pixelStoreUnpackPremultiplyAlpha.set(this.format === s$1.RGBA8 && (!e$1 || !1 !== e$1.premultiply));
					const c$1 = t$1 instanceof HTMLImageElement || t$1 instanceof HTMLCanvasElement || t$1 instanceof HTMLVideoElement || t$1 instanceof ImageData || ImageBitmap && t$1 instanceof ImageBitmap;
					if (!this.size && l$1 > 0 && u$1 > 0) {
						const t$2 = this.useMipmap ? Math.floor(Math.log2(Math.max(l$1, u$1))) + 1 : 1;
						s$1.texStorage2D(s$1.TEXTURE_2D, t$2, this.format, l$1, u$1), this.size = [l$1, u$1];
					}
					this.size && (c$1 ? s$1.texSubImage2D(s$1.TEXTURE_2D, 0, o$1, a$1, Bf(this.format), zf(this.format), t$1) : "data" in t$1 && t$1.data && s$1.texSubImage2D(s$1.TEXTURE_2D, 0, o$1, a$1, r$1, n$1, Bf(this.format), zf(this.format), t$1.data)), this.useMipmap && s$1.generateMipmap(s$1.TEXTURE_2D);
				}
				bind(t$1, e$1, r$1 = !1) {
					const { context: n$1 } = this, { gl: i$1 } = n$1;
					i$1.bindTexture(i$1.TEXTURE_2D, this.texture), t$1 !== this.minFilter && (i$1.texParameteri(i$1.TEXTURE_2D, i$1.TEXTURE_MAG_FILTER, t$1), i$1.texParameteri(i$1.TEXTURE_2D, i$1.TEXTURE_MIN_FILTER, this.useMipmap && !r$1 ? t$1 === i$1.NEAREST ? i$1.NEAREST_MIPMAP_NEAREST : i$1.LINEAR_MIPMAP_LINEAR : t$1), this.minFilter = t$1), e$1 !== this.wrapS && (i$1.texParameteri(i$1.TEXTURE_2D, i$1.TEXTURE_WRAP_S, e$1), i$1.texParameteri(i$1.TEXTURE_2D, i$1.TEXTURE_WRAP_T, e$1), this.wrapS = e$1);
				}
				bindExtraParam(t$1, e$1, r$1, n$1, i$1) {
					const { context: s$1 } = this, { gl: o$1 } = s$1;
					o$1.bindTexture(o$1.TEXTURE_2D, this.texture), e$1 !== this.magFilter && (o$1.texParameteri(o$1.TEXTURE_2D, o$1.TEXTURE_MAG_FILTER, e$1), this.magFilter = e$1), t$1 !== this.minFilter && (o$1.texParameteri(o$1.TEXTURE_2D, o$1.TEXTURE_MIN_FILTER, this.useMipmap ? t$1 === o$1.NEAREST ? o$1.NEAREST_MIPMAP_NEAREST : o$1.LINEAR_MIPMAP_LINEAR : t$1), this.minFilter = t$1), r$1 !== this.wrapS && (o$1.texParameteri(o$1.TEXTURE_2D, o$1.TEXTURE_WRAP_S, r$1), this.wrapS = r$1), n$1 !== this.wrapT && (o$1.texParameteri(o$1.TEXTURE_2D, o$1.TEXTURE_WRAP_T, n$1), this.wrapT = n$1), i$1 !== this.compareMode && (i$1 ? (o$1.texParameteri(o$1.TEXTURE_2D, o$1.TEXTURE_COMPARE_MODE, o$1.COMPARE_REF_TO_TEXTURE), o$1.texParameteri(o$1.TEXTURE_2D, o$1.TEXTURE_COMPARE_FUNC, i$1)) : o$1.texParameteri(o$1.TEXTURE_2D, o$1.TEXTURE_COMPARE_MODE, o$1.NONE), this.compareMode = i$1);
				}
				destroy() {
					const { gl: t$1 } = this.context;
					t$1.deleteTexture(this.texture), this.texture = null;
				}
			}
			class Ef {
				constructor(t$1, e$1) {
					this.context = t$1, this.texture = e$1;
				}
				bind(t$1, e$1) {
					const { context: r$1 } = this, { gl: n$1 } = r$1;
					n$1.bindTexture(n$1.TEXTURE_2D, this.texture), t$1 !== this.minFilter && (n$1.texParameteri(n$1.TEXTURE_2D, n$1.TEXTURE_MAG_FILTER, t$1), n$1.texParameteri(n$1.TEXTURE_2D, n$1.TEXTURE_MIN_FILTER, t$1), this.minFilter = t$1), e$1 !== this.wrapS && (n$1.texParameteri(n$1.TEXTURE_2D, n$1.TEXTURE_WRAP_S, e$1), n$1.texParameteri(n$1.TEXTURE_2D, n$1.TEXTURE_WRAP_T, e$1), this.wrapS = e$1);
				}
			}
			const Vf = ha([{
				name: "a_pos_3f",
				components: 3,
				type: "Float32"
			}]), Ff = ha([{
				name: "a_color_3f",
				components: 3,
				type: "Float32"
			}]), Cf = ha([{
				name: "a_color_4f",
				components: 4,
				type: "Float32"
			}]), Df = ha([{
				name: "a_uv_2f",
				components: 2,
				type: "Float32"
			}]), Rf = ha([{
				name: "a_normal_3f",
				components: 3,
				type: "Float32"
			}]), Lf = ha([
				{
					name: "a_normal_matrix0",
					components: 4,
					type: "Float32"
				},
				{
					name: "a_normal_matrix1",
					components: 4,
					type: "Float32"
				},
				{
					name: "a_normal_matrix2",
					components: 4,
					type: "Float32"
				},
				{
					name: "a_normal_matrix3",
					components: 4,
					type: "Float32"
				}
			]), Of = ha([{
				name: "a_pbr",
				components: 4,
				type: "Uint16"
			}, {
				name: "a_heightBasedEmissiveStrength",
				components: 3,
				type: "Float32"
			}]);
			function Uf(t$1, e$1) {
				const r$1 = jf(t$1.projection, t$1.zoom, t$1.width, t$1.height), n$1 = function(t$2, e$2, r$2, n$2, i$2) {
					const s$1 = new iu(r$2.lng - 180 * $f, r$2.lat), o$1 = new iu(r$2.lng + 180 * $f, r$2.lat), a$1 = t$2.project(s$1.lng, s$1.lat), l$1 = t$2.project(o$1.lng, o$1.lat), c$1 = -Math.atan2(l$1.y - a$1.y, l$1.x - a$1.x), p$1 = bu.fromLngLat(r$2);
					p$1.y = Ft(p$1.y, -1 + $f, 1 - $f);
					const f$1 = p$1.toLngLat(), m$1 = t$2.project(f$1.lng, f$1.lat), g$1 = bu.fromLngLat(f$1);
					g$1.x += $f;
					const x$1 = g$1.toLngLat(), v$1 = t$2.project(x$1.lng, x$1.lat), b$1 = qf(v$1.x - m$1.x, v$1.y - m$1.y, c$1), w$1 = bu.fromLngLat(f$1);
					w$1.y += $f;
					const _$1 = w$1.toLngLat(), A$1 = t$2.project(_$1.lng, _$1.lat), I$1 = qf(A$1.x - m$1.x, A$1.y - m$1.y, c$1), M$1 = Math.abs(b$1.x) / Math.abs(I$1.y), S$1 = u([]);
					y(S$1, S$1, -c$1 * (1 - (i$2 ? 0 : n$2)));
					const P$1 = u([]);
					return d(P$1, P$1, [
						1,
						1 - (1 - M$1) * n$2,
						1
					]), P$1[4] = -I$1.x / I$1.y * n$2, y(P$1, P$1, c$1), h(P$1, S$1, P$1), P$1;
				}(t$1.projection, 0, t$1.center, r$1, e$1), i$1 = Nf(t$1);
				return d(n$1, n$1, [
					i$1,
					i$1,
					1
				]), n$1;
			}
			function Nf(t$1) {
				const e$1 = t$1.projection, r$1 = jf(t$1.projection, t$1.zoom, t$1.width, t$1.height), n$1 = Gf(e$1, t$1.center), i$1 = Gf(e$1, iu.convert(e$1.center));
				return Math.pow(2, n$1 * r$1 + (1 - r$1) * i$1);
			}
			function jf(t$1, e$1, r$1, n$1, i$1 = Infinity) {
				const s$1 = t$1.range;
				if (!s$1) return 0;
				const o$1 = Math.min(i$1, Math.max(r$1, n$1)), a$1 = Math.log2(o$1 / 1024);
				return Ct(s$1[0] + a$1, s$1[1] + a$1, e$1);
			}
			const $f = 1 / 4e4;
			function Gf(t$1, e$1) {
				const r$1 = Ft(e$1.lat, -mu, mu), n$1 = new iu(e$1.lng - 180 * $f, r$1), i$1 = new iu(e$1.lng + 180 * $f, r$1), s$1 = t$1.project(n$1.lng, r$1), o$1 = t$1.project(i$1.lng, r$1), a$1 = bu.fromLngLat(n$1), l$1 = bu.fromLngLat(i$1), u$1 = o$1.x - s$1.x, c$1 = o$1.y - s$1.y, h$1 = l$1.x - a$1.x, p$1 = l$1.y - a$1.y, d$1 = Math.sqrt((h$1 * h$1 + p$1 * p$1) / (u$1 * u$1 + c$1 * c$1));
				return Math.log2(d$1);
			}
			function qf(t$1, e$1, r$1) {
				const n$1 = Math.cos(r$1), i$1 = Math.sin(r$1);
				return {
					x: t$1 * n$1 - e$1 * i$1,
					y: t$1 * i$1 + e$1 * n$1
				};
			}
			function Hf(t$1, e$1, r$1) {
				u(t$1), y(t$1, t$1, kt(e$1[2])), f(t$1, t$1, kt(e$1[0])), m(t$1, t$1, kt(e$1[1])), d(t$1, t$1, r$1), h(t$1, t$1, [
					1,
					0,
					0,
					0,
					0,
					0,
					1,
					0,
					0,
					1,
					0,
					0,
					0,
					0,
					0,
					1
				]);
			}
			function Xf(t$1, e$1, r$1, n$1, i$1, s$1, o$1, a$1) {
				const l$1 = [
					r$1[0] - e$1[0],
					r$1[1] - e$1[1],
					0
				], u$1 = [
					n$1[0] - e$1[0],
					n$1[1] - e$1[1],
					0
				];
				if (I(l$1) < 1e-12 || I(u$1) < 1e-12) return et(t$1);
				const c$1 = U([], l$1, u$1);
				L(c$1, c$1), k(u$1, n$1, e$1), l$1[2] = (s$1 - i$1) * a$1, u$1[2] = (o$1 - i$1) * a$1;
				const h$1 = l$1;
				return U(h$1, l$1, u$1), L(h$1, h$1), lt(t$1, c$1, h$1);
			}
			function Zf(t$1, e$1, r$1 = !1) {
				const n$1 = eh(e$1.zoom), i$1 = function(t$2, e$2, r$2) {
					const n$2 = e$2.worldSize, i$2 = [
						t$2[12],
						t$2[13],
						t$2[14]
					], s$1 = du(i$2[1] / n$2), o$1 = pu(i$2[0] / n$2), a$1 = u([]), l$1 = hu(1, s$1) * n$2, c$1 = hu(1, 0) * n$2 * gu(s$1, e$2.zoom), f$1 = 1 / Jc(n$2);
					let m$1 = c$1 * f$1;
					if (r$2) {
						const t$3 = jf(e$2.projection, e$2.zoom, e$2.width, e$2.height, 1024);
						m$1 = f$1 * e$2.projection.pixelSpaceConversion(e$2.center.lat, n$2, t$3);
					}
					const y$1 = eu(s$1, o$1);
					P(y$1, y$1, E([], L([], y$1), l$1 * m$1 * i$2[2]));
					const g$1 = function(t$3) {
						const e$3 = [
							t$3[0],
							t$3[1],
							t$3[2]
						];
						let r$3 = [
							0,
							1,
							0
						];
						const n$3 = U([], r$3, e$3);
						return U(r$3, e$3, n$3), 0 === D(r$3) && (r$3 = [
							0,
							1,
							0
						], U(n$3, e$3, r$3)), L(n$3, n$3), L(r$3, r$3), L(e$3, e$3), [
							n$3[0],
							n$3[1],
							n$3[2],
							0,
							r$3[0],
							r$3[1],
							r$3[2],
							0,
							e$3[0],
							e$3[1],
							e$3[2],
							0,
							t$3[0],
							t$3[1],
							t$3[2],
							1
						];
					}(y$1);
					d(a$1, a$1, [
						m$1,
						m$1,
						m$1 * l$1
					]), p(a$1, a$1, [
						-i$2[0],
						-i$2[1],
						-i$2[2]
					]);
					const x$1 = h([], e$2.globeMatrix, g$1);
					return h(x$1, x$1, a$1), h(x$1, x$1, t$2), x$1;
				}(t$1, e$1, r$1);
				if (n$1 > 0) return function(t$2, e$2, r$2) {
					const n$2 = (t$3, e$3, r$3) => {
						const n$3 = I(t$3), i$3 = I(e$3), s$2 = jc(t$3, e$3, r$3);
						return E(s$2, s$2, 1 / I(s$2) * pr(n$3, i$3, r$3));
					}, i$2 = n$2([
						t$2[0],
						t$2[1],
						t$2[2]
					], [
						e$2[0],
						e$2[1],
						e$2[2]
					], r$2), s$1 = n$2([
						t$2[4],
						t$2[5],
						t$2[6]
					], [
						e$2[4],
						e$2[5],
						e$2[6]
					], r$2), o$1 = n$2([
						t$2[8],
						t$2[9],
						t$2[10]
					], [
						e$2[8],
						e$2[9],
						e$2[10]
					], r$2), a$1 = jc([
						t$2[12],
						t$2[13],
						t$2[14]
					], [
						e$2[12],
						e$2[13],
						e$2[14]
					], r$2);
					return [
						i$2[0],
						i$2[1],
						i$2[2],
						0,
						s$1[0],
						s$1[1],
						s$1[2],
						0,
						o$1[0],
						o$1[1],
						o$1[2],
						0,
						a$1[0],
						a$1[1],
						a$1[2],
						1
					];
				}(i$1, function(t$2, e$2) {
					const r$2 = e$2.worldSize, n$2 = hu(1, 0) * r$2 * gu(e$2.center.lat, e$2.zoom) / Jc(r$2), i$2 = hu(1, e$2.center.lat) * r$2, s$1 = u([]);
					m(s$1, s$1, kt(e$2.center.lng)), f(s$1, s$1, kt(e$2.center.lat)), p(s$1, s$1, [
						0,
						0,
						Hl
					]), d(s$1, s$1, [
						n$2,
						n$2,
						n$2 * i$2
					]);
					const o$1 = e$2.point;
					return p(s$1, s$1, [
						-o$1.x,
						-o$1.y,
						0
					]), h(s$1, s$1, t$2), h(s$1, e$2.globeMatrix, s$1);
				}(t$1, e$1), n$1);
				return i$1;
			}
			function Wf(t$1, e$1, r$1, n$1) {
				const i$1 = Ju.projectAabbCorners(n$1, r$1);
				let s$1 = Number.MAX_VALUE;
				for (let t$2 = 0; t$2 < i$1.length; ++t$2) {
					const r$2 = i$1[t$2];
					r$2[0] = (.5 * r$2[0] + .5) * e$1.width, r$2[1] = (.5 - .5 * r$2[1]) * e$1.height, r$2[2] < s$1 && (s$1 = r$2[2]);
				}
				if (ic(t$1, function(t$2) {
					const e$2 = [];
					let r$2 = 0;
					for (let e$3 = 1; e$3 < t$2.length; e$3++) (t$2[e$3][0] < t$2[r$2][0] || t$2[e$3][0] === t$2[r$2][0] && t$2[e$3][1] < t$2[r$2][1]) && (r$2 = e$3);
					let n$2, i$2 = r$2;
					const s$2 = new Uint8Array(t$2.length);
					do {
						if (s$2[i$2]) break;
						e$2.push(new It(t$2[i$2][0], t$2[i$2][1])), s$2[i$2] = 1, n$2 = (i$2 + 1) % t$2.length;
						for (let e$3 = 0; e$3 < t$2.length; e$3++) {
							if (t$2[e$3][0] === t$2[n$2][0] && t$2[e$3][1] === t$2[n$2][1] || t$2[e$3][0] === t$2[i$2][0] && t$2[e$3][1] === t$2[i$2][1]) continue;
							const r$3 = [t$2[e$3][0] - t$2[i$2][0], t$2[e$3][1] - t$2[i$2][1]], s$3 = [t$2[n$2][0] - t$2[i$2][0], t$2[n$2][1] - t$2[i$2][1]], o$1 = r$3[0] * s$3[1] - r$3[1] * s$3[0];
							(o$1 > 0 || 0 === o$1 && r$3[0] * s$3[0] + r$3[1] * s$3[1] >= 0 && r$3[0] * r$3[0] + r$3[1] * r$3[1] > s$3[0] * s$3[0] + s$3[1] * s$3[1]) && (n$2 = e$3);
						}
						i$2 = n$2;
					} while (i$2 !== r$2);
					return e$2.length > 0 && e$2.push(e$2[0]), e$2;
				}(i$1))) return s$1;
			}
			const Yf = 64, Kf = {
				CoordinateSpaceTile: 1,
				HasMapboxMeshFeatures: 4,
				HasMeshoptCompression: 8
			};
			function Jf(t$1, e$1, r$1, n$1, i$1, s$1, o$1, a$1, l$1, c$1 = !1) {
				const f$1 = r$1.zoom, m$1 = r$1.project(n$1), y$1 = gu(n$1.lat, f$1), g$1 = 1 / y$1;
				u(t$1), p(t$1, t$1, [
					m$1.x + o$1[0] * g$1,
					m$1.y + o$1[1] * g$1,
					o$1[2]
				]);
				let x$1 = 1, v$1 = 1;
				const w$1 = r$1.worldSize;
				if (c$1) {
					if ("mercator" === r$1.projection.name) {
						let t$2 = 0;
						r$1.elevation && (t$2 = r$1.elevation.getAtPointOrZero(new bu(m$1.x / w$1, m$1.y / w$1), 0));
						const e$2 = Q([], [
							m$1.x,
							m$1.y,
							t$2,
							1
						], r$1.projMatrix)[3] / r$1.cameraToCenterDistance;
						x$1 = e$2, v$1 = e$2 * gu(r$1.center.lat, f$1);
					} else if ("globe" === r$1.projection.name) {
						const e$2 = Zf(t$1, r$1), i$2 = [
							0,
							0,
							0,
							1
						];
						Q(i$2, i$2, h([], r$1.projMatrix, e$2));
						const s$2 = i$2[3] / r$1.cameraToCenterDistance, o$2 = eh(f$1), a$2 = r$1.projection.pixelsPerMeter(n$1.lat, w$1) * gu(n$1.lat, f$1), l$2 = r$1.projection.pixelsPerMeter(r$1.center.lat, w$1) * gu(r$1.center.lat, f$1);
						x$1 = s$2 / pr(a$2, yu(r$1.center.lat), o$2), v$1 = s$2 * y$1 / a$2, x$1 *= l$2, v$1 *= l$2;
					}
				} else x$1 = g$1;
				d(t$1, t$1, [
					x$1,
					x$1,
					v$1
				]);
				const _$1 = [...t$1], A$1 = e$1.orientation, I$1 = [];
				if (Hf(I$1, [
					A$1[0] + (i$1 ? i$1[0] : 0),
					A$1[1] + (i$1 ? i$1[1] : 0),
					A$1[2] + (i$1 ? i$1[2] : 0)
				], s$1), h(t$1, _$1, I$1), a$1 && r$1.elevation) {
					let i$2 = 0;
					const s$2 = [];
					if (l$1 && r$1.elevation) {
						i$2 = function(t$2, e$2, r$2, n$2, i$3) {
							const s$3 = e$2.elevation;
							if (!s$3) return 0;
							const o$2 = Ju.projectAabbCorners(r$2, n$2), a$2 = hu(1, i$3.lat) * e$2.worldSize, l$2 = function(t$3, e$3) {
								const r$3 = [
									0,
									0,
									1
								], n$3 = [
									{
										corners: [
											0,
											1,
											3,
											2
										],
										dotProductWithUp: 0
									},
									{
										corners: [
											1,
											5,
											2,
											6
										],
										dotProductWithUp: 0
									},
									{
										corners: [
											0,
											4,
											1,
											5
										],
										dotProductWithUp: 0
									},
									{
										corners: [
											2,
											6,
											3,
											7
										],
										dotProductWithUp: 0
									},
									{
										corners: [
											4,
											7,
											5,
											6
										],
										dotProductWithUp: 0
									},
									{
										corners: [
											0,
											3,
											4,
											7
										],
										dotProductWithUp: 0
									}
								];
								for (const i$4 of n$3) {
									const n$4 = t$3[i$4.corners[0]], s$4 = t$3[i$4.corners[1]], o$3 = t$3[i$4.corners[2]], a$3 = [
										s$4[0] - n$4[0],
										s$4[1] - n$4[1],
										e$3 * (s$4[2] - n$4[2])
									], l$3 = U(a$3, a$3, [
										o$3[0] - n$4[0],
										o$3[1] - n$4[1],
										e$3 * (o$3[2] - n$4[2])
									]);
									L(l$3, l$3), i$4.dotProductWithUp = O(l$3, r$3);
								}
								return n$3.sort(((t$4, e$4) => t$4.dotProductWithUp - e$4.dotProductWithUp)), n$3[0].corners;
							}(o$2, a$2), u$1 = o$2[l$2[0]], c$2 = o$2[l$2[1]], h$1 = o$2[l$2[2]], p$1 = o$2[l$2[3]], d$1 = s$3.getAtPointOrZero(new bu(u$1[0] / e$2.worldSize, u$1[1] / e$2.worldSize), 0), f$2 = s$3.getAtPointOrZero(new bu(c$2[0] / e$2.worldSize, c$2[1] / e$2.worldSize), 0), m$2 = s$3.getAtPointOrZero(new bu(h$1[0] / e$2.worldSize, h$1[1] / e$2.worldSize), 0), y$2 = s$3.getAtPointOrZero(new bu(p$1[0] / e$2.worldSize, p$1[1] / e$2.worldSize), 0), g$2 = (d$1 + y$2) / 2, x$2 = (f$2 + m$2) / 2;
							return g$2 > x$2 ? f$2 < m$2 ? Xf(t$2, c$2, p$1, u$1, f$2, y$2, d$1, a$2) : Xf(t$2, h$1, u$1, p$1, m$2, d$1, y$2, a$2) : d$1 < y$2 ? Xf(t$2, u$1, c$2, h$1, d$1, f$2, m$2, a$2) : Xf(t$2, p$1, h$1, c$2, y$2, m$2, f$2, a$2), Math.max(g$2, x$2);
						}(s$2, r$1, e$1.aabb, t$1, n$1);
						h(t$1, _$1, h([], b([], s$2), I$1));
					} else i$2 = r$1.elevation.getAtPointOrZero(new bu(m$1.x / w$1, m$1.y / w$1), 0);
					0 !== i$2 && (t$1[14] += i$2);
				}
			}
			class Qf {
				constructor(t$1, e$1, r$1, n$1, i$1) {
					this.materialOverrides = /* @__PURE__ */ new Map(), this.nodeOverrides = /* @__PURE__ */ new Map(), this.materialOverrideNames = [], this.nodeOverrideNames = [], this.featureProperties = {}, this.id = t$1, this.uri = e$1, this.position = null != r$1 ? new iu(r$1[0], r$1[1]) : new iu(0, 0), this.orientation = null != n$1 ? n$1 : [
						0,
						0,
						0
					], this.nodes = i$1, this.uploaded = !1, this.aabb = new Ju([
						Infinity,
						Infinity,
						Infinity
					], [
						-Infinity,
						-Infinity,
						-Infinity
					]), this.matrix = [];
				}
				_applyTransformations(t$1, e$1) {
					h(t$1.globalMatrix, e$1, t$1.localMatrix);
					const r$1 = this.nodeOverrides.get(t$1.name);
					if (void 0 !== r$1) {
						const e$2 = [];
						i$1 = r$1.orientation, u(n$1 = e$2), m(n$1, n$1, kt(i$1[1])), y(n$1, n$1, kt(i$1[2])), f(n$1, n$1, kt(i$1[0])), h(t$1.globalMatrix, t$1.globalMatrix, e$2);
					}
					var n$1, i$1;
					if (t$1.meshes) for (const e$2 of t$1.meshes) {
						const r$2 = Ju.applyTransformFast(e$2.aabb, t$1.globalMatrix);
						this.aabb.encapsulate(r$2);
					}
					if (t$1.children) for (const e$2 of t$1.children) this._applyTransformations(e$2, t$1.globalMatrix);
				}
				computeBoundsAndApplyParent() {
					const t$1 = u([]);
					this.aabb = new Ju([
						Infinity,
						Infinity,
						Infinity
					], [
						-Infinity,
						-Infinity,
						-Infinity
					]);
					for (const e$1 of this.nodes) this._applyTransformations(e$1, t$1);
				}
				computeModelMatrix(t$1, e$1, r$1, n$1, i$1, s$1, o$1 = !1) {
					Jf(this.matrix, this, t$1.transform, this.position, e$1, r$1, n$1, i$1, s$1, o$1);
				}
				upload(t$1) {
					if (!this.uploaded) {
						for (const e$1 of this.nodes) rm(e$1, t$1);
						for (const t$2 of this.nodes) nm(t$2);
						this.uploaded = !0;
					}
				}
				destroy() {
					for (const t$1 of this.nodes) im(t$1);
				}
			}
			function tm(t$1, e$1, r$1 = !1) {
				t$1.uploaded || (t$1.gfxTexture = new Tf(e$1, t$1.image, r$1 ? e$1.gl.R8 : e$1.gl.RGBA8, { useMipmap: t$1.sampler.minFilter >= e$1.gl.NEAREST_MIPMAP_NEAREST }), t$1.uploaded = !0, t$1.image = null);
			}
			function em(t$1, e$1, r$1) {
				t$1.indexBuffer = e$1.createIndexBuffer(t$1.indexArray, !1, !0), t$1.vertexBuffer = e$1.createVertexBuffer(t$1.vertexArray, Vf.members, !1, !0), t$1.normalArray && (t$1.normalBuffer = e$1.createVertexBuffer(t$1.normalArray, Rf.members, !1, !0)), t$1.texcoordArray && (t$1.texcoordBuffer = e$1.createVertexBuffer(t$1.texcoordArray, Df.members, !1, !0)), t$1.colorArray && (t$1.colorBuffer = e$1.createVertexBuffer(t$1.colorArray, (12 === t$1.colorArray.bytesPerElement ? Ff : Cf).members, !1, !0)), t$1.featureArray && (t$1.pbrBuffer = e$1.createVertexBuffer(t$1.featureArray, Of.members, !0)), t$1.segments = hl.simpleSegment(0, 0, t$1.vertexArray.length, t$1.indexArray.length);
				const n$1 = t$1.material;
				n$1.pbrMetallicRoughness.baseColorTexture && tm(n$1.pbrMetallicRoughness.baseColorTexture, e$1), n$1.pbrMetallicRoughness.metallicRoughnessTexture && tm(n$1.pbrMetallicRoughness.metallicRoughnessTexture, e$1), n$1.normalTexture && tm(n$1.normalTexture, e$1), n$1.occlusionTexture && tm(n$1.occlusionTexture, e$1, r$1), n$1.emissionTexture && tm(n$1.emissionTexture, e$1);
			}
			function rm(t$1, e$1, r$1) {
				if (t$1.meshes) for (const n$1 of t$1.meshes) em(n$1, e$1, r$1);
				if (t$1.children) for (const n$1 of t$1.children) rm(n$1, e$1, r$1);
			}
			function nm(t$1) {
				if (t$1.meshes) for (const e$1 of t$1.meshes) e$1.indexArray.destroy(), e$1.vertexArray.destroy(), e$1.colorArray && e$1.colorArray.destroy(), e$1.normalArray && e$1.normalArray.destroy(), e$1.texcoordArray && e$1.texcoordArray.destroy(), e$1.featureArray && e$1.featureArray.destroy();
				if (t$1.children) for (const e$1 of t$1.children) nm(e$1);
			}
			function im(t$1) {
				if (t$1.meshes) for (const r$1 of t$1.meshes) r$1.vertexBuffer && (r$1.vertexBuffer.destroy(), r$1.indexBuffer.destroy(), r$1.normalBuffer && r$1.normalBuffer.destroy(), r$1.texcoordBuffer && r$1.texcoordBuffer.destroy(), r$1.colorBuffer && r$1.colorBuffer.destroy(), r$1.pbrBuffer && r$1.pbrBuffer.destroy(), r$1.segments.destroy(), r$1.material && ((e$1 = r$1.material).pbrMetallicRoughness.baseColorTexture && e$1.pbrMetallicRoughness.baseColorTexture.gfxTexture && e$1.pbrMetallicRoughness.baseColorTexture.gfxTexture.destroy(), e$1.pbrMetallicRoughness.metallicRoughnessTexture && e$1.pbrMetallicRoughness.metallicRoughnessTexture.gfxTexture && e$1.pbrMetallicRoughness.metallicRoughnessTexture.gfxTexture.destroy(), e$1.normalTexture && e$1.normalTexture.gfxTexture && e$1.normalTexture.gfxTexture.destroy(), e$1.emissionTexture && e$1.emissionTexture.gfxTexture && e$1.emissionTexture.gfxTexture.destroy(), e$1.occlusionTexture && e$1.occlusionTexture.gfxTexture && e$1.occlusionTexture.gfxTexture.destroy()));
				var e$1;
				if (t$1.children) for (const e$2 of t$1.children) im(e$2);
			}
			function sm(t$1, e$1) {
				const r$1 = t$1.json.bufferViews[e$1.bufferView], n$1 = df[e$1.componentType];
				return new n$1(t$1.buffers[r$1.buffer], (e$1.byteOffset || 0) + (r$1.byteOffset || 0), e$1.count * (r$1.byteStride && r$1.byteStride !== mf[e$1.type] * n$1.BYTES_PER_ELEMENT ? r$1.byteStride / n$1.BYTES_PER_ELEMENT : mf[e$1.type]));
			}
			function om(t$1, e$1, r$1, n$1) {
				const i$1 = df[e$1.componentType], s$1 = function(t$2) {
					switch (t$2) {
						case Int8Array: return 1 / 127;
						case Uint8Array: return 1 / 255;
						case Int16Array: return 1 / 32767;
						case Uint16Array: return 1 / 65535;
						default: return 1;
					}
				}(i$1), o$1 = t$1.json.bufferViews[e$1.bufferView], a$1 = o$1.byteStride ? o$1.byteStride / i$1.BYTES_PER_ELEMENT : mf[e$1.type], l$1 = r$1.float32, u$1 = l$1.length / r$1.capacity;
				for (let t$2 = 0, r$2 = 0; t$2 < e$1.count * a$1; t$2 += a$1, r$2 += u$1) for (let e$2 = 0; e$2 < u$1; e$2++) l$1[r$2 + e$2] = n$1[t$2 + e$2] * s$1;
				r$1._trim();
			}
			function am(t$1, e$1, r$1) {
				const n$1 = t$1.indices, i$1 = t$1.attributes, s$1 = {};
				s$1.indexArray = new Fa();
				const o$1 = e$1.json.accessors[n$1], a$1 = o$1.count / 3;
				s$1.indexArray.reserve(a$1);
				const l$1 = sm(e$1, o$1);
				for (let t$2 = 0; t$2 < a$1; t$2++) s$1.indexArray.emplaceBack(l$1[3 * t$2], l$1[3 * t$2 + 1], l$1[3 * t$2 + 2]);
				s$1.indexArray._trim(), s$1.vertexArray = new wa();
				const u$1 = e$1.json.accessors[i$1.POSITION];
				s$1.vertexArray.reserve(u$1.count);
				const c$1 = sm(e$1, u$1);
				for (let t$2 = 0; t$2 < u$1.count; t$2++) s$1.vertexArray.emplaceBack(c$1[3 * t$2], c$1[3 * t$2 + 1], c$1[3 * t$2 + 2]);
				if (s$1.vertexArray._trim(), s$1.aabb = new Ju(u$1.min, u$1.max), s$1.centroid = function(t$2, e$2) {
					const r$2 = [
						0,
						0,
						0
					], n$2 = t$2.length;
					if (n$2 > 0) {
						for (let i$2 = 0; i$2 < n$2; i$2++) {
							const n$3 = 3 * t$2[i$2];
							r$2[0] += e$2[n$3], r$2[1] += e$2[n$3 + 1], r$2[2] += e$2[n$3 + 2];
						}
						r$2[0] /= n$2, r$2[1] /= n$2, r$2[2] /= n$2;
					}
					return r$2;
				}(l$1, c$1), void 0 !== i$1.COLOR_0) {
					const t$2 = e$1.json.accessors[i$1.COLOR_0], r$2 = mf[t$2.type], n$2 = sm(e$1, t$2);
					s$1.colorArray = 3 === r$2 ? new wa() : new Pa(), s$1.colorArray.resize(t$2.count), om(e$1, t$2, s$1.colorArray, n$2);
				}
				if (void 0 !== i$1.NORMAL) {
					s$1.normalArray = new wa();
					const t$2 = e$1.json.accessors[i$1.NORMAL];
					s$1.normalArray.resize(t$2.count);
					const r$2 = sm(e$1, t$2);
					om(e$1, t$2, s$1.normalArray, r$2);
				}
				if (void 0 !== i$1.TEXCOORD_0 && r$1.length > 0) {
					s$1.texcoordArray = new ja();
					const t$2 = e$1.json.accessors[i$1.TEXCOORD_0];
					s$1.texcoordArray.resize(t$2.count);
					const r$2 = sm(e$1, t$2);
					om(e$1, t$2, s$1.texcoordArray, r$2);
				}
				if (void 0 !== i$1._FEATURE_ID_RGBA4444) {
					const t$2 = e$1.json.accessors[i$1._FEATURE_ID_RGBA4444];
					e$1.json.extensionsUsed && e$1.json.extensionsUsed.includes("EXT_meshopt_compression") && (s$1.featureData = sm(e$1, t$2));
				}
				void 0 !== i$1._FEATURE_RGBA4444 && (s$1.featureData = new Uint32Array(sm(e$1, e$1.json.accessors[i$1._FEATURE_RGBA4444]).buffer));
				const h$1 = t$1.material;
				return s$1.material = function(t$2, e$2) {
					const { emissiveFactor: r$2 = [
						0,
						0,
						0
					], alphaMode: n$2 = "OPAQUE", alphaCutoff: i$2 = .5, normalTexture: s$2, occlusionTexture: o$2, emissiveTexture: a$2, doubleSided: l$2, name: u$2 } = t$2, { baseColorFactor: c$2 = [
						1,
						1,
						1,
						1
					], metallicFactor: h$2 = 1, roughnessFactor: p$1 = 1, baseColorTexture: d$1, metallicRoughnessTexture: f$1 } = t$2.pbrMetallicRoughness || {}, m$1 = o$2 ? e$2[o$2.index] : void 0;
					if (o$2 && o$2.extensions && o$2.extensions.KHR_texture_transform && m$1) {
						const t$3 = o$2.extensions.KHR_texture_transform;
						m$1.offsetScale = [
							t$3.offset[0],
							t$3.offset[1],
							t$3.scale[0],
							t$3.scale[1]
						];
					}
					return {
						name: u$2,
						pbrMetallicRoughness: {
							baseColorFactor: new lr(...c$2),
							metallicFactor: h$2,
							roughnessFactor: p$1,
							baseColorTexture: d$1 ? e$2[d$1.index] : void 0,
							metallicRoughnessTexture: f$1 ? e$2[f$1.index] : void 0
						},
						doubleSided: l$2,
						emissiveFactor: new lr(...r$2),
						alphaMode: n$2,
						alphaCutoff: i$2,
						normalTexture: s$2 ? e$2[s$2.index] : void 0,
						occlusionTexture: m$1,
						emissionTexture: a$2 ? e$2[a$2.index] : void 0,
						defined: void 0 === t$2.defined
					};
				}(void 0 !== h$1 ? e$1.json.materials[h$1] : { defined: !1 }, r$1), s$1;
			}
			function lm(t$1, e$1, r$1) {
				const { matrix: n$1, rotation: i$1, translation: s$1, scale: o$1, mesh: a$1, extras: u$1, children: c$1, name: h$1 } = t$1, p$1 = {};
				if (p$1.name = h$1, p$1.localMatrix = n$1 || function(t$2, e$2, r$2, n$2) {
					var i$2 = e$2[0], s$2 = e$2[1], o$2 = e$2[2], a$2 = e$2[3], l$1 = i$2 + i$2, u$2 = s$2 + s$2, c$2 = o$2 + o$2, h$2 = i$2 * l$1, p$2 = i$2 * u$2, d$1 = i$2 * c$2, f$1 = s$2 * u$2, m$1 = s$2 * c$2, y$1 = o$2 * c$2, g$1 = a$2 * l$1, x$1 = a$2 * u$2, v$1 = a$2 * c$2, b$1 = n$2[0], w$1 = n$2[1], _$1 = n$2[2];
					return t$2[0] = (1 - (f$1 + y$1)) * b$1, t$2[1] = (p$2 + v$1) * b$1, t$2[2] = (d$1 - x$1) * b$1, t$2[3] = 0, t$2[4] = (p$2 - v$1) * w$1, t$2[5] = (1 - (h$2 + y$1)) * w$1, t$2[6] = (m$1 + g$1) * w$1, t$2[7] = 0, t$2[8] = (d$1 + x$1) * _$1, t$2[9] = (m$1 - g$1) * _$1, t$2[10] = (1 - (h$2 + f$1)) * _$1, t$2[11] = 0, t$2[12] = r$2[0], t$2[13] = r$2[1], t$2[14] = r$2[2], t$2[15] = 1, t$2;
				}([], i$1 || [
					0,
					0,
					0,
					1
				], s$1 || [
					0,
					0,
					0
				], o$1 || [
					1,
					1,
					1
				]), p$1.globalMatrix = l(p$1.localMatrix), void 0 !== a$1) {
					p$1.meshes = r$1[a$1];
					const t$2 = p$1.anchor = [0, 0];
					for (const e$2 of p$1.meshes) {
						const { min: r$2, max: n$2 } = e$2.aabb;
						t$2[0] += r$2[0] + n$2[0], t$2[1] += r$2[1] + n$2[1];
					}
					t$2[0] = Math.floor(t$2[0] / p$1.meshes.length / 2), t$2[1] = Math.floor(t$2[1] / p$1.meshes.length / 2);
				}
				if (u$1 && (u$1.id && (p$1.id = u$1.id), u$1.lights && (p$1.lights = function(t$2) {
					if (!t$2.length) return [];
					const e$2 = function(t$3) {
						const e$3 = atob(t$3), r$3 = new Uint8Array(e$3.length);
						for (let t$4 = 0; t$4 < e$3.length; t$4++) r$3[t$4] = e$3.codePointAt(t$4);
						return r$3;
					}(t$2), r$2 = [], n$2 = e$2.length / 24, i$2 = new Uint16Array(e$2.buffer), s$2 = new Float32Array(e$2.buffer);
					for (let t$3 = 0; t$3 < n$2; t$3++) {
						const e$3 = i$2[2 * t$3 * 6] / 30, n$3 = i$2[2 * t$3 * 6 + 1] / 30, o$2 = i$2[2 * t$3 * 6 + 10] / 100, a$2 = s$2[6 * t$3 + 1], l$1 = s$2[6 * t$3 + 2], u$2 = s$2[6 * t$3 + 3], c$2 = s$2[6 * t$3 + 4], h$2 = u$2 - a$2, p$2 = c$2 - l$1, d$1 = Math.hypot(h$2, p$2);
						r$2.push({
							pos: [
								a$2 + .5 * h$2,
								l$1 + .5 * p$2,
								n$3
							],
							normal: [
								p$2 / d$1,
								-h$2 / d$1,
								0
							],
							width: d$1,
							height: e$3,
							depth: o$2,
							points: [
								a$2,
								l$1,
								u$2,
								c$2
							]
						});
					}
					return r$2;
				}(u$1.lights)), u$1.MAPBOX_geometry_bloom && (p$1.isGeometryBloom = u$1.MAPBOX_geometry_bloom)), c$1) {
					const t$2 = [];
					for (const n$2 of c$1) t$2.push(lm(e$1.json.nodes[n$2], e$1, r$1));
					p$1.children = t$2;
				}
				return p$1;
			}
			function um(t$1) {
				if (0 === t$1.vertices.length || 0 === t$1.indices.length) return null;
				const e$1 = new Mp(t$1.vertices, t$1.indices, 8, 256), [r$1, n$1] = [e$1.min.clone(), e$1.max.clone()];
				return {
					vertices: t$1.vertices,
					indices: t$1.indices,
					grid: e$1,
					min: r$1,
					max: n$1
				};
			}
			function cm(t$1) {
				if (!t$1.extras || !t$1.extras.ground) return null;
				const e$1 = t$1.extras.ground;
				if (!e$1 || !Array.isArray(e$1) || 0 === e$1.length) return null;
				const r$1 = e$1[0];
				if (!r$1 || !Array.isArray(r$1) || 0 === r$1.length) return null;
				const n$1 = [];
				for (const t$2 of r$1) {
					if (!Array.isArray(t$2) || 2 !== t$2.length) continue;
					const e$2 = t$2[0], r$2 = t$2[1];
					"number" == typeof e$2 && "number" == typeof r$2 && n$1.push(new It(e$2, r$2));
				}
				if (n$1.length < 3) return null;
				n$1.length > 1 && n$1[n$1.length - 1].equals(n$1[0]) && n$1.pop();
				let i$1 = 0;
				for (let t$2 = 0; t$2 < n$1.length; t$2++) {
					const e$2 = n$1[t$2], r$2 = n$1[(t$2 + 1) % n$1.length], s$2 = n$1[(t$2 + 2) % n$1.length];
					i$1 += (e$2.x - r$2.x) * (s$2.y - r$2.y) - (s$2.x - r$2.x) * (e$2.y - r$2.y);
				}
				i$1 > 0 && n$1.reverse();
				const s$1 = zh(n$1.flatMap(((t$2) => [t$2.x, t$2.y])), []);
				return 0 === s$1.length ? null : {
					vertices: n$1,
					indices: s$1
				};
			}
			function hm(t$1, e$1) {
				const r$1 = [], n$1 = [];
				let i$1 = 0;
				const s$1 = [];
				for (const o$1 of t$1) {
					i$1 = r$1.length;
					const t$2 = o$1.vertexArray.float32, a$1 = o$1.indexArray.uint16;
					for (let n$2 = 0; n$2 < o$1.vertexArray.length; n$2++) s$1[0] = t$2[3 * n$2 + 0], s$1[1] = t$2[3 * n$2 + 1], s$1[2] = t$2[3 * n$2 + 2], j(s$1, s$1, e$1), r$1.push(new It(s$1[0], s$1[1]));
					for (let t$3 = 0; t$3 < 3 * o$1.indexArray.length; t$3++) n$1.push(a$1[t$3] + i$1);
				}
				if (n$1.length % 3 != 0) return null;
				for (let t$2 = 0; t$2 < n$1.length; t$2 += 3) {
					const e$2 = r$1[n$1[t$2 + 0]], i$2 = r$1[n$1[t$2 + 1]], s$2 = r$1[n$1[t$2 + 2]];
					(e$2.x - i$2.x) * (s$2.y - i$2.y) - (s$2.x - i$2.x) * (e$2.y - i$2.y) > 0 && ([n$1[t$2 + 1], n$1[t$2 + 2]] = [n$1[t$2 + 2], n$1[t$2 + 1]]);
				}
				return {
					vertices: r$1,
					indices: n$1
				};
			}
			function pm(t$1) {
				const r$1 = function(t$2, e$1) {
					const r$2 = [];
					for (const n$2 of t$2.json.meshes) {
						const i$2 = [];
						for (const r$3 of n$2.primitives) i$2.push(am(r$3, t$2, e$1));
						r$2.push(i$2);
					}
					return r$2;
				}(t$1, function(t$2, e$1) {
					const r$2 = [], n$2 = WebGL2RenderingContext;
					if (t$2.json.textures) for (const i$2 of t$2.json.textures) {
						const s$2 = {
							magFilter: n$2.LINEAR,
							minFilter: n$2.NEAREST,
							wrapS: n$2.REPEAT,
							wrapT: n$2.REPEAT
						};
						void 0 !== i$2.sampler && Object.assign(s$2, t$2.json.samplers[i$2.sampler]), r$2.push({
							image: e$1[i$2.source],
							sampler: s$2,
							uploaded: !1
						});
					}
					return r$2;
				}(t$1, t$1.images)), { scenes: n$1, scene: i$1, nodes: s$1 } = t$1.json, o$1 = n$1 ? n$1[i$1 || 0].nodes : [...s$1.keys()], a$1 = [];
				for (const e$1 of o$1) a$1.push(lm(s$1[e$1], t$1, r$1));
				return function(t$2, e$1, r$2) {
					const n$2 = {}, i$2 = /* @__PURE__ */ new Set();
					for (let s$2 = 0; s$2 < t$2.length; s$2++) {
						const t$3 = r$2[e$1[s$2]];
						if (!t$3.extras) continue;
						const o$2 = t$3.extras["mapbox:footprint:version"], a$2 = t$3.extras["mapbox:footprint:id"];
						(o$2 || a$2) && i$2.add(s$2), "1.0.0" === o$2 && a$2 && (n$2[a$2] = s$2);
					}
					for (let s$2 = 0; s$2 < t$2.length; s$2++) {
						if (i$2.has(s$2)) continue;
						const o$2 = t$2[s$2], a$2 = r$2[e$1[s$2]];
						if (!a$2.extras) continue;
						let l$1 = null;
						o$2.id in n$2 && (l$1 = hm(t$2[n$2[o$2.id]].meshes, o$2.localMatrix)), l$1 || (l$1 = cm(a$2)), l$1 && (o$2.footprint = um(l$1));
					}
					if (i$2.size > 0) {
						const e$2 = Array.from(i$2.values()).sort(((t$3, e$3) => t$3 - e$3));
						for (let r$3 = e$2.length - 1; r$3 >= 0; r$3--) t$2.splice(e$2[r$3], 1);
					}
				}(a$1, o$1, t$1.json.nodes), a$1;
			}
			function dm(t$1) {
				t$1.heightmap = new Float32Array(4096), t$1.heightmap.fill(-1);
				const e$1 = t$1.vertexArray.float32, r$1 = t$1.aabb.min[0] - 1, n$1 = t$1.aabb.min[1] - 1, i$1 = Yf / (t$1.aabb.max[0] - r$1 + 2), s$1 = Yf / (t$1.aabb.max[1] - n$1 + 2);
				for (let o$1 = 0; o$1 < e$1.length; o$1 += 3) {
					const a$1 = e$1[o$1 + 2], l$1 = (e$1[o$1 + 0] - r$1) * i$1 | 0, u$1 = (e$1[o$1 + 1] - n$1) * s$1 | 0;
					a$1 > t$1.heightmap[u$1 * Yf + l$1] && (t$1.heightmap[u$1 * Yf + l$1] = a$1);
				}
			}
			function fm(t$1, e$1, r$1, n$1, i$1) {
				r$1.reserve(r$1.length + 4 * t$1.length), n$1.reserve(n$1.length + 10 * t$1.length), i$1.reserve(i$1.length + 10 * t$1.length);
				let s$1 = n$1.length;
				for (const o$1 of t$1) {
					const t$2 = Math.min(10, Math.max(4, 1.3 * o$1.height)) * e$1, a$1 = [
						-o$1.normal[1],
						o$1.normal[0],
						0
					], l$1 = Math.min(.29, .1 * o$1.width / o$1.depth), u$1 = o$1.width - 2 * o$1.depth * e$1 * (l$1 + .01), c$1 = V([], o$1.pos, a$1, u$1 / 2), h$1 = V([], o$1.pos, a$1, -u$1 / 2), p$1 = [
						c$1[0],
						c$1[1],
						c$1[2] + o$1.height
					], d$1 = [
						h$1[0],
						h$1[1],
						h$1[2] + o$1.height
					], f$1 = V([], o$1.normal, a$1, l$1);
					E(f$1, f$1, t$2);
					const m$1 = V([], o$1.normal, a$1, -l$1);
					E(m$1, m$1, t$2), P(f$1, c$1, f$1), P(m$1, h$1, m$1), c$1[2] += .1, h$1[2] += .1, n$1.emplaceBack(f$1[0], f$1[1], f$1[2]), n$1.emplaceBack(m$1[0], m$1[1], m$1[2]), n$1.emplaceBack(c$1[0], c$1[1], c$1[2]), n$1.emplaceBack(h$1[0], h$1[1], h$1[2]), n$1.emplaceBack(p$1[0], p$1[1], p$1[2]), n$1.emplaceBack(d$1[0], d$1[1], d$1[2]), n$1.emplaceBack(c$1[0], c$1[1], c$1[2]), n$1.emplaceBack(h$1[0], h$1[1], h$1[2]), n$1.emplaceBack(f$1[0], f$1[1], f$1[2]), n$1.emplaceBack(m$1[0], m$1[1], m$1[2]);
					const y$1 = u$1 / t$2 / 2;
					i$1.emplaceBack(-y$1 - l$1, -1, y$1, .8), i$1.emplaceBack(y$1 + l$1, -1, y$1, .8), i$1.emplaceBack(-y$1, 0, y$1, 1.3), i$1.emplaceBack(y$1, 0, y$1, 1.3), i$1.emplaceBack(y$1 + l$1, -.8, y$1, .7), i$1.emplaceBack(y$1 + l$1, -.8, y$1, .7), i$1.emplaceBack(0, 0, y$1, 1.3), i$1.emplaceBack(0, 0, y$1, 1.3), i$1.emplaceBack(y$1 + l$1, -1.2, y$1, .8), i$1.emplaceBack(y$1 + l$1, -1.2, y$1, .8), r$1.emplaceBack(6 + s$1, 4 + s$1, 8 + s$1), r$1.emplaceBack(7 + s$1, 9 + s$1, 5 + s$1), r$1.emplaceBack(0 + s$1, 1 + s$1, 2 + s$1), r$1.emplaceBack(1 + s$1, 3 + s$1, 2 + s$1), s$1 += 10;
				}
			}
			function mm(t$1, e$1) {
				const r$1 = {};
				r$1.indexArray = new Fa(), r$1.vertexArray = new wa(), r$1.colorArray = new Pa(), fm(t$1, e$1, r$1.indexArray, r$1.vertexArray, r$1.colorArray);
				const n$1 = { defined: !0 };
				n$1.emissiveFactor = lr.black;
				const i$1 = {};
				return i$1.baseColorFactor = lr.white, n$1.pbrMetallicRoughness = i$1, r$1.material = n$1, r$1.aabb = new Ju([
					Infinity,
					Infinity,
					Infinity
				], [
					-Infinity,
					-Infinity,
					-Infinity
				]), r$1;
			}
			const ym = ha([{
				name: "a_pos_3f",
				components: 3,
				type: "Float32"
			}]), gm = ha([{
				name: "a_normal_3",
				components: 3,
				type: "Int16"
			}]), xm = ha([{
				name: "a_centroid_3",
				components: 3,
				type: "Int16"
			}]), vm = ha([{
				name: "a_part_color_emissive",
				components: 2,
				type: "Uint16"
			}]), bm = ha([{
				name: "a_faux_facade_color_emissive",
				components: 2,
				type: "Uint16"
			}]), wm = ha([{
				name: "a_faux_facade_data",
				components: 4,
				type: "Uint16"
			}]), _m = ha([{
				name: "a_faux_facade_vertical_range",
				components: 2,
				type: "Uint16"
			}]), Am = ha([{
				name: "a_bloom_attenuation",
				components: 4,
				type: "Float32"
			}]), Im = ha([{
				name: "a_flood_light_wall_radius_1i16",
				components: 1,
				type: "Uint16"
			}]), Mm = zu.types, Sm = 32767;
			function Pm(t$1, e$1) {
				const r$1 = Un + e$1;
				for (const n$1 of t$1) for (const t$2 of n$1) if (t$2.x < -e$1 || t$2.x > r$1 || t$2.y < -e$1 || t$2.y > r$1) return !1;
				return !0;
			}
			function km(t$1) {
				switch (t$1) {
					case "flat": return 3;
					case "hipped": return 1;
					case "gabled": return 2;
					case "parapet": return 0;
					case "mansard": return 4;
					case "skillion": return 5;
					case "pyramidal": return 6;
					default: throw new Error(`Unknown roof shape: ${t$1}`);
				}
			}
			class Bm {
				constructor() {
					this.layoutVertexArray = new wa(), this.layoutAttenuationArray = new Pa(), this.layoutColorArray = new Ba(), this.indexArray = new Fa(), this.indexArrayForConflation = new Fa(), this.segmentsBucket = new hl();
				}
			}
			class zm {
				constructor(t$1) {
					this.layoutFacadePaintArray = null, this.layoutFacadeDataArray = null, this.layoutFacadeVerticalRangeArray = null, this.segmentsBucket = new hl(), this.entranceBloom = new Bm();
					const e$1 = 66560;
					this.layoutVertexArray = new wa(), this.layoutVertexArray.reserve(e$1), this.layoutNormalArray = new fa(), this.layoutNormalArray.reserve(e$1), this.layoutCentroidArray = new fa(), this.layoutCentroidArray.reserve(e$1), this.layoutColorArray = new Ba(), this.layoutColorArray.reserve(e$1), this.layoutFloodLightDataArray = new Ga(), this.layoutFloodLightDataArray.reserve(e$1), this.layoutAOArray = new Za(), this.layoutAOArray.reserve(e$1), this.indexArray = new Fa(), this.indexArray.reserve(66560), this.indexArrayForConflation = new Fa(), this.segmentsBucket = new hl(), this.entranceBloom = new Bm(), t$1 && (this.layoutFacadePaintArray = new Ba(), this.layoutFacadeDataArray = new Aa(), this.layoutFacadeVerticalRangeArray = new Ba());
				}
				reserve(t$1, e$1, r$1) {
					this.layoutVertexArray.reserveForAdditional(t$1), this.layoutCentroidArray.reserveForAdditional(t$1), this.layoutFloodLightDataArray.reserveForAdditional(t$1), this.layoutNormalArray.reserveForAdditional(t$1), this.layoutAOArray.reserveForAdditional(t$1), this.layoutColorArray.reserveForAdditional(t$1), this.indexArray.reserveForAdditional(e$1), r$1 && (this.layoutFacadePaintArray.reserveForAdditional(t$1), this.layoutFacadeDataArray.reserveForAdditional(t$1), this.layoutFacadeVerticalRangeArray.reserveForAdditional(t$1));
				}
			}
			class Tm {
				constructor(t$1) {
					this.colorBufferUploaded = !1, this.maxHeight = 0, this.replacementUpdateTime = 0, this.activeReplacements = [], this.footprints = [], this.footprintsVertices = new ja(), this.footprintsIndices = new Ga(), this.footprintsMin = new It(Infinity, Infinity), this.footprintsMax = new It(-Infinity, -Infinity), this.featuresOnBorder = [], this.buildingWithoutFacade = new zm(!1), this.buildingWithFacade = new zm(!0), this.indexArrayForConflationUploaded = !1, this.featureFootprintLookup = /* @__PURE__ */ new Map(), this.buildingIds = /* @__PURE__ */ new Set(), this.footprintLookup = {}, this.zoom = t$1.zoom, this.canonical = t$1.canonical, this.layers = t$1.layers, this.layerIds = this.layers.map(((t$2) => t$2.fqid)), this.index = t$1.index, this.hasPattern = !1, this.worldview = t$1.worldview, this.lut = t$1.lut, this.programConfigurations = new Ul(t$1.layers, {
						zoom: t$1.zoom,
						lut: t$1.lut
					}), this.stateDependentLayerIds = this.layers.filter(((t$2) => t$2.isStateDependent())).map(((t$2) => t$2.id)), this.projection = t$1.projection, this.groundEffect = new yd(t$1), this.groundEffect.groundRadiusArray = new ya(), this.hasAppearances = null;
				}
				updateFootprints(t$1, e$1) {
					const r$1 = new Mp([], [], 1), n$1 = {
						vertices: [],
						indices: new Uint32Array(0),
						grid: r$1,
						min: this.footprintsMin,
						max: this.footprintsMax,
						buildingIds: this.buildingIds
					};
					e$1.push({
						footprint: n$1,
						id: t$1
					});
				}
				updateAppearances(t$1, e$1, r$1, n$1) {}
				prepare() {
					return function() {
						if (null != uf || null != lf) return null;
						if (null != af) return af;
						return af = function(t$1) {
							let e$1, r$1, n$1, i$1, s$1;
							function o$1() {
								e$1 = new Uint8Array(s$1.buffer), r$1 = new Int16Array(s$1.buffer), n$1 = new Int32Array(s$1.buffer), i$1 = new Float32Array(s$1.buffer);
							}
							function a$1() {
								throw new Error("Unexpected BuildingGen error.");
							}
							const l$1 = () => {}, u$1 = { a: {
								a: a$1,
								f: function(t$2) {
									const r$2 = e$1.length, n$2 = Math.max(t$2 >>> 0, Math.ceil(1.2 * r$2)), i$2 = Math.ceil((n$2 - r$2) / 65536);
									try {
										return s$1.grow(i$2), o$1(), !0;
									} catch (t$3) {
										return !1;
									}
								},
								g: a$1,
								b: l$1,
								c: l$1,
								d: l$1,
								e: l$1
							} };
							return (WebAssembly.instantiateStreaming ? WebAssembly.instantiateStreaming(t$1, u$1) : t$1.then(((t$2) => t$2.arrayBuffer())).then(((t$2) => WebAssembly.instantiate(t$2, u$1)))).then(((t$2) => {
								const a$2 = t$2.instance.exports;
								return (0, a$2.g)(), s$1 = a$2.f, o$1(), new Qd({
									setStyle: a$2.h,
									setAOOptions: a$2.i,
									setMetricOptions: a$2.j,
									setStructuralOptions: a$2.k,
									setFacadeOptions: a$2.l,
									setFauxFacadeOptions: a$2.m,
									setFacadeClassifierOptions: a$2.n,
									addFeature: a$2.o,
									addFacade: a$2.p,
									generateMesh: a$2.q,
									getLastError: a$2.r,
									getOuterRingLength: a$2.s,
									getMeshCount: a$2.t,
									getPositionsPtr: a$2.u,
									getPositionsLength: a$2.v,
									getNormalsPtr: a$2.w,
									getNormalsLength: a$2.x,
									getAOPtr: a$2.y,
									getAOLength: a$2.z,
									getUVPtr: a$2.A,
									getUVLength: a$2.B,
									getFauxFacadePtr: a$2.C,
									getFauxFacadeLength: a$2.D,
									getIndicesPtr: a$2.E,
									getIndicesLength: a$2.F,
									getBuildingPart: a$2.G,
									getRingCount: a$2.H,
									getRingPtr: a$2.I,
									getRingLength: a$2.J,
									malloc: a$2.K,
									free: a$2.L,
									heapU8: e$1,
									heap16: r$1,
									heap32: n$1,
									heapF32: i$1
								});
							}));
						}(fetch(oe.BUILDING_GEN_URL)).then(((t$1) => (af = null, uf = t$1, uf))).catch(((t$1) => {
							Xt("Could not load building-gen"), af = null, lf = t$1;
						})), af;
					}();
				}
				populate(t$1, e$1, r$1, n$1) {
					const i$1 = pf();
					if (!i$1) return;
					const s$1 = vu(r$1);
					this.tileToMeter = s$1, this.brightness = e$1.brightness, i$1.setStyle({
						normalScale: [
							1,
							-1,
							s$1
						],
						tileToMeters: s$1
					}), i$1.setAOOptions(!1, .3), i$1.setMetricOptions(!1, 16), i$1.setStructuralOptions(!0), i$1.setFacadeClassifierOptions(3);
					const o$1 = /* @__PURE__ */ new Map(), a$1 = /* @__PURE__ */ new Map();
					let l$1 = 0;
					for (const { feature: e$2 } of t$1) {
						if ("LineString" !== Mm[e$2.type]) {
							o$1.set(e$2.id, e$2.properties.source_id);
							continue;
						}
						const t$2 = this.layers[0]._featureFilter.needGeometry;
						if (t$2 && !this.layers[0]._featureFilter.filter(new Io(this.zoom), e$2, r$1)) continue;
						const i$2 = Bu(e$2, t$2);
						if (!t$2 && !this.layers[0]._featureFilter.filter(new Io(this.zoom), i$2, r$1)) continue;
						const s$2 = t$2 ? i$2.geometry : ku(e$2, r$1, n$1), u$2 = [];
						for (const t$3 of s$2) for (const e$3 of t$3) u$2.push(e$3.x), u$2.push(e$3.y);
						const c$2 = {
							coordinates: u$2,
							crossPerc: e$2.properties.cross_perc,
							distanceToRoad: e$2.properties.distance_to_road,
							entrances: e$2.properties.entrances,
							sourceId: 0
						}, h$2 = e$2.properties.source_id;
						let p$2 = a$1.get(h$2);
						p$2 || (p$2 = [], a$1.set(h$2, p$2)), p$2.push(c$2), ++l$1;
					}
					this.maxHeight = 0;
					const u$1 = new Array(), c$1 = /* @__PURE__ */ new Set(), h$1 = (t$2) => {
						null != t$2 && c$1.add(t$2);
					}, p$1 = (t$2, e$2) => {
						null != t$2 && u$1.push({
							buildingId: t$2,
							footprintIndex: e$2
						});
					}, d$1 = 64 * (t$1.length - l$1), f$1 = d$1 / 2;
					this.buildingWithFacade.reserve(d$1, f$1, !0), this.buildingWithoutFacade.reserve(2 * d$1, 2 * f$1, !1), this.footprintsIndices.reserve(16 * (t$1.length - l$1)), this.footprintsVertices.reserve(8 * (t$1.length - l$1));
					for (const { feature: l$2, id: u$2, index: d$2, sourceLayerIndex: f$2 } of t$1) {
						if ("LineString" === Mm[l$2.type]) continue;
						const t$2 = this.layers[0]._featureFilter.needGeometry;
						if (t$2 && !this.layers[0]._featureFilter.filter(new Io(this.zoom), l$2, r$1)) continue;
						let m$2 = null;
						if (l$2.properties && l$2.properties.hasOwnProperty("building_id") && (m$2 = l$2.properties.building_id, c$1.has(m$2))) continue;
						const y$1 = Bu(l$2, t$2);
						if (!t$2 && !this.layers[0]._featureFilter.filter(new Io(this.zoom), y$1, r$1)) continue;
						const g$1 = t$2 ? y$1.geometry : ku(l$2, r$1, n$1), x$1 = rp(g$1, 500);
						let v$1 = !1;
						for (const t$3 of x$1) if (1 !== t$3.length) {
							v$1 = !0;
							break;
						}
						if (v$1) {
							h$1(m$2);
							continue;
						}
						if (!Pm(g$1, 163)) {
							h$1(m$2);
							continue;
						}
						const b$1 = this.layers[0], w$1 = km(b$1.layout.get("building-roof-shape").evaluate(l$2, {}, r$1)), _$1 = b$1.layout.get("building-base").evaluate(l$2, {}, r$1), A$1 = b$1.layout.get("building-height").evaluate(l$2, {}, r$1), I$1 = b$1.layout.get("building-flood-light-ground-radius").evaluate(l$2, {}, r$1), M$1 = b$1.paint.get("building-ambient-occlusion-intensity"), S$1 = I$1 / this.tileToMeter;
						l$2.properties["building-part"] = "roof";
						const P$1 = b$1.paint.get("building-color").evaluate(l$2, {}, this.canonical).toPremultipliedRenderColor(this.lut), k$1 = b$1.paint.get("building-emissive-strength").evaluate(l$2, {}, this.canonical);
						l$2.properties["building-part"] = "wall";
						const B$1 = b$1.paint.get("building-color").evaluate(l$2, {}, this.canonical).toPremultipliedRenderColor(this.lut), z$1 = b$1.paint.get("building-emissive-strength").evaluate(l$2, {}, this.canonical);
						l$2.properties["building-part"] = "window";
						const T$1 = b$1.paint.get("building-color").evaluate(l$2, {}, this.canonical).toPremultipliedRenderColor(this.lut), E$1 = b$1.paint.get("building-emissive-strength").evaluate(l$2, {}, this.canonical);
						l$2.properties["building-part"] = "door";
						const V$1 = b$1.paint.get("building-color").evaluate(l$2, {}, this.canonical).toPremultipliedRenderColor(this.lut), F$1 = b$1.paint.get("building-emissive-strength").evaluate(l$2, {}, this.canonical);
						let C$1 = b$1.layout.get("building-flood-light-wall-radius").evaluate(l$2, {}, r$1);
						C$1 = Ft(C$1, 0, 2048);
						const D$1 = C$1 / 2048 * Sm, R$1 = o$1.get(u$2), L$1 = a$1.get(R$1) || [], O$1 = 0 !== L$1.length && b$1.layout.get("building-facade").evaluate(l$2, {}, r$1);
						i$1.setFacadeOptions(4, !0), i$1.setFauxFacadeOptions(O$1, !1, 1);
						let U$1 = 0, N$1 = 0, j$1 = 0, $$1 = 0, G$1 = 0, q$1 = 0, H$1 = 0, X$1 = 0, Z$1 = 0, W$1 = 0, Y$1 = 0;
						if (O$1) {
							let t$3 = Math.round(b$1.layout.get("building-facade-floors").evaluate(l$2, {}, r$1));
							if (0 === _$1) {
								t$3 = Math.max(1, t$3 - (L$1.length > 0 ? 1 : 0));
								let e$3 = 4;
								if (A$1 > 100) {
									const t$4 = [
										10,
										13,
										15
									];
									e$3 = t$4[l$2.id ? l$2.id % t$4.length : 0];
								} else A$1 <= 10 && (e$3 = 3);
								i$1.setFacadeOptions(e$3, !0), G$1 = (A$1 < 15 ? 1.3 : 1.61803) * e$3 / s$1;
							} else G$1 = _$1 / s$1;
							q$1 = A$1 / s$1, G$1 = Math.min(G$1, q$1), j$1 = b$1.layout.get("building-facade-unit-width").evaluate(l$2, {}, r$1) / s$1, $$1 = (q$1 - G$1) / t$3, i$1.setFauxFacadeOptions(!0, !0, j$1);
							const e$2 = b$1.layout.get("building-facade-window").evaluate(l$2, {}, r$1);
							U$1 = e$2[0], N$1 = e$2[1], H$1 = Math.floor(65535 * Math.min(1, G$1 / Un)), X$1 = Math.floor(65535 * Math.min(1, q$1 / Un)), Z$1 = Math.floor(255 * U$1) << 8 | Math.floor(255 * N$1), W$1 = Math.floor(65535 * Math.min(1, j$1 / Un)), Y$1 = Math.floor(65535 * Math.min(1, $$1 / Un));
						}
						const K$1 = Array(x$1.length), J$1 = {
							x: Infinity,
							y: Infinity
						}, Q$1 = {
							x: -Infinity,
							y: -Infinity
						}, tt$1 = {
							x: 0,
							y: 0
						};
						let et$1 = 0;
						for (let t$3 = 0; t$3 < x$1.length; t$3++) {
							const e$2 = x$1[t$3];
							if (e$2.length > 0) {
								const r$2 = [], n$2 = Array(e$2.length + 1);
								n$2[0] = 0;
								for (let t$4 = 0; t$4 < e$2.length; t$4++) {
									const i$2 = e$2[t$4];
									for (let t$5 = 0; t$5 < i$2.length; t$5++) {
										const e$3 = i$2[i$2.length - t$5 - 1];
										J$1.x = Math.min(J$1.x, e$3.x), J$1.y = Math.min(J$1.y, e$3.y), Q$1.x = Math.max(Q$1.x, e$3.x), Q$1.y = Math.max(Q$1.y, e$3.y), tt$1.x += e$3.x, tt$1.y += e$3.y, et$1++, r$2.push(e$3.x), r$2.push(e$3.y);
									}
									n$2[t$4 + 1] = r$2.length;
								}
								K$1[t$3] = {
									id: l$2.id ? l$2.id : 0,
									height: A$1,
									minHeight: _$1,
									sourceId: 0,
									roofType: w$1,
									coordinates: r$2,
									ringIndices: n$2
								};
							}
						}
						tt$1.x /= et$1 || 1, tt$1.y /= et$1 || 1;
						const rt$1 = i$1.generateMesh(K$1, L$1);
						if ("string" == typeof rt$1) {
							Xt(`Unable to generate building ${l$2.id}: ${rt$1}`), h$1(m$2);
							continue;
						}
						if (0 === rt$1.meshes.length || 0 === rt$1.modifiedPolygonRings.length) {
							h$1(m$2);
							continue;
						}
						const nt$1 = O$1 ? this.buildingWithFacade : this.buildingWithoutFacade;
						let it$1 = 0;
						for (const t$3 of rt$1.meshes) it$1 += t$3.positions.length / 3;
						const st$1 = nt$1.segmentsBucket.prepareSegment(it$1, nt$1.layoutVertexArray, nt$1.indexArray), ot$1 = [];
						let at$1 = null, lt$1 = 0, ut$1 = -1;
						const ct$1 = nt$1.layoutVertexArray.length, ht$1 = ct$1 + it$1;
						nt$1.layoutVertexArray.resize(ht$1), nt$1.layoutCentroidArray.resize(ht$1), nt$1.layoutNormalArray.resize(ht$1), nt$1.layoutAOArray.resize(ht$1), nt$1.layoutColorArray.resize(ht$1), nt$1.layoutFloodLightDataArray.resize(ht$1), O$1 && (nt$1.layoutFacadePaintArray.resize(ht$1), nt$1.layoutFacadeDataArray.resize(ht$1), nt$1.layoutFacadeVerticalRangeArray.resize(ht$1));
						const pt$1 = nt$1.indexArray.length;
						let dt$1 = 0, ft$1 = ct$1;
						for (const t$3 of rt$1.meshes) {
							let e$2, r$2;
							if (1 === t$3.buildingPart) e$2 = P$1, r$2 = k$1;
							else if (0 === t$3.buildingPart) e$2 = B$1, r$2 = z$1;
							else if (2 === t$3.buildingPart) e$2 = T$1, r$2 = E$1;
							else {
								if (3 !== t$3.buildingPart) continue;
								e$2 = V$1, r$2 = F$1;
							}
							if (r$2 = Ft(r$2, 0, 1), 3 === t$3.buildingPart) {
								const e$3 = new Array();
								for (let r$4 = 0; r$4 < t$3.positions.length; r$4 += 12) {
									const n$4 = t$3.positions[r$4 + 0], i$4 = t$3.positions[r$4 + 1], s$3 = t$3.positions[r$4 + 3], o$3 = t$3.positions[r$4 + 4], a$3 = t$3.positions[r$4 + 2], l$4 = t$3.positions[r$4 + 8] - a$3, u$4 = 1, c$2 = s$3 - n$4, h$2 = o$3 - i$4, p$2 = Math.hypot(c$2, h$2);
									e$3.push({
										pos: [
											n$4 + .5 * c$2,
											i$4 + .5 * h$2,
											a$3
										],
										normal: [
											h$2 / p$2,
											-c$2 / p$2,
											0
										],
										width: p$2,
										height: l$4,
										depth: u$4,
										points: [
											n$4,
											i$4,
											s$3,
											o$3
										]
									});
								}
								const r$3 = nt$1.entranceBloom.segmentsBucket.prepareSegment(10 * e$3.length, nt$1.entranceBloom.layoutVertexArray, nt$1.entranceBloom.indexArray), n$3 = nt$1.entranceBloom.layoutVertexArray.length;
								lt$1 = nt$1.entranceBloom.indexArray.length, fm(e$3, .5 / this.tileToMeter, nt$1.entranceBloom.indexArray, nt$1.entranceBloom.layoutVertexArray, nt$1.entranceBloom.layoutAttenuationArray);
								const i$3 = nt$1.entranceBloom.layoutVertexArray.length - n$3;
								ut$1 = nt$1.entranceBloom.indexArray.length - lt$1;
								for (let t$4 = 0; t$4 < i$3; t$4++) nt$1.entranceBloom.layoutColorArray.emplaceBack(255 * V$1.r << 8 | 255 * V$1.g, 255 * V$1.b << 8 | 51 * F$1);
								r$3.vertexLength += i$3, r$3.primitiveLength += ut$1, at$1 = {
									part: t$3.buildingPart,
									vertexOffset: n$3,
									vertexLength: i$3
								};
							}
							nt$1.layoutVertexArray.float32.set(t$3.positions, 3 * ft$1);
							const n$2 = t$3.positions.length / 3;
							for (let i$3 = 0; i$3 < n$2; ++i$3) {
								const n$3 = 3 * i$3;
								dt$1 = Math.max(dt$1, t$3.positions[n$3 + 2]);
								const s$3 = t$3.normals[n$3 + 1] * Sm, o$3 = t$3.normals[n$3 + 2] * Sm, a$3 = 3 * (ft$1 + i$3);
								nt$1.layoutNormalArray.int16[a$3] = t$3.normals[n$3] * Sm, nt$1.layoutNormalArray.int16[a$3 + 1] = s$3, nt$1.layoutNormalArray.int16[a$3 + 2] = o$3;
								const l$4 = t$3.ao[i$3];
								nt$1.layoutAOArray.uint8[ft$1 + i$3] = 255 * l$4;
								const u$4 = 1 + (l$4 - 1) * M$1, c$2 = 255 * e$2.b * u$4 << 8 | 255 * r$2;
								nt$1.layoutColorArray.uint16[2 * (ft$1 + i$3)] = 255 * e$2.r * u$4 << 8 | 255 * e$2.g * u$4, nt$1.layoutColorArray.uint16[2 * (ft$1 + i$3) + 1] = c$2;
							}
							const i$2 = Math.floor(tt$1.x), s$2 = Math.floor(tt$1.y), o$2 = Math.floor(A$1);
							for (let t$4 = 0; t$4 < n$2; ++t$4) {
								const e$3 = 3 * (ft$1 + t$4);
								nt$1.layoutCentroidArray.int16[e$3] = i$2, nt$1.layoutCentroidArray.int16[e$3 + 1] = s$2, nt$1.layoutCentroidArray.int16[e$3 + 2] = o$2;
							}
							if (nt$1.layoutFloodLightDataArray.uint16.fill(0 === t$3.buildingPart ? D$1 : 0, ft$1, ft$1 + n$2), O$1) {
								const e$3 = 255 * T$1.r << 8 | 255 * T$1.g, r$3 = 255 * T$1.b << 8 | 255 * E$1;
								for (let t$4 = 0; t$4 < n$2; ++t$4) {
									const n$3 = 2 * (ft$1 + t$4);
									nt$1.layoutFacadePaintArray.uint16[n$3] = e$3, nt$1.layoutFacadePaintArray.uint16[n$3 + 1] = r$3;
								}
								for (let e$4 = 0; e$4 < n$2; ++e$4) if (t$3.isFauxFacade[e$4]) {
									const r$4 = Math.min(65535, Math.floor(t$3.uv[2 * e$4] * rt$1.outerRingLength));
									nt$1.layoutFacadeDataArray.emplace(ft$1 + e$4, 1 | r$4, Z$1, W$1, Y$1), nt$1.layoutFacadeVerticalRangeArray.emplace(ft$1 + e$4, H$1, X$1);
								} else nt$1.layoutFacadeDataArray.emplace(ft$1 + e$4, 0, 0, 0, 0), nt$1.layoutFacadeVerticalRangeArray.emplace(ft$1 + e$4, 0, 0);
							}
							const a$2 = st$1.vertexLength, l$3 = t$3.indices.length / 3, u$3 = nt$1.indexArray.length;
							nt$1.indexArray.resize(u$3 + l$3);
							for (let e$3 = 0; e$3 < l$3; ++e$3) {
								const r$3 = 3 * e$3, n$3 = 3 * u$3 + r$3;
								nt$1.indexArray.uint16[n$3] = a$2 + t$3.indices[r$3], nt$1.indexArray.uint16[n$3 + 1] = a$2 + t$3.indices[r$3 + 1], nt$1.indexArray.uint16[n$3 + 2] = a$2 + t$3.indices[r$3 + 2];
							}
							1 !== t$3.buildingPart && 0 !== t$3.buildingPart && 2 !== t$3.buildingPart && 3 !== t$3.buildingPart || ot$1.push({
								part: t$3.buildingPart,
								vertexOffset: ft$1,
								vertexLength: t$3.positions.length / 3
							}), ft$1 += n$2, st$1.vertexLength += n$2, st$1.primitiveLength += t$3.indices.length / 3;
						}
						this.maxHeight = Math.max(this.maxHeight, dt$1);
						const mt$1 = nt$1.indexArray.length - pt$1, yt$1 = this.footprintsIndices.length, gt$1 = this.footprintsVertices.length, xt$1 = [], vt$1 = new It(Infinity, Infinity), bt$1 = new It(-Infinity, -Infinity), wt$1 = this.groundEffect.vertexArray.length;
						for (const t$3 of rt$1.modifiedPolygonRings) {
							const e$2 = [], r$2 = new It(Infinity, Infinity), n$2 = new It(-Infinity, -Infinity);
							for (let i$2 = 0; i$2 < t$3.length; i$2 += 2) {
								const s$2 = t$3.length - i$2 - 2;
								r$2.x = Math.min(r$2.x, t$3[s$2]), r$2.y = Math.min(r$2.y, t$3[s$2 + 1]), n$2.x = Math.max(n$2.x, t$3[s$2]), n$2.y = Math.max(n$2.y, t$3[s$2 + 1]);
								const o$2 = new It(t$3[s$2], t$3[s$2 + 1]);
								e$2.push(o$2), xt$1.push(o$2.x, o$2.y), this.footprintsVertices.emplaceBack(o$2.x, o$2.y);
							}
							vt$1.x = Math.min(vt$1.x, r$2.x), vt$1.y = Math.min(vt$1.y, r$2.y), bt$1.x = Math.max(bt$1.x, n$2.x), bt$1.y = Math.max(bt$1.y, n$2.y), this.groundEffect.addData(e$2, [r$2, n$2], S$1);
						}
						const _t = this.groundEffect.vertexArray.length - wt$1;
						this.groundEffect.groundRadiusArray.reserveForAdditional(_t);
						for (let t$3 = 0; t$3 < _t; t$3++) this.groundEffect.groundRadiusArray.emplaceBack(I$1);
						(J$1.x < 0 || Q$1.x > Un || J$1.y < 0 || Q$1.y > Un) && this.featuresOnBorder.push({
							featureId: l$2.id,
							footprintIndex: this.footprints.length
						});
						{
							const t$3 = zh(xt$1, null, 2);
							this.footprintsIndices.resize(this.footprintsIndices.length + t$3.length), this.footprintsIndices.uint16.set(t$3, yt$1), this.buildingIds.add(null != m$2 ? m$2 : l$2.id), this.footprintsMin.x = Math.min(this.footprintsMin.x, vt$1.x), this.footprintsMin.y = Math.min(this.footprintsMin.y, vt$1.y), this.footprintsMax.x = Math.max(this.footprintsMax.x, bt$1.x), this.footprintsMax.y = Math.max(this.footprintsMax.y, bt$1.y);
							const e$2 = {
								footprintVertexOffset: gt$1,
								footprintVertexLength: this.footprintsVertices.length - gt$1,
								footprintIndexOffset: yt$1,
								footprintIndexLength: this.footprintsIndices.length - yt$1,
								min: vt$1,
								max: bt$1,
								hiddenFlags: 0,
								indicesOffset: pt$1,
								indicesLength: mt$1,
								bloomIndicesOffset: lt$1,
								bloomIndicesLength: ut$1,
								groundEffectVertexOffset: wt$1,
								groundEffectVertexLength: _t,
								hasFauxFacade: O$1,
								height: dt$1,
								promoteId: u$2,
								feature: y$1,
								parts: ot$1,
								buildingBloom: at$1
							}, r$2 = this.footprints.length;
							void 0 !== l$2.id && this.featureFootprintLookup.set(l$2.id, r$2), p$1(m$2, r$2), this.footprints.push(e$2);
						}
						this.programConfigurations.populatePaintArrays(nt$1.layoutVertexArray.length, l$2, d$2, {}, e$1.availableImages, r$1, e$1.brightness), this.groundEffect.addPaintPropertiesData(l$2, d$2, {}, e$1.availableImages, r$1, e$1.brightness), e$1.featureIndex.insert(l$2, g$1, d$2, f$2, this.index, ct$1);
					}
					u$1.forEach((({ buildingId: t$2, footprintIndex: e$2 }) => {
						c$1.has(t$2) && (this.footprints[e$2].hiddenFlags |= 4);
					}));
					const m$1 = /* @__PURE__ */ new Set();
					this.buildingIds.forEach(((t$2, e$2, r$2) => {
						c$1.has(t$2) || m$1.add(t$2);
					})), this.buildingIds = m$1, this.groundEffect.prepareBorderSegments();
				}
				update(t$1, e$1, r$1, n$1, i$1, s$1, o$1) {
					this.programConfigurations.updatePaintArrays(t$1, e$1, i$1, r$1, n$1, s$1, o$1), this.groundEffect.update(t$1, e$1, i$1, r$1, n$1, s$1, o$1), this.evaluate(this.layers[0], t$1), this.colorBufferUploaded = !1;
				}
				isEmpty() {
					return 0 === this.buildingWithoutFacade.layoutVertexArray.length && 0 === this.buildingWithFacade.layoutVertexArray.length;
				}
				uploadPending() {
					return !this.uploaded || this.programConfigurations.needsUpload || this.groundEffect.programConfigurations.needsUpload;
				}
				upload(t$1) {
					const e$1 = (e$2) => {
						e$2.layoutVertexBuffer = t$1.createVertexBuffer(e$2.layoutVertexArray, ym.members), e$2.layoutNormalBuffer = t$1.createVertexBuffer(e$2.layoutNormalArray, gm.members), e$2.layoutCentroidBuffer = t$1.createVertexBuffer(e$2.layoutCentroidArray, xm.members), e$2.layoutFloodLightDataBuffer = t$1.createVertexBuffer(e$2.layoutFloodLightDataArray, Im.members), e$2.layoutFacadeDataArray && e$2.layoutFacadeDataArray.length && (e$2.layoutFacadeDataBuffer = t$1.createVertexBuffer(e$2.layoutFacadeDataArray, wm.members)), e$2.layoutFacadeVerticalRangeArray && e$2.layoutFacadeVerticalRangeArray.length && (e$2.layoutFacadeVerticalRangeBuffer = t$1.createVertexBuffer(e$2.layoutFacadeVerticalRangeArray, _m.members)), e$2.entranceBloom.layoutVertexArray.length && (e$2.entranceBloom.layoutVertexBuffer = t$1.createVertexBuffer(e$2.entranceBloom.layoutVertexArray, ym.members), e$2.entranceBloom.layoutAttenuationBuffer = t$1.createVertexBuffer(e$2.entranceBloom.layoutAttenuationArray, Am.members)), this.uploadUpdatedColorBuffer(t$1), this.uploadUpdatedIndexBuffer(t$1);
					};
					this.uploaded || (e$1(this.buildingWithoutFacade), e$1(this.buildingWithFacade), this.groundEffect.upload(t$1)), this.groundEffect.uploadPaintProperties(t$1), this.programConfigurations.upload(t$1), this.uploaded = !0;
				}
				destroy() {
					const t$1 = (t$2) => {
						t$2.layoutVertexBuffer && (t$2.layoutVertexBuffer.destroy(), t$2.layoutNormalBuffer.destroy(), t$2.layoutColorBuffer.destroy(), t$2.segmentsBucket.destroy(), t$2.indexBuffer && t$2.indexBuffer.destroy(), t$2.entranceBloom.layoutVertexBuffer && (t$2.entranceBloom.layoutVertexBuffer.destroy(), t$2.entranceBloom.layoutColorBuffer.destroy(), t$2.entranceBloom.layoutAttenuationBuffer.destroy(), t$2.entranceBloom.indexBuffer.destroy(), t$2.entranceBloom.segmentsBucket.destroy()));
					};
					t$1(this.buildingWithoutFacade), t$1(this.buildingWithFacade), this.groundEffect.destroy(), this.programConfigurations.destroy();
				}
				updateFootprintHiddenFlags(t$1, e$1, r$1 = !0) {
					let n$1 = !1;
					const i$1 = r$1 ? e$1 : 0, s$1 = 0 | (r$1 ? -1 : ~e$1);
					0 === this.groundEffect.hiddenByLandmarkVertexArray.length && this.groundEffect.hiddenByLandmarkVertexArray.resize(this.groundEffect.vertexArray.length);
					for (const e$2 of t$1) {
						const t$2 = this.footprints[e$2], r$2 = t$2.hiddenFlags & s$1 | i$1;
						t$2.hiddenFlags !== r$2 && (t$2.hiddenFlags = r$2, n$1 = !0, this.groundEffect.updateHiddenByLandmarkRange(t$2.groundEffectVertexOffset, t$2.groundEffectVertexLength, 0 !== t$2.hiddenFlags));
					}
					return n$1 && (this.indexArrayForConflationUploaded = !1), n$1;
				}
				uploadUpdatedIndexBuffer(t$1) {
					if (this.groundEffect.uploadHiddenByLandmark(t$1), this.indexArrayForConflationUploaded) return;
					const e$1 = (t$2) => {
						0 !== t$2.indexArray.length && (t$2.indexArrayForConflation.resize(t$2.indexArray.length), t$2.indexArrayForConflation.uint16.set(t$2.indexArray.uint16), t$2.entranceBloom.indexArrayForConflation.resize(t$2.entranceBloom.indexArray.length), t$2.entranceBloom.indexArrayForConflation.uint16.set(t$2.entranceBloom.indexArray.uint16));
					};
					e$1(this.buildingWithoutFacade), e$1(this.buildingWithFacade);
					for (const t$2 of this.footprints) {
						const e$2 = t$2.hasFauxFacade ? this.buildingWithFacade : this.buildingWithoutFacade, r$2 = t$2.indicesOffset + t$2.indicesLength;
						if (0 !== t$2.hiddenFlags) {
							for (let n$2 = t$2.indicesOffset; n$2 < r$2; n$2++) e$2.indexArrayForConflation.uint16[3 * n$2 + 0] = 0, e$2.indexArrayForConflation.uint16[3 * n$2 + 1] = 0, e$2.indexArrayForConflation.uint16[3 * n$2 + 2] = 0;
							const n$1 = t$2.bloomIndicesOffset + t$2.bloomIndicesLength;
							for (let r$3 = t$2.bloomIndicesOffset; r$3 < n$1; r$3++) e$2.entranceBloom.indexArrayForConflation.uint16[3 * r$3 + 0] = 0, e$2.entranceBloom.indexArrayForConflation.uint16[3 * r$3 + 1] = 0, e$2.entranceBloom.indexArrayForConflation.uint16[3 * r$3 + 2] = 0;
						}
					}
					const r$1 = (e$2) => {
						0 !== e$2.indexArray.length && (e$2.indexBuffer ? e$2.indexBuffer.updateData(e$2.indexArrayForConflation) : e$2.indexBuffer = t$1.createIndexBuffer(e$2.indexArrayForConflation, !0), e$2.entranceBloom.indexBuffer ? e$2.entranceBloom.indexBuffer.updateData(e$2.entranceBloom.indexArrayForConflation) : e$2.entranceBloom.indexBuffer = t$1.createIndexBuffer(e$2.entranceBloom.indexArrayForConflation, !0));
					};
					r$1(this.buildingWithoutFacade), r$1(this.buildingWithFacade), this.indexArrayForConflationUploaded = !0;
				}
				uploadUpdatedColorBuffer(t$1) {
					const e$1 = (e$2) => {
						e$2.layoutColorBuffer ? e$2.layoutColorBuffer.updateData(e$2.layoutColorArray) : e$2.layoutColorBuffer = t$1.createVertexBuffer(e$2.layoutColorArray, vm.members, !0), e$2.layoutFacadePaintArray && (e$2.layoutFacadePaintBuffer ? e$2.layoutFacadePaintBuffer.updateData(e$2.layoutFacadePaintArray) : e$2.layoutFacadePaintBuffer = t$1.createVertexBuffer(e$2.layoutFacadePaintArray, bm.members, !0)), e$2.entranceBloom.layoutColorBuffer ? e$2.entranceBloom.layoutColorBuffer.updateData(e$2.entranceBloom.layoutColorArray) : e$2.entranceBloom.layoutColorBuffer = t$1.createVertexBuffer(e$2.entranceBloom.layoutColorArray, vm.members, !0);
					};
					e$1(this.buildingWithoutFacade), e$1(this.buildingWithFacade), this.colorBufferUploaded = !0;
				}
				evaluate(t$1, e$1) {
					const r$1 = t$1.paint.get("building-ambient-occlusion-intensity");
					for (const n$1 of this.footprints) {
						if (4 & n$1.hiddenFlags) continue;
						const i$1 = e$1[n$1.promoteId], s$1 = n$1.feature;
						s$1.properties["building-part"] = "roof";
						const o$1 = t$1.paint.get("building-color").evaluate(s$1, i$1, this.canonical).toPremultipliedRenderColor(this.lut), a$1 = t$1.paint.get("building-emissive-strength").evaluate(s$1, i$1, this.canonical);
						s$1.properties["building-part"] = "wall";
						const l$1 = t$1.paint.get("building-color").evaluate(s$1, i$1, this.canonical).toPremultipliedRenderColor(this.lut), u$1 = t$1.paint.get("building-emissive-strength").evaluate(s$1, i$1, this.canonical);
						s$1.properties["building-part"] = "window";
						const c$1 = t$1.paint.get("building-color").evaluate(s$1, i$1, this.canonical).toPremultipliedRenderColor(this.lut), h$1 = t$1.paint.get("building-emissive-strength").evaluate(s$1, i$1, this.canonical);
						s$1.properties["building-part"] = "door";
						const p$1 = t$1.paint.get("building-color").evaluate(s$1, i$1, this.canonical).toPremultipliedRenderColor(this.lut), d$1 = t$1.paint.get("building-emissive-strength").evaluate(s$1, i$1, this.canonical), f$1 = n$1.hasFauxFacade ? this.buildingWithFacade : this.buildingWithoutFacade;
						for (const t$2 of n$1.parts) {
							let e$2, i$2 = o$1;
							1 === t$2.part ? (i$2 = o$1, e$2 = a$1) : 0 === t$2.part ? (i$2 = l$1, e$2 = u$1) : 2 === t$2.part ? (i$2 = c$1, e$2 = h$1) : 3 === t$2.part && (i$2 = p$1, e$2 = d$1), e$2 = Ft(e$2, 0, 1);
							for (let s$2 = 0; s$2 < t$2.vertexLength; s$2++) {
								const o$2 = t$2.vertexOffset + s$2, a$2 = 1 + (f$1.layoutAOArray.uint8[o$2] / 255 - 1) * r$1;
								f$1.layoutColorArray.emplace(o$2, i$2.r * a$2 * 255 << 8 | i$2.g * a$2 * 255, i$2.b * a$2 * 255 << 8 | 255 * e$2), n$1.hasFauxFacade && f$1.layoutFacadePaintArray.emplace(o$2, 255 * c$1.r << 8 | 255 * c$1.g, 255 * c$1.b << 8 | 255 * h$1);
							}
						}
						const m$1 = n$1.buildingBloom;
						if (m$1) for (let t$2 = 0; t$2 < m$1.vertexLength; t$2++) f$1.entranceBloom.layoutColorArray.emplace(m$1.vertexOffset + t$2, 255 * p$1.r << 8 | 255 * p$1.g, 255 * p$1.b << 8 | 51 * d$1);
					}
				}
				needsEvaluation() {
					return !this.colorBufferUploaded;
				}
				updateReplacement(t$1, e$1, r$1) {
					if (e$1.updateTime === this.replacementUpdateTime) return;
					this.replacementUpdateTime = e$1.updateTime;
					const n$1 = e$1.getReplacementRegionsForTile(t$1.toUnwrapped());
					if (jp(this.activeReplacements, n$1)) return;
					this.activeReplacements = n$1;
					for (const t$2 of this.footprints) t$2.hiddenFlags &= -2;
					const i$1 = [];
					for (const e$2 of this.activeReplacements) {
						if (e$2.order <= Rp) continue;
						const r$2 = Math.max(1, Math.pow(2, e$2.footprintTileId.canonical.z - t$1.canonical.z));
						for (const n$2 of this.footprints) n$2.min.x > e$2.max.x || n$2.max.x < e$2.min.x || n$2.min.y > e$2.max.y || n$2.max.y < e$2.min.y || (i$1.length = 0, Vm(this.footprintsVertices, n$2.footprintVertexOffset, n$2.footprintVertexLength, e$2.footprintTileId.canonical, t$1.canonical, i$1), qp(e$2.footprint, i$1, this.footprintsIndices.uint16, n$2.footprintIndexOffset, n$2.footprintIndexLength, 0, -r$2) && (n$2.hiddenFlags |= 1));
					}
					0 === this.groundEffect.hiddenByLandmarkVertexArray.length && this.groundEffect.hiddenByLandmarkVertexArray.resize(this.groundEffect.vertexArray.length);
					for (const t$2 of this.footprints) this.groundEffect.updateHiddenByLandmarkRange(t$2.groundEffectVertexOffset, t$2.groundEffectVertexLength, 0 !== t$2.hiddenFlags);
					this.indexArrayForConflationUploaded = !1;
				}
				getFootprint(t$1) {
					if (void 0 !== t$1.id) {
						const e$1 = this.featureFootprintLookup.get(t$1.id);
						return this.footprints[e$1];
					}
					return null;
				}
				getHeightAtTileCoord(t$1, e$1) {
					let r$1 = Number.NEGATIVE_INFINITY, n$1 = !0;
					const i$1 = 4 * (t$1 + Un) * Un + (e$1 + Un);
					if (this.footprintLookup.hasOwnProperty(i$1)) {
						const t$2 = this.footprintLookup[i$1];
						return t$2 ? {
							height: t$2.height,
							hidden: 0 !== t$2.hiddenFlags
						} : void 0;
					}
					const s$1 = new It(t$1, e$1);
					for (const o$1 of this.footprints) t$1 > o$1.max.x || o$1.min.x > t$1 || e$1 > o$1.max.y || o$1.min.y > e$1 || o$1.height <= r$1 || Em(s$1, this.footprintsVertices.float32.subarray(2 * o$1.footprintVertexOffset, 2 * (o$1.footprintVertexOffset + o$1.footprintVertexLength)), this.footprintsIndices.uint16.subarray(o$1.footprintIndexOffset, o$1.footprintIndexOffset + o$1.footprintIndexLength)) && (r$1 = o$1.height, this.footprintLookup[i$1] = o$1, n$1 = 0 !== o$1.hiddenFlags);
					if (r$1 !== Number.NEGATIVE_INFINITY) return {
						height: r$1,
						hidden: n$1
					};
					this.footprintLookup[i$1] = void 0;
				}
			}
			function Em(t$1, e$1, r$1) {
				for (let n$1 = 0; n$1 < r$1.length; n$1 += 3) {
					const i$1 = r$1[n$1], s$1 = r$1[n$1 + 1], o$1 = r$1[n$1 + 2], a$1 = e$1[2 * i$1 + 0], l$1 = e$1[2 * i$1 + 1], u$1 = e$1[2 * s$1 + 0], c$1 = e$1[2 * s$1 + 1], h$1 = e$1[2 * o$1 + 0], p$1 = e$1[2 * o$1 + 1], d$1 = (a$1 - h$1) * (t$1.y - p$1) - (l$1 - p$1) * (t$1.x - h$1), f$1 = (u$1 - a$1) * (t$1.y - l$1) - (c$1 - l$1) * (t$1.x - a$1);
					if (d$1 < 0 != f$1 < 0 && 0 !== d$1 && 0 !== f$1) continue;
					const m$1 = (h$1 - u$1) * (t$1.y - c$1) - (p$1 - c$1) * (t$1.x - u$1);
					if (0 === m$1 || m$1 < 0 == d$1 + f$1 <= 0) return !0;
				}
				return !1;
			}
			function Vm(t$1, e$1, r$1, n$1, i$1, s$1) {
				const o$1 = Math.pow(2, n$1.z - i$1.z);
				for (let a$1 = 0; a$1 < r$1; a$1++) {
					let r$2 = t$1.float32[2 * (a$1 + e$1) + 0], l$1 = t$1.float32[2 * (a$1 + e$1) + 1];
					r$2 = (r$2 + i$1.x * Un) * o$1 - n$1.x * Un, l$1 = (l$1 + i$1.y * Un) * o$1 - n$1.y * Un, s$1.push(new It(r$2, l$1));
				}
			}
			let Fm, Cm;
			Qs(Tm, "BuildingBucket", { omit: ["layers"] }), Qs(zm, "BuildingGeometry"), Qs(Bm, "BuildingBloomGeometry");
			const Dm = ha([
				{
					name: "a_pos_normal",
					components: 2,
					type: "Int16"
				},
				{
					name: "a_data",
					components: 4,
					type: "Uint8"
				},
				{
					name: "a_linesofar",
					components: 1,
					type: "Float32"
				}
			], 4), Rm = ha([{
				name: "a_z_offset_width",
				components: 3,
				type: "Float32"
			}], 4), { members: Lm } = Dm, { members: Um } = ha([{
				name: "a_packed",
				components: 3,
				type: "Float32"
			}]), { members: jm } = ha([{
				name: "a_pattern_data",
				components: 3,
				type: "Float32"
			}]);
			class $m {
				constructor(t$1, e$1) {
					this.width = t$1, this.height = e$1, this.nextRow = 0, this.image = new _h({
						width: t$1,
						height: e$1
					}), this.positions = {}, this.uploaded = !1;
				}
				getDash(t$1, e$1) {
					const r$1 = this.getKey(t$1, e$1);
					return this.positions[r$1];
				}
				trim() {
					const t$1 = this.width, e$1 = this.height = Ut(this.nextRow);
					this.image.resize({
						width: t$1,
						height: e$1
					});
				}
				getKey(t$1, e$1) {
					return t$1.join(",") + e$1;
				}
				getDashRanges(t$1, e$1, r$1) {
					const n$1 = [];
					let i$1 = t$1.length % 2 == 1 ? -t$1[t$1.length - 1] * r$1 : 0, s$1 = t$1[0] * r$1, o$1 = !0;
					n$1.push({
						left: i$1,
						right: s$1,
						isDash: o$1,
						zeroLength: 0 === t$1[0]
					});
					let a$1 = t$1[0];
					for (let e$2 = 1; e$2 < t$1.length; e$2++) {
						o$1 = !o$1;
						const l$1 = t$1[e$2];
						i$1 = a$1 * r$1, a$1 += l$1, s$1 = a$1 * r$1, n$1.push({
							left: i$1,
							right: s$1,
							isDash: o$1,
							zeroLength: 0 === l$1
						});
					}
					return n$1;
				}
				addRoundDash(t$1, e$1, r$1) {
					const n$1 = e$1 / 2;
					for (let e$2 = -r$1; e$2 <= r$1; e$2++) {
						const i$1 = this.width * (this.nextRow + r$1 + e$2);
						let s$1 = 0, o$1 = t$1[s$1];
						for (let a$1 = 0; a$1 < this.width; a$1++) {
							a$1 / o$1.right > 1 && (o$1 = t$1[++s$1]);
							const l$1 = Math.abs(a$1 - o$1.left), u$1 = Math.abs(a$1 - o$1.right), c$1 = Math.min(l$1, u$1);
							let h$1;
							const p$1 = e$2 / r$1 * (n$1 + 1);
							if (o$1.isDash) {
								const t$2 = n$1 - Math.abs(p$1);
								h$1 = Math.sqrt(c$1 * c$1 + t$2 * t$2);
							} else h$1 = n$1 - Math.sqrt(c$1 * c$1 + p$1 * p$1);
							this.image.data[i$1 + a$1] = Math.max(0, Math.min(255, h$1 + 128));
						}
					}
				}
				addRegularDash(t$1, e$1) {
					for (let e$2 = t$1.length - 1; e$2 >= 0; --e$2) {
						const r$2 = t$1[e$2], n$2 = t$1[e$2 + 1];
						r$2.zeroLength ? t$1.splice(e$2, 1) : n$2 && n$2.isDash === r$2.isDash && (n$2.left = r$2.left, t$1.splice(e$2, 1));
					}
					const r$1 = t$1[0], n$1 = t$1[t$1.length - 1];
					r$1.isDash === n$1.isDash && (r$1.left = n$1.left - this.width, n$1.right = r$1.right + this.width);
					const i$1 = this.width * this.nextRow;
					let s$1 = 0, o$1 = t$1[s$1];
					for (let r$2 = 0; r$2 < this.width; r$2++) {
						r$2 / o$1.right > 1 && (o$1 = t$1[++s$1]);
						const n$2 = Math.abs(r$2 - o$1.left), a$1 = Math.abs(r$2 - o$1.right), l$1 = Math.min(n$2, a$1);
						this.image.data[i$1 + r$2] = Math.max(0, Math.min(255, (o$1.isDash ? l$1 : -l$1) + e$1 + 128));
					}
				}
				addDash(t$1, e$1) {
					const r$1 = this.getKey(t$1, e$1);
					if (this.positions[r$1]) return this.positions[r$1];
					const n$1 = "round" === e$1, i$1 = n$1 ? 7 : 0, s$1 = 2 * i$1 + 1;
					if (this.nextRow + s$1 > this.height) return Xt("LineAtlas out of space"), null;
					0 === t$1.length && t$1.push(1);
					let o$1 = 0;
					for (let e$2 = 0; e$2 < t$1.length; e$2++) t$1[e$2] < 0 && (Xt("Negative value is found in line dasharray, replacing values with 0"), t$1[e$2] = 0), o$1 += t$1[e$2];
					if (0 !== o$1) {
						const r$2 = this.width / o$1, s$2 = this.getDashRanges(t$1, this.width, r$2);
						n$1 ? this.addRoundDash(s$2, r$2, i$1) : this.addRegularDash(s$2, "square" === e$1 ? .5 * r$2 : 0);
					}
					const a$1 = this.nextRow + i$1;
					this.nextRow += s$1;
					const l$1 = {
						tl: [a$1, i$1],
						br: [o$1, 0]
					};
					return this.positions[r$1] = l$1, l$1;
				}
			}
			Qs($m, "LineAtlas");
			const Gm = zu.types, qm = Math.cos(Math.PI / 180 * 37.5), Hm = Math.cos(Math.PI / 180 * 5);
			class Xm {
				constructor(t$1) {
					this.evaluationGlobals = {
						zoom: 0,
						lineProgress: void 0
					}, this.elevationType = "none", this.zoom = t$1.zoom, this.evaluationGlobals.zoom = this.zoom, this.overscaling = t$1.overscaling, this.pixelRatio = t$1.pixelRatio, this.layers = t$1.layers, this.layerIds = this.layers.map(((t$2) => t$2.fqid)), this.index = t$1.index, this.projection = t$1.projection, this.hasPattern = !1, this.hasCrossSlope = !1, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach(((t$2) => {
						this.gradients[t$2.id] = {};
					})), this.layoutVertexArray = new ba(), this.layoutVertexArray2 = new wa(), this.patternVertexArray = new wa(), this.indexArray = new Fa(), this.programConfigurations = new Ul(t$1.layers, {
						zoom: t$1.zoom,
						lut: t$1.lut
					}), this.segments = new hl(), this.maxLineLength = 0, this.zOffsetVertexArray = new wa(), this.stateDependentLayerIds = this.layers.filter(((t$2) => t$2.isStateDependent())).map(((t$2) => t$2.id)), this.tessellationStep = t$1.tessellationStep ? t$1.tessellationStep : Un / 64, this.worldview = t$1.worldview, this.hasAppearances = null;
				}
				updateFootprints(t$1, e$1) {}
				updateAppearances(t$1, e$1, r$1, n$1) {}
				populate(t$1, e$1, r$1, n$1) {
					this.hasPattern = sp("line", this.layers, this.pixelRatio, e$1);
					const i$1 = this.layers[0].layout.get("line-sort-key");
					this.tileToMeter = vu(r$1);
					const s$1 = this.layers[0].layout.get("line-elevation-reference");
					if ("hd-road-markup" === s$1) this.elevationType = "road";
					else {
						const t$2 = this.layers[0].layout.get("line-z-offset"), e$2 = t$2.isConstant() && !t$2.constantOr(0);
						this.elevationType = "sea" !== s$1 && "ground" !== s$1 && e$2 ? "none" : "offset", "offset" === this.elevationType && "none" === s$1 && Xt(`line-elevation-reference: ground is used for the layer ${this.layerIds[0]} because non-zero line-z-offset value was found.`);
					}
					const o$1 = this.layers[0].layout.get("line-cross-slope");
					this.hasCrossSlope = "offset" === this.elevationType && void 0 !== o$1;
					const a$1 = [];
					for (const { feature: s$2, id: o$2, index: l$2, sourceLayerIndex: u$2 } of t$1) {
						const t$2 = this.layers[0]._featureFilter.needGeometry, c$2 = Bu(s$2, t$2);
						if (!this.layers[0]._featureFilter.filter(new Io(this.zoom, {
							worldview: this.worldview,
							activeFloors: e$1.activeFloors
						}), c$2, r$1)) continue;
						const h$1 = i$1 ? i$1.evaluate(c$2, {}, r$1) : void 0, p$1 = {
							id: o$2,
							properties: s$2.properties,
							type: s$2.type,
							sourceLayerIndex: u$2,
							index: l$2,
							geometry: t$2 ? c$2.geometry : ku(s$2, r$1, n$1),
							patterns: {},
							sortKey: h$1
						};
						a$1.push(p$1);
					}
					i$1 && a$1.sort(((t$2, e$2) => t$2.sortKey - e$2.sortKey));
					const { lineAtlas: l$1, featureIndex: u$1 } = e$1, c$1 = this.addConstantDashes(l$1);
					for (const n$2 of a$1) {
						const { geometry: i$2, index: s$2, sourceLayerIndex: o$2 } = n$2;
						if (c$1 && this.addFeatureDashes(n$2, l$1), this.hasPattern) {
							const t$2 = op("line", this.layers, n$2, this.zoom, this.pixelRatio, e$1);
							this.patternFeatures.push(t$2);
						} else this.addFeature(n$2, i$2, s$2, r$1, l$1.positions, e$1.availableImages, e$1.brightness, e$1.elevationFeatures);
						u$1.insert(t$1[s$2].feature, i$2, s$2, o$2, this.index);
					}
				}
				addConstantDashes(t$1) {
					let e$1 = !1;
					for (const r$1 of this.layers) {
						const n$1 = r$1.paint.get("line-dasharray").value, i$1 = r$1.layout.get("line-cap").value;
						if ("constant" !== n$1.kind || "constant" !== i$1.kind) e$1 = !0;
						else {
							const e$2 = i$1.value, r$2 = n$1.value;
							if (!r$2) continue;
							t$1.addDash(r$2, e$2);
						}
					}
					return e$1;
				}
				addFeatureDashes(t$1, e$1) {
					const r$1 = this.zoom;
					for (const n$1 of this.layers) {
						const i$1 = n$1.paint.get("line-dasharray").value, s$1 = n$1.layout.get("line-cap").value;
						if ("constant" === i$1.kind && "constant" === s$1.kind) continue;
						let o$1, a$1;
						if ("constant" === i$1.kind) {
							if (o$1 = i$1.value, !o$1) continue;
						} else o$1 = i$1.evaluate({ zoom: r$1 }, t$1);
						a$1 = "constant" === s$1.kind ? s$1.value : s$1.evaluate({ zoom: r$1 }, t$1), e$1.addDash(o$1, a$1), t$1.patterns[n$1.id] = [e$1.getKey(o$1, a$1)];
					}
				}
				update(t$1, e$1, r$1, n$1, i$1, s$1, o$1, a$1) {
					this.programConfigurations.updatePaintArrays(t$1, e$1, i$1, r$1, n$1, s$1, o$1, a$1);
				}
				addFeatures(t$1, e$1, r$1, n$1, i$1, s$1) {
					for (const i$2 of this.patternFeatures) this.addFeature(i$2, i$2.geometry, i$2.index, e$1, r$1, n$1, s$1, t$1.elevationFeatures);
				}
				isEmpty() {
					return 0 === this.layoutVertexArray.length;
				}
				uploadPending() {
					return !this.uploaded || this.programConfigurations.needsUpload;
				}
				upload(t$1) {
					this.uploaded || (0 !== this.layoutVertexArray2.length && (this.layoutVertexBuffer2 = t$1.createVertexBuffer(this.layoutVertexArray2, Um)), 0 !== this.patternVertexArray.length && (this.patternVertexBuffer = t$1.createVertexBuffer(this.patternVertexArray, jm)), !this.zOffsetVertexBuffer && this.zOffsetVertexArray.length > 0 && (this.zOffsetVertexBuffer = t$1.createVertexBuffer(this.zOffsetVertexArray, Rm.members, !0)), this.layoutVertexBuffer = t$1.createVertexBuffer(this.layoutVertexArray, Lm), this.indexBuffer = t$1.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t$1), this.uploaded = !0;
				}
				destroy() {
					this.layoutVertexBuffer && (this.zOffsetVertexBuffer && this.zOffsetVertexBuffer.destroy(), this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
				}
				lineFeatureClips(t$1, e$1) {
					let r$1, n$1;
					if (e$1 && e$1 > 0 ? (r$1 = `mapbox_clip_start_${e$1}`, n$1 = `mapbox_clip_end_${e$1}`) : (r$1 = "mapbox_clip_start", n$1 = "mapbox_clip_end"), t$1.properties && t$1.properties.hasOwnProperty(r$1) && t$1.properties.hasOwnProperty(n$1)) return {
						start: +t$1.properties[r$1],
						end: +t$1.properties[n$1]
					};
				}
				addFeature(t$1, e$1, r$1, n$1, i$1, s$1, o$1, a$1) {
					const l$1 = this.layers[0].layout, u$1 = l$1.get("line-join").evaluate(t$1, {}), c$1 = l$1.get("line-cap").evaluate(t$1, {}), h$1 = l$1.get("line-miter-limit"), p$1 = l$1.get("line-round-limit");
					this.lineClips = this.lineFeatureClips(t$1), this.lineFeature = t$1;
					const d$1 = !(!t$1.properties || !t$1.properties.hasOwnProperty("mapbox_line_metrics")) && t$1.properties.mapbox_line_metrics;
					this.zOffsetValue = l$1.get("line-z-offset").value;
					const f$1 = this.layers[0].paint.get("line-width").value;
					if ("constant" !== f$1.kind && !1 === f$1.isLineProgressConstant && (this.variableWidthValue = f$1), "road" === this.elevationType) {
						const r$2 = this.layoutVertexArray.length;
						if (!this.addElevatedRoadFeature(t$1, e$1, n$1, a$1, u$1, c$1, h$1, p$1)) {
							const [i$2, s$2] = this.clipRuntimeLinesToTile(e$1, 1);
							for (let e$2 = 0; e$2 < i$2.length; e$2++) {
								const r$3 = i$2[e$2], o$2 = s$2[e$2], a$2 = {
									progress: {
										min: o$2.progress.min,
										max: o$2.progress.max
									},
									nextDir: this.computeSegNextDir(o$2, r$3),
									prevDir: this.computeSegPrevDir(o$2, r$3)
								};
								this.addLine(r$3, t$1, n$1, u$1, c$1, h$1, p$1, a$2, d$1 && o$2.parentIndex > 0 ? o$2.parentIndex : null);
							}
							this.fillNonElevatedRoadSegment(r$2);
						}
					} else for (let r$2 = 0; r$2 < e$1.length; r$2++) this.addLine(e$1[r$2], t$1, n$1, u$1, c$1, h$1, p$1, void 0, d$1 && r$2 > 0 ? r$2 : null);
					this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t$1, r$1, i$1, s$1, n$1, o$1, void 0, this.worldview);
				}
				computeSegNextDir(t$1, e$1) {
					return t$1.nextPoint.sub(e$1.at(-2)).unit();
				}
				computeSegPrevDir(t$1, e$1) {
					return e$1[1].sub(t$1.prevPoint).unit();
				}
				clipLinesToTile(t$1, e$1) {
					return Fd(t$1, -e$1, -e$1, Un + e$1, Un + e$1);
				}
				clipRuntimeLinesToTile(t$1, e$1) {
					const r$1 = [];
					return [Fd(t$1, -e$1, -e$1, Un + e$1, Un + e$1, r$1), r$1];
				}
				addElevatedRoadFeature(t$1, e$1, r$1, n$1, i$1, s$1, o$1, a$1) {
					const l$1 = [], u$1 = ec.getElevationFeature(t$1, n$1);
					if (u$1) {
						const t$2 = this.clipLinesToTile(e$1, 1), n$2 = this.prepareElevatedLines(t$2, u$1, r$1);
						for (const t$3 of n$2) l$1.push({
							geometry: t$3,
							elevation: u$1,
							elevationTileID: r$1,
							segment: {
								progress: {
									min: 0,
									max: 1
								},
								nextDir: void 0,
								prevDir: void 0
							}
						});
					}
					if (0 === l$1.length) return !1;
					for (const e$2 of l$1) {
						const n$2 = this.layoutVertexArray.length;
						this.addLine(e$2.geometry, t$1, r$1, i$1, s$1, o$1, a$1);
						const l$2 = new rc(r$1, e$2.elevationTileID);
						if (e$2.elevation) for (let t$2 = n$2; t$2 < this.layoutVertexArray.length; t$2++) {
							const r$2 = new It(this.layoutVertexArray.int16[6 * t$2] >> 1, this.layoutVertexArray.int16[6 * t$2 + 1] >> 1), n$3 = l$2.pointElevation(r$2, e$2.elevation, .05);
							this.updateHeightRange(n$3), this.zOffsetVertexArray.emplaceBack(n$3, 0, 0);
						}
						else this.fillNonElevatedRoadSegment(n$2);
					}
					return !0;
				}
				prepareElevatedLines(t$1, e$1, r$1) {
					if (null != e$1.constantHeight) return t$1;
					const n$1 = [], i$1 = 1 / vu(r$1);
					for (const r$2 of t$1) Cd(r$2, new Qu(e$1, i$1), 0, n$1);
					return n$1;
				}
				fillNonElevatedRoadSegment(t$1) {
					for (let e$1 = t$1; e$1 < this.layoutVertexArray.length; e$1++) this.zOffsetVertexArray.emplaceBack(0, 0, 0);
				}
				updateHeightRange(t$1) {
					this.heightRange ? (this.heightRange.min = Math.min(this.heightRange.min, t$1), this.heightRange.max = Math.max(this.heightRange.max, t$1)) : this.heightRange = {
						min: t$1,
						max: t$1
					};
				}
				addLine(t$1, e$1, r$1, n$1, i$1, s$1, o$1, a$1, l$1) {
					this.distance = 0, this.prevDistance = 0, this.scaledDistance = 0, this.totalDistance = 0, this.totalFeatureLength = 0, this.lineSoFar = 0, this.currentVertex = void 0, this.lineClips = l$1 ? this.lineFeatureClips(e$1, l$1) : this.lineClips;
					const u$1 = "none" === n$1;
					this.patternJoinNone = this.hasPattern && u$1, this.segmentStart = 0, this.segmentStartf32 = 0, this.segmentPoints = [];
					const c$1 = a$1 && a$1.progress.min > 0, h$1 = a$1 && a$1.progress.max < 1;
					if (this.lineClips) {
						let r$2 = {
							min: this.lineClips.start,
							max: this.lineClips.end
						}, n$2 = 1;
						if (a$1) {
							const t$2 = this.lineClips.end - this.lineClips.start;
							r$2 = function(t$3, e$2, r$3) {
								return {
									min: se(t$3.min, e$2, r$3),
									max: se(t$3.max, e$2, r$3)
								};
							}(a$1.progress, {
								min: 0,
								max: 1
							}, r$2), t$2 > 0 && (n$2 = (r$2.max - r$2.min) / t$2);
						}
						const i$2 = +e$1.properties.mapbox_clip_feature_len, s$2 = +e$1.properties.mapbox_clip_seg_len;
						if (Number.isNaN(i$2) || Number.isNaN(s$2)) {
							for (let e$3 = 0; e$3 < t$1.length - 1; e$3++) this.totalDistance += t$1[e$3].dist(t$1[e$3 + 1]);
							const e$2 = this.totalDistance / (r$2.max - r$2.min);
							this.totalFeatureLength = Number.isFinite(e$2) ? e$2 : 0, this.lineClips.start = r$2.min, this.lineClips.end = r$2.max, this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);
						} else this.totalFeatureLength = i$2, this.distance = s$2 * n$2, this.lineClips.start = r$2.min, this.lineClips.end = r$2.max, this.maxLineLength = Math.max(this.maxLineLength, this.distance);
						this.lineClipsArray.push(this.lineClips), this.updateScaledDistance();
					}
					const p$1 = "Polygon" === Gm[e$1.type];
					let d$1 = t$1.length;
					for (; d$1 >= 2 && t$1[d$1 - 1].equals(t$1[d$1 - 2]);) d$1--;
					let f$1 = 0;
					for (; f$1 < d$1 - 1 && t$1[f$1].equals(t$1[f$1 + 1]);) f$1++;
					if (d$1 < (p$1 ? 3 : 2)) return;
					"bevel" === n$1 && (s$1 = 1.05);
					const m$1 = this.segments.prepareSegment(10 * d$1, this.layoutVertexArray, this.indexArray);
					let y$1, g$1, x$1, v$1, b$1, w$1, _$1, A$1;
					a$1 && a$1.prevDir && (w$1 = a$1.prevDir.perp()), a$1 && a$1.nextDir && (_$1 = a$1.nextDir.perp()), this.e1 = this.e2 = -1, p$1 && (y$1 = t$1[d$1 - 2], b$1 = t$1[f$1].sub(y$1)._unit()._perp());
					for (let e$2 = f$1; e$2 < d$1; e$2++) {
						if (x$1 = e$2 === d$1 - 1 ? p$1 ? t$1[f$1 + 1] : void 0 : t$1[e$2 + 1], x$1 && t$1[e$2].equals(x$1)) continue;
						b$1 && (v$1 = b$1), y$1 && (g$1 = y$1), y$1 = t$1[e$2], A$1 = this.evaluateLineProgressFeatures(g$1 ? g$1.dist(y$1) : 0), b$1 = x$1 ? x$1.sub(y$1)._unit()._perp() : v$1, v$1 = v$1 || b$1;
						const r$2 = g$1 && x$1;
						let a$2 = r$2 ? n$1 : p$1 || u$1 ? "butt" : i$1;
						const l$2 = v$1.x * b$1.x + v$1.y * b$1.y;
						if (u$1) {
							const t$2 = function(t$3) {
								if (t$3.patternJoinNone) {
									const e$3 = t$3.segmentPoints.length / 2, r$3 = t$3.lineSoFar - t$3.segmentStart;
									for (let n$2 = 0; n$2 < e$3; ++n$2) {
										const e$4 = t$3.segmentPoints[2 * n$2 + 1], i$2 = Math.round(t$3.segmentPoints[2 * n$2]) + .5 + .25 * e$4;
										t$3.patternVertexArray.emplaceBack(i$2, r$3, t$3.segmentStart), t$3.patternVertexArray.emplaceBack(i$2, r$3, t$3.segmentStart);
									}
									t$3.segmentPoints.length = 0;
								}
								t$3.e1 = t$3.e2 = -1;
							};
							if (r$2 && l$2 < Hm) {
								this.updateDistance(g$1, y$1), this.addCurrentVertex(y$1, v$1, 1, 1, m$1, A$1), t$2(this), this.addCurrentVertex(y$1, b$1, -1, -1, m$1, A$1);
								continue;
							}
							if (g$1) {
								if (!x$1) {
									this.updateDistance(g$1, y$1), this.addCurrentVertex(y$1, v$1, 1, 1, m$1, A$1), t$2(this);
									continue;
								}
								a$2 = "miter";
							}
						}
						let I$1 = v$1.add(b$1);
						0 === I$1.x && 0 === I$1.y || I$1._unit();
						const M$1 = I$1.x * b$1.x + I$1.y * b$1.y, S$1 = 0 !== M$1 ? 1 / M$1 : Infinity, P$1 = 2 * Math.sqrt(2 - 2 * M$1), k$1 = M$1 < qm && g$1 && x$1, B$1 = v$1.x * b$1.y - v$1.y * b$1.x > 0, z$1 = this.overscaling <= 16 ? 15 * Un / (512 * this.overscaling) : 0;
						if (r$2 && "round" === a$2) {
							if (S$1 < o$1) a$2 = "miter";
							else if (S$1 <= 2) {
								const t$2 = Zm(y$1, -10, Un + 10);
								a$2 = "offset" === this.elevationType && (t$2 || this.hasCrossSlope) ? "miter" : "fakeround";
							}
						}
						if ("miter" === a$2 && S$1 > s$1 && (a$2 = "bevel"), "bevel" === a$2 && (S$1 > 2 && (a$2 = "flipbevel"), S$1 < s$1 && (a$2 = "miter")), g$1 && !("miter" === a$2 && k$1) && this.updateDistance(g$1, y$1), "miter" === a$2) if (k$1) {
							const t$2 = y$1.dist(g$1);
							if (t$2 > 2 * z$1) {
								const e$4 = y$1.sub(y$1.sub(g$1)._mult(z$1 / t$2)._round());
								this.updateDistance(g$1, e$4), this.addCurrentVertex(e$4, v$1, 0, 0, m$1, A$1), g$1 = e$4;
							}
							this.updateDistance(g$1, y$1), I$1._mult(S$1), this.addCurrentVertex(y$1, I$1, 0, 0, m$1, A$1);
							const e$3 = y$1.dist(x$1);
							if (e$3 > 2 * z$1) {
								const t$3 = y$1.add(x$1.sub(y$1)._mult(z$1 / e$3)._round());
								this.updateDistance(y$1, t$3), this.addCurrentVertex(t$3, b$1, 0, 0, m$1, A$1), y$1 = t$3;
							}
						} else I$1._mult(S$1), this.addCurrentVertex(y$1, I$1, 0, 0, m$1, A$1);
						else if ("flipbevel" === a$2) {
							if (S$1 > 100) I$1 = b$1.mult(-1);
							else {
								const t$2 = S$1 * v$1.add(b$1).mag() / v$1.sub(b$1).mag();
								I$1._perp()._mult(t$2 * (B$1 ? -1 : 1));
							}
							this.addCurrentVertex(y$1, I$1, 0, 0, m$1, A$1), this.addCurrentVertex(y$1, I$1.mult(-1), 0, 0, m$1, A$1);
						} else if ("bevel" === a$2 || "fakeround" === a$2) {
							null != A$1 && g$1 && this.addCurrentVertex(y$1, _$1 || v$1, -1, -1, m$1, A$1);
							const t$2 = y$1.dist(g$1) <= 2 * z$1 && "bevel" !== a$2, e$3 = I$1.mult(B$1 ? 1 : -1);
							e$3._mult(S$1);
							const r$3 = b$1.mult(B$1 ? -1 : 1), n$2 = v$1.mult(B$1 ? -1 : 1), i$2 = this.evaluateLineProgressFeatures(this.distance);
							if (A$1 ?? (this.addHalfVertex(y$1, e$3.x, e$3.y, !1, !B$1, 0, m$1, i$2), t$2 || this.addHalfVertex(y$1, e$3.x + 2 * n$2.x, e$3.y + 2 * n$2.y, !1, B$1, 0, m$1, i$2)), "fakeround" === a$2) {
								const t$3 = Math.round(180 * P$1 / Math.PI / 20);
								this.addHalfVertex(y$1, n$2.x, n$2.y, !1, B$1, 0, m$1, i$2);
								for (let e$4 = 0; e$4 < t$3; e$4++) {
									let s$2 = e$4 / t$3;
									if (.5 !== s$2) {
										const t$4 = s$2 - .5;
										s$2 += s$2 * t$4 * (s$2 - 1) * ((1.0904 + l$2 * (l$2 * (3.55645 - 1.43519 * l$2) - 3.2452)) * t$4 * t$4 + (.848013 + l$2 * (.215638 * l$2 - 1.06021)));
									}
									const o$2 = r$3.sub(n$2)._mult(s$2)._add(n$2)._unit();
									this.addHalfVertex(y$1, o$2.x, o$2.y, !1, B$1, 0, m$1, i$2);
								}
								this.addHalfVertex(y$1, r$3.x, r$3.y, !1, B$1, 0, m$1, i$2);
							}
							t$2 || null != A$1 || this.addHalfVertex(y$1, e$3.x + 2 * r$3.x, e$3.y + 2 * r$3.y, !1, B$1, 0, m$1, i$2), null != A$1 && x$1 && this.addCurrentVertex(y$1, w$1 || b$1, 1, 1, m$1, A$1);
						} else if ("butt" === a$2) this.addCurrentVertex(y$1, I$1, 0, 0, m$1, A$1);
						else if ("square" === a$2) {
							if (!g$1) {
								const t$2 = c$1 ? 0 : -1;
								this.addCurrentVertex(y$1, I$1, t$2, t$2, m$1, A$1);
							}
							if (this.addCurrentVertex(y$1, I$1, 0, 0, m$1, A$1), g$1) {
								const t$2 = h$1 ? 0 : 1;
								this.addCurrentVertex(y$1, I$1, t$2, t$2, m$1, A$1);
							}
						} else if ("round" === a$2) {
							if (g$1) {
								const t$2 = !r$2 && _$1 ? _$1 : v$1;
								this.addCurrentVertex(y$1, t$2, 0, 0, m$1, A$1), !r$2 && h$1 || this.addCurrentVertex(y$1, t$2, 1, 1, m$1, A$1, !0);
							}
							if (x$1) {
								const t$2 = !r$2 && w$1 ? w$1 : b$1;
								!r$2 && c$1 || this.addCurrentVertex(y$1, t$2, -1, -1, m$1, A$1, !0), this.addCurrentVertex(y$1, t$2, 0, 0, m$1, A$1);
							}
						}
					}
				}
				addVerticesTo(t$1, e$1, r$1, n$1, i$1, s$1, o$1, a$1, l$1, u$1) {
					const c$1 = (e$1.w - t$1.w) / this.tessellationStep | 0;
					let h$1 = 0;
					const p$1 = this.scaledDistance;
					if (c$1 > 1) {
						this.lineSoFar = t$1.w;
						const p$2 = (e$1.x - t$1.x) / c$1, d$2 = (e$1.y - t$1.y) / c$1, f$1 = (e$1.z - t$1.z) / c$1, m$1 = (e$1.w - t$1.w) / c$1;
						for (let e$2 = 1; e$2 < c$1; ++e$2) {
							t$1.x += p$2, t$1.y += d$2, t$1.z += f$1, this.lineSoFar += m$1, h$1 += m$1;
							const e$3 = this.evaluateLineProgressFeatures(this.prevDistance + h$1);
							this.scaledDistance = (this.prevDistance + h$1) / this.totalDistance, this.addHalfVertex(t$1, r$1, n$1, u$1, !1, o$1, l$1, e$3), this.addHalfVertex(t$1, i$1, s$1, u$1, !0, -a$1, l$1, e$3);
						}
					}
					this.lineSoFar = e$1.w, this.scaledDistance = p$1;
					const d$1 = this.evaluateLineProgressFeatures(this.distance);
					this.addHalfVertex(e$1, r$1, n$1, u$1, !1, o$1, l$1, d$1), this.addHalfVertex(e$1, i$1, s$1, u$1, !0, -a$1, l$1, d$1);
				}
				evaluateLineProgressFeatures(t$1) {
					if (!this.variableWidthValue && "offset" !== this.elevationType) return null;
					this.evaluationGlobals.lineProgress = 0, this.lineClips ? this.evaluationGlobals.lineProgress = Math.min(1, (this.totalFeatureLength * this.lineClips.start + t$1) / this.totalFeatureLength) : Xt(`line-progress evaluation for ${this.layerIds[0]} requires enabling 'lineMetrics' for the source.`);
					let e$1 = 0;
					return this.variableWidthValue && "constant" !== this.variableWidthValue.kind && (e$1 = this.variableWidthValue.evaluate(this.evaluationGlobals, this.lineFeature) || 0), "offset" !== this.elevationType ? {
						zOffset: 0,
						variableWidth: e$1
					} : "constant" === this.zOffsetValue.kind ? {
						zOffset: this.zOffsetValue.value,
						variableWidth: e$1
					} : {
						zOffset: this.zOffsetValue.evaluate(this.evaluationGlobals, this.lineFeature) || 0,
						variableWidth: e$1
					};
				}
				addCurrentVertex(t$1, e$1, r$1, n$1, i$1, s$1, o$1 = !1) {
					const a$1 = e$1.x + e$1.y * r$1, l$1 = e$1.y - e$1.x * r$1, u$1 = e$1.y * n$1 - e$1.x, c$1 = -e$1.y - e$1.x * n$1;
					if (null != s$1) {
						const e$2 = "offset" === this.elevationType, h$1 = -10, p$1 = Un + 10, d$1 = s$1.zOffset, f$1 = new Td(t$1.x, t$1.y, d$1, this.lineSoFar), m$1 = !!e$2 && Zm(t$1, h$1, p$1), y$1 = this.lineSoFar, g$1 = this.distance;
						if (this.currentVertex) if (m$1) {
							const e$3 = this.currentVertexIsOutside, s$2 = this.currentVertex, m$2 = new Td(t$1.x, t$1.y, d$1, this.lineSoFar);
							if (Vd(s$2, m$2, h$1, p$1), !Zm(m$2, h$1, p$1)) {
								if (e$3) {
									this.e1 = this.e2 = -1, this.distance -= s$2.dist(f$1), this.lineSoFar = s$2.w;
									const t$2 = this.evaluateLineProgressFeatures(s$2.w - this.totalFeatureLength * (this.lineClips ? this.lineClips.start : 0));
									this.addHalfVertex(s$2, a$1, l$1, o$1, !1, r$1, i$1, t$2), this.addHalfVertex(s$2, u$1, c$1, o$1, !0, -n$1, i$1, t$2), this.prevDistance = this.distance;
								}
								this.distance = this.prevDistance + s$2.dist(m$2), this.scaledDistance = this.distance / this.totalDistance, this.addVerticesTo(s$2, m$2, a$1, l$1, u$1, c$1, r$1, n$1, i$1, o$1), this.distance = g$1, this.scaledDistance = this.distance / this.totalDistance;
							}
						} else {
							const t$2 = this.currentVertex;
							if (this.currentVertexIsOutside) {
								Vd(t$2, f$1, h$1, p$1), this.e1 = this.e2 = -1, this.distance -= t$2.dist(f$1), this.scaledDistance = this.distance / this.totalDistance, this.lineSoFar = t$2.w;
								const e$3 = this.evaluateLineProgressFeatures(t$2.w - this.totalFeatureLength * (this.lineClips ? this.lineClips.start : 0));
								this.addHalfVertex(t$2, a$1, l$1, o$1, !1, r$1, i$1, e$3), this.addHalfVertex(t$2, u$1, c$1, o$1, !0, -n$1, i$1, e$3), this.prevDistance = this.distance, this.distance = g$1, this.scaledDistance = this.distance / this.totalDistance;
							}
							this.addVerticesTo(t$2, f$1, a$1, l$1, u$1, c$1, r$1, n$1, i$1, o$1);
						}
						else m$1 || (this.addHalfVertex(t$1, a$1, l$1, o$1, !1, r$1, i$1, s$1), this.addHalfVertex(t$1, u$1, c$1, o$1, !0, -n$1, i$1, s$1));
						this.currentVertex = f$1, this.currentVertexIsOutside = m$1, this.lineSoFar = y$1;
					} else this.addHalfVertex(t$1, a$1, l$1, o$1, !1, r$1, i$1, s$1), this.addHalfVertex(t$1, u$1, c$1, o$1, !0, -n$1, i$1, s$1);
				}
				addHalfVertex({ x: t$1, y: e$1 }, r$1, n$1, i$1, s$1, o$1, a$1, l$1) {
					if (this.patternJoinNone && (0 === this.segmentPoints.length && (this.segmentStart = this.lineSoFar, this.segmentStartf32 = Math.fround(this.lineSoFar)), s$1 || this.segmentPoints.push(this.lineSoFar - this.segmentStart, o$1)), this.layoutVertexArray.emplaceBack((t$1 << 1) + (i$1 ? 1 : 0), (e$1 << 1) + (s$1 ? 1 : 0), Math.round(63 * r$1) + 128, Math.round(63 * n$1) + 128, 1 + (0 === o$1 ? 0 : o$1 < 0 ? -1 : 1), 0, this.lineSoFar - this.segmentStartf32), this.lineClips) {
						const t$2 = pr(this.lineClips.start, this.lineClips.end, this.scaledDistance);
						this.layoutVertexArray2.emplaceBack(this.scaledDistance, this.lineClipsArray.length, t$2);
					}
					const u$1 = a$1.vertexLength++;
					this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, this.e2, u$1), a$1.primitiveLength++), s$1 ? this.e2 = u$1 : this.e1 = u$1, null != l$1 && this.zOffsetVertexArray.emplaceBack(l$1.zOffset, l$1.variableWidth, l$1.variableWidth);
				}
				updateScaledDistance() {
					this.lineClips ? (this.scaledDistance = this.distance / this.totalDistance, this.lineSoFar = this.totalFeatureLength * this.lineClips.start + this.distance) : this.lineSoFar = this.distance;
				}
				updateDistance(t$1, e$1) {
					this.prevDistance = this.distance, this.distance += t$1.dist(e$1), this.updateScaledDistance();
				}
			}
			function Zm(t$1, e$1, r$1) {
				return t$1.x < e$1 || t$1.x > r$1 || t$1.y < e$1 || t$1.y > r$1;
			}
			let Wm, Ym;
			function Km(t$1, e$1, r$1) {
				return e$1 * (Un / (t$1.tileSize * Math.pow(2, r$1 - t$1.tileID.overscaledZ)));
			}
			Qs(Xm, "LineBucket", { omit: [
				"layers",
				"patternFeatures",
				"currentVertex",
				"currentVertexIsOutside"
			] });
			const Jm = (t$1, e$1, r$1) => (1 - r$1) * t$1 + r$1 * e$1;
			function Qm(t$1, e$1) {
				return 1 / Km(t$1, 1, e$1.tileZoom);
			}
			function ty(t$1, e$1, r$1, n$1) {
				return t$1.translatePosMatrix(n$1 || e$1.tileID.projMatrix, e$1, r$1.paint.get("line-translate"), r$1.paint.get("line-translate-anchor"));
			}
			const ey = (t$1) => {
				const e$1 = [];
				ry(t$1) && e$1.push("RENDER_LINE_DASH"), t$1.paint.get("line-gradient") && e$1.push("RENDER_LINE_GRADIENT");
				const r$1 = t$1.paint.get("line-trim-offset");
				0 === r$1[0] && 0 === r$1[1] || e$1.push("RENDER_LINE_TRIM_OFFSET"), 0 !== t$1.paint.get("line-border-width").constantOr(1) && e$1.push("RENDER_LINE_BORDER");
				const n$1 = "none" === t$1.layout.get("line-join").constantOr("miter"), i$1 = !!t$1.paint.get("line-pattern").constantOr(1);
				return n$1 && i$1 && e$1.push("LINE_JOIN_NONE"), e$1;
			};
			function ry(t$1) {
				const e$1 = t$1.paint.get("line-dasharray").value;
				return "constant" !== e$1.kind || e$1.value;
			}
			let ny;
			const iy = () => ny || (ny = {
				layout: Wm || (Wm = new Do({
					"line-cap": new Fo(Ro.layout_line["line-cap"]),
					"line-join": new Fo(Ro.layout_line["line-join"]),
					"line-miter-limit": new Vo(Ro.layout_line["line-miter-limit"]),
					"line-round-limit": new Vo(Ro.layout_line["line-round-limit"]),
					"line-sort-key": new Fo(Ro.layout_line["line-sort-key"]),
					"line-z-offset": new Fo(Ro.layout_line["line-z-offset"]),
					"line-elevation-reference": new Vo(Ro.layout_line["line-elevation-reference"]),
					"line-cross-slope": new Vo(Ro.layout_line["line-cross-slope"]),
					visibility: new Vo(Ro.layout_line.visibility),
					"line-width-unit": new Vo(Ro.layout_line["line-width-unit"])
				})),
				paint: Ym || (Ym = new Do({
					"line-opacity": new Fo(Ro.paint_line["line-opacity"]),
					"line-color": new Fo(Ro.paint_line["line-color"]),
					"line-translate": new Vo(Ro.paint_line["line-translate"]),
					"line-translate-anchor": new Vo(Ro.paint_line["line-translate-anchor"]),
					"line-width": new Fo(Ro.paint_line["line-width"]),
					"line-gap-width": new Fo(Ro.paint_line["line-gap-width"]),
					"line-offset": new Fo(Ro.paint_line["line-offset"]),
					"line-blur": new Fo(Ro.paint_line["line-blur"]),
					"line-dasharray": new Fo(Ro.paint_line["line-dasharray"]),
					"line-pattern": new Fo(Ro.paint_line["line-pattern"]),
					"line-pattern-cross-fade": new Vo(Ro.paint_line["line-pattern-cross-fade"]),
					"line-gradient": new Co(Ro.paint_line["line-gradient"]),
					"line-trim-offset": new Vo(Ro.paint_line["line-trim-offset"]),
					"line-trim-fade-range": new Vo(Ro.paint_line["line-trim-fade-range"]),
					"line-trim-color": new Vo(Ro.paint_line["line-trim-color"]),
					"line-emissive-strength": new Fo(Ro.paint_line["line-emissive-strength"]),
					"line-border-width": new Fo(Ro.paint_line["line-border-width"]),
					"line-border-color": new Fo(Ro.paint_line["line-border-color"]),
					"line-occlusion-opacity": new Vo(Ro.paint_line["line-occlusion-opacity"]),
					"line-color-use-theme": new Fo({
						type: "string",
						default: "default",
						"property-type": "data-driven"
					}),
					"line-gradient-use-theme": new Fo({
						type: "string",
						default: "default",
						"property-type": "data-driven"
					}),
					"line-trim-color-use-theme": new Fo({
						type: "string",
						default: "default",
						"property-type": "data-driven"
					}),
					"line-border-color-use-theme": new Fo({
						type: "string",
						default: "default",
						"property-type": "data-driven"
					})
				}))
			}, ny);
			class sy extends Fo {
				possiblyEvaluate(t$1, e$1) {
					return e$1 = new Io(Math.floor(e$1.zoom), {
						now: e$1.now,
						fadeDuration: e$1.fadeDuration,
						transition: e$1.transition,
						worldview: e$1.worldview
					}), super.possiblyEvaluate(t$1, e$1);
				}
				evaluate(t$1, e$1, r$1, n$1) {
					return e$1 = Object.assign({}, e$1, { zoom: Math.floor(e$1.zoom) }), super.evaluate(t$1, e$1, r$1, n$1);
				}
			}
			let oy;
			function ay(t$1, e$1) {
				return e$1 > 0 ? e$1 + 2 * t$1 : t$1;
			}
			const ly = ha([
				{
					name: "a_pos_offset",
					components: 4,
					type: "Int16"
				},
				{
					name: "a_tex_size",
					components: 4,
					type: "Uint16"
				},
				{
					name: "a_pixeloffset",
					components: 4,
					type: "Int16"
				}
			], 4), uy = ha([{
				name: "a_globe_anchor",
				components: 3,
				type: "Int16"
			}, {
				name: "a_globe_normal",
				components: 3,
				type: "Float32"
			}], 4), cy = ha([{
				name: "a_projected_pos",
				components: 4,
				type: "Float32"
			}], 4);
			ha([{
				name: "a_fade_opacity",
				components: 1,
				type: "Uint32"
			}], 4);
			const hy = ha([{
				name: "a_auto_z_offset",
				components: 1,
				type: "Float32"
			}], 4), py = ha([{
				name: "a_x_axis",
				components: 3,
				type: "Float32"
			}, {
				name: "a_y_axis",
				components: 3,
				type: "Float32"
			}]), dy = ha([{
				name: "a_texb",
				components: 2,
				type: "Uint16"
			}]), fy = ha([
				{
					name: "a_placed",
					components: 2,
					type: "Uint8"
				},
				{
					name: "a_shift",
					components: 2,
					type: "Float32"
				},
				{
					name: "a_elevation_from_sea",
					components: 2,
					type: "Float32"
				}
			]), my = ha([
				{
					name: "a_size_scale",
					components: 1,
					type: "Float32"
				},
				{
					name: "a_padding",
					components: 2,
					type: "Float32"
				},
				{
					name: "a_auto_z_offset",
					components: 1,
					type: "Float32"
				}
			]);
			ha([
				{
					type: "Int16",
					name: "projectedAnchorX"
				},
				{
					type: "Int16",
					name: "projectedAnchorY"
				},
				{
					type: "Int16",
					name: "projectedAnchorZ"
				},
				{
					type: "Int16",
					name: "tileAnchorX"
				},
				{
					type: "Int16",
					name: "tileAnchorY"
				},
				{
					type: "Float32",
					name: "x1"
				},
				{
					type: "Float32",
					name: "y1"
				},
				{
					type: "Float32",
					name: "x2"
				},
				{
					type: "Float32",
					name: "y2"
				},
				{
					type: "Int16",
					name: "padding"
				},
				{
					type: "Uint32",
					name: "featureIndex"
				},
				{
					type: "Uint16",
					name: "sourceLayerIndex"
				},
				{
					type: "Uint16",
					name: "bucketIndex"
				}
			]);
			const yy = ha([
				{
					name: "a_pos",
					components: 3,
					type: "Int16"
				},
				{
					name: "a_anchor_pos",
					components: 2,
					type: "Int16"
				},
				{
					name: "a_extrude",
					components: 2,
					type: "Int16"
				}
			], 4), gy = ha([
				{
					name: "a_pos_2f",
					components: 2,
					type: "Float32"
				},
				{
					name: "a_radius",
					components: 1,
					type: "Float32"
				},
				{
					name: "a_flags",
					components: 2,
					type: "Int16"
				}
			], 4);
			ha([{
				name: "triangle",
				components: 3,
				type: "Uint16"
			}]), ha([
				{
					type: "Int16",
					name: "projectedAnchorX"
				},
				{
					type: "Int16",
					name: "projectedAnchorY"
				},
				{
					type: "Int16",
					name: "projectedAnchorZ"
				},
				{
					type: "Float32",
					name: "tileAnchorX"
				},
				{
					type: "Float32",
					name: "tileAnchorY"
				},
				{
					type: "Uint16",
					name: "glyphStartIndex"
				},
				{
					type: "Uint16",
					name: "numGlyphs"
				},
				{
					type: "Uint32",
					name: "vertexStartIndex"
				},
				{
					type: "Uint32",
					name: "lineStartIndex"
				},
				{
					type: "Uint32",
					name: "lineLength"
				},
				{
					type: "Uint16",
					name: "segment"
				},
				{
					type: "Uint16",
					name: "lowerSize"
				},
				{
					type: "Uint16",
					name: "upperSize"
				},
				{
					type: "Float32",
					name: "lineOffsetX"
				},
				{
					type: "Float32",
					name: "lineOffsetY"
				},
				{
					type: "Uint8",
					name: "writingMode"
				},
				{
					type: "Uint8",
					name: "placedOrientation"
				},
				{
					type: "Uint8",
					name: "hidden"
				},
				{
					type: "Uint32",
					name: "crossTileID"
				},
				{
					type: "Int16",
					name: "associatedIconIndex"
				},
				{
					type: "Uint8",
					name: "flipState"
				}
			]), ha([
				{
					type: "Float32",
					name: "tileAnchorX"
				},
				{
					type: "Float32",
					name: "tileAnchorY"
				},
				{
					type: "Int16",
					name: "projectedAnchorX"
				},
				{
					type: "Int16",
					name: "projectedAnchorY"
				},
				{
					type: "Int16",
					name: "projectedAnchorZ"
				},
				{
					type: "Int16",
					name: "rightJustifiedTextSymbolIndex"
				},
				{
					type: "Int16",
					name: "centerJustifiedTextSymbolIndex"
				},
				{
					type: "Int16",
					name: "leftJustifiedTextSymbolIndex"
				},
				{
					type: "Int16",
					name: "verticalPlacedTextSymbolIndex"
				},
				{
					type: "Int16",
					name: "placedIconSymbolIndex"
				},
				{
					type: "Int16",
					name: "verticalPlacedIconSymbolIndex"
				},
				{
					type: "Uint16",
					name: "key"
				},
				{
					type: "Uint16",
					name: "textBoxStartIndex"
				},
				{
					type: "Uint16",
					name: "textBoxEndIndex"
				},
				{
					type: "Uint16",
					name: "verticalTextBoxStartIndex"
				},
				{
					type: "Uint16",
					name: "verticalTextBoxEndIndex"
				},
				{
					type: "Uint16",
					name: "iconBoxStartIndex"
				},
				{
					type: "Uint16",
					name: "iconBoxEndIndex"
				},
				{
					type: "Uint16",
					name: "verticalIconBoxStartIndex"
				},
				{
					type: "Uint16",
					name: "verticalIconBoxEndIndex"
				},
				{
					type: "Uint16",
					name: "featureIndex"
				},
				{
					type: "Uint16",
					name: "numHorizontalGlyphVertices"
				},
				{
					type: "Uint16",
					name: "numVerticalGlyphVertices"
				},
				{
					type: "Uint16",
					name: "numIconVertices"
				},
				{
					type: "Uint16",
					name: "numVerticalIconVertices"
				},
				{
					type: "Uint16",
					name: "useRuntimeCollisionCircles"
				},
				{
					type: "Uint32",
					name: "crossTileID"
				},
				{
					type: "Float32",
					components: 2,
					name: "textOffset"
				},
				{
					type: "Float32",
					name: "collisionCircleDiameter"
				},
				{
					type: "Float32",
					name: "zOffset"
				},
				{
					type: "Uint8",
					name: "hasIconTextFit"
				},
				{
					type: "Uint16",
					name: "elevationFeatureIndex"
				}
			]), ha([{
				type: "Float32",
				name: "offsetX"
			}]), ha([{
				type: "Int16",
				name: "x"
			}, {
				type: "Int16",
				name: "y"
			}]);
			var xy = 24;
			function vy(t$1, e$1, r$1) {
				return t$1.sections.forEach(((t$2) => {
					t$2.text = function(t$3, e$2, r$2) {
						const n$1 = e$2.layout.get("text-transform").evaluate(r$2, {});
						return "uppercase" === n$1 ? t$3 = t$3.toLocaleUpperCase() : "lowercase" === n$1 && (t$3 = t$3.toLocaleLowerCase()), Ao.applyArabicShaping && (t$3 = Ao.applyArabicShaping(t$3)), t$3;
					}(t$2.text, e$1, r$1);
				})), t$1;
			}
			const by = {
				"!": "",
				"#": "",
				$: "",
				"%": "",
				"&": "",
				"(": "",
				")": "",
				"*": "",
				"+": "",
				",": "",
				"-": "",
				".": "",
				"/": "",
				":": "",
				";": "",
				"<": "",
				"=": "",
				">": "",
				"?": "",
				"@": "",
				"[": "",
				"\\": "",
				"]": "",
				"^": "",
				_: "",
				"`": "",
				"{": "",
				"|": "",
				"}": "",
				"~": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": ""
			};
			function wy(t$1) {
				return "" === t$1 || "" === t$1 || "" === t$1 || "" === t$1 || "" === t$1 || "" === t$1 || "" === t$1 || "" === t$1 || "" === t$1 || "" === t$1 || "" === t$1 || "" === t$1 || "" === t$1 || "" === t$1 || "" === t$1 || "" === t$1 || "" === t$1;
			}
			function _y(t$1) {
				return "" === t$1 || "" === t$1 || "" === t$1 || "" === t$1 || "" === t$1 || "" === t$1 || "" === t$1 || "" === t$1 || "" === t$1 || "" === t$1;
			}
			const Ay = 4294967296, Iy = 1 / Ay, My = "undefined" == typeof TextDecoder ? null : new TextDecoder("utf-8");
			let Sy = class {
				constructor(t$1 = new Uint8Array(16)) {
					this.buf = ArrayBuffer.isView(t$1) ? t$1 : new Uint8Array(t$1), this.dataView = new DataView(this.buf.buffer), this.pos = 0, this.type = 0, this.length = this.buf.length;
				}
				readFields(t$1, e$1, r$1 = this.length) {
					for (; this.pos < r$1;) {
						const r$2 = this.readVarint(), n$1 = r$2 >> 3, i$1 = this.pos;
						this.type = 7 & r$2, t$1(n$1, e$1, this), this.pos === i$1 && this.skip(r$2);
					}
					return e$1;
				}
				readMessage(t$1, e$1) {
					return this.readFields(t$1, e$1, this.readVarint() + this.pos);
				}
				readFixed32() {
					const t$1 = this.dataView.getUint32(this.pos, !0);
					return this.pos += 4, t$1;
				}
				readSFixed32() {
					const t$1 = this.dataView.getInt32(this.pos, !0);
					return this.pos += 4, t$1;
				}
				readFixed64() {
					const t$1 = this.dataView.getUint32(this.pos, !0) + this.dataView.getUint32(this.pos + 4, !0) * Ay;
					return this.pos += 8, t$1;
				}
				readSFixed64() {
					const t$1 = this.dataView.getUint32(this.pos, !0) + this.dataView.getInt32(this.pos + 4, !0) * Ay;
					return this.pos += 8, t$1;
				}
				readFloat() {
					const t$1 = this.dataView.getFloat32(this.pos, !0);
					return this.pos += 4, t$1;
				}
				readDouble() {
					const t$1 = this.dataView.getFloat64(this.pos, !0);
					return this.pos += 8, t$1;
				}
				readVarint(t$1) {
					const e$1 = this.buf;
					let r$1, n$1;
					return n$1 = e$1[this.pos++], r$1 = 127 & n$1, n$1 < 128 ? r$1 : (n$1 = e$1[this.pos++], r$1 |= (127 & n$1) << 7, n$1 < 128 ? r$1 : (n$1 = e$1[this.pos++], r$1 |= (127 & n$1) << 14, n$1 < 128 ? r$1 : (n$1 = e$1[this.pos++], r$1 |= (127 & n$1) << 21, n$1 < 128 ? r$1 : (n$1 = e$1[this.pos], r$1 |= (15 & n$1) << 28, function(t$2, e$2, r$2) {
						const n$2 = r$2.buf;
						let i$1, s$1;
						if (s$1 = n$2[r$2.pos++], i$1 = (112 & s$1) >> 4, s$1 < 128) return Py(t$2, i$1, e$2);
						if (s$1 = n$2[r$2.pos++], i$1 |= (127 & s$1) << 3, s$1 < 128) return Py(t$2, i$1, e$2);
						if (s$1 = n$2[r$2.pos++], i$1 |= (127 & s$1) << 10, s$1 < 128) return Py(t$2, i$1, e$2);
						if (s$1 = n$2[r$2.pos++], i$1 |= (127 & s$1) << 17, s$1 < 128) return Py(t$2, i$1, e$2);
						if (s$1 = n$2[r$2.pos++], i$1 |= (127 & s$1) << 24, s$1 < 128) return Py(t$2, i$1, e$2);
						if (s$1 = n$2[r$2.pos++], i$1 |= (1 & s$1) << 31, s$1 < 128) return Py(t$2, i$1, e$2);
						throw new Error("Expected varint not more than 10 bytes");
					}(r$1, t$1, this)))));
				}
				readVarint64() {
					return this.readVarint(!0);
				}
				readSVarint() {
					const t$1 = this.readVarint();
					return t$1 % 2 == 1 ? (t$1 + 1) / -2 : t$1 / 2;
				}
				readBoolean() {
					return Boolean(this.readVarint());
				}
				readString() {
					const t$1 = this.readVarint() + this.pos, e$1 = this.pos;
					return this.pos = t$1, t$1 - e$1 >= 12 && My ? My.decode(this.buf.subarray(e$1, t$1)) : function(t$2, e$2, r$1) {
						let n$1 = "", i$1 = e$2;
						for (; i$1 < r$1;) {
							const e$3 = t$2[i$1];
							let s$1, o$1, a$1, l$1 = null, u$1 = e$3 > 239 ? 4 : e$3 > 223 ? 3 : e$3 > 191 ? 2 : 1;
							if (i$1 + u$1 > r$1) break;
							1 === u$1 ? e$3 < 128 && (l$1 = e$3) : 2 === u$1 ? (s$1 = t$2[i$1 + 1], 128 == (192 & s$1) && (l$1 = (31 & e$3) << 6 | 63 & s$1, l$1 <= 127 && (l$1 = null))) : 3 === u$1 ? (s$1 = t$2[i$1 + 1], o$1 = t$2[i$1 + 2], 128 == (192 & s$1) && 128 == (192 & o$1) && (l$1 = (15 & e$3) << 12 | (63 & s$1) << 6 | 63 & o$1, (l$1 <= 2047 || l$1 >= 55296 && l$1 <= 57343) && (l$1 = null))) : 4 === u$1 && (s$1 = t$2[i$1 + 1], o$1 = t$2[i$1 + 2], a$1 = t$2[i$1 + 3], 128 == (192 & s$1) && 128 == (192 & o$1) && 128 == (192 & a$1) && (l$1 = (15 & e$3) << 18 | (63 & s$1) << 12 | (63 & o$1) << 6 | 63 & a$1, (l$1 <= 65535 || l$1 >= 1114112) && (l$1 = null))), null === l$1 ? (l$1 = 65533, u$1 = 1) : l$1 > 65535 && (l$1 -= 65536, n$1 += String.fromCharCode(l$1 >>> 10 & 1023 | 55296), l$1 = 56320 | 1023 & l$1), n$1 += String.fromCharCode(l$1), i$1 += u$1;
						}
						return n$1;
					}(this.buf, e$1, t$1);
				}
				readBytes() {
					const t$1 = this.readVarint() + this.pos, e$1 = this.buf.subarray(this.pos, t$1);
					return this.pos = t$1, e$1;
				}
				readPackedVarint(t$1 = [], e$1) {
					const r$1 = this.readPackedEnd();
					for (; this.pos < r$1;) t$1.push(this.readVarint(e$1));
					return t$1;
				}
				readPackedSVarint(t$1 = []) {
					const e$1 = this.readPackedEnd();
					for (; this.pos < e$1;) t$1.push(this.readSVarint());
					return t$1;
				}
				readPackedBoolean(t$1 = []) {
					const e$1 = this.readPackedEnd();
					for (; this.pos < e$1;) t$1.push(this.readBoolean());
					return t$1;
				}
				readPackedFloat(t$1 = []) {
					const e$1 = this.readPackedEnd();
					for (; this.pos < e$1;) t$1.push(this.readFloat());
					return t$1;
				}
				readPackedDouble(t$1 = []) {
					const e$1 = this.readPackedEnd();
					for (; this.pos < e$1;) t$1.push(this.readDouble());
					return t$1;
				}
				readPackedFixed32(t$1 = []) {
					const e$1 = this.readPackedEnd();
					for (; this.pos < e$1;) t$1.push(this.readFixed32());
					return t$1;
				}
				readPackedSFixed32(t$1 = []) {
					const e$1 = this.readPackedEnd();
					for (; this.pos < e$1;) t$1.push(this.readSFixed32());
					return t$1;
				}
				readPackedFixed64(t$1 = []) {
					const e$1 = this.readPackedEnd();
					for (; this.pos < e$1;) t$1.push(this.readFixed64());
					return t$1;
				}
				readPackedSFixed64(t$1 = []) {
					const e$1 = this.readPackedEnd();
					for (; this.pos < e$1;) t$1.push(this.readSFixed64());
					return t$1;
				}
				readPackedEnd() {
					return 2 === this.type ? this.readVarint() + this.pos : this.pos + 1;
				}
				skip(t$1) {
					const e$1 = 7 & t$1;
					if (0 === e$1) for (; this.buf[this.pos++] > 127;);
					else if (2 === e$1) this.pos = this.readVarint() + this.pos;
					else if (5 === e$1) this.pos += 4;
					else {
						if (1 !== e$1) throw new Error(`Unimplemented type: ${e$1}`);
						this.pos += 8;
					}
				}
				writeTag(t$1, e$1) {
					this.writeVarint(t$1 << 3 | e$1);
				}
				realloc(t$1) {
					let e$1 = this.length || 16;
					for (; e$1 < this.pos + t$1;) e$1 *= 2;
					if (e$1 !== this.length) {
						const t$2 = new Uint8Array(e$1);
						t$2.set(this.buf), this.buf = t$2, this.dataView = new DataView(t$2.buffer), this.length = e$1;
					}
				}
				finish() {
					return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
				}
				writeFixed32(t$1) {
					this.realloc(4), this.dataView.setInt32(this.pos, t$1, !0), this.pos += 4;
				}
				writeSFixed32(t$1) {
					this.realloc(4), this.dataView.setInt32(this.pos, t$1, !0), this.pos += 4;
				}
				writeFixed64(t$1) {
					this.realloc(8), this.dataView.setInt32(this.pos, -1 & t$1, !0), this.dataView.setInt32(this.pos + 4, Math.floor(t$1 * Iy), !0), this.pos += 8;
				}
				writeSFixed64(t$1) {
					this.realloc(8), this.dataView.setInt32(this.pos, -1 & t$1, !0), this.dataView.setInt32(this.pos + 4, Math.floor(t$1 * Iy), !0), this.pos += 8;
				}
				writeVarint(t$1) {
					(t$1 = +t$1 || 0) > 268435455 || t$1 < 0 ? function(t$2, e$1) {
						let r$1, n$1;
						if (t$2 >= 0 ? (r$1 = t$2 % 4294967296 | 0, n$1 = t$2 / 4294967296 | 0) : (r$1 = ~(-t$2 % 4294967296), n$1 = ~(-t$2 / 4294967296), 4294967295 ^ r$1 ? r$1 = r$1 + 1 | 0 : (r$1 = 0, n$1 = n$1 + 1 | 0)), t$2 >= 0x10000000000000000 || t$2 < -0x10000000000000000) throw new Error("Given varint doesn't fit into 10 bytes");
						e$1.realloc(10), function(t$3, e$2, r$2) {
							r$2.buf[r$2.pos++] = 127 & t$3 | 128, t$3 >>>= 7, r$2.buf[r$2.pos++] = 127 & t$3 | 128, t$3 >>>= 7, r$2.buf[r$2.pos++] = 127 & t$3 | 128, t$3 >>>= 7, r$2.buf[r$2.pos++] = 127 & t$3 | 128, r$2.buf[r$2.pos] = 127 & (t$3 >>>= 7);
						}(r$1, 0, e$1), function(t$3, e$2) {
							const r$2 = (7 & t$3) << 4;
							e$2.buf[e$2.pos++] |= r$2 | ((t$3 >>>= 3) ? 128 : 0), t$3 && (e$2.buf[e$2.pos++] = 127 & t$3 | ((t$3 >>>= 7) ? 128 : 0), t$3 && (e$2.buf[e$2.pos++] = 127 & t$3 | ((t$3 >>>= 7) ? 128 : 0), t$3 && (e$2.buf[e$2.pos++] = 127 & t$3 | ((t$3 >>>= 7) ? 128 : 0), t$3 && (e$2.buf[e$2.pos++] = 127 & t$3 | ((t$3 >>>= 7) ? 128 : 0), t$3 && (e$2.buf[e$2.pos++] = 127 & t$3)))));
						}(n$1, e$1);
					}(t$1, this) : (this.realloc(4), this.buf[this.pos++] = 127 & t$1 | (t$1 > 127 ? 128 : 0), t$1 <= 127 || (this.buf[this.pos++] = 127 & (t$1 >>>= 7) | (t$1 > 127 ? 128 : 0), t$1 <= 127 || (this.buf[this.pos++] = 127 & (t$1 >>>= 7) | (t$1 > 127 ? 128 : 0), t$1 <= 127 || (this.buf[this.pos++] = t$1 >>> 7 & 127))));
				}
				writeSVarint(t$1) {
					this.writeVarint(t$1 < 0 ? 2 * -t$1 - 1 : 2 * t$1);
				}
				writeBoolean(t$1) {
					this.writeVarint(+t$1);
				}
				writeString(t$1) {
					t$1 = String(t$1), this.realloc(4 * t$1.length), this.pos++;
					const e$1 = this.pos;
					this.pos = function(t$2, e$2, r$2) {
						for (let n$1, i$1, s$1 = 0; s$1 < e$2.length; s$1++) {
							if (n$1 = e$2.charCodeAt(s$1), n$1 > 55295 && n$1 < 57344) {
								if (!i$1) {
									n$1 > 56319 || s$1 + 1 === e$2.length ? (t$2[r$2++] = 239, t$2[r$2++] = 191, t$2[r$2++] = 189) : i$1 = n$1;
									continue;
								}
								if (n$1 < 56320) {
									t$2[r$2++] = 239, t$2[r$2++] = 191, t$2[r$2++] = 189, i$1 = n$1;
									continue;
								}
								n$1 = i$1 - 55296 << 10 | n$1 - 56320 | 65536, i$1 = null;
							} else i$1 && (t$2[r$2++] = 239, t$2[r$2++] = 191, t$2[r$2++] = 189, i$1 = null);
							n$1 < 128 ? t$2[r$2++] = n$1 : (n$1 < 2048 ? t$2[r$2++] = n$1 >> 6 | 192 : (n$1 < 65536 ? t$2[r$2++] = n$1 >> 12 | 224 : (t$2[r$2++] = n$1 >> 18 | 240, t$2[r$2++] = n$1 >> 12 & 63 | 128), t$2[r$2++] = n$1 >> 6 & 63 | 128), t$2[r$2++] = 63 & n$1 | 128);
						}
						return r$2;
					}(this.buf, t$1, this.pos);
					const r$1 = this.pos - e$1;
					r$1 >= 128 && ky(e$1, r$1, this), this.pos = e$1 - 1, this.writeVarint(r$1), this.pos += r$1;
				}
				writeFloat(t$1) {
					this.realloc(4), this.dataView.setFloat32(this.pos, t$1, !0), this.pos += 4;
				}
				writeDouble(t$1) {
					this.realloc(8), this.dataView.setFloat64(this.pos, t$1, !0), this.pos += 8;
				}
				writeBytes(t$1) {
					const e$1 = t$1.length;
					this.writeVarint(e$1), this.realloc(e$1);
					for (let r$1 = 0; r$1 < e$1; r$1++) this.buf[this.pos++] = t$1[r$1];
				}
				writeRawMessage(t$1, e$1) {
					this.pos++;
					const r$1 = this.pos;
					t$1(e$1, this);
					const n$1 = this.pos - r$1;
					n$1 >= 128 && ky(r$1, n$1, this), this.pos = r$1 - 1, this.writeVarint(n$1), this.pos += n$1;
				}
				writeMessage(t$1, e$1, r$1) {
					this.writeTag(t$1, 2), this.writeRawMessage(e$1, r$1);
				}
				writePackedVarint(t$1, e$1) {
					e$1.length && this.writeMessage(t$1, By, e$1);
				}
				writePackedSVarint(t$1, e$1) {
					e$1.length && this.writeMessage(t$1, zy, e$1);
				}
				writePackedBoolean(t$1, e$1) {
					e$1.length && this.writeMessage(t$1, Vy, e$1);
				}
				writePackedFloat(t$1, e$1) {
					e$1.length && this.writeMessage(t$1, Ty, e$1);
				}
				writePackedDouble(t$1, e$1) {
					e$1.length && this.writeMessage(t$1, Ey, e$1);
				}
				writePackedFixed32(t$1, e$1) {
					e$1.length && this.writeMessage(t$1, Fy, e$1);
				}
				writePackedSFixed32(t$1, e$1) {
					e$1.length && this.writeMessage(t$1, Cy, e$1);
				}
				writePackedFixed64(t$1, e$1) {
					e$1.length && this.writeMessage(t$1, Dy, e$1);
				}
				writePackedSFixed64(t$1, e$1) {
					e$1.length && this.writeMessage(t$1, Ry, e$1);
				}
				writeBytesField(t$1, e$1) {
					this.writeTag(t$1, 2), this.writeBytes(e$1);
				}
				writeFixed32Field(t$1, e$1) {
					this.writeTag(t$1, 5), this.writeFixed32(e$1);
				}
				writeSFixed32Field(t$1, e$1) {
					this.writeTag(t$1, 5), this.writeSFixed32(e$1);
				}
				writeFixed64Field(t$1, e$1) {
					this.writeTag(t$1, 1), this.writeFixed64(e$1);
				}
				writeSFixed64Field(t$1, e$1) {
					this.writeTag(t$1, 1), this.writeSFixed64(e$1);
				}
				writeVarintField(t$1, e$1) {
					this.writeTag(t$1, 0), this.writeVarint(e$1);
				}
				writeSVarintField(t$1, e$1) {
					this.writeTag(t$1, 0), this.writeSVarint(e$1);
				}
				writeStringField(t$1, e$1) {
					this.writeTag(t$1, 2), this.writeString(e$1);
				}
				writeFloatField(t$1, e$1) {
					this.writeTag(t$1, 5), this.writeFloat(e$1);
				}
				writeDoubleField(t$1, e$1) {
					this.writeTag(t$1, 1), this.writeDouble(e$1);
				}
				writeBooleanField(t$1, e$1) {
					this.writeVarintField(t$1, +e$1);
				}
			};
			function Py(t$1, e$1, r$1) {
				return r$1 ? 4294967296 * e$1 + (t$1 >>> 0) : 4294967296 * (e$1 >>> 0) + (t$1 >>> 0);
			}
			function ky(t$1, e$1, r$1) {
				const n$1 = e$1 <= 16383 ? 1 : e$1 <= 2097151 ? 2 : e$1 <= 268435455 ? 3 : Math.floor(Math.log(e$1) / (7 * Math.LN2));
				r$1.realloc(n$1);
				for (let e$2 = r$1.pos - 1; e$2 >= t$1; e$2--) r$1.buf[e$2 + n$1] = r$1.buf[e$2];
			}
			function By(t$1, e$1) {
				for (let r$1 = 0; r$1 < t$1.length; r$1++) e$1.writeVarint(t$1[r$1]);
			}
			function zy(t$1, e$1) {
				for (let r$1 = 0; r$1 < t$1.length; r$1++) e$1.writeSVarint(t$1[r$1]);
			}
			function Ty(t$1, e$1) {
				for (let r$1 = 0; r$1 < t$1.length; r$1++) e$1.writeFloat(t$1[r$1]);
			}
			function Ey(t$1, e$1) {
				for (let r$1 = 0; r$1 < t$1.length; r$1++) e$1.writeDouble(t$1[r$1]);
			}
			function Vy(t$1, e$1) {
				for (let r$1 = 0; r$1 < t$1.length; r$1++) e$1.writeBoolean(t$1[r$1]);
			}
			function Fy(t$1, e$1) {
				for (let r$1 = 0; r$1 < t$1.length; r$1++) e$1.writeFixed32(t$1[r$1]);
			}
			function Cy(t$1, e$1) {
				for (let r$1 = 0; r$1 < t$1.length; r$1++) e$1.writeSFixed32(t$1[r$1]);
			}
			function Dy(t$1, e$1) {
				for (let r$1 = 0; r$1 < t$1.length; r$1++) e$1.writeFixed64(t$1[r$1]);
			}
			function Ry(t$1, e$1) {
				for (let r$1 = 0; r$1 < t$1.length; r$1++) e$1.writeSFixed64(t$1[r$1]);
			}
			const Ly = 3;
			function Oy(t$1, e$1, r$1) {
				e$1.glyphs = [], 1 === t$1 && r$1.readMessage(Uy, e$1);
			}
			function Uy(t$1, e$1, r$1) {
				if (3 === t$1) {
					const { id: t$2, bitmap: n$1, width: i$1, height: s$1, left: o$1, top: a$1, advance: l$1 } = r$1.readMessage(Ny, {});
					e$1.glyphs.push({
						id: t$2,
						bitmap: new _h({
							width: i$1 + 2 * Ly,
							height: s$1 + 2 * Ly
						}, n$1),
						metrics: {
							width: i$1,
							height: s$1,
							left: o$1,
							top: a$1,
							advance: l$1
						}
					});
				} else 4 === t$1 ? e$1.ascender = r$1.readSVarint() : 5 === t$1 && (e$1.descender = r$1.readSVarint());
			}
			function Ny(t$1, e$1, r$1) {
				1 === t$1 ? e$1.id = r$1.readVarint() : 2 === t$1 ? e$1.bitmap = r$1.readBytes() : 3 === t$1 ? e$1.width = r$1.readVarint() : 4 === t$1 ? e$1.height = r$1.readVarint() : 5 === t$1 ? e$1.left = r$1.readSVarint() : 6 === t$1 ? e$1.top = r$1.readSVarint() : 7 === t$1 && (e$1.advance = r$1.readVarint());
			}
			const jy = Ly, $y = {
				horizontal: 1,
				vertical: 2,
				horizontalOnly: 3
			};
			class Gy {
				constructor() {
					this.scale = 1, this.fontStack = "", this.image = null;
				}
				static forText(t$1, e$1) {
					const r$1 = new Gy();
					return r$1.scale = t$1 || 1, r$1.fontStack = e$1, r$1;
				}
				static forImage(t$1) {
					const e$1 = new Gy();
					return e$1.image = t$1, e$1;
				}
			}
			class qy {
				constructor() {
					this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null;
				}
				static fromFeature(t$1, e$1, r$1) {
					const n$1 = new qy();
					for (let i$1 = 0; i$1 < t$1.sections.length; i$1++) {
						const s$1 = t$1.sections[i$1];
						s$1.image ? n$1.addImageSection(s$1, r$1) : n$1.addTextSection(s$1, e$1);
					}
					return n$1;
				}
				length() {
					return this.text.length;
				}
				getSection(t$1) {
					return this.sections[this.sectionIndex[t$1]];
				}
				getSections() {
					return this.sections;
				}
				getSectionIndex(t$1) {
					return this.sectionIndex[t$1];
				}
				getCodePoint(t$1) {
					return this.text.codePointAt(t$1);
				}
				verticalizePunctuation(t$1) {
					this.text = function(t$2, e$1) {
						let r$1 = "";
						for (let n$1 = 0; n$1 < t$2.length; n$1++) {
							const i$1 = t$2.charCodeAt(n$1 + 1) || null, s$1 = t$2.charCodeAt(n$1 - 1) || null;
							r$1 += !e$1 && (i$1 && lo(i$1) && !by[t$2[n$1 + 1]] || s$1 && lo(s$1) && !by[t$2[n$1 - 1]]) || !by[t$2[n$1]] ? t$2[n$1] : by[t$2[n$1]];
						}
						return r$1;
					}(this.text, t$1);
				}
				trim() {
					let t$1 = 0;
					for (let e$2 = 0; e$2 < this.text.length && Xy[this.text.charCodeAt(e$2)]; e$2++) t$1++;
					let e$1 = this.text.length;
					for (let r$1 = this.text.length - 1; r$1 >= 0 && r$1 >= t$1 && Xy[this.text.charCodeAt(r$1)]; r$1--) e$1--;
					this.text = this.text.substring(t$1, e$1), this.sectionIndex = this.sectionIndex.slice(t$1, e$1);
				}
				substring(t$1, e$1) {
					const r$1 = new qy();
					return r$1.text = this.text.substring(t$1, e$1), r$1.sectionIndex = this.sectionIndex.slice(t$1, e$1), r$1.sections = this.sections, r$1;
				}
				toString() {
					return this.text;
				}
				getMaxScale() {
					return this.sectionIndex.reduce(((t$1, e$1) => Math.max(t$1, this.sections[e$1].scale)), 0);
				}
				addTextSection(t$1, e$1) {
					this.text += t$1.text, this.sections.push(Gy.forText(t$1.scale, t$1.fontStack || e$1));
					const r$1 = this.sections.length - 1;
					for (let e$2 = 0; e$2 < t$1.text.length; ++e$2) this.sectionIndex.push(r$1);
				}
				addImageSection(t$1, e$1) {
					const r$1 = t$1.image ? t$1.image.getPrimary() : null;
					if (!r$1) return void Xt("Can't add FormattedSection with an empty image.");
					r$1.scaleSelf(e$1);
					const n$1 = this.getNextImageSectionCharCode();
					n$1 ? (this.text += String.fromCodePoint(n$1), this.sections.push(Gy.forImage(r$1)), this.sectionIndex.push(this.sections.length - 1)) : Xt("Reached maximum number of images 6401");
				}
				getNextImageSectionCharCode() {
					return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID);
				}
			}
			function Hy(t$1, e$1, r$1, n$1, i$1, s$1, o$1, a$1, l$1, u$1, c$1, h$1, p$1, d$1, f$1, m$1 = 1) {
				const y$1 = qy.fromFeature(t$1, i$1, m$1);
				h$1 === $y.vertical && y$1.verticalizePunctuation(p$1);
				let g$1 = [];
				const x$1 = function(t$2, e$2, r$2, n$2, i$2, s$2) {
					if (!t$2) return [];
					const o$2 = [], a$2 = function(t$3, e$3, r$3, n$3, i$3, s$3) {
						let o$3 = 0;
						for (let r$4 = 0; r$4 < t$3.length(); r$4++) {
							const a$3 = t$3.getSection(r$4);
							o$3 += Wy(t$3.getCodePoint(r$4), a$3, n$3, i$3, e$3, s$3);
						}
						return o$3 / Math.max(1, Math.ceil(o$3 / r$3));
					}(t$2, e$2, r$2, n$2, i$2, s$2), l$2 = t$2.text.indexOf("") >= 0;
					let u$2 = 0;
					for (let r$3 = 0; r$3 < t$2.length(); r$3++) {
						const h$2 = t$2.getSection(r$3), p$2 = t$2.getCodePoint(r$3);
						if (Xy[p$2] || (u$2 += Wy(p$2, h$2, n$2, i$2, e$2, s$2)), r$3 < t$2.length() - 1) {
							const e$3 = !((c$2 = p$2) < 11904 || !(no["Bopomofo Extended"](c$2) || no.Bopomofo(c$2) || no["CJK Compatibility Forms"](c$2) || no["CJK Compatibility Ideographs"](c$2) || no["CJK Compatibility"](c$2) || no["CJK Radicals Supplement"](c$2) || no["CJK Strokes"](c$2) || no["CJK Symbols and Punctuation"](c$2) || no["CJK Unified Ideographs Extension A"](c$2) || no["CJK Unified Ideographs"](c$2) || no["Enclosed CJK Letters and Months"](c$2) || no["Halfwidth and Fullwidth Forms"](c$2) || no.Hiragana(c$2) || no["Ideographic Description Characters"](c$2) || no["Kangxi Radicals"](c$2) || no["Katakana Phonetic Extensions"](c$2) || no.Katakana(c$2) || no["Vertical Forms"](c$2) || no["Yi Radicals"](c$2) || no["Yi Syllables"](c$2)));
							(Zy[p$2] || e$3 || h$2.image) && o$2.push(Jy(r$3 + 1, u$2, a$2, o$2, Ky(p$2, t$2.getCodePoint(r$3 + 1), e$3 && l$2), !1));
						}
					}
					var c$2;
					return Qy(Jy(t$2.length(), u$2, a$2, o$2, 0, !0));
				}(y$1, u$1, s$1, e$1, n$1, d$1), { processBidirectionalText: v$1, processStyledBidirectionalText: b$1 } = Ao;
				if (v$1 && 1 === y$1.sections.length) {
					const t$2 = v$1(y$1.toString(), x$1);
					for (const e$2 of t$2) {
						const t$3 = new qy();
						t$3.text = e$2, t$3.sections = y$1.sections;
						for (let r$2 = 0; r$2 < e$2.length; r$2++) t$3.sectionIndex.push(0);
						g$1.push(t$3);
					}
				} else if (b$1) {
					const t$2 = b$1(y$1.text, y$1.sectionIndex, x$1);
					for (const e$2 of t$2) {
						const t$3 = new qy();
						t$3.text = e$2[0], t$3.sectionIndex = e$2[1], t$3.sections = y$1.sections, g$1.push(t$3);
					}
				} else g$1 = function(t$2, e$2) {
					const r$2 = [], n$2 = t$2.text;
					let i$2 = 0;
					for (const n$3 of e$2) r$2.push(t$2.substring(i$2, n$3)), i$2 = n$3;
					return i$2 < n$2.length && r$2.push(t$2.substring(i$2, n$2.length)), r$2;
				}(y$1, x$1);
				const w$1 = [], _$1 = {
					positionedLines: w$1,
					text: y$1.toString(),
					top: c$1[1],
					bottom: c$1[1],
					left: c$1[0],
					right: c$1[0],
					writingMode: h$1,
					iconsInText: !1,
					verticalizable: !1,
					hasBaseline: !1
				};
				if (function(t$2, e$2, r$2, n$2, i$2, s$2, o$2, a$2, l$2, u$2, c$2, h$2) {
					let p$2 = 0, d$2 = 0, f$2 = 0;
					const m$2 = "right" === a$2 ? 1 : "left" === a$2 ? 0 : .5;
					let y$2 = !1;
					for (const t$3 of i$2) {
						const r$3 = t$3.getSections();
						for (const t$4 of r$3) {
							if (t$4.image) continue;
							const r$4 = e$2[t$4.fontStack];
							if (r$4 && (y$2 = void 0 !== r$4.ascender && void 0 !== r$4.descender, !y$2)) break;
						}
						if (!y$2) break;
					}
					let g$2 = 0;
					for (const o$3 of i$2) {
						o$3.trim();
						const i$3 = o$3.getMaxScale(), a$3 = (i$3 - 1) * xy, v$3 = {
							positionedGlyphs: [],
							lineOffset: 0
						};
						t$2.positionedLines[g$2] = v$3;
						const b$3 = v$3.positionedGlyphs;
						let w$3 = 0;
						if (!o$3.length()) {
							d$2 += s$2, ++g$2;
							continue;
						}
						let _$2 = 0, A$1 = 0;
						for (let s$3 = 0; s$3 < o$3.length(); s$3++) {
							const a$4 = o$3.getSection(s$3), f$3 = o$3.getSectionIndex(s$3), m$3 = o$3.getCodePoint(s$3);
							let g$3 = a$4.scale, v$4 = null, I$2 = null, M$1 = null, S$1 = xy, P$1 = 0, k$1 = l$2;
							k$1 === $y.vertical && (12312 === (x$2 = m$3) || 12313 === x$2 || 12316 === x$2 || 12540 === x$2 || 12448 === x$2) && (k$1 = $y.horizontal);
							const B$1 = !(k$1 === $y.horizontal || !c$2 && !ao(m$3) || c$2 && (Xy[m$3] || uo(m$3)));
							if (a$4.image) {
								const e$3 = n$2.get(a$4.image.toString());
								if (!e$3) continue;
								M$1 = a$4.image, t$2.iconsInText = t$2.iconsInText || !0, I$2 = e$3.paddedRect;
								const r$3 = e$3.displaySize;
								g$3 = g$3 * xy / h$2, v$4 = {
									width: r$3[0],
									height: r$3[1],
									left: 0,
									top: -jy,
									advance: B$1 ? r$3[1] : r$3[0],
									localGlyph: !1
								}, P$1 = y$2 ? -v$4.height * g$3 : i$3 * xy - 17 - r$3[1] * g$3, S$1 = v$4.advance;
								const s$4 = (B$1 ? r$3[0] : r$3[1]) * g$3 - xy * i$3;
								s$4 > 0 && s$4 > w$3 && (w$3 = s$4);
							} else {
								const t$3 = r$2[a$4.fontStack];
								if (!t$3) continue;
								t$3[m$3] && (I$2 = t$3[m$3]);
								const n$3 = e$2[a$4.fontStack];
								if (!n$3) continue;
								const s$4 = n$3.glyphs[m$3];
								if (!s$4) continue;
								if (v$4 = s$4.metrics, S$1 = 8203 !== m$3 ? xy : 0, y$2) {
									const t$4 = void 0 !== n$3.ascender ? Math.abs(n$3.ascender) : 0, e$3 = void 0 !== n$3.descender ? Math.abs(n$3.descender) : 0, r$3 = (t$4 + e$3) * g$3;
									_$2 < r$3 && (_$2 = r$3, A$1 = (t$4 - e$3) / 2 * g$3), P$1 = -t$4 * g$3;
								} else P$1 = (i$3 - g$3) * xy - 17;
							}
							B$1 ? (t$2.verticalizable = !0, b$3.push({
								glyph: m$3,
								image: M$1,
								x: p$2,
								y: d$2 + P$1,
								vertical: B$1,
								scale: g$3,
								localGlyph: v$4.localGlyph,
								fontStack: a$4.fontStack,
								sectionIndex: f$3,
								metrics: v$4,
								rect: I$2
							}), p$2 += S$1 * g$3 + u$2) : (b$3.push({
								glyph: m$3,
								image: M$1,
								x: p$2,
								y: d$2 + P$1,
								vertical: B$1,
								scale: g$3,
								localGlyph: v$4.localGlyph,
								fontStack: a$4.fontStack,
								sectionIndex: f$3,
								metrics: v$4,
								rect: I$2
							}), p$2 += v$4.advance * g$3 + u$2);
						}
						0 !== b$3.length && (f$2 = Math.max(p$2 - u$2, f$2), y$2 ? eg(b$3, m$2, w$3, A$1, s$2 * i$3 / 2) : eg(b$3, m$2, w$3, 0, s$2 / 2)), p$2 = 0;
						const I$1 = s$2 * i$3 + w$3;
						v$3.lineOffset = Math.max(w$3, a$3), d$2 += I$1, ++g$2;
					}
					var x$2;
					const v$2 = d$2, { horizontalAlign: b$2, verticalAlign: w$2 } = tg(o$2);
					(function(t$3, e$3, r$3, n$3, i$3, s$3) {
						const o$3 = (e$3 - r$3) * i$3, a$3 = -s$3 * n$3;
						for (const e$4 of t$3) for (const t$4 of e$4.positionedGlyphs) t$4.x += o$3, t$4.y += a$3;
					})(t$2.positionedLines, m$2, b$2, w$2, f$2, v$2), t$2.top += -w$2 * v$2, t$2.bottom = t$2.top + v$2, t$2.left += -b$2 * f$2, t$2.right = t$2.left + f$2, t$2.hasBaseline = y$2;
				}(_$1, e$1, r$1, n$1, g$1, o$1, a$1, l$1, h$1, u$1, p$1, f$1), !function(t$2) {
					for (const e$2 of t$2) if (0 !== e$2.positionedGlyphs.length) return !1;
					return !0;
				}(w$1)) return _$1;
			}
			const Xy = {
				9: !0,
				10: !0,
				11: !0,
				12: !0,
				13: !0,
				32: !0
			}, Zy = {
				10: !0,
				32: !0,
				38: !0,
				40: !0,
				41: !0,
				43: !0,
				45: !0,
				47: !0,
				173: !0,
				183: !0,
				8203: !0,
				8208: !0,
				8211: !0,
				8231: !0
			};
			function Wy(t$1, e$1, r$1, n$1, i$1, s$1) {
				if (e$1.image) {
					const t$2 = n$1.get(e$1.image.toString());
					return t$2 ? t$2.displaySize[0] * e$1.scale * xy / s$1 + i$1 : 0;
				}
				{
					const n$2 = r$1[e$1.fontStack], s$2 = n$2 && n$2.glyphs[t$1];
					return s$2 ? s$2.metrics.advance * e$1.scale + i$1 : 0;
				}
			}
			function Yy(t$1, e$1, r$1, n$1) {
				const i$1 = Math.pow(t$1 - e$1, 2);
				return n$1 ? t$1 < e$1 ? i$1 / 2 : 2 * i$1 : i$1 + Math.abs(r$1) * r$1;
			}
			function Ky(t$1, e$1, r$1) {
				let n$1 = 0;
				return 10 === t$1 && (n$1 -= 1e4), r$1 && (n$1 += 150), 40 !== t$1 && 65288 !== t$1 || (n$1 += 50), 41 !== e$1 && 65289 !== e$1 || (n$1 += 50), n$1;
			}
			function Jy(t$1, e$1, r$1, n$1, i$1, s$1) {
				let o$1 = null, a$1 = Yy(e$1, r$1, i$1, s$1);
				for (const t$2 of n$1) {
					const n$2 = Yy(e$1 - t$2.x, r$1, i$1, s$1) + t$2.badness;
					n$2 <= a$1 && (o$1 = t$2, a$1 = n$2);
				}
				return {
					index: t$1,
					x: e$1,
					priorBreak: o$1,
					badness: a$1
				};
			}
			function Qy(t$1) {
				return t$1 ? Qy(t$1.priorBreak).concat(t$1.index) : [];
			}
			function tg(t$1) {
				let e$1 = .5, r$1 = .5;
				switch (t$1) {
					case "right":
					case "top-right":
					case "bottom-right":
						e$1 = 1;
						break;
					case "left":
					case "top-left":
					case "bottom-left": e$1 = 0;
				}
				switch (t$1) {
					case "bottom":
					case "bottom-right":
					case "bottom-left":
						r$1 = 1;
						break;
					case "top":
					case "top-right":
					case "top-left": r$1 = 0;
				}
				return {
					horizontalAlign: e$1,
					verticalAlign: r$1
				};
			}
			function eg(t$1, e$1, r$1, n$1, i$1) {
				if (!(e$1 || r$1 || n$1 || i$1)) return;
				const s$1 = t$1.length - 1, o$1 = t$1[s$1], a$1 = (o$1.x + o$1.metrics.advance * o$1.scale) * e$1;
				for (let e$2 = 0; e$2 <= s$1; e$2++) t$1[e$2].x -= a$1, t$1[e$2].y += r$1 + n$1 + i$1;
			}
			function rg(t$1) {
				return void 0 !== t$1.imagePrimary && void 0 !== t$1.top && void 0 !== t$1.bottom && void 0 !== t$1.left && void 0 !== t$1.right;
			}
			function ng(t$1, e$1, r$1, n$1) {
				const { horizontalAlign: i$1, verticalAlign: s$1 } = tg(n$1), o$1 = r$1[0] - t$1.displaySize[0] * i$1, a$1 = r$1[1] - t$1.displaySize[1] * s$1;
				return {
					imagePrimary: t$1,
					imageSecondary: e$1,
					top: a$1,
					bottom: a$1 + t$1.displaySize[1],
					left: o$1,
					right: o$1 + t$1.displaySize[0]
				};
			}
			function ig(t$1, e$1, r$1, n$1, i$1, s$1) {
				const o$1 = t$1.imagePrimary;
				let a$1;
				if (o$1.content) {
					const t$2 = o$1.content, e$2 = o$1.pixelRatio || 1;
					a$1 = [
						t$2[0] / e$2,
						t$2[1] / e$2,
						o$1.displaySize[0] - t$2[2] / e$2,
						o$1.displaySize[1] - t$2[3] / e$2
					];
				}
				const l$1 = e$1.left * s$1, u$1 = e$1.right * s$1;
				let c$1, h$1, p$1, d$1;
				"width" === r$1 || "both" === r$1 ? (d$1 = i$1[0] + l$1 - n$1[3], h$1 = i$1[0] + u$1 + n$1[1]) : (d$1 = i$1[0] + (l$1 + u$1 - o$1.displaySize[0]) / 2, h$1 = d$1 + o$1.displaySize[0]);
				const f$1 = e$1.top * s$1, m$1 = e$1.bottom * s$1;
				return "height" === r$1 || "both" === r$1 ? (c$1 = i$1[1] + f$1 - n$1[0], p$1 = i$1[1] + m$1 + n$1[2]) : (c$1 = i$1[1] + (f$1 + m$1 - o$1.displaySize[1]) / 2, p$1 = c$1 + o$1.displaySize[1]), {
					imagePrimary: o$1,
					imageSecondary: void 0,
					top: c$1,
					right: h$1,
					bottom: p$1,
					left: d$1,
					collisionPadding: a$1
				};
			}
			function sg(t$1) {
				return !t$1.imagePrimary.stretchX;
			}
			function og(t$1) {
				return !t$1.imagePrimary.stretchY;
			}
			function ag(t$1) {
				return {
					width: t$1.right - t$1.left,
					height: t$1.bottom - t$1.top
				};
			}
			const lg = 128;
			function ug(t$1, e$1, r$1) {
				const { expression: n$1 } = e$1;
				if ("constant" === n$1.kind) return {
					kind: "constant",
					layoutSize: n$1.evaluate(new Io(t$1 + 1, { worldview: r$1 }))
				};
				if ("source" === n$1.kind) return { kind: "source" };
				{
					const { zoomStops: e$2, interpolationType: i$1 } = n$1;
					let s$1 = 0;
					for (; s$1 < e$2.length && e$2[s$1] <= t$1;) s$1++;
					s$1 = Math.max(0, s$1 - 1);
					let o$1 = s$1;
					for (; o$1 < e$2.length && e$2[o$1] < t$1 + 1;) o$1++;
					o$1 = Math.min(e$2.length - 1, o$1);
					const a$1 = e$2[s$1], l$1 = e$2[o$1];
					return "composite" === n$1.kind ? {
						kind: "composite",
						minZoom: a$1,
						maxZoom: l$1,
						interpolationType: i$1
					} : {
						kind: "camera",
						minZoom: a$1,
						maxZoom: l$1,
						minSize: n$1.evaluate(new Io(a$1, { worldview: r$1 })),
						maxSize: n$1.evaluate(new Io(l$1, { worldview: r$1 })),
						interpolationType: i$1
					};
				}
			}
			function cg(t$1, { uSize: e$1, uSizeT: r$1 }, { lowerSize: n$1, upperSize: i$1 }) {
				return "source" === t$1.kind ? n$1 / lg : "composite" === t$1.kind ? pr(n$1 / lg, i$1 / lg, r$1) : e$1;
			}
			function hg(t$1, e$1, r$1 = 1) {
				let n$1 = 0, i$1 = 0;
				if ("constant" === t$1.kind) i$1 = t$1.layoutSize * r$1;
				else if ("source" !== t$1.kind) {
					const { interpolationType: s$1, minZoom: o$1, maxZoom: a$1 } = t$1, l$1 = s$1 ? Ft(Xi.interpolationFactor(s$1, e$1, o$1, a$1), 0, 1) : 0;
					"camera" === t$1.kind ? i$1 = pr(t$1.minSize, t$1.maxSize, l$1) * r$1 : n$1 = l$1 * r$1;
				}
				return {
					uSizeT: n$1,
					uSize: i$1
				};
			}
			class pg extends It {
				constructor(t$1, e$1, r$1, n$1, i$1) {
					super(t$1, e$1), this.angle = n$1, this.z = r$1, void 0 !== i$1 && (this.segment = i$1);
				}
				clone() {
					return new pg(this.x, this.y, this.z, this.angle, this.segment);
				}
			}
			function dg(t$1, e$1, r$1, n$1, i$1) {
				if (void 0 === e$1.segment) return !0;
				let s$1 = e$1, o$1 = e$1.segment + 1, a$1 = 0;
				for (; a$1 > -r$1 / 2;) {
					if (o$1--, o$1 < 0) return !1;
					a$1 -= t$1[o$1].dist(s$1), s$1 = t$1[o$1];
				}
				a$1 += t$1[o$1].dist(t$1[o$1 + 1]), o$1++;
				const l$1 = [];
				let u$1 = 0;
				for (; a$1 < r$1 / 2;) {
					const e$2 = t$1[o$1], r$2 = t$1[o$1 + 1];
					if (!r$2) return !1;
					let s$2 = t$1[o$1 - 1].angleTo(e$2) - e$2.angleTo(r$2);
					for (s$2 = Math.abs((s$2 + 3 * Math.PI) % (2 * Math.PI) - Math.PI), l$1.push({
						distance: a$1,
						angleDelta: s$2
					}), u$1 += s$2; a$1 - l$1[0].distance > n$1;) u$1 -= l$1.shift().angleDelta;
					if (u$1 > i$1) return !1;
					o$1++, a$1 += e$2.dist(r$2);
				}
				return !0;
			}
			function fg(t$1) {
				let e$1 = 0;
				for (let r$1 = 0; r$1 < t$1.length - 1; r$1++) e$1 += t$1[r$1].dist(t$1[r$1 + 1]);
				return e$1;
			}
			function mg(t$1, e$1, r$1) {
				return t$1 ? .6 * e$1 * r$1 : 0;
			}
			function yg(t$1, e$1) {
				return Math.max(t$1 ? t$1.right - t$1.left : 0, e$1 ? e$1.right - e$1.left : 0);
			}
			function gg(t$1, e$1, r$1, n$1, i$1, s$1) {
				const o$1 = mg(r$1, i$1, s$1), a$1 = yg(r$1, n$1) * s$1;
				let l$1 = 0;
				const u$1 = fg(t$1) / 2;
				for (let r$2 = 0; r$2 < t$1.length - 1; r$2++) {
					const n$2 = t$1[r$2], i$2 = t$1[r$2 + 1], s$2 = n$2.dist(i$2);
					if (l$1 + s$2 > u$1) {
						const c$1 = (u$1 - l$1) / s$2, d$1 = new pg(pr(n$2.x, i$2.x, c$1), pr(n$2.y, i$2.y, c$1), 0, i$2.angleTo(n$2), r$2);
						return !o$1 || dg(t$1, d$1, a$1, o$1, e$1) ? d$1 : void 0;
					}
					l$1 += s$2;
				}
			}
			function xg(t$1, e$1, r$1, n$1, i$1, s$1, o$1, a$1, l$1) {
				const u$1 = mg(n$1, s$1, o$1), c$1 = yg(n$1, i$1), h$1 = c$1 * o$1, p$1 = 0 === t$1[0].x || t$1[0].x === l$1 || 0 === t$1[0].y || t$1[0].y === l$1;
				return e$1 - h$1 < e$1 / 4 && (e$1 = h$1 + e$1 / 4), vg(t$1, p$1 ? e$1 / 2 * a$1 % e$1 : (c$1 / 2 + 2 * s$1) * o$1 * a$1 % e$1, e$1, u$1, r$1, h$1, p$1, !1, l$1);
			}
			function vg(t$1, e$1, r$1, n$1, i$1, s$1, o$1, a$1, l$1) {
				const u$1 = s$1 / 2, c$1 = fg(t$1);
				let h$1 = 0, p$1 = e$1 - r$1, d$1 = [];
				for (let e$2 = 0; e$2 < t$1.length - 1; e$2++) {
					const o$2 = t$1[e$2], a$2 = t$1[e$2 + 1], f$1 = o$2.dist(a$2), m$1 = a$2.angleTo(o$2);
					for (; p$1 + r$1 < h$1 + f$1;) {
						p$1 += r$1;
						const y$1 = (p$1 - h$1) / f$1, g$1 = pr(o$2.x, a$2.x, y$1), x$1 = pr(o$2.y, a$2.y, y$1);
						if (g$1 >= 0 && g$1 < l$1 && x$1 >= 0 && x$1 < l$1 && p$1 - u$1 >= 0 && p$1 + u$1 <= c$1) {
							const r$2 = new pg(g$1, x$1, 0, m$1, e$2);
							n$1 && !dg(t$1, r$2, s$1, n$1, i$1) || d$1.push(r$2);
						}
					}
					h$1 += f$1;
				}
				return a$1 || d$1.length || o$1 || (d$1 = vg(t$1, h$1 / 2, r$1, n$1, i$1, s$1, o$1, !0, l$1)), d$1;
			}
			function bg(t$1) {
				let e$1 = 0, r$1 = 0;
				for (const n$2 of t$1) e$1 += n$2.w * n$2.h, r$1 = Math.max(r$1, n$2.w);
				t$1.sort(((t$2, e$2) => e$2.h - t$2.h));
				const n$1 = [{
					x: 0,
					y: 0,
					w: Math.max(Math.ceil(Math.sqrt(e$1 / .95)), r$1),
					h: Infinity
				}];
				let i$1 = 0, s$1 = 0;
				for (const e$2 of t$1) for (let t$2 = n$1.length - 1; t$2 >= 0; t$2--) {
					const r$2 = n$1[t$2];
					if (!(e$2.w > r$2.w || e$2.h > r$2.h)) {
						if (e$2.x = r$2.x, e$2.y = r$2.y, s$1 = Math.max(s$1, e$2.y + e$2.h), i$1 = Math.max(i$1, e$2.x + e$2.w), e$2.w === r$2.w && e$2.h === r$2.h) {
							const e$3 = n$1.pop();
							e$3 && t$2 < n$1.length && (n$1[t$2] = e$3);
						} else e$2.h === r$2.h ? (r$2.x += e$2.w, r$2.w -= e$2.w) : e$2.w === r$2.w ? (r$2.y += e$2.h, r$2.h -= e$2.h) : (n$1.push({
							x: r$2.x + e$2.w,
							y: r$2.y,
							w: r$2.w - e$2.w,
							h: e$2.h
						}), r$2.y += e$2.h, r$2.h -= e$2.h);
						break;
					}
				}
				return {
					w: i$1,
					h: s$1,
					fill: e$1 / (i$1 * s$1) || 0
				};
			}
			Qs(pg, "Anchor");
			const wg = 1;
			class _g {
				static getImagePositionScale(t$1, e$1, r$1) {
					if (e$1 && t$1) {
						const { sx: e$2, sy: r$2 } = t$1;
						return {
							x: e$2,
							y: r$2
						};
					}
					return {
						x: r$1,
						y: r$1
					};
				}
				constructor(t$1, e$1, r$1, n$1) {
					this.paddedRect = t$1;
					const { pixelRatio: i$1, version: s$1, stretchX: o$1, stretchY: a$1, content: l$1, sdf: u$1, usvg: c$1 } = e$1;
					this.pixelRatio = i$1, this.stretchX = o$1, this.stretchY = a$1, this.content = l$1, this.version = s$1, this.padding = r$1, this.sdf = u$1, this.usvg = c$1, this.scale = _g.getImagePositionScale(n$1, c$1, i$1);
				}
				get tl() {
					return [this.paddedRect.x + this.padding, this.paddedRect.y + this.padding];
				}
				get br() {
					return [this.paddedRect.x + this.paddedRect.w - this.padding, this.paddedRect.y + this.paddedRect.h - this.padding];
				}
				get displaySize() {
					return [(this.paddedRect.w - 2 * this.padding) / this.scale.x, (this.paddedRect.h - 2 * this.padding) / this.scale.y];
				}
			}
			function Ag(t$1, e$1, r$1) {
				const n$1 = Rr.parse(t$1), i$1 = function(t$2, e$2, r$2 = [1, 1]) {
					return {
						x: 0,
						y: 0,
						w: (t$2.data ? t$2.data.width : t$2.width * r$2[0]) + 2 * e$2,
						h: (t$2.data ? t$2.data.height : t$2.height * r$2[1]) + 2 * e$2
					};
				}(e$1, r$1, [n$1.sx, n$1.sy]);
				return {
					bin: i$1,
					imagePosition: new _g(i$1, e$1, r$1, n$1),
					imageVariant: n$1
				};
			}
			class Ig {
				constructor(t$1, e$1, r$1) {
					const n$1 = /* @__PURE__ */ new Map(), i$1 = /* @__PURE__ */ new Map();
					this.haveRenderCallbacks = [];
					const s$1 = [];
					this.addImages(t$1, n$1, wg, s$1), this.addImages(e$1, i$1, 2, s$1);
					const { w: o$1, h: a$1 } = bg(s$1), l$1 = new Ah({
						width: o$1 || 1,
						height: a$1 || 1
					});
					for (const [e$2, r$2] of t$1.entries()) {
						const t$2 = n$1.get(e$2).paddedRect;
						Ah.copy(r$2.data, l$1, {
							x: 0,
							y: 0
						}, {
							x: t$2.x + wg,
							y: t$2.y + wg
						}, r$2.data, null, r$2.sdf);
					}
					for (const [t$2, n$2] of e$1.entries()) {
						const e$2 = i$1.get(t$2), s$2 = e$2.paddedRect;
						let o$2 = e$2.padding;
						const a$2 = s$2.x + o$2, u$1 = s$2.y + o$2, c$1 = n$2.data.width, h$1 = n$2.data.height;
						o$2 = o$2 > 1 ? o$2 - 1 : o$2, Ah.copy(n$2.data, l$1, {
							x: 0,
							y: 0
						}, {
							x: a$2,
							y: u$1
						}, n$2.data, r$1), Ah.copy(n$2.data, l$1, {
							x: 0,
							y: h$1 - o$2
						}, {
							x: a$2,
							y: u$1 - o$2
						}, {
							width: c$1,
							height: o$2
						}, r$1), Ah.copy(n$2.data, l$1, {
							x: 0,
							y: 0
						}, {
							x: a$2,
							y: u$1 + h$1
						}, {
							width: c$1,
							height: o$2
						}, r$1), Ah.copy(n$2.data, l$1, {
							x: c$1 - o$2,
							y: 0
						}, {
							x: a$2 - o$2,
							y: u$1
						}, {
							width: o$2,
							height: h$1
						}, r$1), Ah.copy(n$2.data, l$1, {
							x: 0,
							y: 0
						}, {
							x: a$2 + c$1,
							y: u$1
						}, {
							width: o$2,
							height: h$1
						}, r$1), Ah.copy(n$2.data, l$1, {
							x: c$1 - o$2,
							y: h$1 - o$2
						}, {
							x: a$2 - o$2,
							y: u$1 - o$2
						}, {
							width: o$2,
							height: o$2
						}, r$1), Ah.copy(n$2.data, l$1, {
							x: 0,
							y: h$1 - o$2
						}, {
							x: a$2 + c$1,
							y: u$1 - o$2
						}, {
							width: o$2,
							height: o$2
						}, r$1), Ah.copy(n$2.data, l$1, {
							x: 0,
							y: 0
						}, {
							x: a$2 + c$1,
							y: u$1 + h$1
						}, {
							width: o$2,
							height: o$2
						}, r$1), Ah.copy(n$2.data, l$1, {
							x: c$1 - o$2,
							y: 0
						}, {
							x: a$2 - o$2,
							y: u$1 + h$1
						}, {
							width: o$2,
							height: o$2
						}, r$1);
					}
					this.lut = r$1, this.image = l$1, this.iconPositions = n$1, this.patternPositions = i$1;
				}
				addImages(t$1, e$1, r$1, n$1) {
					for (const [i$1, s$1] of t$1.entries()) {
						const { bin: t$2, imagePosition: o$1, imageVariant: a$1 } = Ag(i$1, s$1, r$1);
						e$1.set(i$1, o$1), n$1.push(t$2), s$1.hasRenderCallback && this.haveRenderCallbacks.push(a$1.id);
					}
				}
				patchUpdatedImages(t$1, e$1, r$1) {
					this.haveRenderCallbacks = this.haveRenderCallbacks.filter(((e$2) => t$1.hasImage(e$2, r$1))), t$1.dispatchRenderCallbacks(this.haveRenderCallbacks, r$1);
					for (const n$1 of t$1.getUpdatedImages(r$1)) {
						for (const i$1 of this.iconPositions.keys()) {
							const s$1 = Rr.parse(i$1);
							if (ir.isEqual(s$1.id, n$1)) {
								const s$2 = t$1.getImage(n$1, r$1);
								this.patchUpdatedImage(this.iconPositions.get(i$1), s$2, e$1, null);
							}
						}
						for (const i$1 of this.patternPositions.keys()) {
							const s$1 = Rr.parse(i$1);
							if (ir.isEqual(s$1.id, n$1)) {
								const s$2 = t$1.getImage(n$1, r$1);
								this.patchUpdatedImage(this.patternPositions.get(i$1), s$2, e$1, this.lut);
							}
						}
					}
				}
				patchUpdatedImage(t$1, e$1, r$1, n$1 = null) {
					if (!t$1 || !e$1) return;
					if (t$1.version === e$1.version) return;
					t$1.version = e$1.version;
					const [i$1, s$1] = t$1.tl, o$1 = t$1.sdf;
					if (this.lut || o$1) {
						const t$2 = {
							width: e$1.data.width,
							height: e$1.data.height
						}, a$1 = new Ah(t$2);
						Ah.copy(e$1.data, a$1, {
							x: 0,
							y: 0
						}, {
							x: 0,
							y: 0
						}, t$2, n$1, o$1), r$1.update(a$1, { position: {
							x: i$1,
							y: s$1
						} });
					} else r$1.update(e$1.data, { position: {
						x: i$1,
						y: s$1
					} });
				}
			}
			Qs(_g, "ImagePosition"), Qs(Ig, "ImageAtlas");
			const Mg = 0x56bc75e2d63100000;
			function Sg(t$1, e$1, r$1, n$1, i$1, s$1, o$1, a$1, l$1) {
				for (let u$1 = e$1; u$1 < e$1 + n$1; u$1++) Pg(t$1, r$1 * s$1 + u$1, s$1, i$1, o$1, a$1, l$1);
				for (let u$1 = r$1; u$1 < r$1 + i$1; u$1++) Pg(t$1, u$1 * s$1 + e$1, 1, n$1, o$1, a$1, l$1);
			}
			function Pg(t$1, e$1, r$1, n$1, i$1, s$1, o$1) {
				s$1[0] = 0, o$1[0] = -Mg, o$1[1] = Mg, i$1[0] = t$1[e$1];
				for (let a$1 = 1, l$1 = 0, u$1 = 0; a$1 < n$1; a$1++) {
					i$1[a$1] = t$1[e$1 + a$1 * r$1];
					const n$2 = a$1 * a$1;
					do {
						const t$2 = s$1[l$1];
						u$1 = (i$1[a$1] - i$1[t$2] + n$2 - t$2 * t$2) / (a$1 - t$2) / 2;
					} while (u$1 <= o$1[l$1] && --l$1 > -1);
					l$1++, s$1[l$1] = a$1, o$1[l$1] = u$1, o$1[l$1 + 1] = Mg;
				}
				for (let a$1 = 0, l$1 = 0; a$1 < n$1; a$1++) {
					for (; o$1[l$1 + 1] < a$1;) l$1++;
					const n$2 = s$1[l$1], u$1 = a$1 - n$2;
					t$1[e$1 + a$1 * r$1] = i$1[n$2] + u$1 * u$1;
				}
			}
			const kg = 2, Bg = {
				none: 0,
				ideographs: 1,
				all: 2
			};
			class zg {
				constructor(t$1, e$1, r$1) {
					this.requestManager = t$1, this.localGlyphMode = e$1, this.localFontFamily = r$1, this.url = "", this.entries = {}, this.localGlyphs = {
						200: {},
						400: {},
						500: {},
						900: {}
					};
				}
				setURL(t$1) {
					this.url = t$1;
				}
				getGlyphs(t$1, e$1) {
					const r$1 = [], n$1 = this.url || oe.GLYPHS_URL;
					for (const e$2 in t$1) for (const n$2 of t$1[e$2]) r$1.push({
						stack: e$2,
						id: n$2
					});
					Rt(r$1, (({ stack: t$2, id: e$2 }, r$2) => {
						let i$1 = this.entries[t$2];
						i$1 || (i$1 = this.entries[t$2] = {
							glyphs: {},
							requests: {},
							ranges: {},
							ascender: void 0,
							descender: void 0
						});
						let s$1 = i$1.glyphs[e$2];
						if (void 0 !== s$1) return void r$2(null, {
							stack: t$2,
							id: e$2,
							glyph: s$1
						});
						if (s$1 = this._tinySDF(i$1, t$2, e$2), s$1) return i$1.glyphs[e$2] = s$1, void r$2(null, {
							stack: t$2,
							id: e$2,
							glyph: s$1
						});
						const o$1 = Math.floor(e$2 / 256);
						if (256 * o$1 > 65535) return Xt("glyphs > 65535 not supported"), void r$2(null, {
							stack: t$2,
							id: e$2,
							glyph: s$1
						});
						if (i$1.ranges[o$1]) return void r$2(null, {
							stack: t$2,
							id: e$2,
							glyph: s$1
						});
						let a$1 = i$1.requests[o$1];
						a$1 || (a$1 = i$1.requests[o$1] = [], zg.loadGlyphRange(t$2, o$1, n$1, this.requestManager, ((t$3, e$3) => {
							if (e$3) {
								i$1.ascender = e$3.ascender, i$1.descender = e$3.descender;
								for (const t$4 in e$3.glyphs) this._doesCharSupportLocalGlyph(+t$4) || (i$1.glyphs[+t$4] = e$3.glyphs[+t$4]);
								i$1.ranges[o$1] = !0;
							}
							for (const r$3 of a$1) r$3(t$3, e$3);
							delete i$1.requests[o$1];
						}))), a$1.push(((n$2, i$2) => {
							n$2 ? r$2(n$2) : i$2 && r$2(null, {
								stack: t$2,
								id: e$2,
								glyph: i$2.glyphs[e$2] || null
							});
						}));
					}), ((t$2, r$2) => {
						if (t$2) e$1(t$2);
						else if (r$2) {
							const t$3 = {};
							for (const { stack: e$2, id: n$2, glyph: i$1 } of r$2) void 0 === t$3[e$2] && (t$3[e$2] = {}), void 0 === t$3[e$2].glyphs && (t$3[e$2].glyphs = {}), t$3[e$2].glyphs[n$2] = i$1 && {
								id: i$1.id,
								bitmap: i$1.bitmap.clone(),
								metrics: i$1.metrics
							}, t$3[e$2].ascender = this.entries[e$2].ascender, t$3[e$2].descender = this.entries[e$2].descender;
							e$1(null, t$3);
						}
					}));
				}
				_doesCharSupportLocalGlyph(t$1) {
					return this.localGlyphMode !== Bg.none && (this.localGlyphMode === Bg.all ? !!this.localFontFamily : !!this.localFontFamily && (no["CJK Unified Ideographs"](t$1) || no["Hangul Syllables"](t$1) || no.Hiragana(t$1) || no.Katakana(t$1) || no["CJK Symbols and Punctuation"](t$1) || no["CJK Unified Ideographs Extension A"](t$1) || no["CJK Unified Ideographs Extension B"](t$1) || no.Osage(t$1)));
				}
				_tinySDF(t$1, e$1, r$1) {
					const n$1 = this.localFontFamily;
					if (!n$1 || !this._doesCharSupportLocalGlyph(r$1)) return;
					let i$1 = t$1.tinySDF;
					if (!i$1) {
						let r$2 = "400";
						/bold/i.test(e$1) ? r$2 = "900" : /medium/i.test(e$1) ? r$2 = "500" : /light/i.test(e$1) && (r$2 = "200"), i$1 = t$1.tinySDF = new zg.TinySDF({
							fontFamily: n$1,
							fontWeight: r$2,
							fontSize: 24 * kg,
							buffer: 3 * kg,
							radius: 8 * kg
						}), i$1.fontWeight = r$2;
					}
					if (this.localGlyphs[i$1.fontWeight][r$1]) return this.localGlyphs[i$1.fontWeight][r$1];
					const s$1 = String.fromCodePoint(r$1), { data: o$1, width: a$1, height: l$1, glyphWidth: u$1, glyphHeight: c$1, glyphLeft: h$1, glyphTop: p$1, glyphAdvance: d$1 } = i$1.draw(s$1);
					return this.localGlyphs[i$1.fontWeight][r$1] = {
						id: r$1,
						bitmap: new _h({
							width: a$1,
							height: l$1
						}, o$1),
						metrics: {
							width: u$1 / kg,
							height: c$1 / kg,
							left: h$1 / kg,
							top: p$1 / kg - 27,
							advance: d$1 / kg,
							localGlyph: !0
						}
					};
				}
			}
			zg.loadGlyphRange = function(t$1, e$1, r$1, n$1, i$1) {
				const s$1 = 256 * e$1, o$1 = s$1 + 255;
				Oe(n$1.transformRequest(n$1.normalizeGlyphsURL(r$1).replace("{fontstack}", t$1).replace("{range}", `${s$1}-${o$1}`), Ce.Glyphs), ((t$2, e$2) => {
					if (t$2) i$1(t$2);
					else if (e$2) {
						const t$3 = {}, r$2 = function(t$4) {
							return new Sy(t$4).readFields(Oy, {});
						}(e$2);
						for (const e$3 of r$2.glyphs) t$3[e$3.id] = e$3;
						i$1(null, {
							glyphs: t$3,
							ascender: r$2.ascender,
							descender: r$2.descender
						});
					}
				}));
			}, zg.TinySDF = class {
				constructor({ fontSize: t$1 = 24, buffer: e$1 = 3, radius: r$1 = 8, cutoff: n$1 = .25, fontFamily: i$1 = "sans-serif", fontWeight: s$1 = "normal", fontStyle: o$1 = "normal", lang: a$1 = null } = {}) {
					this.buffer = e$1, this.cutoff = n$1, this.radius = r$1, this.lang = a$1;
					const l$1 = this.size = t$1 + 4 * e$1, c$1 = this.ctx = this._createCanvas(l$1).getContext("2d", { willReadFrequently: !0 });
					c$1.font = `${o$1} ${s$1} ${t$1}px ${i$1}`, c$1.textBaseline = "alphabetic", c$1.textAlign = "left", c$1.fillStyle = "black", this.gridOuter = new Float64Array(l$1 * l$1), this.gridInner = new Float64Array(l$1 * l$1), this.f = new Float64Array(l$1), this.z = new Float64Array(l$1 + 1), this.v = new Uint16Array(l$1);
				}
				_createCanvas(t$1) {
					const e$1 = document.createElement("canvas");
					return e$1.width = e$1.height = t$1, e$1;
				}
				draw(t$1) {
					const { width: e$1, actualBoundingBoxAscent: r$1, actualBoundingBoxDescent: n$1, actualBoundingBoxLeft: i$1, actualBoundingBoxRight: s$1 } = this.ctx.measureText(t$1), o$1 = Math.ceil(r$1), a$1 = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(s$1 - i$1))), l$1 = Math.min(this.size - this.buffer, o$1 + Math.ceil(n$1)), u$1 = a$1 + 2 * this.buffer, c$1 = l$1 + 2 * this.buffer, h$1 = Math.max(u$1 * c$1, 0), p$1 = new Uint8ClampedArray(h$1), d$1 = {
						data: p$1,
						width: u$1,
						height: c$1,
						glyphWidth: a$1,
						glyphHeight: l$1,
						glyphTop: o$1,
						glyphLeft: 0,
						glyphAdvance: e$1
					};
					if (0 === a$1 || 0 === l$1) return d$1;
					const { ctx: f$1, buffer: m$1, gridInner: y$1, gridOuter: g$1 } = this;
					this.lang && (f$1.lang = this.lang), f$1.clearRect(m$1, m$1, a$1, l$1), f$1.fillText(t$1, m$1, m$1 + o$1);
					const x$1 = f$1.getImageData(m$1, m$1, a$1, l$1);
					g$1.fill(Mg, 0, h$1), y$1.fill(0, 0, h$1);
					for (let t$2 = 0; t$2 < l$1; t$2++) for (let e$2 = 0; e$2 < a$1; e$2++) {
						const r$2 = x$1.data[4 * (t$2 * a$1 + e$2) + 3] / 255;
						if (0 === r$2) continue;
						const n$2 = (t$2 + m$1) * u$1 + e$2 + m$1;
						if (1 === r$2) g$1[n$2] = 0, y$1[n$2] = Mg;
						else {
							const t$3 = .5 - r$2;
							g$1[n$2] = t$3 > 0 ? t$3 * t$3 : 0, y$1[n$2] = t$3 < 0 ? t$3 * t$3 : 0;
						}
					}
					Sg(g$1, 0, 0, u$1, c$1, u$1, this.f, this.v, this.z), Sg(y$1, m$1, m$1, a$1, l$1, u$1, this.f, this.v, this.z);
					for (let t$2 = 0; t$2 < h$1; t$2++) {
						const e$2 = Math.sqrt(g$1[t$2]) - Math.sqrt(y$1[t$2]);
						p$1[t$2] = Math.round(255 - 255 * (e$2 / this.radius + this.cutoff));
					}
					return d$1;
				}
			};
			const Tg = wg;
			function Eg(t$1, e$1) {
				return t$1 + e$1[1] - e$1[0];
			}
			function Vg(t$1, e$1, r$1, n$1, i$1 = 1) {
				const s$1 = [], o$1 = t$1.imagePrimary, a$1 = o$1.pixelRatio, l$1 = o$1.paddedRect.w - 2 * Tg, u$1 = o$1.paddedRect.h - 2 * Tg, c$1 = (t$1.right - t$1.left) * i$1, h$1 = (t$1.bottom - t$1.top) * i$1, p$1 = o$1.stretchX || [[0, l$1]], d$1 = o$1.stretchY || [[0, u$1]], f$1 = p$1.reduce(Eg, 0), m$1 = d$1.reduce(Eg, 0), y$1 = l$1 - f$1, g$1 = u$1 - m$1;
				let x$1 = 0, v$1 = f$1, b$1 = 0, w$1 = m$1, _$1 = 0, A$1 = y$1, I$1 = 0, M$1 = g$1;
				if (o$1.content && n$1) {
					const t$2 = o$1.content;
					x$1 = Cg(p$1, 0, t$2[0]), b$1 = Cg(d$1, 0, t$2[1]), v$1 = Cg(p$1, t$2[0], t$2[2]), w$1 = Cg(d$1, t$2[1], t$2[3]), _$1 = t$2[0] - x$1, I$1 = t$2[1] - b$1, A$1 = t$2[2] - t$2[0] - v$1, M$1 = t$2[3] - t$2[1] - w$1;
				}
				const S$1 = (n$2, s$2, l$2, u$2) => {
					const p$2 = Lg(n$2.stretch - x$1, v$1, c$1, t$1.left * i$1), d$2 = Og(n$2.fixed - _$1, A$1, n$2.stretch, f$1), y$2 = Lg(s$2.stretch - b$1, w$1, h$1, t$1.top * i$1), g$2 = Og(s$2.fixed - I$1, M$1, s$2.stretch, m$1), S$2 = Lg(l$2.stretch - x$1, v$1, c$1, t$1.left * i$1), P$1 = Og(l$2.fixed - _$1, A$1, l$2.stretch, f$1), k$1 = Lg(u$2.stretch - b$1, w$1, h$1, t$1.top * i$1), B$1 = Og(u$2.fixed - I$1, M$1, u$2.stretch, m$1), z$1 = new It(p$2, y$2), T$1 = new It(S$2, y$2), E$1 = new It(S$2, k$1), V$1 = new It(p$2, k$1), F$1 = new It(d$2 / a$1, g$2 / a$1), C$1 = new It(P$1 / a$1, B$1 / a$1), D$1 = e$1 * Math.PI / 180;
					if (D$1) {
						const t$2 = Math.sin(D$1), e$2 = Math.cos(D$1), r$2 = [
							e$2,
							-t$2,
							t$2,
							e$2
						];
						z$1._matMult(r$2), T$1._matMult(r$2), V$1._matMult(r$2), E$1._matMult(r$2);
					}
					const R$1 = n$2.stretch + n$2.fixed, L$1 = l$2.stretch + l$2.fixed, O$1 = s$2.stretch + s$2.fixed, U$1 = u$2.stretch + u$2.fixed, N$1 = t$1.imageSecondary;
					return {
						tl: z$1,
						tr: T$1,
						bl: V$1,
						br: E$1,
						texPrimary: {
							x: o$1.paddedRect.x + Tg + R$1,
							y: o$1.paddedRect.y + Tg + O$1,
							w: L$1 - R$1,
							h: U$1 - O$1
						},
						texSecondary: N$1 ? {
							x: N$1.paddedRect.x + Tg + R$1,
							y: N$1.paddedRect.y + Tg + O$1,
							w: L$1 - R$1,
							h: U$1 - O$1
						} : void 0,
						writingMode: void 0,
						glyphOffset: [0, 0],
						sectionIndex: 0,
						pixelOffsetTL: F$1,
						pixelOffsetBR: C$1,
						minFontScaleX: A$1 / a$1 / c$1,
						minFontScaleY: M$1 / a$1 / h$1,
						isSDF: r$1
					};
				};
				if (n$1 && (o$1.stretchX || o$1.stretchY)) {
					const t$2 = Dg(p$1, y$1, f$1), e$2 = Dg(d$1, g$1, m$1);
					for (let r$2 = 0; r$2 < t$2.length - 1; r$2++) {
						const n$2 = t$2[r$2], i$2 = t$2[r$2 + 1];
						for (let t$3 = 0; t$3 < e$2.length - 1; t$3++) s$1.push(S$1(n$2, e$2[t$3], i$2, e$2[t$3 + 1]));
					}
				} else s$1.push(S$1({
					fixed: 0,
					stretch: -1
				}, {
					fixed: 0,
					stretch: -1
				}, {
					fixed: 0,
					stretch: l$1 + 1
				}, {
					fixed: 0,
					stretch: u$1 + 1
				}));
				return s$1;
			}
			function Fg(t$1, e$1) {
				const r$1 = t$1.stretchY || [[0, t$1.paddedRect.h - 2 * Tg]];
				return e$1 && (t$1.stretchX || t$1.stretchY) ? Rg(t$1.stretchX || [[0, t$1.paddedRect.w - 2 * Tg]]) * Rg(r$1) : 1;
			}
			function Cg(t$1, e$1, r$1) {
				let n$1 = 0;
				for (const i$1 of t$1) n$1 += Math.max(e$1, Math.min(r$1, i$1[1])) - Math.max(e$1, Math.min(r$1, i$1[0]));
				return n$1;
			}
			function Dg(t$1, e$1, r$1) {
				const n$1 = [{
					fixed: -Tg,
					stretch: 0
				}];
				for (const [e$2, r$2] of t$1) {
					const t$2 = n$1[n$1.length - 1];
					n$1.push({
						fixed: e$2 - t$2.stretch,
						stretch: t$2.stretch
					}), n$1.push({
						fixed: e$2 - t$2.stretch,
						stretch: t$2.stretch + (r$2 - e$2)
					});
				}
				return n$1.push({
					fixed: e$1 + Tg,
					stretch: r$1
				}), n$1;
			}
			function Rg(t$1) {
				return 2 * t$1.length + 1;
			}
			function Lg(t$1, e$1, r$1, n$1) {
				return t$1 / e$1 * r$1 + n$1;
			}
			function Og(t$1, e$1, r$1, n$1) {
				return t$1 - e$1 * r$1 / n$1;
			}
			function Ug(t$1, e$1, r$1, n$1) {
				const i$1 = e$1 + t$1.positionedLines[n$1].lineOffset;
				return 0 === n$1 ? r$1 + i$1 / 2 : r$1 + (i$1 + (e$1 + t$1.positionedLines[n$1 - 1].lineOffset)) / 2;
			}
			function Ng(t$1, e$1 = 1, r$1 = !1) {
				let n$1 = Infinity, i$1 = Infinity, s$1 = -Infinity, o$1 = -Infinity;
				const a$1 = t$1[0];
				for (let t$2 = 0; t$2 < a$1.length; t$2++) {
					const e$2 = a$1[t$2];
					(!t$2 || e$2.x < n$1) && (n$1 = e$2.x), (!t$2 || e$2.y < i$1) && (i$1 = e$2.y), (!t$2 || e$2.x > s$1) && (s$1 = e$2.x), (!t$2 || e$2.y > o$1) && (o$1 = e$2.y);
				}
				const l$1 = Math.min(s$1 - n$1, o$1 - i$1);
				let u$1 = l$1 / 2;
				const c$1 = new On([], jg);
				if (0 === l$1) return new It(n$1, i$1);
				for (let e$2 = n$1; e$2 < s$1; e$2 += l$1) for (let r$2 = i$1; r$2 < o$1; r$2 += l$1) c$1.push(new $g(e$2 + u$1, r$2 + u$1, u$1, t$1));
				let h$1 = function(t$2) {
					let e$2 = 0, r$2 = 0, n$2 = 0;
					const i$2 = t$2[0];
					for (let t$3 = 0, s$2 = i$2.length, o$2 = s$2 - 1; t$3 < s$2; o$2 = t$3++) {
						const s$3 = i$2[t$3], a$2 = i$2[o$2], l$2 = s$3.x * a$2.y - a$2.x * s$3.y;
						r$2 += (s$3.x + a$2.x) * l$2, n$2 += (s$3.y + a$2.y) * l$2, e$2 += 3 * l$2;
					}
					return new $g(r$2 / e$2, n$2 / e$2, 0, t$2);
				}(t$1), p$1 = c$1.length;
				for (; c$1.length;) {
					const n$2 = c$1.pop();
					(n$2.d > h$1.d || !h$1.d) && (h$1 = n$2, r$1 && console.log("found best %d after %d probes", Math.round(1e4 * n$2.d) / 1e4, p$1)), n$2.max - h$1.d <= e$1 || (u$1 = n$2.h / 2, c$1.push(new $g(n$2.p.x - u$1, n$2.p.y - u$1, u$1, t$1)), c$1.push(new $g(n$2.p.x + u$1, n$2.p.y - u$1, u$1, t$1)), c$1.push(new $g(n$2.p.x - u$1, n$2.p.y + u$1, u$1, t$1)), c$1.push(new $g(n$2.p.x + u$1, n$2.p.y + u$1, u$1, t$1)), p$1 += 4);
				}
				return r$1 && (console.log(`num probes: ${p$1}`), console.log(`best distance: ${h$1.d}`)), h$1.p;
			}
			function jg(t$1, e$1) {
				return e$1.max - t$1.max;
			}
			class $g {
				constructor(t$1, e$1, r$1, n$1) {
					this.p = new It(t$1, e$1), this.h = r$1, this.d = function(t$2, e$2) {
						let r$2 = !1, n$2 = Infinity;
						for (let i$1 = 0; i$1 < e$2.length; i$1++) {
							const s$1 = e$2[i$1];
							for (let e$3 = 0, i$2 = s$1.length, o$1 = i$2 - 1; e$3 < i$2; o$1 = e$3++) {
								const i$3 = s$1[e$3], a$1 = s$1[o$1];
								i$3.y > t$2.y != a$1.y > t$2.y && t$2.x < (a$1.x - i$3.x) * (t$2.y - i$3.y) / (a$1.y - i$3.y) + i$3.x && (r$2 = !r$2), n$2 = Math.min(n$2, dc(t$2, i$3, a$1));
							}
						}
						return (r$2 ? 1 : -1) * Math.sqrt(n$2);
					}(this.p, n$1), this.max = this.d + this.h * Math.SQRT2;
				}
			}
			const Gg = Object.keys, qg = Number.POSITIVE_INFINITY, Hg = Math.sqrt(2);
			function Xg(t$1, e$1, r$1, n$1, i$1) {
				const s$1 = rg(t$1) && t$1.collisionPadding ? t$1.collisionPadding : [
					0,
					0,
					0,
					0
				], o$1 = {
					top: t$1.top - s$1[1],
					bottom: t$1.bottom + s$1[3],
					left: t$1.left - s$1[0],
					right: t$1.right + s$1[2],
					scaled: !1
				};
				return void 0 !== n$1 && function(t$2, e$2) {
					t$2.top *= e$2, t$2.bottom *= e$2, t$2.left *= e$2, t$2.right *= e$2, t$2.scaled = !0;
				}(o$1, n$1), r$1 && function(t$2, e$2) {
					if (!e$2) return;
					const r$2 = kt(e$2), n$2 = new It(t$2.left, t$2.top), i$2 = new It(t$2.right, t$2.top), s$2 = new It(t$2.left, t$2.bottom), o$2 = new It(t$2.right, t$2.bottom), a$1 = new It(0, 0);
					n$2._rotateAround(r$2, a$1), i$2._rotateAround(r$2, a$1), s$2._rotateAround(r$2, a$1), o$2._rotateAround(r$2, a$1), t$2.left = Math.min(n$2.x, i$2.x, s$2.x, o$2.x), t$2.right = Math.max(n$2.x, i$2.x, s$2.x, o$2.x), t$2.top = Math.min(n$2.y, i$2.y, s$2.y, o$2.y), t$2.bottom = Math.max(n$2.y, i$2.y, s$2.y, o$2.y);
				}(o$1, r$1), i$1 && (o$1.left += i$1[0], o$1.right += i$1[0], o$1.top += i$1[1], o$1.bottom += i$1[1]), e$1 ? {
					top: Math.min(e$1.top, o$1.top),
					bottom: Math.max(e$1.bottom, o$1.bottom),
					left: Math.min(e$1.left, o$1.left),
					right: Math.max(e$1.right, o$1.right),
					scaled: e$1.scaled || o$1.scaled
				} : o$1;
			}
			function Zg(t$1, [e$1, r$1]) {
				let n$1 = 0, i$1 = 0;
				if (r$1 === qg) {
					e$1 < 0 && (e$1 = 0);
					const r$2 = e$1 / Hg;
					switch (t$1) {
						case "top-right":
						case "top-left":
							i$1 = r$2 - 7;
							break;
						case "bottom-right":
						case "bottom-left":
							i$1 = 7 - r$2;
							break;
						case "bottom":
							i$1 = 7 - e$1;
							break;
						case "top": i$1 = e$1 - 7;
					}
					switch (t$1) {
						case "top-right":
						case "bottom-right":
							n$1 = -r$2;
							break;
						case "top-left":
						case "bottom-left":
							n$1 = r$2;
							break;
						case "left":
							n$1 = e$1;
							break;
						case "right": n$1 = -e$1;
					}
				} else {
					switch (e$1 = Math.abs(e$1), r$1 = Math.abs(r$1), t$1) {
						case "top-right":
						case "top-left":
						case "top":
							i$1 = r$1 - 7;
							break;
						case "bottom-right":
						case "bottom-left":
						case "bottom": i$1 = 7 - r$1;
					}
					switch (t$1) {
						case "top-right":
						case "bottom-right":
						case "right":
							n$1 = -e$1;
							break;
						case "top-left":
						case "bottom-left":
						case "left": n$1 = e$1;
					}
				}
				return [n$1, i$1];
			}
			function Wg(t$1, e$1, r$1, n$1, i$1, s$1, o$1, a$1, l$1, u$1, c$1, h$1, p$1, d$1) {
				const f$1 = t$1.layers[0], m$1 = f$1.appearances;
				if (0 === m$1.length) return {
					iconBBox: null,
					iconVerticalBBox: null,
					textBBox: null,
					textVerticalBBox: null
				};
				const y$1 = {
					iconBBox: null,
					iconVerticalBBox: null
				}, g$1 = {
					textBBox: null,
					textVerticalBBox: null
				}, { baseIconRotate: x$1, baseTextRotate: v$1, iconScaleFactor: b$1 } = function(t$2, e$2, r$2) {
					const n$2 = t$2.get("icon-rotate").evaluate(e$2, {}, r$2), i$2 = t$2.get("text-rotate").evaluate(e$2, {}, r$2), [s$2, o$2] = t$2.get("icon-size-scale-range");
					return {
						baseIconRotate: n$2,
						baseTextRotate: i$2,
						iconScaleFactor: Ft(1, s$2, o$2)
					};
				}(n$1, i$1, s$1);
				e$1 && (y$1.iconBBox = Xg(e$1, y$1.iconBBox, x$1, o$1), r$1) && (y$1.iconVerticalBBox = Xg(r$1, y$1.iconVerticalBBox, x$1 + 90, o$1));
				const w$1 = hx(h$1.horizontal);
				w$1 && (g$1.textBBox = Xg(w$1, g$1.textBBox, v$1, 1, d$1)), h$1.vertical && (g$1.textVerticalBBox = Xg(h$1.vertical, g$1.textVerticalBBox, v$1 + 90, 1, d$1));
				for (const r$2 of m$1) r$2.hasIconProperties() && Yg(y$1, t$1, f$1, r$2, i$1, s$1, a$1, x$1, o$1, l$1, e$1, u$1, b$1, c$1), r$2.hasTextProperties() && Kg(g$1, f$1, r$2, i$1, s$1, d$1, v$1, p$1, w$1, h$1.vertical);
				return {
					iconBBox: y$1.iconBBox,
					iconVerticalBBox: y$1.iconVerticalBBox,
					textBBox: g$1.textBBox,
					textVerticalBBox: g$1.textVerticalBBox
				};
			}
			function Yg(t$1, e$1, r$1, n$1, i$1, s$1, o$1, a$1, l$1, u$1, c$1, h$1, p$1, d$1) {
				const { appearanceIconOffset: f$1, appearanceIconRotate: m$1, appearanceIconSize: y$1 } = function(t$2, e$2, r$2, n$2, i$2, s$2, o$2, a$2) {
					const l$2 = t$2.hasProperty("icon-offset") ? e$2.getAppearanceValueAndResolveTokens(t$2, "icon-offset", r$2, n$2, []) : null, u$2 = l$2 && Array.isArray(l$2) ? l$2 : i$2, c$2 = t$2.hasProperty("icon-rotate") ? e$2.getAppearanceValueAndResolveTokens(t$2, "icon-rotate", r$2, n$2, []) : null, h$2 = "number" == typeof c$2 ? c$2 : s$2, p$2 = t$2.hasProperty("icon-size") ? e$2.getAppearanceValueAndResolveTokens(t$2, "icon-size", r$2, n$2, []) : null;
					return {
						appearanceIconOffset: u$2,
						appearanceIconRotate: h$2,
						appearanceIconSize: "number" == typeof p$2 ? p$2 * a$2.iconScaleFactor : o$2
					};
				}(n$1, r$1, i$1, s$1, o$1, a$1, l$1, u$1);
				let g$1 = null, x$1 = null, v$1 = null;
				n$1.hasProperty("icon-image") ? v$1 = function(t$2, e$2, r$2, n$2, i$2, s$2, o$2) {
					let a$2 = null;
					const l$2 = e$2.getAppearanceValueAndResolveTokens(r$2, "icon-image", n$2, i$2, []);
					if (l$2) {
						const e$3 = t$2.getResolvedImageFromTokens(l$2), u$2 = r$2.getUnevaluatedProperty("icon-size"), c$2 = tx(e$3, ug(t$2.zoom, u$2, t$2.worldview), u$2, i$2, t$2.zoom, n$2, t$2.pixelRatio, o$2, t$2.worldview);
						a$2 = s$2.get(c$2.iconPrimary.toString());
					}
					return a$2;
				}(e$1, r$1, n$1, i$1, s$1, h$1, p$1) : c$1 && (v$1 = c$1.imagePrimary), v$1 && (g$1 = ng(v$1, null, f$1, d$1), e$1.allowVerticalPlacement && (x$1 = ng(v$1, null, f$1, d$1))), g$1 && (t$1.iconBBox = Xg(g$1, t$1.iconBBox, m$1, y$1)), x$1 && (t$1.iconVerticalBBox = Xg(x$1, t$1.iconVerticalBBox, m$1 + 90, y$1));
			}
			function Kg(t$1, e$1, r$1, n$1, i$1, s$1, o$1, a$1, l$1, u$1) {
				const { appearanceTextOffset: c$1, appearanceTextRotate: h$1, appearanceTextSize: p$1 } = function(t$2, e$2, r$2, n$2, i$2, s$2, o$2) {
					const a$2 = t$2.hasProperty("text-offset") ? e$2.getAppearanceValueAndResolveTokens(t$2, "text-offset", r$2, n$2, []) : null, l$2 = a$2 && Array.isArray(a$2) ? [a$2[0] * xy, a$2[1] * xy] : i$2, u$2 = t$2.hasProperty("text-rotate") ? e$2.getAppearanceValueAndResolveTokens(t$2, "text-rotate", r$2, n$2, []) : null, c$2 = "number" == typeof u$2 ? u$2 : s$2, h$2 = t$2.hasProperty("text-size") ? e$2.getAppearanceValueAndResolveTokens(t$2, "text-size", r$2, n$2, []) : null;
					return {
						appearanceTextOffset: l$2,
						appearanceTextRotate: c$2,
						appearanceTextSize: "number" == typeof h$2 ? h$2 : o$2
					};
				}(r$1, e$1, n$1, i$1, s$1, o$1, a$1), d$1 = p$1 / a$1;
				l$1 && (t$1.textBBox = Xg(l$1, t$1.textBBox, h$1, d$1, c$1)), u$1 && (t$1.textVerticalBBox = Xg(u$1, t$1.textVerticalBBox, h$1 + 90, d$1, c$1));
			}
			function Jg(t$1, e$1, r$1, n$1, i$1, s$1, o$1, a$1, l$1) {
				if (!e$1 || !e$1.usvg) return;
				const u$1 = ag(n$1), c$1 = ag(i$1), h$1 = "both" !== s$1 && "width" !== s$1 || !sg(n$1) ? 1 : c$1.width / u$1.width, p$1 = "both" !== s$1 && "height" !== s$1 || !og(n$1) ? 1 : c$1.height / u$1.height;
				r$1.scaleSelf(h$1, p$1);
				const d$1 = r$1.toString();
				o$1.set(d$1, r$1), a$1.set(d$1, e$1);
				const { imagePosition: f$1 } = Ag(d$1, e$1, wg);
				l$1.set(d$1, f$1);
			}
			function Qg(t$1, e$1, r$1, n$1, i$1, s$1, o$1, a$1, l$1) {
				if (!t$1) return;
				const u$1 = function(t$2, e$2, r$2, n$2, i$2, s$2) {
					if ("camera" === t$2.kind) return t$2.maxSize;
					if ("composite" === t$2.kind) {
						const n$3 = e$2.possiblyEvaluate(new Io(t$2.maxZoom, { worldview: s$2 }), r$2).evaluate(i$2, {}, r$2), o$2 = e$2.possiblyEvaluate(new Io(t$2.minZoom, { worldview: s$2 }), r$2).evaluate(i$2, {}, r$2);
						return Math.max(n$3, o$2);
					}
					return e$2.possiblyEvaluate(new Io(n$2, { worldview: s$2 })).evaluate(i$2, {}, r$2);
				}(e$1, r$1, n$1, i$1, s$1, l$1);
				return t$1.scaleSelf(u$1 * a$1 * o$1);
			}
			function tx(t$1, e$1, r$1, n$1, i$1, s$1, o$1, a$1, l$1) {
				return {
					iconPrimary: Qg(t$1.getPrimary(), e$1, r$1, n$1, i$1, s$1, o$1, a$1, l$1),
					iconSecondary: Qg(t$1.getSecondary(), e$1, r$1, n$1, i$1, s$1, o$1, a$1, l$1)
				};
			}
			function ex(t$1, e$1, r$1) {
				if (!e$1) return;
				const n$1 = r$1.get(t$1.toString()), i$1 = r$1.get(e$1.toString());
				n$1 && i$1 && (n$1.paddedRect.w === i$1.paddedRect.w && n$1.paddedRect.h === i$1.paddedRect.h || Xt(`Mismatch in icon variant sizes: ${t$1.toString()} and ${e$1.toString()}`), n$1.usvg !== i$1.usvg && Xt(`Mismatch in icon variant image types: ${t$1.id} and ${e$1.id}`));
			}
			function rx(t$1, e$1, r$1, n$1) {
				if (!t$1) return;
				if (t$1.imagePrimary = e$1.get(r$1.toString()), n$1) t$1.imageSecondary = e$1.get(n$1.toString());
			}
			function nx(t$1, e$1) {
				for (const r$1 in t$1.horizontal) ix(t$1.horizontal[r$1], e$1);
				ix(t$1.vertical, e$1);
			}
			function ix(t$1, e$1) {
				if (t$1) {
					for (const r$1 of t$1.positionedLines) for (const t$2 of r$1.positionedGlyphs) if (null !== t$2.image) {
						const r$2 = t$2.image.toString();
						t$2.rect = e$1.get(r$2).paddedRect;
					}
				}
			}
			function sx(t$1) {
				switch (t$1) {
					case "right":
					case "top-right":
					case "bottom-right": return "right";
					case "left":
					case "top-left":
					case "bottom-left": return "left";
				}
				return "center";
			}
			function ox(t$1, e$1, r$1, n$1, i$1, s$1, o$1, a$1, l$1) {
				const u$1 = hx(s$1.horizontal) || s$1.vertical, c$1 = r$1.get("icon-text-fit-padding").evaluate(n$1, {}, i$1);
				let h$1, p$1 = e$1;
				return e$1 && "none" !== l$1 && (t$1.allowVerticalPlacement && s$1.vertical && (h$1 = ig(e$1, s$1.vertical, l$1, c$1, a$1, o$1)), u$1 && (p$1 = ig(e$1, u$1, l$1, c$1, a$1, o$1))), {
					defaultShapedIcon: p$1,
					verticallyShapedIcon: h$1
				};
			}
			function ax(t$1, e$1, r$1, n$1, i$1, s$1, o$1, a$1, l$1, u$1, c$1, h$1, p$1, d$1, f$1, m$1, y$1, g$1, x$1, v$1, b$1, w$1, _$1, A$1) {
				let I$1 = o$1.textMaxSize.evaluate(e$1, {}, p$1);
				void 0 === I$1 ? I$1 = a$1 * o$1.textScaleFactor : I$1 *= o$1.textScaleFactor;
				const M$1 = t$1.layers[0].layout, S$1 = xy, P$1 = a$1 * o$1.textScaleFactor / S$1, k$1 = hx(r$1.horizontal) || r$1.vertical;
				if ("none" !== y$1 && t$1.appearanceFeatureData && e$1.index < t$1.appearanceFeatureData.length) {
					const r$2 = t$1.appearanceFeatureData[e$1.index];
					r$2 && (r$2.textShaping = k$1, r$2.iconTextFitPadding = M$1.get("icon-text-fit-padding").evaluate(e$1, {}, p$1), r$2.fontScale = P$1);
				}
				const B$1 = "globe" === d$1.name, z$1 = t$1.tilePixelRatio * I$1 / S$1, T$1 = (R$1 = t$1.overscaling, t$1.zoom > 18 && R$1 > 2 && (R$1 >>= 1), Math.max(Un / (512 * R$1), 1) * M$1.get("symbol-spacing")), E$1 = M$1.get("text-padding") * t$1.tilePixelRatio, V$1 = M$1.get("icon-padding") * t$1.tilePixelRatio, F$1 = kt(M$1.get("text-max-angle")), C$1 = "map" === M$1.get("icon-rotation-alignment") && "point" !== v$1, D$1 = T$1 / 2;
				var R$1;
				!1 === t$1.hasAnyIconTextFit && "none" !== y$1 && (t$1.hasAnyIconTextFit = !0);
				const L$1 = e$1.properties ? +e$1.properties[Ru] : null, O$1 = L$1 && t$1.elevationFeatureIdToIndex ? t$1.elevationFeatureIdToIndex.get(L$1) : 65535, U$1 = (a$2, l$2, v$2) => {
					if (l$2.x < 0 || l$2.x >= Un || l$2.y < 0 || l$2.y >= Un) return;
					let A$2 = null;
					if (B$1) {
						const { x: t$2, y: e$2, z: r$2 } = d$1.projectTilePoint(l$2.x, l$2.y, v$2);
						A$2 = {
							anchor: new pg(t$2, e$2, r$2, 0, void 0),
							up: d$1.upVector(v$2, l$2.x, l$2.y)
						};
					}
					(function(t$2, e$2, r$2, n$2, i$2, s$2, o$2, a$3, l$3, u$2, c$2, h$2, p$2, d$2, f$2, m$2, y$2, g$2, x$2, v$3, b$2, w$2, _$2, A$3, I$2, M$2, S$2, P$2, k$2, B$2, z$2, T$2, E$2) {
						const V$2 = t$2.addToLineVertexArray(e$2, n$2);
						let F$2, C$2, D$2, R$2, L$2, O$2, U$2, N$1 = 0, j$1 = 0, $$1 = 0, G$1 = 0, q$1 = -1, H$1 = -1;
						const X$1 = {};
						let Z$1 = Je("");
						const W$1 = r$2 ? r$2.anchor : e$2, Y$1 = "none" !== P$2;
						let K$1 = 0, J$1 = 0;
						if (void 0 === l$3._unevaluatedLayout.getValue("text-radial-offset")) {
							const t$3 = l$3.layout.get("text-offset").evaluate(b$2, {}, I$2);
							K$1 = t$3[0] * xy, J$1 = t$3[1] * xy;
						} else K$1 = l$3.layout.get("text-radial-offset").evaluate(b$2, {}, I$2) * xy, J$1 = qg;
						if (t$2.allowVerticalPlacement && i$2.vertical) {
							const t$3 = i$2.vertical;
							if (f$2) O$2 = dx(t$3), a$3 && (U$2 = dx(a$3));
							else {
								const r$3 = l$3.layout.get("text-rotate").evaluate(b$2, {}, I$2) + 90;
								D$2 = px(u$2, W$1, e$2, c$2, h$2, p$2, t$3, d$2, r$3, m$2, T$2), a$3 && (R$2 = px(u$2, W$1, e$2, c$2, h$2, p$2, a$3, g$2, r$3, null, z$2));
							}
						}
						if (s$2) {
							const n$3 = t$2.iconSizeData, i$3 = l$3.layout.get("icon-rotate").evaluate(b$2, {}, I$2), o$3 = Vg(s$2, i$3, _$2, Y$1, w$2.iconScaleFactor), d$3 = a$3 ? Vg(a$3, i$3, _$2, Y$1, w$2.iconScaleFactor) : void 0;
							C$2 = px(u$2, W$1, e$2, c$2, h$2, p$2, s$2, g$2, i$3, null, B$2);
							const f$3 = function(t$3, e$3, r$3, n$4, i$4, s$3, o$4, a$4) {
								const l$4 = t$3.layers[0], u$3 = l$4.appearances;
								let c$3 = e$3.length;
								if (r$3 && (c$3 = Math.max(c$3, r$3.length)), 0 === u$3.length) return c$3;
								const [h$3, p$3] = n$4.get("icon-size-scale-range"), d$4 = Ft(1, h$3, p$3);
								for (const e$4 of u$3) {
									const r$4 = e$4.getUnevaluatedProperties();
									if (void 0 !== r$4._values["icon-image"].value) {
										const n$5 = l$4.getAppearanceValueAndResolveTokens(e$4, "icon-image", i$4, s$3, []);
										if (n$5) {
											const e$5 = t$3.getResolvedImageFromTokens(n$5);
											if (e$5) {
												const n$6 = r$4._values["icon-size"], l$5 = tx(e$5, ug(t$3.zoom, n$6, t$3.worldview), n$6, s$3, t$3.zoom, i$4, t$3.pixelRatio, d$4, t$3.worldview), u$4 = o$4.get(l$5.iconPrimary.toString());
												c$3 = Math.max(c$3, Fg(u$4, a$4));
											}
										}
									}
								}
								return c$3;
							}(t$2, o$3, d$3, l$3.layout, b$2, I$2, t$2.iconAtlasPositions, Y$1);
							N$1 = 4 * f$3;
							let m$3 = null;
							"source" === n$3.kind ? (m$3 = [lg * l$3.layout.get("icon-size").evaluate(b$2, {}, I$2) * w$2.iconScaleFactor], m$3[0] > ux && Xt(`${t$2.layerIds[0]}: Value for "icon-size" is >= ${lx}. Reduce your "icon-size".`)) : "composite" === n$3.kind && (m$3 = [lg * w$2.compositeIconSizes[0].evaluate(b$2, {}, I$2) * w$2.iconScaleFactor, lg * w$2.compositeIconSizes[1].evaluate(b$2, {}, I$2) * w$2.iconScaleFactor], (m$3[0] > ux || m$3[1] > ux) && Xt(`${t$2.layerIds[0]}: Value for "icon-size" is >= ${lx}. Reduce your "icon-size".`)), t$2.addSymbols(t$2.icon, o$3, m$3, v$3, x$2, b$2, void 0, r$2, e$2, V$2.lineStartIndex, V$2.lineLength, -1, A$3, I$2, M$2, S$2, t$2.symbolInstances.length, f$3), q$1 = t$2.icon.placedSymbolArray.length - 1, d$3 && (j$1 = 4 * f$3, t$2.addSymbols(t$2.icon, d$3, m$3, v$3, x$2, b$2, $y.vertical, r$2, e$2, V$2.lineStartIndex, V$2.lineLength, -1, A$3, I$2, M$2, S$2, t$2.symbolInstances.length, f$3), H$1 = t$2.icon.placedSymbolArray.length - 1);
						}
						for (const n$3 in i$2.horizontal) {
							const s$3 = n$3, a$4 = i$2.horizontal[s$3];
							F$2 || (Z$1 = Je(a$4.text), f$2 ? L$2 = dx(a$4) : F$2 = px(u$2, W$1, e$2, c$2, h$2, p$2, a$4, d$2, l$3.layout.get("text-rotate").evaluate(b$2, {}, I$2), m$2, T$2));
							const y$3 = 1 === a$4.positionedLines.length;
							if ($$1 += cx(t$2, r$2, e$2, a$4, o$2, l$3, f$2, b$2, m$2, V$2, i$2.vertical ? $y.horizontal : $y.horizontalOnly, y$3 ? Gg(i$2.horizontal) : [s$3], X$1, q$1, w$2, A$3, I$2, t$2.symbolInstances.length, M$2), y$3) break;
						}
						i$2.vertical && (G$1 += cx(t$2, r$2, e$2, i$2.vertical, o$2, l$3, f$2, b$2, m$2, V$2, $y.vertical, ["vertical"], X$1, H$1, w$2, A$3, I$2, t$2.symbolInstances.length, M$2));
						let Q$1 = -1;
						const tt$1 = (t$3, e$3) => t$3 ? Math.max(t$3, e$3) : e$3;
						Q$1 = tt$1(L$2, Q$1), Q$1 = tt$1(O$2, Q$1), Q$1 = tt$1(U$2, Q$1);
						const et$1 = Q$1 > -1 ? 1 : 0;
						t$2.glyphOffsetArray.length >= 65535 && Xt("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), void 0 !== b$2.sortKey && t$2.addToSortKeyRanges(t$2.symbolInstances.length, b$2.sortKey), t$2.symbolInstances.emplaceBack(e$2.x, e$2.y, W$1.x, W$1.y, W$1.z, X$1.right >= 0 ? X$1.right : -1, X$1.center >= 0 ? X$1.center : -1, X$1.left >= 0 ? X$1.left : -1, X$1.vertical >= 0 ? X$1.vertical : -1, q$1, H$1, Z$1, void 0 !== F$2 ? F$2 : t$2.collisionBoxArray.length, void 0 !== F$2 ? F$2 + 1 : t$2.collisionBoxArray.length, void 0 !== D$2 ? D$2 : t$2.collisionBoxArray.length, void 0 !== D$2 ? D$2 + 1 : t$2.collisionBoxArray.length, void 0 !== C$2 ? C$2 : t$2.collisionBoxArray.length, void 0 !== C$2 ? C$2 + 1 : t$2.collisionBoxArray.length, R$2 || t$2.collisionBoxArray.length, R$2 ? R$2 + 1 : t$2.collisionBoxArray.length, c$2, $$1, G$1, N$1, j$1, et$1, 0, K$1, J$1, Q$1, 0, Y$1 ? 1 : 0, k$2);
					})(t$1, l$2, A$2, a$2, r$1, n$1, s$1, i$1, t$1.layers[0], t$1.collisionBoxArray, e$1.index, e$1.sourceLayerIndex, t$1.index, E$1, x$1, u$1, 0, V$1, C$1, g$1, e$1, o$1, c$1, h$1, p$1, f$1, m$1, y$1, O$1, b$1, w$1, _$1);
				};
				if ("line" === v$1) for (const i$2 of Fd(e$1.geometry, 0, 0, Un, Un)) {
					const e$2 = xg(i$2, T$1, F$1, r$1.vertical || k$1, n$1, S$1, z$1, t$1.overscaling, Un);
					for (const r$2 of e$2) k$1 && fx(t$1, k$1.text, D$1, r$2) || U$1(i$2, r$2, p$1);
				}
				else if ("line-center" === v$1) {
					for (const t$2 of e$1.geometry) if (t$2.length > 1) {
						const e$2 = gg(t$2, F$1, r$1.vertical || k$1, n$1, S$1, z$1);
						e$2 && U$1(t$2, e$2, p$1);
					}
				} else if ("Polygon" === e$1.type) for (const t$2 of rp(e$1.geometry, 0)) {
					const e$2 = Ng(t$2, 16);
					U$1(t$2[0], new pg(e$2.x, e$2.y, 0, 0, void 0), p$1);
				}
				else if ("LineString" === e$1.type) for (const t$2 of e$1.geometry) U$1(t$2, new pg(t$2[0].x, t$2[0].y, 0, 0, void 0), p$1);
				else if ("Point" === e$1.type) for (const t$2 of e$1.geometry) for (const e$2 of t$2) U$1([e$2], new pg(e$2.x, e$2.y, 0, 0, void 0), p$1);
			}
			const lx = 255, ux = lx * lg;
			function cx(t$1, e$1, r$1, n$1, i$1, s$1, o$1, a$1, l$1, u$1, c$1, h$1, p$1, d$1, f$1, m$1, y$1, g$1, x$1) {
				const v$1 = function(t$2, e$2, r$2, n$2, i$2, s$2, o$2, a$2) {
					const l$2 = [];
					if (0 === e$2.positionedLines.length) return l$2;
					const u$2 = n$2.layout.get("text-rotate").evaluate(s$2, {}) * Math.PI / 180, c$2 = function(t$3) {
						const e$3 = t$3[0], r$3 = t$3[1], n$3 = e$3 * r$3;
						return n$3 > 0 ? [e$3, -r$3] : n$3 < 0 ? [-e$3, r$3] : 0 === e$3 ? [r$3, e$3] : [r$3, -e$3];
					}(r$2);
					let h$2 = Math.abs(e$2.top - e$2.bottom);
					for (const t$3 of e$2.positionedLines) h$2 -= t$3.lineOffset;
					const p$2 = e$2.positionedLines.length, d$2 = h$2 / p$2;
					let f$2 = e$2.top - r$2[1];
					for (let t$3 = 0; t$3 < p$2; ++t$3) {
						const n$3 = e$2.positionedLines[t$3];
						f$2 = Ug(e$2, d$2, f$2, t$3);
						for (const t$4 of n$3.positionedGlyphs) {
							if (!t$4.rect) continue;
							const n$4 = t$4.rect || {};
							let s$3 = jy + 1, h$3 = !0, p$3 = 1, d$3 = 0;
							if (t$4.image) {
								const e$3 = o$2.get(t$4.image.toString());
								if (!e$3) continue;
								if (e$3.sdf) {
									Xt("SDF images are not supported in formatted text and will be ignored.");
									continue;
								}
								h$3 = !1, p$3 = e$3.pixelRatio, s$3 = wg / p$3;
							}
							const m$2 = (i$2 || a$2) && t$4.vertical, y$2 = t$4.metrics.advance * t$4.scale / 2, g$2 = t$4.metrics, x$2 = t$4.rect;
							if (null === x$2) continue;
							a$2 && e$2.verticalizable && (d$3 = t$4.image ? y$2 - t$4.metrics.width * t$4.scale / 2 : 0);
							const v$2 = i$2 ? [t$4.x + y$2, t$4.y] : [0, 0];
							let b$2 = [0, 0], w$2 = [0, 0], _$1 = !1;
							i$2 || (m$2 ? (w$2 = [t$4.x + y$2 + c$2[0], t$4.y + c$2[1] - d$3], _$1 = !0) : b$2 = [t$4.x + y$2 + r$2[0], t$4.y + r$2[1] - d$3]);
							const A$1 = x$2.w * t$4.scale / (p$3 * (t$4.localGlyph ? kg : 1)), I$1 = x$2.h * t$4.scale / (p$3 * (t$4.localGlyph ? kg : 1));
							let M$1, S$1, P$1, k$1;
							if (m$2) {
								const e$3 = t$4.y - f$2, r$3 = new It(-y$2, y$2 - e$3), n$5 = -Math.PI / 2, i$3 = new It(...w$2);
								M$1 = new It(-y$2 + b$2[0], b$2[1]), M$1._rotateAround(n$5, r$3)._add(i$3), M$1.x += -e$3 + y$2, M$1.y -= (g$2.left - s$3) * t$4.scale;
								const o$3 = t$4.image ? g$2.advance * t$4.scale : xy * t$4.scale, a$3 = String.fromCodePoint(t$4.glyph);
								wy(a$3) ? M$1.x += (1 - s$3) * t$4.scale : _y(a$3) ? M$1.x += o$3 - g$2.height * t$4.scale + (-s$3 - 1) * t$4.scale : M$1.x += t$4.image || g$2.width + 2 * s$3 === x$2.w && g$2.height + 2 * s$3 === x$2.h ? (o$3 - I$1) / 2 : (o$3 - (g$2.height + 2 * s$3) * t$4.scale) / 2, S$1 = new It(M$1.x, M$1.y - A$1), P$1 = new It(M$1.x + I$1, M$1.y), k$1 = new It(M$1.x + I$1, M$1.y - A$1);
							} else {
								const e$3 = (g$2.left - s$3) * t$4.scale - y$2 + b$2[0], r$3 = (-g$2.top - s$3) * t$4.scale + b$2[1], n$5 = e$3 + A$1, i$3 = r$3 + I$1;
								M$1 = new It(e$3, r$3), S$1 = new It(n$5, r$3), P$1 = new It(e$3, i$3), k$1 = new It(n$5, i$3);
							}
							if (u$2) {
								let t$5;
								t$5 = i$2 ? new It(0, 0) : _$1 ? new It(c$2[0], c$2[1]) : new It(r$2[0], r$2[1]), M$1._rotateAround(u$2, t$5), S$1._rotateAround(u$2, t$5), P$1._rotateAround(u$2, t$5), k$1._rotateAround(u$2, t$5);
							}
							const B$1 = new It(0, 0), z$1 = new It(0, 0);
							l$2.push({
								tl: M$1,
								tr: S$1,
								bl: P$1,
								br: k$1,
								texPrimary: n$4,
								texSecondary: void 0,
								writingMode: e$2.writingMode,
								glyphOffset: v$2,
								sectionIndex: t$4.sectionIndex,
								isSDF: h$3,
								pixelOffsetTL: B$1,
								pixelOffsetBR: z$1,
								minFontScaleX: 0,
								minFontScaleY: 0
							});
						}
					}
					return l$2;
				}(0, n$1, l$1, s$1, o$1, a$1, i$1, t$1.allowVerticalPlacement), b$1 = t$1.textSizeData;
				let w$1 = null;
				"source" === b$1.kind ? (w$1 = [lg * s$1.layout.get("text-size").evaluate(a$1, {}, y$1) * f$1.textScaleFactor], w$1[0] > ux && Xt(`${t$1.layerIds[0]}: Value for "text-size" is >= ${lx}. Reduce your "text-size".`)) : "composite" === b$1.kind && (w$1 = [lg * f$1.compositeTextSizes[0].evaluate(a$1, {}, y$1) * f$1.textScaleFactor, lg * f$1.compositeTextSizes[1].evaluate(a$1, {}, y$1) * f$1.textScaleFactor], (w$1[0] > ux || w$1[1] > ux) && Xt(`${t$1.layerIds[0]}: Value for "text-size" is >= ${lx}. Reduce your "text-size".`)), t$1.addSymbols(t$1.text, v$1, w$1, l$1, o$1, a$1, c$1, e$1, r$1, u$1.lineStartIndex, u$1.lineLength, d$1, m$1, y$1, x$1, !1, g$1, v$1.length);
				for (const e$2 of h$1) p$1[e$2] = t$1.text.placedSymbolArray.length - 1;
				return 4 * v$1.length;
			}
			function hx(t$1) {
				for (const e$1 in t$1) return t$1[e$1];
				return null;
			}
			function px(t$1, e$1, r$1, n$1, i$1, s$1, o$1, a$1, l$1, u$1, c$1) {
				let h$1, p$1, d$1, f$1;
				if (h$1 = c$1 ? c$1.top : o$1.top, p$1 = c$1 ? c$1.bottom : o$1.bottom, d$1 = c$1 ? c$1.left : o$1.left, f$1 = c$1 ? c$1.right : o$1.right, rg(o$1) && o$1.collisionPadding) {
					const t$2 = o$1.collisionPadding;
					d$1 -= t$2[0], h$1 -= t$2[1], f$1 += t$2[2], p$1 += t$2[3];
				}
				if (l$1) {
					const t$2 = new It(d$1, h$1), e$2 = new It(f$1, h$1), r$2 = new It(d$1, p$1), n$2 = new It(f$1, p$1), i$2 = kt(l$1);
					let s$2 = new It(0, 0);
					u$1 && (s$2 = new It(u$1[0], u$1[1])), t$2._rotateAround(i$2, s$2), e$2._rotateAround(i$2, s$2), r$2._rotateAround(i$2, s$2), n$2._rotateAround(i$2, s$2), d$1 = Math.min(t$2.x, e$2.x, r$2.x, n$2.x), f$1 = Math.max(t$2.x, e$2.x, r$2.x, n$2.x), h$1 = Math.min(t$2.y, e$2.y, r$2.y, n$2.y), p$1 = Math.max(t$2.y, e$2.y, r$2.y, n$2.y);
				}
				return t$1.emplaceBack(e$1.x, e$1.y, e$1.z, r$1.x, r$1.y, d$1, h$1, f$1, p$1, a$1, n$1, i$1, s$1), t$1.length - 1;
			}
			function dx(t$1) {
				rg(t$1) && t$1.collisionPadding && (t$1.top -= t$1.collisionPadding[1], t$1.bottom += t$1.collisionPadding[3]);
				const e$1 = t$1.bottom - t$1.top;
				return e$1 > 0 ? Math.max(10, e$1) : null;
			}
			function fx(t$1, e$1, r$1, n$1) {
				const i$1 = t$1.compareText;
				if (e$1 in i$1) {
					const t$2 = i$1[e$1];
					for (let e$2 = t$2.length - 1; e$2 >= 0; e$2--) if (n$1.dist(t$2[e$2]) < r$1) return !0;
				} else i$1[e$1] = [];
				return i$1[e$1].push(n$1), !1;
			}
			function mx(t$1, e$1) {
				const r$1 = t$1.fovAboveCenter, n$1 = t$1.elevation ? t$1.elevation.getMinElevationBelowMSL() * e$1 : 0, i$1 = (t$1._camera.position[2] * t$1.worldSize - n$1) / Math.cos(t$1._pitch), s$1 = Math.sin(r$1) * i$1 / Math.sin(Math.max(Math.PI / 2 - t$1._pitch - r$1, .01));
				let o$1 = Math.sin(t$1._pitch) * s$1 + i$1;
				const a$1 = i$1 * (1 / t$1._horizonShift);
				if (!t$1.elevation || 0 === t$1.elevation.exaggeration()) {
					let e$2 = Math.max(t$1.zoom - 17, 0);
					t$1.isOrthographic && (e$2 /= 10), o$1 *= 1 + e$2;
				}
				return Math.min(1.01 * o$1, a$1);
			}
			function yx(t$1, e$1) {
				if (!e$1.isReprojectedInTileSpace) return {
					scale: 1 << t$1.z,
					x: t$1.x,
					y: t$1.y,
					x2: t$1.x + 1,
					y2: t$1.y + 1,
					projection: e$1
				};
				const r$1 = Math.pow(2, -t$1.z), n$1 = t$1.x * r$1, i$1 = (t$1.x + 1) * r$1, s$1 = t$1.y * r$1, o$1 = (t$1.y + 1) * r$1, a$1 = pu(n$1), l$1 = pu(i$1), u$1 = du(s$1), c$1 = du(o$1), h$1 = e$1.project(a$1, u$1), p$1 = e$1.project(l$1, u$1), d$1 = e$1.project(l$1, c$1), f$1 = e$1.project(a$1, c$1);
				let m$1 = Math.min(h$1.x, p$1.x, d$1.x, f$1.x), y$1 = Math.min(h$1.y, p$1.y, d$1.y, f$1.y), g$1 = Math.max(h$1.x, p$1.x, d$1.x, f$1.x), x$1 = Math.max(h$1.y, p$1.y, d$1.y, f$1.y);
				const v$1 = r$1 / 16;
				function b$1(t$2, r$2, n$2, i$2, s$2, o$2) {
					const a$2 = (n$2 + s$2) / 2, l$2 = (i$2 + o$2) / 2, u$2 = e$1.project(pu(a$2), du(l$2)), c$2 = Math.max(0, m$1 - u$2.x, y$1 - u$2.y, u$2.x - g$1, u$2.y - x$1);
					m$1 = Math.min(m$1, u$2.x), g$1 = Math.max(g$1, u$2.x), y$1 = Math.min(y$1, u$2.y), x$1 = Math.max(x$1, u$2.y), c$2 > v$1 && (b$1(t$2, u$2, n$2, i$2, a$2, l$2), b$1(u$2, r$2, a$2, l$2, s$2, o$2));
				}
				b$1(h$1, p$1, n$1, s$1, i$1, s$1), b$1(p$1, d$1, i$1, s$1, i$1, o$1), b$1(d$1, f$1, i$1, o$1, n$1, o$1), b$1(f$1, h$1, n$1, o$1, n$1, s$1), m$1 -= v$1, y$1 -= v$1, g$1 += v$1, x$1 += v$1;
				const w$1 = 1 / Math.max(g$1 - m$1, x$1 - y$1);
				return {
					scale: w$1,
					x: m$1 * w$1,
					y: y$1 * w$1,
					x2: g$1 * w$1,
					y2: x$1 * w$1,
					projection: e$1
				};
			}
			function gx(t$1, { x: e$1, y: r$1 }, n$1 = 0) {
				return new It(((e$1 - n$1) * t$1.scale - t$1.x) * Un, (r$1 * t$1.scale - t$1.y) * Un);
			}
			const xx = u(new Float32Array(16));
			class vx {
				constructor(t$1) {
					this.spec = t$1, this.name = t$1.name, this.wrap = !1, this.requiresDraping = !1, this.supportsWorldCopies = !1, this.supportsTerrain = !1, this.supportsFog = !1, this.supportsFreeCamera = !1, this.zAxisUnit = "meters", this.isReprojectedInTileSpace = !0, this.unsupportedLayers = ["custom"], this.center = [0, 0], this.range = [3.5, 7];
				}
				project(t$1, e$1) {
					return {
						x: 0,
						y: 0,
						z: 0
					};
				}
				unproject(t$1, e$1) {
					return new iu(0, 0);
				}
				projectTilePoint(t$1, e$1, r$1) {
					return {
						x: t$1,
						y: e$1,
						z: 0
					};
				}
				locationPoint(t$1, e$1, r$1, n$1 = !0) {
					return t$1._coordinatePoint(t$1.locationCoordinate(e$1, r$1), n$1);
				}
				pixelsPerMeter(t$1, e$1) {
					return hu(1, t$1) * e$1;
				}
				pixelSpaceConversion(t$1, e$1, r$1) {
					return 1;
				}
				farthestPixelDistance(t$1) {
					return mx(t$1, t$1.pixelsPerMeter);
				}
				pointCoordinate(t$1, e$1, r$1, n$1) {
					const i$1 = t$1.horizonLineFromTop(!1), s$1 = new It(e$1, Math.max(i$1, r$1));
					return t$1.rayIntersectionCoordinate(t$1.pointRayIntersection(s$1, n$1));
				}
				pointCoordinate3D(t$1, e$1, r$1) {
					const n$1 = new It(e$1, r$1);
					if (t$1.elevation) return t$1.elevation.pointCoordinate(n$1);
					{
						const e$2 = this.pointCoordinate(t$1, n$1.x, n$1.y, 0);
						return [
							e$2.x,
							e$2.y,
							e$2.z
						];
					}
				}
				isPointAboveHorizon(t$1, e$1) {
					if (t$1.elevation && t$1.elevation.visibleDemTiles.length) return !this.pointCoordinate3D(t$1, e$1.x, e$1.y);
					const r$1 = t$1.horizonLineFromTop();
					return e$1.y < r$1;
				}
				createInversionMatrix(t$1, e$1) {
					return xx;
				}
				createTileMatrix(t$1, e$1, r$1) {
					let n$1, i$1, s$1;
					const o$1 = r$1.canonical, a$1 = u(new Float64Array(16));
					if (this.isReprojectedInTileSpace) {
						const l$1 = yx(o$1, this);
						n$1 = 1, i$1 = l$1.x + r$1.wrap * l$1.scale, s$1 = l$1.y, d(a$1, a$1, [
							n$1 / l$1.scale,
							n$1 / l$1.scale,
							t$1.pixelsPerMeter / e$1
						]);
					} else n$1 = e$1 / t$1.zoomScale(o$1.z), i$1 = (o$1.x + Math.pow(2, o$1.z) * r$1.wrap) * n$1, s$1 = o$1.y * n$1;
					return p(a$1, a$1, [
						i$1,
						s$1,
						0
					]), d(a$1, a$1, [
						n$1 / Un,
						n$1 / Un,
						1
					]), a$1;
				}
				upVector(t$1, e$1, r$1) {
					return [
						0,
						0,
						1
					];
				}
				upVectorScale(t$1, e$1, r$1) {
					return { metersToTile: 1 };
				}
			}
			class bx extends vx {
				constructor(t$1) {
					super(t$1), this.range = [4, 7], this.center = t$1.center || [-96, 37.5];
					const [e$1, r$1] = this.parallels = t$1.parallels || [29.5, 45.5], n$1 = Math.sin(kt(e$1));
					this.n = (n$1 + Math.sin(kt(r$1))) / 2, this.c = 1 + n$1 * (2 * this.n - n$1), this.r0 = Math.sqrt(this.c) / this.n;
				}
				project(t$1, e$1) {
					const { n: r$1, c: n$1, r0: i$1 } = this, s$1 = kt(t$1 - this.center[0]), o$1 = kt(e$1), a$1 = Math.sqrt(n$1 - 2 * r$1 * Math.sin(o$1)) / r$1;
					return {
						x: a$1 * Math.sin(s$1 * r$1),
						y: a$1 * Math.cos(s$1 * r$1) - i$1,
						z: 0
					};
				}
				unproject(t$1, e$1) {
					const { n: r$1, c: n$1, r0: i$1 } = this, s$1 = i$1 + e$1;
					let o$1 = Math.atan2(t$1, Math.abs(s$1)) * Math.sign(s$1);
					s$1 * r$1 < 0 && (o$1 -= Math.PI * Math.sign(t$1) * Math.sign(s$1));
					const a$1 = kt(this.center[0]) * r$1;
					o$1 = Dt(o$1, -Math.PI - a$1, Math.PI - a$1);
					return new iu(Ft(Bt(o$1 / r$1) + this.center[0], -180, 180), Ft(Bt(Math.asin(Ft((n$1 - (t$1 * t$1 + s$1 * s$1) * r$1 * r$1) / (2 * r$1), -1, 1))), -mu, mu));
				}
			}
			const wx = 1.340264, _x = -.081106, Ax = 893e-6, Ix = .003796, Mx = Math.sqrt(3) / 2;
			class Sx extends vx {
				project(t$1, e$1) {
					e$1 = e$1 / 180 * Math.PI, t$1 = t$1 / 180 * Math.PI;
					const r$1 = Math.asin(Mx * Math.sin(e$1)), n$1 = r$1 * r$1, i$1 = n$1 * n$1 * n$1;
					return {
						x: .5 * (t$1 * Math.cos(r$1) / (Mx * (wx + 3 * _x * n$1 + i$1 * (7 * Ax + 9 * Ix * n$1))) / Math.PI + .5),
						y: 1 - .5 * (r$1 * (wx + _x * n$1 + i$1 * (Ax + Ix * n$1)) / Math.PI + 1),
						z: 0
					};
				}
				unproject(t$1, e$1) {
					t$1 = (2 * t$1 - .5) * Math.PI;
					let r$1 = e$1 = (2 * (1 - e$1) - 1) * Math.PI, n$1 = r$1 * r$1, i$1 = n$1 * n$1 * n$1;
					for (let t$2, s$2, o$2, a$1 = 0; a$1 < 12 && (s$2 = r$1 * (wx + _x * n$1 + i$1 * (Ax + Ix * n$1)) - e$1, o$2 = wx + 3 * _x * n$1 + i$1 * (7 * Ax + 9 * Ix * n$1), t$2 = s$2 / o$2, r$1 = Ft(r$1 - t$2, -Math.PI / 3, Math.PI / 3), n$1 = r$1 * r$1, i$1 = n$1 * n$1 * n$1, !(Math.abs(t$2) < 1e-12)); ++a$1);
					const s$1 = Mx * t$1 * (wx + 3 * _x * n$1 + i$1 * (7 * Ax + 9 * Ix * n$1)) / Math.cos(r$1), o$1 = Math.asin(Math.sin(r$1) / Mx);
					return new iu(Ft(180 * s$1 / Math.PI, -180, 180), Ft(180 * o$1 / Math.PI, -mu, mu));
				}
			}
			class Px extends vx {
				constructor(t$1) {
					super(t$1), this.wrap = !0, this.supportsWorldCopies = !0;
				}
				project(t$1, e$1) {
					return {
						x: .5 + t$1 / 360,
						y: .5 - e$1 / 360,
						z: 0
					};
				}
				unproject(t$1, e$1) {
					return new iu(360 * (t$1 - .5), Ft(360 * (.5 - e$1), -mu, mu));
				}
			}
			const kx = Math.PI / 2;
			function Bx(t$1) {
				return Math.tan((kx + t$1) / 2);
			}
			class zx extends vx {
				constructor(t$1) {
					super(t$1), this.center = t$1.center || [0, 30];
					const [e$1, r$1] = this.parallels = t$1.parallels || [30, 30];
					let n$1 = kt(e$1), i$1 = kt(r$1);
					this.southernCenter = n$1 + i$1 < 0, this.southernCenter && (n$1 = -n$1, i$1 = -i$1);
					const s$1 = Math.cos(n$1), o$1 = Bx(n$1);
					this.n = n$1 === i$1 ? Math.sin(n$1) : Math.log(s$1 / Math.cos(i$1)) / Math.log(Bx(i$1) / o$1), this.f = s$1 * Math.pow(Bx(n$1), this.n) / this.n;
				}
				project(t$1, e$1) {
					e$1 = kt(e$1), this.southernCenter && (e$1 = -e$1), t$1 = kt(t$1 - this.center[0]);
					const r$1 = 1e-6, { n: n$1, f: i$1 } = this;
					i$1 > 0 ? e$1 < -kx + r$1 && (e$1 = -kx + r$1) : e$1 > kx - r$1 && (e$1 = kx - r$1);
					const s$1 = i$1 / Math.pow(Bx(e$1), n$1);
					let o$1 = s$1 * Math.sin(n$1 * t$1), a$1 = i$1 - s$1 * Math.cos(n$1 * t$1);
					return o$1 = .5 * (o$1 / Math.PI + .5), a$1 = .5 * (a$1 / Math.PI + .5), {
						x: o$1,
						y: this.southernCenter ? a$1 : 1 - a$1,
						z: 0
					};
				}
				unproject(t$1, e$1) {
					t$1 = (2 * t$1 - .5) * Math.PI, this.southernCenter && (e$1 = 1 - e$1), e$1 = (2 * (1 - e$1) - .5) * Math.PI;
					const { n: r$1, f: n$1 } = this, i$1 = n$1 - e$1, s$1 = Math.sign(i$1), o$1 = Math.sign(r$1) * Math.sqrt(t$1 * t$1 + i$1 * i$1);
					let a$1 = Math.atan2(t$1, Math.abs(i$1)) * s$1;
					i$1 * r$1 < 0 && (a$1 -= Math.PI * Math.sign(t$1) * s$1);
					const l$1 = Ft(Bt(a$1 / r$1) + this.center[0], -180, 180), u$1 = Ft(Bt(2 * Math.atan(Math.pow(n$1 / o$1, 1 / r$1)) - kx), -mu, mu);
					return new iu(l$1, this.southernCenter ? -u$1 : u$1);
				}
			}
			class Tx extends vx {
				constructor(t$1) {
					super(t$1), this.wrap = !0, this.supportsWorldCopies = !0, this.supportsTerrain = !0, this.supportsFog = !0, this.supportsFreeCamera = !0, this.isReprojectedInTileSpace = !1, this.unsupportedLayers = [], this.range = null;
				}
				project(t$1, e$1) {
					return {
						x: uu(t$1),
						y: cu(e$1),
						z: 0
					};
				}
				unproject(t$1, e$1) {
					return new iu(pu(t$1), du(e$1));
				}
			}
			const Ex = kt(mu);
			class Vx extends vx {
				project(t$1, e$1) {
					const r$1 = (e$1 = kt(e$1)) * e$1, n$1 = r$1 * r$1;
					return {
						x: .5 * ((t$1 = kt(t$1)) * (.8707 - .131979 * r$1 + n$1 * (n$1 * (.003971 * r$1 - .001529 * n$1) - .013791)) / Math.PI + .5),
						y: 1 - .5 * (e$1 * (1.007226 + r$1 * (.015085 + n$1 * (.028874 * r$1 - .044475 - .005916 * n$1))) / Math.PI + 1),
						z: 0
					};
				}
				unproject(t$1, e$1) {
					t$1 = (2 * t$1 - .5) * Math.PI;
					let r$1 = e$1 = (2 * (1 - e$1) - 1) * Math.PI, n$1 = 25, i$1 = 0, s$1 = r$1 * r$1;
					do {
						s$1 = r$1 * r$1;
						const t$2 = s$1 * s$1;
						i$1 = (r$1 * (1.007226 + s$1 * (.015085 + t$2 * (.028874 * s$1 - .044475 - .005916 * t$2))) - e$1) / (1.007226 + s$1 * (.045255 + t$2 * (.259866 * s$1 - .311325 - .005916 * 11 * t$2))), r$1 = Ft(r$1 - i$1, -Ex, Ex);
					} while (Math.abs(i$1) > 1e-6 && --n$1 > 0);
					s$1 = r$1 * r$1;
					return new iu(Ft(Bt(t$1 / (.8707 + s$1 * (s$1 * (s$1 * s$1 * s$1 * (.003971 - .001529 * s$1) - .013791) - .131979))), -180, 180), Bt(r$1));
				}
			}
			const Fx = kt(mu);
			class Cx extends vx {
				project(t$1, e$1) {
					e$1 = kt(e$1), t$1 = kt(t$1);
					const r$1 = Math.cos(e$1), n$1 = 2 / Math.PI, i$1 = Math.acos(r$1 * Math.cos(t$1 / 2)), s$1 = Math.sin(i$1) / i$1, o$1 = .5 * (t$1 * n$1 + 2 * r$1 * Math.sin(t$1 / 2) / s$1) || 0, a$1 = .5 * (e$1 + Math.sin(e$1) / s$1) || 0;
					return {
						x: .5 * (o$1 / Math.PI + .5),
						y: 1 - .5 * (a$1 / Math.PI + 1),
						z: 0
					};
				}
				unproject(t$1, e$1) {
					let r$1 = t$1 = (2 * t$1 - .5) * Math.PI, n$1 = e$1 = (2 * (1 - e$1) - 1) * Math.PI, i$1 = 25;
					const s$1 = 1e-6;
					let o$1 = 0, a$1 = 0;
					do {
						const i$2 = Math.cos(n$1), s$2 = Math.sin(n$1), l$1 = 2 * s$2 * i$2, u$1 = s$2 * s$2, c$1 = i$2 * i$2, h$1 = Math.cos(r$1 / 2), p$1 = Math.sin(r$1 / 2), d$1 = 2 * h$1 * p$1, f$1 = p$1 * p$1, m$1 = 1 - c$1 * h$1 * h$1, y$1 = m$1 ? 1 / m$1 : 0, g$1 = m$1 ? Math.acos(i$2 * h$1) * Math.sqrt(1 / m$1) : 0, x$1 = .5 * (2 * g$1 * i$2 * p$1 + 2 * r$1 / Math.PI) - t$1, v$1 = .5 * (g$1 * s$2 + n$1) - e$1, b$1 = .5 * y$1 * (c$1 * f$1 + g$1 * i$2 * h$1 * u$1) + 1 / Math.PI, w$1 = y$1 * (d$1 * l$1 / 4 - g$1 * s$2 * p$1), _$1 = .125 * y$1 * (l$1 * p$1 - g$1 * s$2 * c$1 * d$1), A$1 = .5 * y$1 * (u$1 * h$1 + g$1 * f$1 * i$2) + .5, I$1 = w$1 * _$1 - A$1 * b$1;
						o$1 = (v$1 * w$1 - x$1 * A$1) / I$1, a$1 = (x$1 * _$1 - v$1 * b$1) / I$1, r$1 = Ft(r$1 - o$1, -Math.PI, Math.PI), n$1 = Ft(n$1 - a$1, -Fx, Fx);
					} while ((Math.abs(o$1) > s$1 || Math.abs(a$1) > s$1) && --i$1 > 0);
					return new iu(Bt(r$1), Bt(n$1));
				}
			}
			class Dx extends vx {
				constructor(t$1) {
					super(t$1), this.center = t$1.center || [0, 0], this.parallels = t$1.parallels || [0, 0], this.cosPhi = Math.max(.01, Math.cos(kt(this.parallels[0]))), this.scale = 1 / (2 * Math.max(Math.PI * this.cosPhi, 1 / this.cosPhi)), this.wrap = !0, this.supportsWorldCopies = !0;
				}
				project(t$1, e$1) {
					const { scale: r$1, cosPhi: n$1 } = this;
					return {
						x: kt(t$1) * n$1 * r$1 + .5,
						y: -Math.sin(kt(e$1)) / n$1 * r$1 + .5,
						z: 0
					};
				}
				unproject(t$1, e$1) {
					const { scale: r$1, cosPhi: n$1 } = this, i$1 = -(e$1 - .5) / r$1;
					return new iu(Ft(Bt((t$1 - .5) / r$1) / n$1, -180, 180), Ft(Bt(Math.asin(Ft(i$1 * n$1, -1, 1))), -mu, mu));
				}
			}
			class Rx extends Tx {
				constructor(t$1) {
					super(t$1), this.requiresDraping = !0, this.supportsWorldCopies = !1, this.supportsFog = !0, this.zAxisUnit = "pixels", this.unsupportedLayers = ["debug"], this.range = [3, 5];
				}
				projectTilePoint(t$1, e$1, r$1) {
					const n$1 = Xc(t$1, e$1, r$1);
					return j(n$1, n$1, Yc(Nc(r$1))), {
						x: n$1[0],
						y: n$1[1],
						z: n$1[2]
					};
				}
				locationPoint(t$1, e$1, r$1) {
					const n$1 = eu(e$1.lat, e$1.lng), i$1 = L([], n$1), s$1 = r$1 ? t$1._centerAltitude + r$1 : t$1.elevation ? t$1.elevation.getAtPointOrZero(t$1.locationCoordinate(e$1), t$1._centerAltitude) : t$1._centerAltitude;
					V(n$1, n$1, i$1, hu(1, 0) * Un * s$1);
					const o$1 = u(new Float64Array(16));
					return h(o$1, t$1.pixelMatrix, t$1.globeMatrix), j(n$1, n$1, o$1), new It(n$1[0], n$1[1]);
				}
				pixelsPerMeter(t$1, e$1) {
					return hu(1, 0) * e$1;
				}
				pixelSpaceConversion(t$1, e$1, r$1) {
					const n$1 = hu(1, t$1) * e$1, i$1 = pr(hu(1, 45) * e$1, n$1, r$1);
					return this.pixelsPerMeter(t$1, e$1) / i$1;
				}
				createTileMatrix(t$1, e$1, r$1) {
					const n$1 = Kc(Nc(r$1.canonical));
					return h(new Float64Array(16), t$1.globeMatrix, n$1);
				}
				createInversionMatrix(t$1, e$1) {
					const { center: r$1 } = t$1, n$1 = Yc(Nc(e$1));
					return m(n$1, n$1, kt(r$1.lng)), f(n$1, n$1, kt(r$1.lat)), d(n$1, n$1, [
						t$1._pixelsPerMercatorPixel,
						t$1._pixelsPerMercatorPixel,
						1
					]), Float32Array.from(n$1);
				}
				pointCoordinate(t$1, e$1, r$1, n$1) {
					return Lc(t$1, e$1, r$1, !0) || new bu(0, 0);
				}
				pointCoordinate3D(t$1, e$1, r$1) {
					const n$1 = this.pointCoordinate(t$1, e$1, r$1, 0);
					return [
						n$1.x,
						n$1.y,
						n$1.z
					];
				}
				isPointAboveHorizon(t$1, e$1) {
					return !Lc(t$1, e$1.x, e$1.y, !1);
				}
				farthestPixelDistance(t$1) {
					const e$1 = function(t$2, e$2) {
						const r$2 = t$2.cameraToCenterDistance, n$1 = t$2._centerAltitude * e$2, i$1 = t$2._camera, s$1 = t$2._camera.forward(), o$1 = P([], E([], s$1, -r$2), [
							0,
							0,
							n$1
						]), a$1 = t$2.worldSize / (2 * Math.PI), l$1 = [
							0,
							0,
							-a$1
						], u$1 = t$2.width / t$2.height, c$1 = Math.tan(t$2.fovAboveCenter), h$1 = E([], i$1.up(), c$1), p$1 = E([], i$1.right(), c$1 * u$1), d$1 = L([], P([], P([], s$1, h$1), p$1)), f$1 = [];
						let m$1;
						if (new qu(o$1, d$1).closestPointOnSphere(l$1, a$1, f$1)) {
							const r$3 = X([], P([], f$1, l$1), o$1);
							m$1 = Math.cos(t$2.fovAboveCenter) * I(r$3);
						} else {
							const t$3 = X([], o$1, l$1), e$3 = X([], l$1, o$1);
							L(e$3, e$3);
							const r$3 = I(t$3) - a$1;
							m$1 = Math.sqrt(r$3 * (r$3 + 2 * a$1));
							const n$2 = Math.acos(m$1 / (a$1 + r$3)) - Math.acos(O(s$1, e$3));
							m$1 *= Math.cos(n$2);
						}
						return 1.01 * m$1;
					}(t$1, this.pixelsPerMeter(t$1.center.lat, t$1.worldSize)), r$1 = eh(t$1.zoom);
					if (r$1 > 0) {
						const n$1 = mx(t$1, hu(1, t$1.center.lat) * t$1.worldSize), i$1 = t$1.worldSize / (2 * Math.PI), s$1 = Math.max(t$1.width, t$1.height) / t$1.worldSize * Math.PI;
						return pr(e$1, n$1 + i$1 * (1 - Math.cos(s$1)), Math.pow(r$1, 10));
					}
					return e$1;
				}
				upVector(t$1, e$1, r$1) {
					return Xc(e$1, r$1, t$1, 1);
				}
				upVectorScale(t$1) {
					return { metersToTile: Dc(Zc(Nc(t$1))) };
				}
			}
			function Lx(t$1) {
				const e$1 = t$1.parallels, r$1 = !!e$1 && Math.abs(e$1[0] + e$1[1]) < .01;
				switch (t$1.name) {
					case "mercator": return new Tx(t$1);
					case "equirectangular": return new Px(t$1);
					case "naturalEarth": return new Vx(t$1);
					case "equalEarth": return new Sx(t$1);
					case "winkelTripel": return new Cx(t$1);
					case "albers": return r$1 ? new Dx(t$1) : new bx(t$1);
					case "lambertConformalConic": return r$1 ? new Dx(t$1) : new zx(t$1);
					case "globe": return new Rx(t$1);
				}
				throw new Error(`Invalid projection name: ${t$1.name}`);
			}
			const Ox = zu.types, Ux = [{
				name: "a_fade_opacity",
				components: 1,
				type: "Uint8",
				offset: 0
			}];
			function Nx(t$1, e$1, r$1, n$1, i$1, s$1, o$1, a$1, l$1, u$1, c$1, h$1, p$1) {
				const d$1 = a$1 ? Math.min(ux, Math.round(a$1[0])) : 0, f$1 = a$1 ? Math.min(ux, Math.round(a$1[1])) : 0;
				t$1.emplaceBack(e$1, r$1, Math.round(32 * n$1), Math.round(32 * i$1), s$1, o$1, (d$1 << 1) + (l$1 ? 1 : 0), 0 + (f$1 << 1), 16 * u$1, 16 * c$1, 256 * h$1, 256 * p$1);
			}
			function jx(t$1, e$1, r$1) {
				t$1.emplaceBack(e$1, r$1);
			}
			function $x(t$1, e$1, r$1, n$1, i$1, s$1, o$1) {
				t$1.emplaceBack(e$1, r$1, n$1, i$1, s$1, o$1);
			}
			const Gx = (t$1, e$1, r$1, n$1) => {
				for (let i$1 = 0; i$1 < e$1; i$1++) t$1.emplaceBack(r$1[0], r$1[1], r$1[2], n$1[0], n$1[1], n$1[2]);
			};
			function qx(t$1, e$1, r$1, n$1, i$1) {
				t$1.emplaceBack(e$1, r$1, n$1, i$1), t$1.emplaceBack(e$1, r$1, n$1, i$1), t$1.emplaceBack(e$1, r$1, n$1, i$1), t$1.emplaceBack(e$1, r$1, n$1, i$1);
			}
			function Hx(t$1) {
				for (const e$1 of t$1.sections) if (po(e$1.text)) return !0;
				return !1;
			}
			class Xx {
				constructor(t$1) {
					this.layoutVertexArray = new Ma(), this.indexArray = new Fa(), this.programConfigurations = t$1, this.segments = new hl(), this.dynamicLayoutVertexArray = new Pa(), this.opacityVertexArray = new ka(), this.placedSymbolArray = new Ja(), this.iconTransitioningVertexArray = new Ba(), this.globeExtVertexArray = new Sa(), this.zOffsetVertexArray = new ya(), this.orientationVertexArray = new Ra(), this.symbolInstanceIndices = [];
				}
				isEmpty() {
					return 0 === this.layoutVertexArray.length && 0 === this.indexArray.length && 0 === this.dynamicLayoutVertexArray.length && 0 === this.opacityVertexArray.length && 0 === this.iconTransitioningVertexArray.length;
				}
				getIconVertexData(t$1, e$1) {
					const r$1 = [], n$1 = this.layoutVertexArray.uint16;
					for (let i$1 = 0; i$1 < e$1; ++i$1) {
						const e$2 = 12 * (t$1 + i$1);
						r$1.push(...n$1.slice(e$2, e$2 + 12));
					}
					return r$1;
				}
				updateIconVertexData(t$1, e$1, r$1, n$1, i$1, s$1, o$1, a$1, l$1, u$1, c$1, h$1, p$1) {
					const d$1 = this.layoutVertexArray.uint16, f$1 = 12 * t$1;
					d$1[f$1] = e$1, d$1[f$1 + 1] = r$1, d$1[f$1 + 2] = n$1, d$1[f$1 + 3] = i$1, d$1[f$1 + 4] = s$1, d$1[f$1 + 5] = o$1, d$1[f$1 + 6] = a$1, d$1[f$1 + 7] = l$1, d$1[f$1 + 8] = u$1, d$1[f$1 + 9] = c$1, d$1[f$1 + 10] = h$1, d$1[f$1 + 11] = p$1;
				}
				upload(t$1, e$1, r$1, n$1, i$1, s$1) {
					this.isEmpty() || (r$1 && (this.layoutVertexBuffer = t$1.createVertexBuffer(this.layoutVertexArray, ly.members, !!s$1), this.indexBuffer = t$1.createIndexBuffer(this.indexArray, e$1), this.dynamicLayoutVertexBuffer = t$1.createVertexBuffer(this.dynamicLayoutVertexArray, cy.members, !0), this.opacityVertexBuffer = t$1.createVertexBuffer(this.opacityVertexArray, Ux, !0), this.iconTransitioningVertexArray.length > 0 && (this.iconTransitioningVertexBuffer = t$1.createVertexBuffer(this.iconTransitioningVertexArray, dy.members, !0)), this.globeExtVertexArray.length > 0 && (this.globeExtVertexBuffer = t$1.createVertexBuffer(this.globeExtVertexArray, uy.members, !0)), !this.zOffsetVertexBuffer && (this.zOffsetVertexArray.length > 0 || i$1) && (this.zOffsetVertexBuffer = t$1.createVertexBuffer(this.zOffsetVertexArray, hy.members, !0)), !this.orientationVertexBuffer && this.orientationVertexArray && this.orientationVertexArray.length > 0 && (this.orientationVertexBuffer = t$1.createVertexBuffer(this.orientationVertexArray, py.members, !0)), this.opacityVertexBuffer.itemSize = 1), (r$1 || n$1) && this.programConfigurations.upload(t$1));
				}
				destroy() {
					this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy(), this.iconTransitioningVertexBuffer && this.iconTransitioningVertexBuffer.destroy(), this.globeExtVertexBuffer && this.globeExtVertexBuffer.destroy(), this.zOffsetVertexBuffer && this.zOffsetVertexBuffer.destroy(), this.orientationVertexBuffer && this.orientationVertexBuffer.destroy());
				}
			}
			Qs(Xx, "SymbolBuffers");
			class Zx {
				constructor(t$1, e$1, r$1) {
					this.layoutVertexArray = new t$1(), this.layoutAttributes = e$1, this.indexArray = new r$1(), this.segments = new hl(), this.collisionVertexArray = new Va(), this.collisionVertexArrayExt = new Pa();
				}
				upload(t$1) {
					this.layoutVertexBuffer = t$1.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = t$1.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = t$1.createVertexBuffer(this.collisionVertexArray, fy.members, !0), this.collisionVertexBufferExt = t$1.createVertexBuffer(this.collisionVertexArrayExt, my.members, !0);
				}
				destroy() {
					this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy(), this.collisionVertexBufferExt.destroy());
				}
			}
			Qs(Zx, "CollisionBuffers");
			class Wx {
				constructor(t$1) {
					this.collisionBoxArray = t$1.collisionBoxArray, this.zoom = t$1.zoom, this.overscaling = t$1.overscaling, this.layers = t$1.layers, this.layerIds = this.layers.map(((t$2) => t$2.fqid)), this.index = t$1.index, this.pixelRatio = t$1.pixelRatio, this.sourceLayerIndex = t$1.sourceLayerIndex, this.hasPattern = !1, this.hasRTLText = !1, this.fullyClipped = !1, this.hasAnyIconTextFit = !1, this.sortKeyRanges = [], this.collisionCircleArray = [], this.placementInvProjMatrix = u([]), this.placementViewportMatrix = u([]);
					const e$1 = this.layers[0]._unevaluatedLayout._values;
					this.worldview = t$1.worldview, this.localizable = t$1.localizable, this.textSizeData = ug(this.zoom, e$1["text-size"], this.worldview), this.iconSizeData = ug(this.zoom, e$1["icon-size"], this.worldview);
					const r$1 = this.layers[0].layout, n$1 = r$1.get("symbol-sort-key"), i$1 = r$1.get("symbol-z-order");
					this.lut = t$1.lut, this.canOverlap = r$1.get("text-allow-overlap") || r$1.get("icon-allow-overlap") || r$1.get("text-ignore-placement") || r$1.get("icon-ignore-placement"), this.sortFeaturesByKey = "viewport-y" !== i$1 && void 0 !== n$1.constantOr(1), this.sortFeaturesByY = ("viewport-y" === i$1 || "auto" === i$1 && !this.sortFeaturesByKey) && this.canOverlap, this.writingModes = r$1.get("text-writing-mode").map(((t$2) => $y[t$2])), this.stateDependentLayerIds = this.layers.filter(((t$2) => t$2.isStateDependent())).map(((t$2) => t$2.id)), this.sourceID = t$1.sourceID, this.projection = t$1.projection, this.hasAnyZOffset = !1, this.zOffsetSortDirty = !1, this.zOffsetBuffersNeedUpload = !1, this.elevationType = "none", this.elevationStateComplete = !1, this.activeReplacements = [], this.replacementUpdateTime = 0, this.hasAnySecondaryIcon = !1, this.hasAppearances = null, this.lastActiveApperance = null, this.featureToAppearanceIndex = {};
				}
				hasAnyAppearanceProperty(t$1) {
					const e$1 = this.layers[0].getAppearances();
					return !(!e$1 || 0 === e$1.length) && e$1.some(((e$2) => null != e$2.getProperty(t$1)));
				}
				createArrays() {
					this.text = new Xx(new Ul(this.layers, {
						zoom: this.zoom,
						lut: this.lut
					}, ((t$1) => t$1.startsWith("text") || t$1.startsWith("symbol")))), this.icon = new Xx(new Ul(this.layers, {
						zoom: this.zoom,
						lut: this.lut
					}, ((t$1) => t$1.startsWith("icon") || t$1.startsWith("symbol")))), this.glyphOffsetArray = new el(), this.lineVertexArray = new rl(), this.symbolInstances = new tl();
				}
				calculateGlyphDependencies(t$1, e$1, r$1, n$1, i$1) {
					for (const r$2 of t$1) {
						const t$2 = r$2.codePointAt(0);
						if (void 0 === t$2) break;
						if (e$1[t$2] = !0, n$1 && i$1 && t$2 <= 65535) {
							const t$3 = by[r$2];
							t$3 && (e$1[t$3.charCodeAt(0)] = !0);
						}
					}
				}
				calculateEffectiveAppearanceIconSize(t$1, e$1, r$1, n$1, i$1, s$1) {
					let o$1 = 1;
					const a$1 = t$1.getUnevaluatedProperties()._values["icon-size"], l$1 = ug(this.zoom, a$1, this.worldview), u$1 = hg(l$1, e$1);
					if ("constant" !== l$1.kind && "camera" !== l$1.kind || (o$1 = u$1.uSize), "composite" === l$1.kind) {
						const { minZoom: t$2, maxZoom: e$2 } = l$1, s$2 = a$1.possiblyEvaluate(new Io(t$2, { worldview: this.worldview }), n$1), c$1 = a$1.possiblyEvaluate(new Io(e$2, { worldview: this.worldview }), n$1), h$1 = s$2.evaluate(r$1, {}, n$1, i$1);
						o$1 = h$1 + (c$1.evaluate(r$1, {}, n$1, i$1) - h$1) * u$1.uSizeT;
					}
					return "source" === l$1.kind && (o$1 = a$1.possiblyEvaluate(new Io(this.zoom, { worldview: this.worldview }), n$1).evaluate(r$1, {}, n$1, i$1)), o$1 * s$1;
				}
				updateFootprints(t$1, e$1) {}
				updateReplacement(t$1, e$1) {
					if (e$1.updateTime === this.replacementUpdateTime) return !1;
					this.replacementUpdateTime = e$1.updateTime;
					const r$1 = e$1.getReplacementRegionsForTile(t$1.toUnwrapped(), !0);
					return !jp(this.activeReplacements, r$1) && (this.activeReplacements = r$1, !0);
				}
				getResolvedImageFromTokens(t$1) {
					return "string" == typeof t$1 ? Lr.build(t$1) : t$1;
				}
				populate(t$1, e$1, r$1, n$1) {
					const i$1 = this.layers[0], s$1 = i$1.layout, o$1 = "globe" === this.projection.name, a$1 = s$1.get("text-font"), l$1 = s$1.get("text-field"), u$1 = s$1.get("icon-image"), [c$1, h$1] = s$1.get("icon-size-scale-range"), p$1 = Ft(e$1.scaleFactor || 1, c$1, h$1), d$1 = ("constant" !== l$1.value.kind || l$1.value.value instanceof Dr && !l$1.value.value.isEmpty() || l$1.value.value.toString().length > 0) && ("constant" !== a$1.value.kind || a$1.value.value.length > 0), f$1 = "constant" !== u$1.value.kind || !!u$1.value.value || Object.keys(u$1.parameters).length > 0, m$1 = this.hasAnyAppearanceProperty("icon-image"), y$1 = s$1.get("symbol-sort-key");
					if (this.features = [], this.appearanceFeatureData = [], !d$1 && !f$1 && !m$1) return;
					const g$1 = e$1.iconDependencies, x$1 = e$1.glyphDependencies, v$1 = e$1.availableImages, b$1 = new Io(this.zoom, {
						worldview: this.worldview,
						activeFloors: e$1.activeFloors
					}), w$1 = (t$2) => {
						const e$2 = t$2.id.toString();
						g$1.has(e$2) ? g$1.get(e$2).push(t$2) : g$1.set(e$2, [t$2]);
					};
					for (const e$2 of t$1) {
						const { feature: t$2, id: l$2, index: u$2, sourceLayerIndex: c$2 } = e$2, h$2 = i$1._featureFilter.needGeometry, _$1 = Bu(t$2, h$2);
						if (!i$1._featureFilter.filter(b$1, _$1, r$1)) continue;
						if (h$2 || (_$1.geometry = ku(t$2, r$1, n$1)), o$1 && 1 !== t$2.type && r$1.z <= 5) {
							const t$3 = _$1.geometry, e$3 = .98078528056, n$2 = (t$4, n$3) => O(Xc(t$4.x, t$4.y, r$1, 1), Xc(n$3.x, n$3.y, r$1, 1)) < e$3;
							for (let e$4 = 0; e$4 < t$3.length; e$4++) t$3[e$4] = Iu(t$3[e$4], n$2);
						}
						let A$1, I$1;
						if (d$1) {
							const t$3 = i$1.getValueAndResolveTokens("text-field", _$1, r$1, v$1), e$3 = Dr.factory(t$3);
							Hx(e$3) && (this.hasRTLText = !0), (!this.hasRTLText || "unavailable" === wo() || this.hasRTLText && Ao.isParsed()) && (A$1 = vy(e$3, i$1, _$1));
						}
						if (f$1) {
							const t$3 = i$1.getValueAndResolveTokens("icon-image", _$1, r$1, v$1);
							I$1 = this.getResolvedImageFromTokens(t$3);
						}
						const M$1 = this.layers[0];
						let S$1 = !1;
						if (!I$1 && m$1) {
							const t$3 = M$1.getAppearances();
							for (const e$3 of t$3) if (e$3.getProperty("icon-image")) {
								const t$4 = M$1.getAppearanceValueAndResolveTokens(e$3, "icon-image", _$1, r$1, v$1);
								if (t$4) {
									I$1 = this.getResolvedImageFromTokens(t$4), S$1 = !0;
									break;
								}
							}
						}
						if (!A$1 && !I$1) continue;
						const P$1 = this.sortFeaturesByKey ? y$1.evaluate(_$1, {}, r$1) : void 0, k$1 = {
							id: l$2,
							text: A$1,
							icon: I$1,
							index: u$2,
							sourceLayerIndex: c$2,
							geometry: _$1.geometry,
							properties: t$2.properties,
							type: Ox[t$2.type],
							sortKey: P$1
						};
						if (this.features.push(k$1), this.featureToAppearanceIndex[u$2] = this.appearanceFeatureData.length, this.appearanceFeatureData.push({
							id: l$2,
							properties: t$2.properties,
							usesAppearanceIconAsPlaceholder: S$1,
							isUsingAppearanceVertexData: !1,
							layoutBasedVertexData: [],
							activeAppearance: null
						}), I$1) {
							const t$3 = M$1._unevaluatedLayout._values, { iconPrimary: e$3, iconSecondary: n$2 } = tx(I$1, this.iconSizeData, t$3["icon-size"], r$1, this.zoom, k$1, this.pixelRatio, p$1, this.worldview);
							w$1(e$3), n$2 && (this.hasAnySecondaryIcon = !0, w$1(n$2));
						}
						const B$1 = M$1.getAppearances();
						if (0 !== B$1.length && B$1.forEach(((t$3) => {
							if (!t$3.getProperty("icon-image")) return;
							const e$3 = this.getCombinedIconPrimary(t$3, M$1, _$1, r$1, v$1, k$1, p$1);
							e$3 && w$1(e$3);
						})), A$1) {
							const t$3 = a$1.evaluate(_$1, {}, r$1).join(","), e$3 = "map" === s$1.get("text-rotation-alignment") && "point" !== s$1.get("symbol-placement");
							this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf($y.vertical) >= 0;
							for (const r$2 of A$1.sections) if (r$2.image) {
								const t$4 = r$2.image.getPrimary().scaleSelf(this.pixelRatio), e$4 = t$4.id.toString(), n$2 = g$1.get(e$4) || [];
								n$2.push(t$4), g$1.set(e$4, n$2);
							} else {
								const n$2 = io(A$1.toString()), i$2 = r$2.fontStack || t$3, s$2 = x$1[i$2] = x$1[i$2] || {};
								this.calculateGlyphDependencies(r$2.text, s$2, e$3, this.allowVerticalPlacement, n$2);
							}
						}
					}
					if ("line" === s$1.get("symbol-placement") && (this.features = function(t$2) {
						const e$2 = {}, r$2 = {}, n$2 = [];
						let i$2 = 0;
						function s$2(e$3) {
							n$2.push(t$2[e$3]), i$2++;
						}
						function o$2(t$3, e$3, i$3) {
							const s$3 = r$2[t$3];
							return delete r$2[t$3], r$2[e$3] = s$3, n$2[s$3].geometry[0].pop(), n$2[s$3].geometry[0] = n$2[s$3].geometry[0].concat(i$3[0]), s$3;
						}
						function a$2(t$3, r$3, i$3) {
							const s$3 = e$2[r$3];
							return delete e$2[r$3], e$2[t$3] = s$3, n$2[s$3].geometry[0].shift(), n$2[s$3].geometry[0] = i$3[0].concat(n$2[s$3].geometry[0]), s$3;
						}
						function l$2(t$3, e$3, r$3) {
							const n$3 = r$3 ? e$3[0][e$3[0].length - 1] : e$3[0][0];
							return `${t$3}:${n$3.x}:${n$3.y}`;
						}
						for (let u$2 = 0; u$2 < t$2.length; u$2++) {
							const c$2 = t$2[u$2], h$2 = c$2.geometry, p$2 = c$2.text ? c$2.text.toString() : null;
							if (!p$2) {
								s$2(u$2);
								continue;
							}
							const d$2 = l$2(p$2, h$2), f$2 = l$2(p$2, h$2, !0);
							if (d$2 in r$2 && f$2 in e$2 && r$2[d$2] !== e$2[f$2]) {
								const t$3 = a$2(d$2, f$2, h$2), i$3 = o$2(d$2, f$2, n$2[t$3].geometry);
								delete e$2[d$2], delete r$2[f$2], r$2[l$2(p$2, n$2[i$3].geometry, !0)] = i$3, n$2[t$3].geometry = null;
							} else d$2 in r$2 ? o$2(d$2, f$2, h$2) : f$2 in e$2 ? a$2(d$2, f$2, h$2) : (s$2(u$2), e$2[d$2] = i$2 - 1, r$2[f$2] = i$2 - 1);
						}
						return n$2.filter(((t$3) => t$3.geometry));
					}(this.features)), "hd-road-markup" === s$1.get("symbol-elevation-reference")) {
						if (this.elevationType = "road", e$1.elevationFeatures) {
							!this.elevationFeatures && e$1.elevationFeatures.length > 0 && (this.elevationFeatures = [], this.elevationFeatureIdToIndex = /* @__PURE__ */ new Map());
							for (const t$2 of e$1.elevationFeatures) this.elevationFeatureIdToIndex.set(t$2.id, this.elevationFeatures.length), this.elevationFeatures.push(t$2);
						}
					} else s$1.get("symbol-z-elevate") && (this.elevationType = "offset");
					"none" !== this.elevationType && (this.zOffsetBuffersNeedUpload = !0), this.sortFeaturesByKey && this.features.sort(((t$2, e$2) => t$2.sortKey - e$2.sortKey));
				}
				getCombinedIconPrimary(t$1, e$1, r$1, n$1, i$1, s$1, o$1) {
					let a$1, l$1;
					const u$1 = t$1.getUnevaluatedProperties();
					if (void 0 !== u$1._values["icon-image"].value) {
						const s$2 = e$1.getAppearanceValueAndResolveTokens(t$1, "icon-image", r$1, n$1, i$1);
						a$1 = this.getResolvedImageFromTokens(s$2);
					} else {
						const t$2 = e$1.getValueAndResolveTokens("icon-image", r$1, n$1, i$1);
						a$1 = this.getResolvedImageFromTokens(t$2);
					}
					if (a$1) {
						const t$2 = u$1._values["icon-size"] || e$1._unevaluatedLayout._values["icon-size"];
						l$1 = tx(a$1, ug(this.zoom, t$2, this.worldview), t$2, n$1, this.zoom, s$1, this.pixelRatio, o$1, this.worldview).iconPrimary;
					}
					return l$1;
				}
				updateAppearanceBasedIconTextures(t$1, e$1, r$1, n$1) {
					if (!this.appearanceFeatureData) return !1;
					if (!this.icon.layoutVertexArray || 0 === this.icon.layoutVertexArray.length) return !1;
					const i$1 = this.layers[0];
					let s$1 = !1, o$1 = 0;
					const [l$1, u$1] = i$1.layout.get("icon-size-scale-range"), c$1 = Ft(1, l$1, u$1);
					for (let a$1 = 0; a$1 < this.symbolInstances.length; a$1++) {
						const l$2 = this.symbolInstances.get(a$1), u$2 = this.featureToAppearanceIndex[l$2.featureIndex], h$1 = void 0 !== u$2 ? this.appearanceFeatureData[u$2] : void 0;
						if (h$1 && l$2.placedIconSymbolIndex >= 0) {
							const a$2 = h$1.id, u$3 = e$1 && void 0 !== a$2 ? e$1[String(a$2)] : void 0, p$1 = {
								type: "Point",
								id: h$1.id,
								properties: h$1.properties,
								geometry: []
							}, d$1 = this.layers[0].appearances && this.layers[0].appearances.find(((e$2) => e$2.isActive({
								globals: n$1,
								feature: p$1,
								canonical: t$1,
								featureState: u$3
							})));
							if (h$1.activeAppearance === d$1) {
								o$1 += l$2.numIconVertices;
								continue;
							}
							if (d$1) {
								h$1.activeAppearance = d$1;
								const e$2 = this.getCombinedIconPrimary(d$1, i$1, p$1, t$1, r$1, {
									sortKey: void 0,
									text: void 0,
									icon: null,
									index: l$2.featureIndex,
									sourceLayerIndex: l$2.featureIndex,
									geometry: [],
									properties: h$1.properties,
									type: "Point",
									id: h$1.id
								}, c$1);
								if (!e$2) continue;
								const a$3 = e$2.toString(), u$4 = this.iconAtlasPositions && this.iconAtlasPositions.get(a$3);
								if (u$4) {
									const e$3 = i$1.getAppearanceValueAndResolveTokens(d$1, "icon-offset", p$1, t$1, r$1), a$4 = e$3 && Array.isArray(e$3) ? e$3 : [0, 0];
									let f$1 = ng(u$4, void 0, a$4, i$1.layout.get("icon-anchor").evaluate(p$1, {}, t$1));
									const m$1 = i$1.getAppearanceValueAndResolveTokens(d$1, "icon-rotate", p$1, t$1, r$1), y$1 = "number" == typeof m$1 ? m$1 : 0, g$1 = u$4.sdf, x$1 = i$1.layout.get("icon-text-fit").constantOr("none");
									"none" !== x$1 && h$1.textShaping && h$1.iconTextFitPadding && h$1.fontScale && (f$1 = ig(f$1, h$1.textShaping, x$1, h$1.iconTextFitPadding, a$4, h$1.fontScale));
									const v$1 = this.calculateEffectiveAppearanceIconSize(d$1, n$1.zoom, p$1, t$1, r$1, c$1), b$1 = 0, w$1 = 1 + (Math.min(ux, Math.round(v$1 * lg)) << 1), _$1 = Vg(f$1, y$1, g$1, "none" !== x$1, c$1);
									h$1.isUsingAppearanceVertexData || (h$1.isUsingAppearanceVertexData = !0, h$1.layoutBasedVertexData = this.icon.getIconVertexData(o$1, l$2.numIconVertices));
									for (let t$2 = 0; t$2 < _$1.length; ++t$2) {
										const e$4 = _$1[t$2], r$2 = h$1.layoutBasedVertexData[0] || l$2.tileAnchorX, n$2 = h$1.layoutBasedVertexData[1] || l$2.tileAnchorY, i$2 = 16 * e$4.pixelOffsetTL.x, s$2 = 16 * e$4.pixelOffsetTL.y, a$5 = 16 * e$4.pixelOffsetBR.x, u$5 = 16 * e$4.pixelOffsetBR.y, c$2 = 16 * e$4.minFontScaleX, p$2 = 16 * e$4.minFontScaleY;
										this.icon.updateIconVertexData(o$1, r$2, n$2, Math.round(32 * e$4.tl.x), Math.round(32 * e$4.tl.y), e$4.texPrimary.x, e$4.texPrimary.y, b$1, w$1, i$2, s$2, c$2, p$2), this.icon.updateIconVertexData(o$1 + 1, r$2, n$2, Math.round(32 * e$4.tr.x), Math.round(32 * e$4.tr.y), e$4.texPrimary.x + e$4.texPrimary.w, e$4.texPrimary.y, b$1, w$1, a$5, s$2, c$2, p$2), this.icon.updateIconVertexData(o$1 + 2, r$2, n$2, Math.round(32 * e$4.bl.x), Math.round(32 * e$4.bl.y), e$4.texPrimary.x, e$4.texPrimary.y + e$4.texPrimary.h, b$1, w$1, i$2, u$5, c$2, p$2), this.icon.updateIconVertexData(o$1 + 3, r$2, n$2, Math.round(32 * e$4.br.x), Math.round(32 * e$4.br.y), e$4.texPrimary.x + e$4.texPrimary.w, e$4.texPrimary.y + e$4.texPrimary.h, b$1, w$1, a$5, u$5, c$2, p$2), o$1 += 4;
									}
									const A$1 = l$2.numIconVertices - 4 * _$1.length;
									for (let t$2 = 0; t$2 < A$1; ++t$2) this.icon.updateIconVertexData(o$1 + t$2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
									s$1 = !0;
								} else o$1 += l$2.numIconVertices;
							} else if (h$1.usesAppearanceIconAsPlaceholder) this.layers[0].appearances && this.layers[0].appearances.length > 0 && (this.icon.updateIconVertexData(o$1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0), this.icon.updateIconVertexData(o$1 + 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0), this.icon.updateIconVertexData(o$1 + 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0), this.icon.updateIconVertexData(o$1 + 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0), s$1 = !0), o$1 += l$2.numIconVertices, h$1.activeAppearance = null;
							else if (h$1.isUsingAppearanceVertexData) {
								const t$2 = 12, e$2 = h$1.layoutBasedVertexData.length / t$2;
								for (let r$2 = 0; r$2 < e$2; ++r$2) {
									const e$3 = r$2 * t$2;
									this.icon.updateIconVertexData(o$1 + r$2, h$1.layoutBasedVertexData[e$3 + 0], h$1.layoutBasedVertexData[e$3 + 1], h$1.layoutBasedVertexData[e$3 + 2], h$1.layoutBasedVertexData[e$3 + 3], h$1.layoutBasedVertexData[e$3 + 4], h$1.layoutBasedVertexData[e$3 + 5], h$1.layoutBasedVertexData[e$3 + 6], h$1.layoutBasedVertexData[e$3 + 7], h$1.layoutBasedVertexData[e$3 + 8], h$1.layoutBasedVertexData[e$3 + 9], h$1.layoutBasedVertexData[e$3 + 10], h$1.layoutBasedVertexData[e$3 + 11]);
								}
								o$1 += e$2, h$1.isUsingAppearanceVertexData = !1, h$1.activeAppearance = null, s$1 = !0;
							} else o$1 += l$2.numIconVertices, h$1.activeAppearance = null;
						}
					}
					return s$1;
				}
				update(t$1, e$1, r$1, n$1, i$1, s$1, o$1) {
					this.text.programConfigurations.updatePaintArrays(t$1, e$1, i$1, r$1, n$1, s$1, o$1, this.worldview), this.icon.programConfigurations.updatePaintArrays(t$1, e$1, i$1, r$1, n$1, s$1, o$1, this.worldview);
				}
				updateRoadElevation(t$1) {
					if ("road" !== this.elevationType || !this.elevationFeatures) return;
					if (this.elevationStateComplete) return;
					this.elevationStateComplete = !0, this.hasAnyZOffset = !1;
					let e$1 = !1;
					const r$1 = vu(t$1), n$1 = 1 / r$1;
					let i$1 = !1, s$1 = !1;
					for (let t$2 = 0; t$2 < this.symbolInstances.length; t$2++) {
						const o$1 = this.symbolInstances.get(t$2), a$1 = M(1, 0, 0), l$1 = M(0, 1, 0), { numHorizontalGlyphVertices: u$1, numVerticalGlyphVertices: c$1, numIconVertices: h$1, numVerticalIconVertices: p$1 } = o$1, d$1 = u$1 > 0 || c$1 > 0, f$1 = h$1 > 0, m$1 = this.elevationFeatures[o$1.elevationFeatureIndex];
						if (m$1) {
							const t$3 = new It(o$1.tileAnchorX, o$1.tileAnchorY), u$2 = .075 + m$1.pointElevation(t$3);
							o$1.zOffset !== u$2 && (e$1 = !0, o$1.zOffset = u$2), 0 !== u$2 && (this.hasAnyZOffset = !0);
							const c$2 = m$1.computeSlopeNormal(t$3, n$1), h$2 = lt(tt(), M(0, 0, 1), c$2);
							G(a$1, a$1, h$2), G(l$1, l$1, h$2), a$1[2] *= r$1, l$1[2] *= r$1, 1 === a$1[0] && 0 === a$1[1] && 0 === a$1[2] && 0 === l$1[0] && 1 === l$1[1] && 0 === l$1[2] || (i$1 = i$1 || d$1, s$1 = s$1 || f$1);
						}
						if (d$1 && (Gx(this.text.orientationVertexArray, u$1, a$1, l$1), Gx(this.text.orientationVertexArray, c$1, a$1, l$1)), f$1) {
							const { placedIconSymbolIndex: t$3, verticalPlacedIconSymbolIndex: e$2 } = o$1;
							t$3 >= 0 && Gx(this.icon.orientationVertexArray, h$1, a$1, l$1), e$2 >= 0 && Gx(this.icon.orientationVertexArray, p$1, a$1, l$1);
						}
					}
					i$1 || (this.text.orientationVertexArray = void 0), s$1 || (this.icon.orientationVertexArray = void 0), e$1 && (this.zOffsetBuffersNeedUpload = !0, this.zOffsetSortDirty = !0);
				}
				updateZOffset() {
					const t$1 = (t$2, e$2, n$2) => {
						r$1 += e$2, r$1 > t$2.length && t$2.resize(r$1);
						for (let i$1 = -e$2; i$1 < 0; i$1++) t$2.emplace(i$1 + r$1, n$2);
					}, e$1 = (t$2, e$2, r$2) => {
						n$1 += e$2, n$1 > t$2.length && t$2.resize(n$1);
						for (let i$1 = -e$2; i$1 < 0; i$1++) t$2.emplace(i$1 + n$1, r$2);
					};
					if (!this.zOffsetBuffersNeedUpload) return;
					this.zOffsetBuffersNeedUpload = !1;
					let r$1 = 0, n$1 = 0;
					for (let r$2 = 0; r$2 < this.symbolInstances.length; r$2++) {
						const n$2 = this.symbolInstances.get(r$2), { numHorizontalGlyphVertices: i$1, numVerticalGlyphVertices: s$1, numIconVertices: o$1 } = n$2, a$1 = n$2.zOffset, l$1 = o$1 > 0;
						if ((i$1 > 0 || s$1 > 0) && (t$1(this.text.zOffsetVertexArray, i$1, a$1), t$1(this.text.zOffsetVertexArray, s$1, a$1)), l$1) {
							const { placedIconSymbolIndex: t$2, verticalPlacedIconSymbolIndex: r$3 } = n$2;
							t$2 >= 0 && e$1(this.icon.zOffsetVertexArray, o$1, a$1), r$3 >= 0 && e$1(this.icon.zOffsetVertexArray, n$2.numVerticalIconVertices, a$1);
						}
					}
					this.text.zOffsetVertexBuffer && this.text.zOffsetVertexBuffer.updateData(this.text.zOffsetVertexArray), this.icon.zOffsetVertexBuffer && this.icon.zOffsetVertexBuffer.updateData(this.icon.zOffsetVertexArray);
				}
				isEmpty() {
					return 0 === this.symbolInstances.length && !this.hasRTLText;
				}
				uploadPending() {
					return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;
				}
				upload(t$1, e$1, r$1, n$1, i$1) {
					!this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(t$1), this.iconCollisionBox.upload(t$1)), this.text.upload(t$1, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload, this.zOffsetBuffersNeedUpload, !1), null === this.hasAppearances && (this.hasAppearances = this.layers.some(((t$2) => t$2.appearances && t$2.appearances.length > 0))), this.icon.upload(t$1, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload, this.zOffsetBuffersNeedUpload, this.hasAppearances), this.uploaded = !0;
				}
				updateAppearances(t$1, e$1, r$1, n$1) {
					return !!(t$1 && e$1 && r$1) && !(!this.icon.layoutVertexArray || 0 === this.icon.layoutVertexArray.length) && !!this.icon.layoutVertexArray.arrayBuffer && void (this.updateAppearanceBasedIconTextures(t$1, e$1, r$1, n$1) && this.icon.layoutVertexBuffer && null !== this.icon.layoutVertexArray.arrayBuffer && this.icon.layoutVertexArray.length === this.icon.layoutVertexBuffer.length && this.icon.layoutVertexBuffer.updateData(this.icon.layoutVertexArray));
				}
				destroyDebugData() {
					this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();
				}
				getProjection() {
					return this.projectionInstance || (this.projectionInstance = Lx(this.projection)), this.projectionInstance;
				}
				destroy() {
					this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();
				}
				addToLineVertexArray(t$1, e$1) {
					const r$1 = this.lineVertexArray.length;
					if (void 0 !== t$1.segment) for (const { x: t$2, y: r$2 } of e$1) this.lineVertexArray.emplaceBack(t$2, r$2);
					return {
						lineStartIndex: r$1,
						lineLength: this.lineVertexArray.length - r$1
					};
				}
				addSymbols(t$1, e$1, r$1, n$1, i$1, s$1, o$1, a$1, l$1, u$1, c$1, h$1, p$1, d$1, f$1, m$1, y$1, g$1) {
					const x$1 = t$1.indexArray, v$1 = t$1.layoutVertexArray, b$1 = t$1.globeExtVertexArray, w$1 = t$1.segments.prepareSegment(4 * g$1, v$1, x$1, this.canOverlap ? s$1.sortKey : void 0), _$1 = this.glyphOffsetArray.length, A$1 = w$1.vertexLength, I$1 = this.allowVerticalPlacement && o$1 === $y.vertical ? Math.PI / 2 : 0, M$1 = s$1.text && s$1.text.sections;
					for (let n$2 = 0; n$2 < e$1.length; n$2++) {
						const { tl: i$2, tr: o$2, bl: u$2, br: c$2, texPrimary: h$2, texSecondary: y$2, pixelOffsetTL: g$2, pixelOffsetBR: _$2, minFontScaleX: A$2, minFontScaleY: S$2, glyphOffset: P$2, isSDF: k$1, sectionIndex: B$1 } = e$1[n$2], z$1 = w$1.vertexLength, T$1 = P$2[1];
						if (Nx(v$1, l$1.x, l$1.y, i$2.x, T$1 + i$2.y, h$2.x, h$2.y, r$1, k$1, g$2.x, g$2.y, A$2, S$2), Nx(v$1, l$1.x, l$1.y, o$2.x, T$1 + o$2.y, h$2.x + h$2.w, h$2.y, r$1, k$1, _$2.x, g$2.y, A$2, S$2), Nx(v$1, l$1.x, l$1.y, u$2.x, T$1 + u$2.y, h$2.x, h$2.y + h$2.h, r$1, k$1, g$2.x, _$2.y, A$2, S$2), Nx(v$1, l$1.x, l$1.y, c$2.x, T$1 + c$2.y, h$2.x + h$2.w, h$2.y + h$2.h, r$1, k$1, _$2.x, _$2.y, A$2, S$2), a$1) {
							const { x: e$2, y: r$2, z: n$3 } = a$1.anchor, [i$3, s$2, o$3] = a$1.up;
							$x(b$1, e$2, r$2, n$3, i$3, s$2, o$3), $x(b$1, e$2, r$2, n$3, i$3, s$2, o$3), $x(b$1, e$2, r$2, n$3, i$3, s$2, o$3), $x(b$1, e$2, r$2, n$3, i$3, s$2, o$3), qx(t$1.dynamicLayoutVertexArray, e$2, r$2, n$3, I$1);
						} else qx(t$1.dynamicLayoutVertexArray, l$1.x, l$1.y, l$1.z, I$1);
						if (m$1) {
							const e$2 = y$2 || h$2;
							jx(t$1.iconTransitioningVertexArray, e$2.x, e$2.y), jx(t$1.iconTransitioningVertexArray, e$2.x + e$2.w, e$2.y), jx(t$1.iconTransitioningVertexArray, e$2.x, e$2.y + e$2.h), jx(t$1.iconTransitioningVertexArray, e$2.x + e$2.w, e$2.y + e$2.h);
						}
						x$1.emplaceBack(z$1, z$1 + 1, z$1 + 2), x$1.emplaceBack(z$1 + 1, z$1 + 2, z$1 + 3), w$1.vertexLength += 4, w$1.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(P$2[0]), n$2 !== e$1.length - 1 && B$1 === e$1[n$2 + 1].sectionIndex || t$1.programConfigurations.populatePaintArrays(v$1.length, s$1, s$1.index, {}, p$1, d$1, f$1, M$1 && M$1[B$1], this.worldview);
					}
					const S$1 = g$1 - e$1.length;
					0 !== S$1 && this._addNullVertices(S$1, v$1, r$1, a$1, b$1, t$1, m$1, w$1, x$1);
					const P$1 = a$1 ? a$1.anchor : l$1;
					t$1.placedSymbolArray.emplaceBack(P$1.x, P$1.y, P$1.z, l$1.x, l$1.y, _$1, this.glyphOffsetArray.length - _$1, A$1, u$1, c$1, l$1.segment, r$1 ? r$1[0] : 0, r$1 ? r$1[1] : 0, n$1[0], n$1[1], o$1, 0, 0, 0, h$1, 0), t$1.symbolInstanceIndices.push(y$1);
				}
				_addNullVertices(t$1, e$1, r$1, n$1, i$1, s$1, o$1, a$1, l$1) {
					for (let u$1 = 0; u$1 < t$1; u$1++) {
						for (let t$3 = 0; t$3 < 4; t$3++) Nx(e$1, 0, 0, 0, 0, 0, 0, r$1, !1, 0, 0, 0, 0), n$1 ? ($x(i$1, 0, 0, 0, 0, 0, 0), qx(s$1.dynamicLayoutVertexArray, 0, 0, 0, 0)) : qx(s$1.dynamicLayoutVertexArray, 0, 0, 0, 0), o$1 && jx(s$1.iconTransitioningVertexArray, 0, 0);
						const t$2 = a$1.vertexLength;
						l$1.emplaceBack(t$2, t$2 + 1, t$2 + 2), l$1.emplaceBack(t$2 + 1, t$2 + 2, t$2 + 3), a$1.vertexLength += 4, a$1.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(0);
					}
				}
				_commitLayoutVertex(t$1, e$1, r$1, n$1, i$1, s$1, o$1) {
					t$1.emplaceBack(e$1, r$1, n$1, i$1, s$1, Math.round(o$1.x), Math.round(o$1.y));
				}
				_addCollisionDebugVertices(t$1, e$1, r$1, n$1, i$1, s$1, o$1) {
					const a$1 = r$1.segments.prepareSegment(4, r$1.layoutVertexArray, r$1.indexArray), l$1 = a$1.vertexLength, u$1 = o$1.tileAnchorX, c$1 = o$1.tileAnchorY;
					for (let t$2 = 0; t$2 < 4; t$2++) r$1.collisionVertexArray.emplaceBack(0, 0, 0, 0, 0, 0);
					this._commitDebugCollisionVertexUpdate(r$1.collisionVertexArrayExt, e$1, t$1.padding, o$1.zOffset), this._commitLayoutVertex(r$1.layoutVertexArray, n$1, i$1, s$1, u$1, c$1, new It(t$1.x1, t$1.y1)), this._commitLayoutVertex(r$1.layoutVertexArray, n$1, i$1, s$1, u$1, c$1, new It(t$1.x2, t$1.y1)), this._commitLayoutVertex(r$1.layoutVertexArray, n$1, i$1, s$1, u$1, c$1, new It(t$1.x2, t$1.y2)), this._commitLayoutVertex(r$1.layoutVertexArray, n$1, i$1, s$1, u$1, c$1, new It(t$1.x1, t$1.y2)), a$1.vertexLength += 4;
					const h$1 = r$1.indexArray;
					h$1.emplaceBack(l$1, l$1 + 1), h$1.emplaceBack(l$1 + 1, l$1 + 2), h$1.emplaceBack(l$1 + 2, l$1 + 3), h$1.emplaceBack(l$1 + 3, l$1), a$1.primitiveLength += 4;
				}
				_addTextDebugCollisionBoxes(t$1, e$1, r$1, n$1, i$1, s$1) {
					for (let o$1 = n$1; o$1 < i$1; o$1++) {
						const n$2 = r$1.get(o$1), i$2 = this.getSymbolInstanceTextSize(t$1, s$1, e$1, o$1);
						this._addCollisionDebugVertices(n$2, i$2, this.textCollisionBox, n$2.projectedAnchorX, n$2.projectedAnchorY, n$2.projectedAnchorZ, s$1);
					}
				}
				_addIconDebugCollisionBoxes(t$1, e$1, r$1, n$1, i$1, s$1) {
					for (let o$1 = n$1; o$1 < i$1; o$1++) {
						const n$2 = r$1.get(o$1), i$2 = this.getSymbolInstanceIconSize(t$1, e$1, s$1.placedIconSymbolIndex);
						this._addCollisionDebugVertices(n$2, i$2, this.iconCollisionBox, n$2.projectedAnchorX, n$2.projectedAnchorY, n$2.projectedAnchorZ, s$1);
					}
				}
				generateCollisionDebugBuffers(t$1, e$1, r$1) {
					this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new Zx(Ta, yy.members, Ba), this.iconCollisionBox = new Zx(Ta, yy.members, Ba);
					const n$1 = hg(this.iconSizeData, t$1), i$1 = hg(this.textSizeData, t$1, r$1);
					for (let r$2 = 0; r$2 < this.symbolInstances.length; r$2++) {
						const s$1 = this.symbolInstances.get(r$2);
						this._addTextDebugCollisionBoxes(i$1, t$1, e$1, s$1.textBoxStartIndex, s$1.textBoxEndIndex, s$1), this._addTextDebugCollisionBoxes(i$1, t$1, e$1, s$1.verticalTextBoxStartIndex, s$1.verticalTextBoxEndIndex, s$1), this._addIconDebugCollisionBoxes(n$1, t$1, e$1, s$1.iconBoxStartIndex, s$1.iconBoxEndIndex, s$1), this._addIconDebugCollisionBoxes(n$1, t$1, e$1, s$1.verticalIconBoxStartIndex, s$1.verticalIconBoxEndIndex, s$1);
					}
				}
				getSymbolInstanceTextSize(t$1, e$1, r$1, n$1) {
					const i$1 = this.text.placedSymbolArray.get(e$1.rightJustifiedTextSymbolIndex >= 0 ? e$1.rightJustifiedTextSymbolIndex : e$1.centerJustifiedTextSymbolIndex >= 0 ? e$1.centerJustifiedTextSymbolIndex : e$1.leftJustifiedTextSymbolIndex >= 0 ? e$1.leftJustifiedTextSymbolIndex : e$1.verticalPlacedTextSymbolIndex >= 0 ? e$1.verticalPlacedTextSymbolIndex : n$1), s$1 = cg(this.textSizeData, t$1, i$1) / xy;
					return this.tilePixelRatio * s$1;
				}
				getSymbolInstanceIconSize(t$1, e$1, r$1) {
					const n$1 = this.icon.placedSymbolArray.get(r$1), i$1 = cg(this.iconSizeData, t$1, n$1);
					return this.tilePixelRatio * i$1;
				}
				_commitDebugCollisionVertexUpdate(t$1, e$1, r$1, n$1) {
					t$1.emplaceBack(e$1, -r$1, -r$1, n$1), t$1.emplaceBack(e$1, r$1, -r$1, n$1), t$1.emplaceBack(e$1, r$1, r$1, n$1), t$1.emplaceBack(e$1, -r$1, r$1, n$1);
				}
				_updateTextDebugCollisionBoxes(t$1, e$1, r$1, n$1, i$1, s$1, o$1) {
					for (let o$2 = n$1; o$2 < i$1; o$2++) {
						const n$2 = r$1.get(o$2), i$2 = this.getSymbolInstanceTextSize(t$1, s$1, e$1, o$2);
						this._commitDebugCollisionVertexUpdate(this.textCollisionBox.collisionVertexArrayExt, i$2, n$2.padding, s$1.zOffset);
					}
				}
				_updateIconDebugCollisionBoxes(t$1, e$1, r$1, n$1, i$1, s$1, o$1) {
					for (let o$2 = n$1; o$2 < i$1; o$2++) {
						const n$2 = r$1.get(o$2), i$2 = this.getSymbolInstanceIconSize(t$1, e$1, s$1.placedIconSymbolIndex);
						this._commitDebugCollisionVertexUpdate(this.iconCollisionBox.collisionVertexArrayExt, i$2, n$2.padding, s$1.zOffset);
					}
				}
				updateCollisionDebugBuffers(t$1, e$1, r$1, n$1) {
					if (!this.hasDebugData()) return;
					this.hasTextCollisionBoxData() && this.textCollisionBox.collisionVertexArrayExt.clear(), this.hasIconCollisionBoxData() && this.iconCollisionBox.collisionVertexArrayExt.clear();
					const i$1 = hg(this.iconSizeData, t$1, n$1), s$1 = hg(this.textSizeData, t$1, r$1);
					for (let o$1 = 0; o$1 < this.symbolInstances.length; o$1++) {
						const a$1 = this.symbolInstances.get(o$1);
						this._updateTextDebugCollisionBoxes(s$1, t$1, e$1, a$1.textBoxStartIndex, a$1.textBoxEndIndex, a$1, r$1), this._updateTextDebugCollisionBoxes(s$1, t$1, e$1, a$1.verticalTextBoxStartIndex, a$1.verticalTextBoxEndIndex, a$1, r$1), this._updateIconDebugCollisionBoxes(i$1, t$1, e$1, a$1.iconBoxStartIndex, a$1.iconBoxEndIndex, a$1, n$1), this._updateIconDebugCollisionBoxes(i$1, t$1, e$1, a$1.verticalIconBoxStartIndex, a$1.verticalIconBoxEndIndex, a$1, n$1);
					}
					this.hasTextCollisionBoxData() && this.textCollisionBox.collisionVertexBufferExt && this.textCollisionBox.collisionVertexBufferExt.updateData(this.textCollisionBox.collisionVertexArrayExt), this.hasIconCollisionBoxData() && this.iconCollisionBox.collisionVertexBufferExt && this.iconCollisionBox.collisionVertexBufferExt.updateData(this.iconCollisionBox.collisionVertexArrayExt);
				}
				_deserializeCollisionBoxesForSymbol(t$1, e$1, r$1, n$1, i$1, s$1, o$1, a$1, l$1) {
					const u$1 = {};
					if (e$1 < r$1) {
						const { x1: r$2, y1: n$2, x2: i$2, y2: s$2, padding: o$2, projectedAnchorX: a$2, projectedAnchorY: l$2, projectedAnchorZ: c$1, tileAnchorX: h$1, tileAnchorY: p$1, featureIndex: d$1 } = t$1.get(e$1);
						u$1.textBox = {
							x1: r$2,
							y1: n$2,
							x2: i$2,
							y2: s$2,
							padding: o$2,
							projectedAnchorX: a$2,
							projectedAnchorY: l$2,
							projectedAnchorZ: c$1,
							tileAnchorX: h$1,
							tileAnchorY: p$1
						}, u$1.textFeatureIndex = d$1;
					}
					if (n$1 < i$1) {
						const { x1: e$2, y1: r$2, x2: i$2, y2: s$2, padding: o$2, projectedAnchorX: a$2, projectedAnchorY: l$2, projectedAnchorZ: c$1, tileAnchorX: h$1, tileAnchorY: p$1, featureIndex: d$1 } = t$1.get(n$1);
						u$1.verticalTextBox = {
							x1: e$2,
							y1: r$2,
							x2: i$2,
							y2: s$2,
							padding: o$2,
							projectedAnchorX: a$2,
							projectedAnchorY: l$2,
							projectedAnchorZ: c$1,
							tileAnchorX: h$1,
							tileAnchorY: p$1
						}, u$1.verticalTextFeatureIndex = d$1;
					}
					if (s$1 < o$1) {
						const { x1: e$2, y1: r$2, x2: n$2, y2: i$2, padding: o$2, projectedAnchorX: a$2, projectedAnchorY: l$2, projectedAnchorZ: c$1, tileAnchorX: h$1, tileAnchorY: p$1, featureIndex: d$1 } = t$1.get(s$1);
						u$1.iconBox = {
							x1: e$2,
							y1: r$2,
							x2: n$2,
							y2: i$2,
							padding: o$2,
							projectedAnchorX: a$2,
							projectedAnchorY: l$2,
							projectedAnchorZ: c$1,
							tileAnchorX: h$1,
							tileAnchorY: p$1
						}, u$1.iconFeatureIndex = d$1;
					}
					if (a$1 < l$1) {
						const { x1: e$2, y1: r$2, x2: n$2, y2: i$2, padding: s$2, projectedAnchorX: o$2, projectedAnchorY: l$2, projectedAnchorZ: c$1, tileAnchorX: h$1, tileAnchorY: p$1, featureIndex: d$1 } = t$1.get(a$1);
						u$1.verticalIconBox = {
							x1: e$2,
							y1: r$2,
							x2: n$2,
							y2: i$2,
							padding: s$2,
							projectedAnchorX: o$2,
							projectedAnchorY: l$2,
							projectedAnchorZ: c$1,
							tileAnchorX: h$1,
							tileAnchorY: p$1
						}, u$1.verticalIconFeatureIndex = d$1;
					}
					return u$1;
				}
				deserializeCollisionBoxes(t$1) {
					this.collisionArrays = [];
					for (let e$1 = 0; e$1 < this.symbolInstances.length; e$1++) {
						const r$1 = this.symbolInstances.get(e$1);
						this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(t$1, r$1.textBoxStartIndex, r$1.textBoxEndIndex, r$1.verticalTextBoxStartIndex, r$1.verticalTextBoxEndIndex, r$1.iconBoxStartIndex, r$1.iconBoxEndIndex, r$1.verticalIconBoxStartIndex, r$1.verticalIconBoxEndIndex));
					}
				}
				hasTextData() {
					return this.text.segments.get().length > 0;
				}
				hasIconData() {
					return this.icon.segments.get().length > 0;
				}
				hasDebugData() {
					return this.textCollisionBox && this.iconCollisionBox;
				}
				hasTextCollisionBoxData() {
					return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;
				}
				hasIconCollisionBoxData() {
					return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;
				}
				hasIconTextFit() {
					return this.hasAnyIconTextFit;
				}
				addIndicesForPlacedSymbol(t$1, e$1) {
					const r$1 = t$1.placedSymbolArray.get(e$1), n$1 = r$1.vertexStartIndex + 4 * r$1.numGlyphs;
					for (let e$2 = r$1.vertexStartIndex; e$2 < n$1; e$2 += 4) t$1.indexArray.emplaceBack(e$2, e$2 + 1, e$2 + 2), t$1.indexArray.emplaceBack(e$2 + 1, e$2 + 2, e$2 + 3);
				}
				getSortedSymbolIndexes(t$1) {
					if (this.sortedAngle === t$1 && void 0 !== this.symbolInstanceIndexes) return this.symbolInstanceIndexes;
					const e$1 = Math.sin(t$1), r$1 = Math.cos(t$1), n$1 = [], i$1 = [], s$1 = [];
					for (let t$2 = 0; t$2 < this.symbolInstances.length; ++t$2) {
						s$1.push(t$2);
						const o$1 = this.symbolInstances.get(t$2);
						n$1.push(0 | Math.round(e$1 * o$1.tileAnchorX + r$1 * o$1.tileAnchorY)), i$1.push(o$1.featureIndex);
					}
					return s$1.sort(((t$2, e$2) => n$1[t$2] - n$1[e$2] || i$1[e$2] - i$1[t$2])), s$1;
				}
				getSortedIndexesByZOffset() {
					if (!this.zOffsetSortDirty) return this.symbolInstanceIndexesSortedZOffset;
					if (!this.symbolInstanceIndexesSortedZOffset) {
						this.symbolInstanceIndexesSortedZOffset = [];
						for (let t$1 = 0; t$1 < this.symbolInstances.length; ++t$1) this.symbolInstanceIndexesSortedZOffset.push(t$1);
					}
					return this.zOffsetSortDirty = !1, this.symbolInstanceIndexesSortedZOffset.sort(((t$1, e$1) => this.symbolInstances.get(e$1).zOffset - this.symbolInstances.get(t$1).zOffset));
				}
				addToSortKeyRanges(t$1, e$1) {
					const r$1 = this.sortKeyRanges[this.sortKeyRanges.length - 1];
					r$1 && r$1.sortKey === e$1 ? r$1.symbolInstanceEnd = t$1 + 1 : this.sortKeyRanges.push({
						sortKey: e$1,
						symbolInstanceStart: t$1,
						symbolInstanceEnd: t$1 + 1
					});
				}
				sortFeatures(t$1) {
					if (this.sortFeaturesByY && this.sortedAngle !== t$1 && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
						this.symbolInstanceIndexes = this.getSortedSymbolIndexes(t$1), this.sortedAngle = t$1, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
						for (const t$2 of this.symbolInstanceIndexes) {
							const e$1 = this.symbolInstances.get(t$2);
							this.featureSortOrder.push(e$1.featureIndex);
							const { rightJustifiedTextSymbolIndex: r$1, centerJustifiedTextSymbolIndex: n$1, leftJustifiedTextSymbolIndex: i$1, verticalPlacedTextSymbolIndex: s$1, placedIconSymbolIndex: o$1, verticalPlacedIconSymbolIndex: a$1 } = e$1;
							r$1 >= 0 && this.addIndicesForPlacedSymbol(this.text, r$1), n$1 >= 0 && n$1 !== r$1 && this.addIndicesForPlacedSymbol(this.text, n$1), i$1 >= 0 && i$1 !== n$1 && i$1 !== r$1 && this.addIndicesForPlacedSymbol(this.text, i$1), s$1 >= 0 && this.addIndicesForPlacedSymbol(this.text, s$1), o$1 >= 0 && this.addIndicesForPlacedSymbol(this.icon, o$1), a$1 >= 0 && this.addIndicesForPlacedSymbol(this.icon, a$1);
						}
						this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);
					}
				}
				getElevationFeatureForText(t$1) {
					const e$1 = this.symbolInstances.get(this.text.symbolInstanceIndices[t$1]).elevationFeatureIndex;
					let r$1;
					return this.elevationFeatures && e$1 < this.elevationFeatures.length && (r$1 = this.elevationFeatures[e$1]), r$1;
				}
			}
			function Yx(t$1, e$1) {
				return e$1.replace(/{([^{}]+)}/g, ((e$2, r$1) => r$1 in t$1 ? String(t$1[r$1]) : ""));
			}
			let Kx, Jx, Qx;
			Qs(Wx, "SymbolBucket", { omit: [
				"layers",
				"collisionBoxArray",
				"compareText",
				"features"
			] }), Wx.addDynamicAttributes = qx;
			class tv {
				constructor(t$1) {
					this.type = t$1.property.overrides ? t$1.property.overrides.runtimeType : gr, this.defaultValue = t$1;
				}
				evaluate(t$1) {
					if (t$1.formattedSection) {
						const e$1 = this.defaultValue.property.overrides;
						if (e$1 && e$1.hasOverride(t$1.formattedSection)) return e$1.getOverride(t$1.formattedSection);
					}
					return t$1.feature && t$1.featureState ? this.defaultValue.evaluate(t$1.feature, t$1.featureState) : this.defaultValue.property.specification.default;
				}
				eachChild(t$1) {
					this.defaultValue.isConstant() || t$1(this.defaultValue.value._styleExpression.expression);
				}
				outputDefined() {
					return !1;
				}
				serialize() {
					return null;
				}
			}
			Qs(tv, "FormatSectionOverride", { omit: ["defaultValue"] });
			const ev = () => Qx || (Qx = {
				layout: Kx || (Kx = new Do({
					"symbol-placement": new Vo(Ro.layout_symbol["symbol-placement"]),
					"symbol-spacing": new Vo(Ro.layout_symbol["symbol-spacing"]),
					"symbol-avoid-edges": new Vo(Ro.layout_symbol["symbol-avoid-edges"]),
					"symbol-sort-key": new Fo(Ro.layout_symbol["symbol-sort-key"]),
					"symbol-z-order": new Vo(Ro.layout_symbol["symbol-z-order"]),
					"symbol-z-elevate": new Vo(Ro.layout_symbol["symbol-z-elevate"]),
					"symbol-elevation-reference": new Vo(Ro.layout_symbol["symbol-elevation-reference"]),
					"icon-allow-overlap": new Vo(Ro.layout_symbol["icon-allow-overlap"]),
					"icon-ignore-placement": new Vo(Ro.layout_symbol["icon-ignore-placement"]),
					"icon-optional": new Vo(Ro.layout_symbol["icon-optional"]),
					"icon-rotation-alignment": new Vo(Ro.layout_symbol["icon-rotation-alignment"]),
					"icon-size": new Fo(Ro.layout_symbol["icon-size"]),
					"icon-size-scale-range": new Vo(Ro.layout_symbol["icon-size-scale-range"]),
					"icon-text-fit": new Fo(Ro.layout_symbol["icon-text-fit"]),
					"icon-text-fit-padding": new Fo(Ro.layout_symbol["icon-text-fit-padding"]),
					"icon-image": new Fo(Ro.layout_symbol["icon-image"]),
					"icon-image-use-theme": new Vo({
						type: "string",
						default: "default",
						"property-type": "data-constant"
					}),
					"icon-rotate": new Fo(Ro.layout_symbol["icon-rotate"]),
					"icon-padding": new Vo(Ro.layout_symbol["icon-padding"]),
					"icon-keep-upright": new Vo(Ro.layout_symbol["icon-keep-upright"]),
					"icon-offset": new Fo(Ro.layout_symbol["icon-offset"]),
					"icon-anchor": new Fo(Ro.layout_symbol["icon-anchor"]),
					"icon-pitch-alignment": new Vo(Ro.layout_symbol["icon-pitch-alignment"]),
					"text-pitch-alignment": new Vo(Ro.layout_symbol["text-pitch-alignment"]),
					"text-rotation-alignment": new Vo(Ro.layout_symbol["text-rotation-alignment"]),
					"text-field": new Fo(Ro.layout_symbol["text-field"]),
					"text-font": new Fo(Ro.layout_symbol["text-font"]),
					"text-size": new Fo(Ro.layout_symbol["text-size"]),
					"text-size-scale-range": new Vo(Ro.layout_symbol["text-size-scale-range"]),
					"text-max-width": new Fo(Ro.layout_symbol["text-max-width"]),
					"text-line-height": new Fo(Ro.layout_symbol["text-line-height"]),
					"text-letter-spacing": new Fo(Ro.layout_symbol["text-letter-spacing"]),
					"text-justify": new Fo(Ro.layout_symbol["text-justify"]),
					"text-radial-offset": new Fo(Ro.layout_symbol["text-radial-offset"]),
					"text-variable-anchor": new Vo(Ro.layout_symbol["text-variable-anchor"]),
					"text-anchor": new Fo(Ro.layout_symbol["text-anchor"]),
					"text-max-angle": new Vo(Ro.layout_symbol["text-max-angle"]),
					"text-writing-mode": new Vo(Ro.layout_symbol["text-writing-mode"]),
					"text-rotate": new Fo(Ro.layout_symbol["text-rotate"]),
					"text-padding": new Vo(Ro.layout_symbol["text-padding"]),
					"text-keep-upright": new Vo(Ro.layout_symbol["text-keep-upright"]),
					"text-transform": new Fo(Ro.layout_symbol["text-transform"]),
					"text-offset": new Fo(Ro.layout_symbol["text-offset"]),
					"text-allow-overlap": new Vo(Ro.layout_symbol["text-allow-overlap"]),
					"text-ignore-placement": new Vo(Ro.layout_symbol["text-ignore-placement"]),
					"text-optional": new Vo(Ro.layout_symbol["text-optional"]),
					visibility: new Vo(Ro.layout_symbol.visibility)
				})),
				paint: Jx || (Jx = new Do({
					"icon-opacity": new Fo(Ro.paint_symbol["icon-opacity"]),
					"icon-occlusion-opacity": new Fo(Ro.paint_symbol["icon-occlusion-opacity"]),
					"icon-emissive-strength": new Fo(Ro.paint_symbol["icon-emissive-strength"]),
					"text-emissive-strength": new Fo(Ro.paint_symbol["text-emissive-strength"]),
					"icon-color": new Fo(Ro.paint_symbol["icon-color"]),
					"icon-halo-color": new Fo(Ro.paint_symbol["icon-halo-color"]),
					"icon-halo-width": new Fo(Ro.paint_symbol["icon-halo-width"]),
					"icon-halo-blur": new Fo(Ro.paint_symbol["icon-halo-blur"]),
					"icon-translate": new Vo(Ro.paint_symbol["icon-translate"]),
					"icon-translate-anchor": new Vo(Ro.paint_symbol["icon-translate-anchor"]),
					"icon-image-cross-fade": new Vo(Ro.paint_symbol["icon-image-cross-fade"]),
					"text-opacity": new Fo(Ro.paint_symbol["text-opacity"]),
					"text-occlusion-opacity": new Fo(Ro.paint_symbol["text-occlusion-opacity"]),
					"text-color": new Fo(Ro.paint_symbol["text-color"], {
						runtimeType: wr,
						getOverride: (t$1) => t$1.textColor,
						hasOverride: (t$1) => !!t$1.textColor
					}),
					"text-halo-color": new Fo(Ro.paint_symbol["text-halo-color"]),
					"text-halo-width": new Fo(Ro.paint_symbol["text-halo-width"]),
					"text-halo-blur": new Fo(Ro.paint_symbol["text-halo-blur"]),
					"text-translate": new Vo(Ro.paint_symbol["text-translate"]),
					"text-translate-anchor": new Vo(Ro.paint_symbol["text-translate-anchor"]),
					"icon-color-saturation": new Vo(Ro.paint_symbol["icon-color-saturation"]),
					"icon-color-contrast": new Vo(Ro.paint_symbol["icon-color-contrast"]),
					"icon-color-brightness-min": new Vo(Ro.paint_symbol["icon-color-brightness-min"]),
					"icon-color-brightness-max": new Vo(Ro.paint_symbol["icon-color-brightness-max"]),
					"symbol-z-offset": new Fo(Ro.paint_symbol["symbol-z-offset"]),
					"icon-color-use-theme": new Fo({
						type: "string",
						default: "default",
						"property-type": "data-driven"
					}),
					"icon-halo-color-use-theme": new Fo({
						type: "string",
						default: "default",
						"property-type": "data-driven"
					}),
					"text-color-use-theme": new Fo({
						type: "string",
						default: "default",
						"property-type": "data-driven"
					}),
					"text-halo-color-use-theme": new Fo({
						type: "string",
						default: "default",
						"property-type": "data-driven"
					})
				}))
			}, Qx);
			class rv extends oa {
				constructor(t$1, e$1, r$1, n$1) {
					super(t$1, ev(), e$1, r$1, n$1, t$1.layout ? t$1.layout["icon-image-use-theme"] : null), this._colorAdjustmentMatrix = u([]), this.hasOcclusionOpacityProperties = void 0 !== t$1.paint && ("icon-occlusion-opacity" in t$1.paint || "text-occlusion-opacity" in t$1.paint);
				}
				_handleSpecialPaintPropertyUpdate(t$1) {
					"icon-occlusion-opacity" !== t$1 && "text-occlusion-opacity" !== t$1 || (this.hasOcclusionOpacityProperties = !0);
				}
				recalculate(t$1, e$1) {
					super.recalculate(t$1, e$1), this.appearances && this.appearances.forEach(((r$2) => {
						r$2.recalculate(t$1, e$1, this.iconImageUseTheme);
					})), "auto" === this.layout.get("icon-rotation-alignment") && (this.layout._values["icon-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-rotation-alignment") && (this.layout._values["text-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-pitch-alignment") && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment")), "auto" === this.layout.get("icon-pitch-alignment") && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment"));
					const r$1 = this.layout.get("text-writing-mode");
					if (r$1) {
						const t$2 = [];
						for (const e$2 of r$1) t$2.indexOf(e$2) < 0 && t$2.push(e$2);
						this.layout._values["text-writing-mode"] = t$2;
					} else this.layout._values["text-writing-mode"] = "point" === this.layout.get("symbol-placement") ? ["horizontal"] : ["horizontal", "vertical"];
					this._setPaintOverrides();
				}
				getColorAdjustmentMatrix(t$1, e$1, r$1, n$1) {
					return this._saturation === t$1 && this._contrast === e$1 && this._brightnessMin === r$1 && this._brightnessMax === n$1 || (this._colorAdjustmentMatrix = function(t$2, e$2, r$2, n$2) {
						t$2 = ie(t$2), e$2 = ne(e$2);
						const i$1 = a(), s$1 = t$2 / 3, o$1 = 1 - 2 * s$1, l$1 = [
							o$1,
							s$1,
							s$1,
							0,
							s$1,
							o$1,
							s$1,
							0,
							s$1,
							s$1,
							o$1,
							0,
							0,
							0,
							0,
							1
						], u$1 = .5 - .5 * e$2, c$1 = n$2 - r$2;
						return h(i$1, [
							c$1,
							0,
							0,
							0,
							0,
							c$1,
							0,
							0,
							0,
							0,
							c$1,
							0,
							r$2,
							r$2,
							r$2,
							1
						], [
							e$2,
							0,
							0,
							0,
							0,
							e$2,
							0,
							0,
							0,
							0,
							e$2,
							0,
							u$1,
							u$1,
							u$1,
							1
						]), h(i$1, i$1, l$1), i$1;
					}(t$1, e$1, r$1, n$1), this._saturation = t$1, this._contrast = e$1, this._brightnessMin = r$1, this._brightnessMax = n$1), this._colorAdjustmentMatrix;
				}
				getValueAndResolveTokens(t$1, e$1, r$1, n$1) {
					const i$1 = this.layout.get(t$1).evaluate(e$1, {}, r$1, n$1), s$1 = this._unevaluatedLayout._values[t$1];
					return s$1.isDataDriven() || Ns(s$1.value) || !i$1 ? i$1 : Yx(e$1.properties, i$1);
				}
				getAppearanceValueAndResolveTokens(t$1, e$1, r$1, n$1, i$1) {
					const s$1 = t$1.getProperty(e$1);
					if (!s$1) return;
					const o$1 = s$1.evaluate(r$1, {}, n$1, i$1), a$1 = t$1.getUnevaluatedProperties()._values[e$1];
					return a$1.isDataDriven() || Ns(a$1.value) || !o$1 || "string" != typeof o$1 ? o$1 : Yx(r$1.properties, o$1);
				}
				createBucket(t$1) {
					return new Wx(t$1);
				}
				queryRadius() {
					return 0;
				}
				queryIntersectsFeature() {
					return !1;
				}
				_setPaintOverrides() {
					for (const t$1 of ev().paint.overridableProperties) {
						if (!rv.hasPaintOverride(this.layout, t$1)) continue;
						const e$1 = this.paint.get(t$1), n$1 = new Us(new tv(e$1), e$1.property.specification, this.scope, this.options, this.layout.get("icon-image-use-theme"));
						let i$1 = null;
						i$1 = "constant" === e$1.value.kind || "source" === e$1.value.kind ? new $s("source", n$1) : new Gs("composite", n$1, e$1.value.zoomStops, e$1.value.interpolationType), this.paint._values[t$1] = new To(e$1.property, i$1, e$1.parameters);
					}
				}
				_handleOverridablePaintPropertyUpdate(t$1, e$1, r$1) {
					return !(!this.layout || e$1.isDataDriven() || r$1.isDataDriven()) && rv.hasPaintOverride(this.layout, t$1);
				}
				static hasPaintOverride(t$1, e$1) {
					const r$1 = t$1.get("text-field"), n$1 = ev().paint.properties[e$1];
					let i$1 = !1;
					const s$1 = (t$2) => {
						for (const e$2 of t$2) if (n$1.overrides && n$1.overrides.hasOverride(e$2)) return void (i$1 = !0);
					};
					if ("constant" === r$1.value.kind && r$1.value.value instanceof Dr) s$1(r$1.value.value.sections);
					else if ("source" === r$1.value.kind) {
						const t$2 = (e$3) => {
							i$1 || (e$3 instanceof $r && Nr(e$3.value) === Mr ? s$1(e$3.value.sections) : e$3 instanceof Xr ? s$1(e$3.sections) : e$3.eachChild(t$2));
						}, e$2 = r$1.value;
						e$2._styleExpression && t$2(e$2._styleExpression.expression);
					}
					return i$1;
				}
				getProgramIds() {
					return ["symbol"];
				}
				getDefaultProgramParams(t$1, e$1, r$1) {
					return {
						config: new Ol(this, {
							zoom: e$1,
							lut: r$1
						}),
						overrideFog: !1
					};
				}
				hasElevation() {
					return this.layout && "hd-road-markup" === this.layout.get("symbol-elevation-reference");
				}
			}
			let nv, iv, sv, ov;
			var av = ha([{
				name: "a_pos",
				type: "Int16",
				components: 2
			}, {
				name: "a_texture_pos",
				type: "Int16",
				components: 2
			}]);
			function lv(t$1, e$1, r$1, n$1, i$1, a$1, l$1, u$1) {
				const c$1 = [
					t$1,
					e$1,
					1,
					r$1,
					n$1,
					1,
					i$1,
					a$1,
					1
				], h$1 = [
					l$1,
					u$1,
					1
				], [d$1, f$1, m$1] = $(h$1, h$1, s([], c$1));
				return o(c$1, c$1, [
					d$1,
					0,
					0,
					0,
					f$1,
					0,
					0,
					0,
					m$1
				]);
			}
			function uv(t$1, e$1, r$1, n$1, i$1, a$1, l$1, u$1) {
				const c$1 = function(t$2, e$2, r$2, n$2, i$2, a$2, l$2, u$2) {
					const c$2 = lv(0, 0, 1, 0, 1, 1, 0, 1), h$1 = lv(t$2, e$2, r$2, n$2, i$2, a$2, l$2, u$2);
					return o(h$1, h$1, s([], c$2));
				}(t$1, e$1, r$1, n$1, i$1, a$1, l$1, u$1);
				return [c$1[2] / c$1[8] / Un, c$1[5] / c$1[8] / Un];
			}
			function cv(t$1) {
				return [t$1[0], Math.min(Math.max(t$1[1], -mu), mu)];
			}
			class hv extends nr {
				constructor(t$1, e$1, r$1, n$1) {
					super(), this.id = t$1, this.dispatcher = r$1, this.coordinates = e$1.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = !1, this.onNorthPole = !1, this.onSouthPole = !1, this.setEventedParent(n$1), this.options = e$1, this._dirty = !1;
				}
				load(t$1, e$1) {
					if (this._loaded = e$1 || !1, this.fire(new Qe("dataloading", { dataType: "source" })), this.url = this.options.url, !this.url) return t$1 && (this.coordinates = t$1), this._loaded = !0, void this._finishLoading();
					this._imageRequest = Ge(this.map._requestManager.transformRequest(this.url, Ce.Image), ((e$2, r$1) => {
						this._imageRequest = null, this._loaded = !0, e$2 ? this.fire(new tr(e$2)) : r$1 && (this.image = r$1 instanceof HTMLImageElement ? ye.getImageData(r$1) : r$1, this._dirty = !0, this.width = this.image.width, this.height = this.image.height, t$1 && (this.coordinates = t$1), this._finishLoading());
					}));
				}
				loaded() {
					return this._loaded;
				}
				updateImage(t$1) {
					return t$1.url ? (this._imageRequest && t$1.url !== this.options.url && (this._imageRequest.cancel(), this._imageRequest = null), this.options.url = t$1.url, this.load(t$1.coordinates, this._loaded), this) : this;
				}
				setTexture(t$1) {
					if (!(t$1.handle instanceof WebGLTexture)) throw new Error("The provided handle is not a WebGLTexture instance");
					return this.texture = new Ef(this.map.painter.context, t$1.handle), this.width = t$1.dimensions[0], this.height = t$1.dimensions[1], this._dirty = !1, this._loaded = !0, this._finishLoading(), this;
				}
				_finishLoading() {
					this.map && (this.setCoordinates(this.coordinates), this.fire(new Qe("data", {
						dataType: "source",
						sourceDataType: "metadata"
					})));
				}
				onAdd(t$1) {
					this.map = t$1, this.load();
				}
				onRemove(t$1) {
					this._imageRequest && (this._imageRequest.cancel(), this._imageRequest = null), !this.texture || this.texture instanceof Ef || this.texture.destroy(), this.boundsBuffer && (this.boundsBuffer.destroy(), this.elevatedGlobeVertexBuffer && this.elevatedGlobeVertexBuffer.destroy(), this.elevatedGlobeIndexBuffer && this.elevatedGlobeIndexBuffer.destroy());
				}
				setCoordinates(t$1) {
					if (this.coordinates = t$1, this._boundsArray = void 0, this._unsupportedCoords = !1, !t$1.length) return this;
					this.onNorthPole = !1, this.onSouthPole = !1;
					let e$1 = t$1[0][1], r$1 = t$1[0][1];
					for (const n$2 of t$1) n$2[1] > r$1 && (r$1 = n$2[1]), n$2[1] < e$1 && (e$1 = n$2[1]);
					const n$1 = (r$1 + e$1) / 2;
					if (n$1 > mu ? this.onNorthPole = !0 : n$1 < -mu && (this.onSouthPole = !0), !this.onNorthPole && !this.onSouthPole) this.tileID = function(t$2) {
						let e$2 = Infinity, r$2 = Infinity, n$2 = -Infinity, i$1 = -Infinity;
						for (const s$2 of t$2) e$2 = Math.min(e$2, s$2.x), r$2 = Math.min(r$2, s$2.y), n$2 = Math.max(n$2, s$2.x), i$1 = Math.max(i$1, s$2.y);
						const s$1 = Math.max(n$2 - e$2, i$1 - r$2), o$1 = Math.max(0, Math.floor(-Math.log2(s$1))), a$1 = Math.pow(2, o$1);
						let l$1 = Math.floor((e$2 + n$2) / 2 * a$1);
						return l$1 > 1 && (l$1 -= 1), new Pc(o$1, l$1, Math.floor((r$2 + i$1) / 2 * a$1));
					}(t$1.map(bu.fromLngLat)), this.minzoom = this.maxzoom = this.tileID.z;
					return this.fire(new Qe("data", {
						dataType: "source",
						sourceDataType: "content"
					})), this;
				}
				_clear() {
					!this.texture || this.texture instanceof Ef || (this.texture.destroy(), this._dirty = !0), this.texture = null, this._boundsArray = void 0, this._unsupportedCoords = !1;
				}
				_prepareData(t$1) {
					for (const t$2 in this.tiles) {
						const e$2 = this.tiles[t$2];
						"loaded" !== e$2.state && (e$2.state = "loaded", e$2.texture = this.texture);
					}
					if (this._boundsArray || this.onNorthPole || this.onSouthPole || this._unsupportedCoords) return;
					const e$1 = yx(new Pc(0, 0, 0), this.map.transform.projection), r$1 = [
						e$1.projection.project(this.coordinates[0][0], this.coordinates[0][1]),
						e$1.projection.project(this.coordinates[1][0], this.coordinates[1][1]),
						e$1.projection.project(this.coordinates[2][0], this.coordinates[2][1]),
						e$1.projection.project(this.coordinates[3][0], this.coordinates[3][1])
					];
					if (!function(t$2) {
						const e$2 = t$2[1].x - t$2[0].x, r$2 = t$2[1].y - t$2[0].y, n$2 = t$2[2].x - t$2[1].x, i$2 = t$2[2].y - t$2[1].y, s$1 = t$2[3].x - t$2[2].x, o$1 = t$2[3].y - t$2[2].y, a$2 = t$2[0].x - t$2[3].x, l$2 = t$2[0].y - t$2[3].y, u$2 = e$2 * i$2 - n$2 * r$2, c$2 = n$2 * o$1 - s$1 * i$2, h$2 = s$1 * l$2 - a$2 * o$1, p$2 = a$2 * r$2 - e$2 * l$2;
						return u$2 > 0 && c$2 > 0 && h$2 > 0 && p$2 > 0 || u$2 < 0 && c$2 < 0 && h$2 < 0 && p$2 < 0;
					}(r$1)) return console.warn("Image source coordinates are defining non-convex area in the Mercator projection"), void (this._unsupportedCoords = !0);
					const n$1 = yx(this.tileID, this.map.transform.projection), [i$1, a$1, l$1, u$1] = this.coordinates.map(((t$2) => {
						return gx(n$1, n$1.projection.project(t$2[0], t$2[1]))._round();
					}));
					this.perspectiveTransform = uv(i$1.x, i$1.y, a$1.x, a$1.y, l$1.x, l$1.y, u$1.x, u$1.y);
					const c$1 = this._boundsArray = new ma();
					c$1.emplaceBack(i$1.x, i$1.y, 0, 0), c$1.emplaceBack(a$1.x, a$1.y, Un, 0), c$1.emplaceBack(u$1.x, u$1.y, 0, Un), c$1.emplaceBack(l$1.x, l$1.y, Un, Un), this.boundsBuffer && (this.boundsBuffer.destroy(), this.elevatedGlobeVertexBuffer && this.elevatedGlobeVertexBuffer.destroy(), this.elevatedGlobeIndexBuffer && this.elevatedGlobeIndexBuffer.destroy()), this.boundsBuffer = t$1.createVertexBuffer(c$1, av.members), this.boundsSegments = hl.simpleSegment(0, 0, 4, 2);
					const h$1 = [], p$1 = [
						cv((d$1 = this.coordinates)[0]),
						cv(d$1[1]),
						cv(d$1[2]),
						cv(d$1[3])
					];
					var d$1;
					const [f$1, m$1, y$1, g$1] = function(t$2) {
						let e$2 = t$2[0][0], r$2 = e$2, n$2 = t$2[0][1], i$2 = n$2;
						for (let s$1 = 1; s$1 < t$2.length; s$1++) t$2[s$1][0] < e$2 ? e$2 = t$2[s$1][0] : t$2[s$1][0] > r$2 && (r$2 = t$2[s$1][0]), t$2[s$1][1] < n$2 ? n$2 = t$2[s$1][1] : t$2[s$1][1] > i$2 && (i$2 = t$2[s$1][1]);
						return [
							e$2,
							n$2,
							r$2 - e$2,
							i$2 - n$2
						];
					}(p$1);
					{
						const n$2 = new ma(), [i$2, a$2, l$2, u$2] = function(t$2) {
							let e$2 = t$2[0].x, r$2 = e$2, n$3 = t$2[0].y, i$3 = n$3;
							for (let s$1 = 1; s$1 < t$2.length; s$1++) t$2[s$1].x < e$2 ? e$2 = t$2[s$1].x : t$2[s$1].x > r$2 && (r$2 = t$2[s$1].x), t$2[s$1].y < n$3 ? n$3 = t$2[s$1].y : t$2[s$1].y > i$3 && (i$3 = t$2[s$1].y);
							return [
								e$2,
								n$3,
								r$2 - e$2,
								i$3 - n$3
							];
						}(r$1), c$2 = (t$2) => [(t$2.x - i$2) / l$2, (t$2.y - a$2) / u$2], [p$2, d$2, x$1, v$1] = r$1.map(c$2), b$1 = function(t$2, e$2, r$2, n$3, i$3, a$3, l$3, u$3) {
							const c$3 = lv(0, 0, 1, 0, 1, 1, 0, 1);
							return o(c$3, c$3, s([], lv(t$2, e$2, r$2, n$3, i$3, a$3, l$3, u$3)));
						}(p$2[0], p$2[1], d$2[0], d$2[1], x$1[0], x$1[1], v$1[0], v$1[1]);
						this.elevatedGlobePerspectiveTransform = uv(p$2[0], p$2[1], d$2[0], d$2[1], x$1[0], x$1[1], v$1[0], v$1[1]);
						const w$1 = (t$2, e$2) => {
							h$1.push(t$2.lng);
							const r$2 = Math.round((t$2.lng - f$1) / y$1 * Un), i$3 = Math.round((t$2.lat - m$1) / g$1 * Un), s$1 = c$2(e$2), o$1 = $([], [
								s$1[0],
								s$1[1],
								1
							], b$1), a$3 = Math.round(o$1[0] / o$1[2] * Un), l$3 = Math.round(o$1[1] / o$1[2] * Un);
							n$2.emplaceBack(r$2, i$3, a$3, l$3);
						}, _$1 = r$1[3].x - r$1[0].x, A$1 = r$1[3].y - r$1[0].y, I$1 = r$1[2].x - r$1[1].x, M$1 = r$1[2].y - r$1[1].y;
						for (let t$2 = 0; t$2 < 65; t$2++) {
							const n$3 = t$2 / 64, i$3 = [r$1[0].x + n$3 * _$1, r$1[0].y + n$3 * A$1], s$1 = [r$1[1].x + n$3 * I$1, r$1[1].y + n$3 * M$1], o$1 = s$1[0] - i$3[0], a$3 = s$1[1] - i$3[1];
							for (let t$3 = 0; t$3 < 65; t$3++) {
								const r$2 = t$3 / 64, n$4 = {
									x: i$3[0] + o$1 * r$2,
									y: i$3[1] + a$3 * r$2
								};
								w$1(e$1.projection.unproject(n$4.x, n$4.y), n$4);
							}
						}
						this.elevatedGlobeVertexBuffer = t$1.createVertexBuffer(n$2, av.members);
					}
					{
						this.maxLongitudeTriangleSize = 0;
						let e$2 = [], r$2 = new Fa();
						const n$2 = (t$2, n$3, i$2) => {
							r$2.emplaceBack(t$2, n$3, i$2);
							const s$1 = h$1[t$2], o$1 = h$1[n$3], a$2 = h$1[i$2], l$2 = Math.min(Math.min(s$1, o$1), a$2), u$2 = Math.max(Math.max(s$1, o$1), a$2) - l$2;
							u$2 > this.maxLongitudeTriangleSize && (this.maxLongitudeTriangleSize = u$2), e$2.push(l$2 + u$2 / 2);
						};
						for (let t$2 = 0; t$2 < 64; t$2++) for (let e$3 = 0; e$3 < 64; e$3++) {
							const r$3 = 65 * t$2 + e$3, i$2 = r$3 + 1, s$1 = r$3 + 65, o$1 = s$1 + 1;
							n$2(r$3, s$1, i$2), n$2(i$2, s$1, o$1);
						}
						[e$2, r$2] = function(t$2, e$3) {
							const r$3 = Array.from({ length: t$2.length }, ((t$3, e$4) => e$4));
							r$3.sort(((e$4, r$4) => t$2[e$4] - t$2[r$4]));
							const n$3 = [], i$2 = new Fa();
							for (let s$1 = 0; s$1 < r$3.length; s$1++) {
								const o$1 = r$3[s$1];
								n$3.push(t$2[o$1]);
								const a$2 = 3 * o$1, l$2 = a$2 + 1;
								i$2.emplaceBack(e$3.uint16[a$2], e$3.uint16[l$2], e$3.uint16[l$2 + 1]);
							}
							return [n$3, i$2];
						}(e$2, r$2), this.elevatedGlobeTrianglesCenterLongitudes = e$2, this.elevatedGlobeIndexBuffer = t$1.createIndexBuffer(r$2);
					}
					this.elevatedGlobeSegments = hl.simpleSegment(0, 0, 4225, 8192), this.elevatedGlobeGridMatrix = new Float32Array([
						0,
						y$1 / Un,
						0,
						g$1 / Un,
						0,
						0,
						m$1,
						f$1,
						0
					]);
				}
				prepare() {
					const t$1 = 0 !== Object.keys(this.tiles).length;
					if (this.tileID && !t$1) return;
					const e$1 = this.map.painter.context, r$1 = e$1.gl;
					!this._dirty || this.texture instanceof Ef || (this.texture ? this.texture.update(this.image) : (this.texture = new Tf(e$1, this.image, r$1.RGBA8), this.texture.bind(r$1.LINEAR, r$1.CLAMP_TO_EDGE)), this._dirty = !1), t$1 && this._prepareData(e$1);
				}
				loadTile(t$1, e$1) {
					this.tileID && this.tileID.equals(t$1.tileID.canonical) ? (this.tiles[String(t$1.tileID.wrap)] = t$1, t$1.buckets = {}, e$1(null)) : (t$1.state = "errored", e$1(null));
				}
				serialize() {
					return {
						type: "image",
						url: this.options.url,
						coordinates: this.coordinates
					};
				}
				hasTransition() {
					return !1;
				}
				getSegmentsForLongitude(t$1) {
					const e$1 = this.elevatedGlobeSegments;
					if (!this.elevatedGlobeTrianglesCenterLongitudes || !e$1) return null;
					const r$1 = this.elevatedGlobeTrianglesCenterLongitudes;
					let n$1 = (i$1 = t$1 + 180) + 360 * Math.round((r$1[0] - i$1) / 360);
					var i$1;
					const s$1 = new hl(), o$1 = (t$2, r$2) => {
						s$1.segments.push({
							vertexOffset: 0,
							primitiveOffset: t$2,
							vertexLength: e$1.segments[0].vertexLength,
							primitiveLength: r$2,
							sortKey: void 0,
							vaos: {}
						});
					}, a$1 = .51 * this.maxLongitudeTriangleSize;
					if (Math.abs(r$1[0] - n$1) <= a$1) {
						const t$2 = re(r$1, 0, r$1.length, n$1 + a$1);
						return t$2 === r$1.length || o$1(t$2, ee(r$1, t$2 + 1, r$1.length, n$1 + 360 - a$1) - t$2), s$1;
					}
					n$1 < r$1[0] && (n$1 += 360);
					const l$1 = ee(r$1, 0, r$1.length, n$1 - a$1);
					if (l$1 === r$1.length) return o$1(0, r$1.length), s$1;
					o$1(0, l$1 - 0);
					const u$1 = re(r$1, l$1 + 1, r$1.length, n$1 + a$1);
					return u$1 !== r$1.length && o$1(u$1, r$1.length - u$1), s$1;
				}
			}
			const pv = (Math.pow(256, 2) - 1) / 16907520;
			class dv extends oa {
				constructor(t$1, e$1, r$1, n$1) {
					super(t$1, {
						layout: sv || (sv = new Do({ visibility: new Vo(Ro.layout_raster.visibility) })),
						paint: ov || (ov = new Do({
							"raster-opacity": new Vo(Ro.paint_raster["raster-opacity"]),
							"raster-color": new Co(Ro.paint_raster["raster-color"]),
							"raster-color-mix": new Vo(Ro.paint_raster["raster-color-mix"]),
							"raster-color-range": new Vo(Ro.paint_raster["raster-color-range"]),
							"raster-hue-rotate": new Vo(Ro.paint_raster["raster-hue-rotate"]),
							"raster-brightness-min": new Vo(Ro.paint_raster["raster-brightness-min"]),
							"raster-brightness-max": new Vo(Ro.paint_raster["raster-brightness-max"]),
							"raster-saturation": new Vo(Ro.paint_raster["raster-saturation"]),
							"raster-contrast": new Vo(Ro.paint_raster["raster-contrast"]),
							"raster-resampling": new Vo(Ro.paint_raster["raster-resampling"]),
							"raster-fade-duration": new Vo(Ro.paint_raster["raster-fade-duration"]),
							"raster-emissive-strength": new Vo(Ro.paint_raster["raster-emissive-strength"]),
							"raster-array-band": new Vo(Ro.paint_raster["raster-array-band"]),
							"raster-elevation": new Vo(Ro.paint_raster["raster-elevation"]),
							"raster-color-use-theme": new Fo({
								type: "string",
								default: "default",
								"property-type": "data-driven"
							})
						}))
					}, e$1, r$1, n$1), this.updateColorRamp(), this._curRampRange = [NaN, NaN];
				}
				getProgramIds() {
					return ["raster"];
				}
				hasColorMap() {
					return !!this._transitionablePaint._values["raster-color"].value.value;
				}
				tileCoverLift() {
					return this.paint.get("raster-elevation");
				}
				isDraped(t$1) {
					return !(t$1 && t$1._source instanceof hv && (t$1._source.onNorthPole || t$1._source.onSouthPole)) && 0 === this.paint.get("raster-elevation");
				}
				_handleSpecialPaintPropertyUpdate(t$1) {
					"raster-color" !== t$1 && "raster-color-range" !== t$1 || (this._curRampRange = [NaN, NaN], this.updateColorRamp());
				}
				_clear() {
					this.colorRampTexture && (this.colorRampTexture.destroy(), this.colorRampTexture = null);
				}
				updateColorRamp(t$1) {
					if (!this.hasColorMap()) return;
					if (!this._curRampRange) return;
					const e$1 = this._transitionablePaint._values["raster-color"].value.expression, [r$1, n$1] = t$1 || this._transitionablePaint._values["raster-color-range"].value.expression.evaluate({ zoom: 0 }) || [NaN, NaN];
					isNaN(r$1) && isNaN(n$1) || r$1 === this._curRampRange[0] && n$1 === this._curRampRange[1] || (this.colorRamp = Mh({
						expression: e$1,
						evaluationKey: "rasterValue",
						image: this.colorRamp,
						clips: [{
							start: r$1,
							end: n$1
						}],
						resolution: 256
					}), this.colorRampTexture = null, this._curRampRange = [r$1, n$1]);
				}
			}
			let fv, mv, yv, gv, xv;
			class vv extends oa {
				constructor(t$1, e$1, r$1, n$1) {
					super(t$1, {
						layout: fv || (fv = new Do({ visibility: new Vo(Ro["layout_raster-particle"].visibility) })),
						paint: mv || (mv = new Do({
							"raster-particle-array-band": new Vo(Ro["paint_raster-particle"]["raster-particle-array-band"]),
							"raster-particle-count": new Vo(Ro["paint_raster-particle"]["raster-particle-count"]),
							"raster-particle-color": new Co(Ro["paint_raster-particle"]["raster-particle-color"]),
							"raster-particle-max-speed": new Vo(Ro["paint_raster-particle"]["raster-particle-max-speed"]),
							"raster-particle-speed-factor": new Vo(Ro["paint_raster-particle"]["raster-particle-speed-factor"]),
							"raster-particle-fade-opacity-factor": new Vo(Ro["paint_raster-particle"]["raster-particle-fade-opacity-factor"]),
							"raster-particle-reset-rate-factor": new Vo(Ro["paint_raster-particle"]["raster-particle-reset-rate-factor"]),
							"raster-particle-elevation": new Vo(Ro["paint_raster-particle"]["raster-particle-elevation"]),
							"raster-particle-color-use-theme": new Fo({
								type: "string",
								default: "default",
								"property-type": "data-driven"
							})
						}))
					}, e$1, r$1, n$1), this._updateColorRamp(), this.lastInvalidatedAt = ye.now();
				}
				_clear() {
					this.colorRampTexture && (this.colorRampTexture.destroy(), this.colorRampTexture = null), this.tileFramebuffer && (this.tileFramebuffer.destroy(), this.tileFramebuffer = null), this.particleFramebuffer && (this.particleFramebuffer.destroy(), this.particleFramebuffer = null);
				}
				onRemove(t$1) {
					this.colorRampTexture && this.colorRampTexture.destroy(), this.tileFramebuffer && this.tileFramebuffer.destroy(), this.particleFramebuffer && this.particleFramebuffer.destroy();
				}
				hasColorMap() {
					return !!this._transitionablePaint._values["raster-particle-color"].value.value;
				}
				getProgramIds() {
					return ["rasterParticle"];
				}
				hasOffscreenPass() {
					return "none" !== this.visibility;
				}
				isDraped(t$1) {
					return !1;
				}
				_handleSpecialPaintPropertyUpdate(t$1) {
					"raster-particle-color" !== t$1 && "raster-particle-max-speed" !== t$1 || (this._updateColorRamp(), this._invalidateAnimationState()), "raster-particle-count" === t$1 && this._invalidateAnimationState();
				}
				_updateColorRamp() {
					if (!this.hasColorMap()) return;
					const t$1 = this._transitionablePaint._values["raster-particle-color"].value.expression, e$1 = this._transitionablePaint._values["raster-particle-max-speed"].value.expression.evaluate({ zoom: 0 });
					this.colorRamp = Mh({
						expression: t$1,
						evaluationKey: "rasterParticleSpeed",
						image: this.colorRamp,
						clips: [{
							start: 0,
							end: e$1
						}],
						resolution: 256
					}), this.colorRampTexture = null;
				}
				_invalidateAnimationState() {
					this.lastInvalidatedAt = ye.now();
				}
				tileCoverLift() {
					return this.paint.get("raster-particle-elevation");
				}
			}
			class bv extends oa {
				constructor(t$1, e$1) {
					super(t$1, {}, e$1, null), this.implementation = t$1, t$1.slot && (this.slot = t$1.slot);
				}
				is3D(t$1) {
					return "3d" === this.implementation.renderingMode;
				}
				hasOffscreenPass() {
					return void 0 !== this.implementation.prerender;
				}
				isDraped(t$1) {
					return void 0 !== this.implementation.renderToTile;
				}
				shouldRedrape() {
					return !!this.implementation.shouldRerenderTiles && this.implementation.shouldRerenderTiles();
				}
				recalculate() {}
				updateTransitions() {}
				hasTransition() {
					return !1;
				}
				serialize() {}
				onAdd(t$1) {
					this.implementation.onAdd && this.implementation.onAdd(t$1, t$1.painter.context.gl);
				}
				onRemove(t$1) {
					this.implementation.onRemove && this.implementation.onRemove(t$1, t$1.painter.context.gl);
				}
			}
			function wv(t$1, e$1, r$1) {
				const n$1 = [
					0,
					0,
					1
				], i$1 = et([]);
				return nt(i$1, i$1, r$1 ? -kt(t$1) + Math.PI : kt(t$1)), rt(i$1, i$1, -kt(e$1)), G(n$1, n$1, i$1), L(n$1, n$1);
			}
			const _v = {
				None: 0,
				Model: 1,
				Symbol: 2,
				FillExtrusion: 4
			};
			class Av {
				constructor(t$1, e$1, r$1, n$1) {
					this.message = (t$1 ? `${t$1}: ` : "") + r$1, n$1 && (this.identifier = n$1), null != e$1 && e$1.__line__ && (this.line = e$1.__line__);
				}
			}
			function Iv(t$1, e$1) {
				const r$1 = -1 === t$1.indexOf("://");
				try {
					return new URL(t$1, r$1 && e$1 ? "http://example.com" : void 0), !0;
				} catch (t$2) {
					return !1;
				}
			}
			class Mv {
				constructor(t$1, e$1) {
					this.feature = t$1, this.instancedDataOffset = e$1, this.instancedDataCount = 0, this.rotation = [
						0,
						0,
						0
					], this.scale = [
						1,
						1,
						1
					], this.translation = [
						0,
						0,
						0
					];
				}
			}
			class Sv {
				constructor() {
					this.maxScale = 1, this.maxXYTranslationDistance = 0, this.instancedDataArray = new qa(), this.instancesEvaluatedElevation = [], this.features = [], this.idToFeaturesIndex = {};
				}
				colorForInstance(t$1) {
					const e$1 = 16 * t$1, r$1 = this.instancedDataArray.float32;
					let n$1 = Math.floor(r$1[e$1 + 2]);
					const i$1 = 1.05 * (r$1[e$1 + 2] - n$1);
					return n$1 /= 100, [
						r$1[e$1] % 1 * 1.05,
						r$1[e$1 + 1] % 1 * 1.05,
						i$1,
						n$1
					];
				}
				tileCoordinatesForInstance(t$1) {
					const e$1 = 16 * t$1, r$1 = this.instancedDataArray.float32;
					let n$1 = r$1[e$1 + 0];
					return n$1 = n$1 > Un ? n$1 - Un : n$1, new It(Math.trunc(n$1), Math.trunc(r$1[e$1 + 1]));
				}
				translationForInstance(t$1) {
					const e$1 = 16 * t$1, r$1 = this.instancedDataArray.float32;
					return [
						r$1[e$1 + 4],
						r$1[e$1 + 5],
						r$1[e$1 + 6]
					];
				}
				rotationScaleForInstance(t$1) {
					const e$1 = 16 * t$1, r$1 = this.instancedDataArray.float32;
					return [
						r$1[e$1 + 7],
						r$1[e$1 + 8],
						r$1[e$1 + 9],
						r$1[e$1 + 10],
						r$1[e$1 + 11],
						r$1[e$1 + 12],
						r$1[e$1 + 13],
						r$1[e$1 + 14],
						r$1[e$1 + 15]
					];
				}
				transformForInstance(t$1) {
					const e$1 = 16 * t$1, r$1 = this.instancedDataArray.float32;
					return [
						r$1[e$1 + 7],
						r$1[e$1 + 8],
						r$1[e$1 + 9],
						r$1[e$1 + 4],
						r$1[e$1 + 10],
						r$1[e$1 + 11],
						r$1[e$1 + 12],
						r$1[e$1 + 5],
						r$1[e$1 + 13],
						r$1[e$1 + 14],
						r$1[e$1 + 15],
						r$1[e$1 + 6],
						0,
						0,
						0,
						1
					];
				}
			}
			class Pv {
				constructor(t$1) {
					this.zoom = t$1.zoom, this.canonical = t$1.canonical, this.overscaledZ = this.canonical.z + Math.log2(t$1.overscaling), this.layers = t$1.layers, this.layerIds = this.layers.map(((t$2) => t$2.fqid)), this.projection = t$1.projection, this.index = t$1.index, this.worldview = t$1.worldview, this.hasZoomDependentProperties = this.layers[0].isZoomDependent(), this.stateDependentLayerIds = this.layers.filter(((t$2) => t$2.isStateDependent())).map(((t$2) => t$2.id)), this.hasPattern = !1, this.instancesPerModel = {}, this.validForExaggeration = 0, this.maxVerticalOffset = 0, this.maxScale = 0, this.maxHeight = 0, this.lookupDim = this.zoom > this.canonical.z + 1 ? 0 : this.zoom > this.canonical.z ? 256 : this.zoom > 15 ? 75 : 100, this.instanceCount = 0, this.terrainElevationMin = 0, this.terrainElevationMax = 0, this.validForDEMTile = {
						id: null,
						timestamp: 0
					}, this.modelUris = [], this.modelsRequested = !1, this.activeReplacements = [], this.replacementUpdateTime = 0, this.styleDefinedModelURLs = t$1.styleDefinedModelURLs, this.hasAppearances = null;
				}
				updateFootprints(t$1, e$1) {}
				updateAppearances(t$1, e$1, r$1, n$1) {}
				populate(t$1, e$1, r$1, n$1) {
					this.tileToMeter = vu(r$1);
					const i$1 = this.layers[0]._featureFilter.needGeometry;
					this.lookup = new Uint8Array(this.lookupDim * this.lookupDim);
					for (const { feature: s$1, id: o$1, index: a$1, sourceLayerIndex: l$1 } of t$1) {
						const t$2 = null != o$1 ? o$1 : s$1.properties && s$1.properties.hasOwnProperty("id") ? s$1.properties.id : void 0, u$1 = Bu(s$1, i$1);
						if (!this.layers[0]._featureFilter.filter(new Io(this.zoom, {
							worldview: this.worldview,
							activeFloors: e$1.activeFloors
						}), u$1, r$1)) continue;
						const c$1 = {
							id: t$2,
							sourceLayerIndex: l$1,
							index: a$1,
							geometry: i$1 ? u$1.geometry : ku(s$1, r$1, n$1),
							properties: s$1.properties,
							type: s$1.type,
							patterns: {}
						}, h$1 = this.addFeature(c$1, c$1.geometry, u$1);
						h$1 && e$1.featureIndex.insert(s$1, c$1.geometry, a$1, l$1, this.index, this.instancesPerModel[h$1].instancedDataArray.length, Un / 32);
					}
					this.lookup = null;
				}
				evaluateQueryRenderedFeaturePadding() {
					const t$1 = this.layers[0].modelManager, e$1 = this.layers[0].scope;
					let r$1 = 0;
					for (const n$1 of this.modelUris) {
						const i$1 = t$1.getModel(n$1, e$1);
						if (!i$1) continue;
						const s$1 = this.instancesPerModel[n$1];
						if (s$1) {
							const t$2 = .5 * F(i$1.aabb.max, i$1.aabb.min) * s$1.maxScale + s$1.maxXYTranslationDistance, e$2 = Math.min(Un, Math.max(t$2 / this.tileToMeter, Un / 32));
							r$1 = Math.max(e$2, r$1);
						}
					}
					return r$1;
				}
				update(t$1, e$1, r$1, n$1) {
					for (const e$2 in this.instancesPerModel) {
						const r$2 = this.instancesPerModel[e$2];
						for (const e$3 in t$1) r$2.idToFeaturesIndex.hasOwnProperty(e$3) && (this.evaluate(r$2.features[r$2.idToFeaturesIndex[e$3]], t$1[e$3], r$2, !0), this.uploaded = !1);
					}
					this.maxHeight = 0;
				}
				updateZoomBasedPaintProperties() {
					if (!this.hasZoomDependentProperties) return !1;
					let t$1 = !1;
					for (const e$1 in this.instancesPerModel) {
						const r$1 = this.instancesPerModel[e$1];
						for (const e$2 of r$1.features) {
							const n$1 = this.layers[0], i$1 = e$2.feature, s$1 = this.canonical, o$1 = n$1.paint.get("model-rotation").evaluate(i$1, {}, s$1), a$1 = n$1.paint.get("model-scale").evaluate(i$1, {}, s$1), l$1 = n$1.paint.get("model-translation").evaluate(i$1, {}, s$1);
							H(e$2.rotation, o$1) && H(e$2.scale, a$1) && H(e$2.translation, l$1) || (this.evaluate(e$2, e$2.featureStates, r$1, !0), t$1 = !0);
						}
					}
					return t$1;
				}
				updateReplacement(t$1, e$1, r$1, n$1) {
					if (e$1.updateTime === this.replacementUpdateTime) return !1;
					this.replacementUpdateTime = e$1.updateTime;
					const i$1 = e$1.getReplacementRegionsForTile(t$1.toUnwrapped(), !0);
					if (jp(this.activeReplacements, i$1)) return !1;
					this.activeReplacements = i$1;
					let s$1 = !1;
					for (const e$2 in this.instancesPerModel) {
						const i$2 = this.instancesPerModel[e$2], o$1 = i$2.instancedDataArray;
						for (const e$3 of i$2.features) {
							const i$3 = e$3.instancedDataOffset, a$1 = e$3.instancedDataCount;
							for (let e$4 = 0; e$4 < a$1; e$4++) {
								const a$2 = 16 * (e$4 + i$3);
								let l$1 = o$1.float32[a$2 + 0];
								const u$1 = l$1 > Un;
								l$1 = u$1 ? l$1 - Un : l$1;
								const c$1 = Math.floor(l$1), h$1 = Math.floor(o$1.float32[a$2 + 1]);
								let p$1 = !1;
								for (const e$5 of this.activeReplacements) if (!Lp(e$5, r$1, _v.Model, n$1) && !(e$5.min.x > c$1 || c$1 > e$5.max.x || e$5.min.y > h$1 || h$1 > e$5.max.y) && (p$1 = Zp(Xp(c$1, h$1, t$1.canonical, e$5.footprintTileId.canonical), e$5.footprint), p$1)) break;
								o$1.float32[a$2] = p$1 ? l$1 + Un : l$1, s$1 = s$1 || p$1 !== u$1;
							}
						}
					}
					return s$1;
				}
				isEmpty() {
					for (const t$1 in this.instancesPerModel) if (0 !== this.instancesPerModel[t$1].instancedDataArray.length) return !1;
					return !0;
				}
				uploadPending() {
					return !this.uploaded;
				}
				upload(t$1) {
					if (!this.uploaded) for (const e$1 in this.instancesPerModel) {
						const r$1 = this.instancesPerModel[e$1];
						r$1.instancedDataArray.length < 0 || 0 === r$1.instancedDataArray.length || (r$1.instancedDataBuffer ? r$1.instancedDataBuffer.updateData(r$1.instancedDataArray) : r$1.instancedDataBuffer = t$1.createVertexBuffer(r$1.instancedDataArray, Lf.members, !0, void 0, this.instanceCount));
					}
					this.uploaded = !0;
				}
				destroy(t$1) {
					for (const t$2 in this.instancesPerModel) {
						const e$2 = this.instancesPerModel[t$2];
						0 !== e$2.instancedDataArray.length && e$2.instancedDataBuffer && e$2.instancedDataBuffer.destroy();
					}
					const e$1 = this.layers[0].modelManager;
					if (t$1 && e$1 && this.modelUris && this.modelsRequested) for (const t$2 of this.modelUris) e$1.removeModel(t$2, "", !0);
				}
				addFeature(t$1, e$1, r$1) {
					const n$1 = this.layers[0], i$1 = n$1.layout.get("model-id").evaluate(r$1, {}, this.canonical);
					if (!i$1) return Xt(`modelId is not evaluated for layer ${n$1.id} and it is not going to get rendered.`), i$1;
					(Iv(i$1, !1) || void 0 !== this.styleDefinedModelURLs[i$1]) && (this.modelUris.includes(i$1) || this.modelUris.push(i$1)), this.instancesPerModel[i$1] || (this.instancesPerModel[i$1] = new Sv());
					const s$1 = this.instancesPerModel[i$1], o$1 = s$1.instancedDataArray, a$1 = new Mv(r$1, o$1.length);
					for (const t$2 of e$1) for (const e$2 of t$2) {
						if (e$2.x < 0 || e$2.x >= Un || e$2.y < 0 || e$2.y >= Un) continue;
						if (0 !== this.lookupDim) {
							const t$4 = (this.lookupDim - 1) / Un, r$2 = this.lookupDim * (e$2.y * t$4 | 0) + e$2.x * t$4 | 0;
							if (this.lookup) {
								if (0 !== this.lookup[r$2]) continue;
								this.lookup[r$2] = 1;
							}
						}
						this.instanceCount++;
						const t$3 = o$1.length;
						o$1.resize(t$3 + 1), s$1.instancesEvaluatedElevation.push(0), o$1.float32[16 * t$3] = e$2.x, o$1.float32[16 * t$3 + 1] = e$2.y;
					}
					return a$1.instancedDataCount = s$1.instancedDataArray.length - a$1.instancedDataOffset, a$1.instancedDataCount > 0 && (t$1.id && (s$1.idToFeaturesIndex[t$1.id] = s$1.features.length), s$1.features.push(a$1), this.evaluate(a$1, {}, s$1, !1)), i$1;
				}
				getModelUris() {
					return this.modelUris;
				}
				evaluate(t$1, e$1, r$1, n$1) {
					const i$1 = this.layers[0], s$1 = t$1.feature, o$1 = this.canonical, a$1 = t$1.rotation = i$1.paint.get("model-rotation").evaluate(s$1, e$1, o$1), l$1 = t$1.scale = i$1.paint.get("model-scale").evaluate(s$1, e$1, o$1), u$1 = t$1.translation = i$1.paint.get("model-translation").evaluate(s$1, e$1, o$1), c$1 = Object.assign({}, i$1.paint.get("model-color").evaluate(s$1, e$1, o$1));
					c$1.a = i$1.paint.get("model-color-mix-intensity").evaluate(s$1, e$1, o$1);
					const h$1 = [];
					this.maxVerticalOffset < u$1[2] && (this.maxVerticalOffset = u$1[2]);
					const p$1 = u$1[0] * u$1[0] + u$1[1] * u$1[1], d$1 = p$1 > 0 ? Math.sqrt(p$1) : 0;
					r$1.maxScale = Math.max(Math.max(r$1.maxScale, l$1[0]), Math.max(l$1[1], l$1[2])), r$1.maxXYTranslationDistance = Math.max(r$1.maxXYTranslationDistance, d$1), this.maxScale = Math.max(Math.max(this.maxScale, l$1[0]), Math.max(l$1[1], l$1[2])), Hf(h$1, a$1, l$1);
					const f$1 = Math.round(100 * c$1.a) + c$1.b / 1.05;
					for (let e$2 = 0; e$2 < t$1.instancedDataCount; ++e$2) {
						const i$2 = t$1.instancedDataOffset + e$2, s$2 = 16 * i$2, a$2 = r$1.instancedDataArray.float32;
						let l$2 = 0;
						n$1 && (l$2 = a$2[s$2 + 6] - r$1.instancesEvaluatedElevation[i$2]);
						const p$2 = 0 | a$2[s$2 + 1];
						a$2[s$2] = (0 | a$2[s$2]) + c$1.r / 1.05, a$2[s$2 + 1] = p$2 + c$1.g / 1.05, a$2[s$2 + 2] = f$1, a$2[s$2 + 3] = 1 / (o$1.z > 10 ? this.tileToMeter : vu(o$1, p$2)), a$2[s$2 + 4] = u$1[0], a$2[s$2 + 5] = u$1[1], a$2[s$2 + 6] = u$1[2] + l$2, a$2[s$2 + 7] = h$1[0], a$2[s$2 + 8] = h$1[1], a$2[s$2 + 9] = h$1[2], a$2[s$2 + 10] = h$1[4], a$2[s$2 + 11] = h$1[5], a$2[s$2 + 12] = h$1[6], a$2[s$2 + 13] = h$1[8], a$2[s$2 + 14] = h$1[9], a$2[s$2 + 15] = h$1[10], r$1.instancesEvaluatedElevation[i$2] = u$1[2];
					}
				}
			}
			let kv, Bv;
			Qs(Pv, "ModelBucket", { omit: ["layers"] }), Qs(Sv, "PerModelAttributes"), Qs(Mv, "ModelFeature");
			class zv {
				constructor(t$1, e$1, r$1) {
					this._demTile = t$1, this._dem = this._demTile.dem, this._scale = e$1, this._offset = r$1;
				}
				static create(t$1, e$1, r$1) {
					const n$1 = r$1 || t$1.findDEMTileFor(e$1);
					if (!n$1 || !n$1.dem) return;
					const i$1 = n$1.dem, s$1 = n$1.tileID, o$1 = 1 << e$1.canonical.z - s$1.canonical.z;
					return new zv(n$1, i$1.dim / Un / o$1, [(e$1.canonical.x / o$1 - s$1.canonical.x) * i$1.dim, (e$1.canonical.y / o$1 - s$1.canonical.y) * i$1.dim]);
				}
				tileCoordToPixel(t$1, e$1) {
					const r$1 = e$1 * this._scale + this._offset[1];
					return new It(Math.floor(t$1 * this._scale + this._offset[0]), Math.floor(r$1));
				}
				getElevationAt(t$1, e$1, r$1, n$1) {
					const i$1 = t$1 * this._scale + this._offset[0], s$1 = e$1 * this._scale + this._offset[1], o$1 = Math.floor(i$1), a$1 = Math.floor(s$1), l$1 = this._dem;
					return n$1 = !!n$1, r$1 ? pr(pr(l$1.get(o$1, a$1, n$1), l$1.get(o$1, a$1 + 1, n$1), s$1 - a$1), pr(l$1.get(o$1 + 1, a$1, n$1), l$1.get(o$1 + 1, a$1 + 1, n$1), s$1 - a$1), i$1 - o$1) : l$1.get(o$1, a$1, n$1);
				}
				getElevationAtPixel(t$1, e$1, r$1) {
					return this._dem.get(t$1, e$1, !!r$1);
				}
				getMeterToDEM(t$1) {
					return (1 << this._demTile.tileID.canonical.z) * hu(1, t$1) * this._dem.stride;
				}
			}
			const Tv = new Float32Array(262144), Ev = new Uint8Array(262144);
			function Vv(t$1) {
				let e$1 = 0;
				if (t$1.meshes) for (const r$1 of t$1.meshes) e$1 = Math.max(e$1, r$1.aabb.max[2]);
				if (t$1.children) for (const r$1 of t$1.children) e$1 = Math.max(e$1, Vv(r$1));
				return e$1;
			}
			function Fv(t$1, e$1, r$1) {
				if (t$1.meshes) for (const n$1 of t$1.meshes) {
					if (n$1.aabb.min[0] === Infinity) continue;
					const i$1 = Ju.applyTransform(n$1.aabb, t$1.globalMatrix);
					r$1.insert(e$1, i$1.min[0], i$1.min[1], i$1.max[0], i$1.max[1]);
				}
				if (t$1.children) for (const n$1 of t$1.children) Fv(n$1, e$1, r$1);
			}
			const Cv = [
				"",
				"wall",
				"door",
				"roof",
				"window",
				"lamp",
				"logo"
			];
			class Dv {
				constructor(t$1) {
					this.node = t$1, this.evaluatedRMEA = [
						[
							1,
							0,
							0,
							1
						],
						[
							1,
							0,
							0,
							1
						],
						[
							1,
							0,
							0,
							1
						],
						[
							1,
							0,
							0,
							1
						],
						[
							.4,
							1,
							0,
							1
						],
						[
							1,
							0,
							0,
							1
						],
						[
							1,
							0,
							0,
							1
						]
					], this.hiddenByReplacement = !1, this.evaluatedTranslation = [
						0,
						0,
						0
					], this.evaluatedScale = [
						1,
						1,
						1
					], this.evaluatedColor = [], this.emissionHeightBasedParams = [], this.cameraCollisionOpacity = 1, this.feature = {
						type: "Point",
						id: t$1.id,
						geometry: [],
						properties: { height: Vv(t$1) }
					}, this.aabb = this._getLocalBounds(), this.state = null;
				}
				_getLocalBounds() {
					if (!this.node.meshes) return new Ju([
						Infinity,
						Infinity,
						Infinity
					], [
						-Infinity,
						-Infinity,
						-Infinity
					]);
					if (!this.aabb) {
						let t$1 = 0;
						const e$1 = new Ju([
							Infinity,
							Infinity,
							Infinity
						], [
							-Infinity,
							-Infinity,
							-Infinity
						]);
						for (const r$1 of this.node.meshes) this.node.lightMeshIndex !== t$1 && (r$1.transformedAabb = Ju.applyTransformFast(r$1.aabb, this.node.globalMatrix), e$1.encapsulate(r$1.transformedAabb)), t$1++;
						this.aabb = e$1;
					}
					return this.aabb;
				}
			}
			class Rv {
				constructor(t$1, e$1, r$1, n$1, i$1, s$1, o$1, a$1) {
					this.id = r$1, this.layers = t$1, this.layerIds = this.layers.map(((t$2) => t$2.fqid)), this.stateDependentLayerIds = this.layers.filter(((t$2) => t$2.isStateDependent())).map(((t$2) => t$2.id)), this.modelTraits |= Kf.CoordinateSpaceTile, this.uploaded = !1, this.hasPattern = !1, n$1 && (this.modelTraits |= Kf.HasMapboxMeshFeatures), i$1 && (this.modelTraits |= Kf.HasMeshoptCompression), this.zoom = -1, this.terrainExaggeration = 1, this.projection = { name: "mercator" }, this.replacementUpdateTime = 0, this.elevationReadFromZ = 255, this.brightness = s$1, this.worldview = a$1, this.dirty = !0, this.needsUpload = !1, this.filter = null, this.nodesInfo = [];
					for (const t$2 of e$1) this.nodesInfo.push(new Dv(t$2)), Fv(t$2, o$1.featureIndexArray.length, o$1.grid), o$1.featureIndexArray.emplaceBack(this.nodesInfo.length - 1, 0, o$1.bucketLayerIDs.length - 1, 0);
					this.states = {}, this.hasAppearances = null;
				}
				updateFootprints(t$1, e$1) {
					for (const r$1 of this.getNodesInfo()) {
						const n$1 = r$1.node;
						n$1.footprint && e$1.push({
							footprint: n$1.footprint,
							id: t$1
						});
					}
				}
				updateAppearances(t$1, e$1, r$1, n$1) {}
				update(t$1) {
					const e$1 = 0 !== Object.keys(t$1).length;
					if (e$1 && !this.stateDependentLayers.length) return;
					const r$1 = e$1 ? this.stateDependentLayers : this.layers;
					if (!Mt(t$1, this.states)) for (const e$2 of r$1) this.evaluate(e$2, t$1);
					this.states = structuredClone(t$1);
				}
				populate() {
					console.log("populate 3D model bucket");
				}
				uploadPending() {
					return !this.uploaded || this.needsUpload;
				}
				upload(t$1) {
					if (!this.needsUpload) return;
					const e$1 = this.getNodesInfo();
					for (const r$1 of e$1) {
						const e$2 = r$1.node;
						this.uploaded ? this.updatePbrBuffer(e$2) : rm(e$2, t$1, !0);
					}
					for (const t$2 of e$1) nm(t$2.node);
					this.uploaded = !0, this.needsUpload = !1;
				}
				updatePbrBuffer(t$1) {
					let e$1 = !1;
					if (!t$1.meshes) return e$1;
					for (const r$1 of t$1.meshes) r$1.pbrBuffer && (r$1.pbrBuffer.updateData(r$1.featureArray), e$1 = !0);
					return e$1;
				}
				needsReEvaluation(t$1, e$1, r$1) {
					const n$1 = t$1.transform.projectionOptions, i$1 = t$1.style.getBrightness(), s$1 = this.brightness !== i$1;
					if (!this.uploaded || this.dirty || n$1.name !== this.projection.name || Lv(r$1.paint.get("model-color").value, s$1) || Lv(r$1.paint.get("model-color-mix-intensity").value, s$1) || Lv(r$1.paint.get("model-roughness").value, s$1) || Lv(r$1.paint.get("model-emissive-strength").value, s$1) || Lv(r$1.paint.get("model-height-based-emissive-strength-multiplier").value, s$1)) {
						this.projection = n$1, this.brightness = i$1;
						const t$2 = this.getNodesInfo();
						for (const e$2 of t$2) e$2.state = null;
						return !0;
					}
					return !1;
				}
				evaluateTransform(t$1, e$1) {
					if (t$1.transform.zoom === this.zoom) return;
					this.zoom = t$1.transform.zoom;
					const r$1 = this.getNodesInfo(), n$1 = this.id.canonical;
					for (const t$2 of r$1) {
						const r$2 = t$2.feature;
						t$2.evaluatedTranslation = e$1.paint.get("model-translation").evaluate(r$2, {}, n$1), t$2.evaluatedScale = e$1.paint.get("model-scale").evaluate(r$2, {}, n$1);
					}
				}
				evaluate(t$1, e$1) {
					const r$1 = this.getNodesInfo();
					for (const n$1 of r$1) {
						if (!n$1.node.meshes) continue;
						const r$2 = n$1.feature, i$1 = e$1 && e$1[r$2.id];
						if (Mt(i$1, n$1.state)) continue;
						n$1.state = structuredClone(i$1);
						const s$1 = n$1.node.meshes && n$1.node.meshes[0].featureData, o$1 = n$1.evaluatedColor[2], a$1 = n$1.evaluatedRMEA[2], l$1 = this.id.canonical;
						if (n$1.hasTranslucentParts = !1, s$1) {
							for (let e$2 = 0; e$2 < Cv.length; e$2++) {
								const s$2 = Cv[e$2];
								s$2.length && (r$2.properties.part = s$2);
								const o$2 = t$1.paint.get("model-color").evaluate(r$2, i$1, l$1).toPremultipliedRenderColor(null), a$2 = t$1.paint.get("model-color-mix-intensity").evaluate(r$2, i$1, l$1);
								n$1.evaluatedColor[e$2] = [
									o$2.r,
									o$2.g,
									o$2.b,
									a$2
								], n$1.evaluatedRMEA[e$2][0] = t$1.paint.get("model-roughness").evaluate(r$2, i$1, l$1), n$1.evaluatedRMEA[e$2][2] = t$1.paint.get("model-emissive-strength").evaluate(r$2, i$1, l$1), n$1.evaluatedRMEA[e$2][3] = o$2.a, n$1.emissionHeightBasedParams[e$2] = t$1.paint.get("model-height-based-emissive-strength-multiplier").evaluate(r$2, i$1, l$1), !n$1.hasTranslucentParts && o$2.a < 1 && (n$1.hasTranslucentParts = !0);
							}
							delete r$2.properties.part, Uv(n$1, o$1 !== n$1.evaluatedColor[2] || a$1 !== n$1.evaluatedRMEA[2], this.modelTraits);
						} else n$1.evaluatedRMEA[0][2] = t$1.paint.get("model-emissive-strength").evaluate(r$2, i$1, l$1);
						n$1.evaluatedTranslation = t$1.paint.get("model-translation").evaluate(r$2, i$1, l$1), n$1.evaluatedScale = t$1.paint.get("model-scale").evaluate(r$2, i$1, l$1), this.updatePbrBuffer(n$1.node) || (this.needsUpload = !0);
					}
					this.dirty = !1;
				}
				elevationUpdate(t$1, e$1, r$1, n$1) {
					const i$1 = t$1.findDEMTileFor(r$1);
					if (i$1 && (i$1.tileID.canonical !== this.terrainTile || e$1 !== this.terrainExaggeration)) {
						if (i$1.dem && i$1.tileID.overscaledZ !== this.elevationReadFromZ) {
							this.elevationReadFromZ = i$1.tileID.overscaledZ;
							const e$2 = zv.create(t$1, r$1, i$1);
							if (!e$2) return;
							this.modelTraits & Kf.HasMapboxMeshFeatures && this.updateDEM(t$1, e$2, r$1, n$1);
							for (const t$2 of this.getNodesInfo()) {
								const r$2 = t$2.node;
								if (!r$2.footprint || !r$2.footprint.vertices || !r$2.footprint.vertices.length) continue;
								const n$2 = r$2.footprint.vertices;
								let i$2 = e$2.getElevationAt(n$2[0].x, n$2[0].y, !0, !0);
								for (let t$3 = 1; t$3 < n$2.length; t$3++) i$2 = Math.min(i$2, e$2.getElevationAt(n$2[t$3].x, n$2[t$3].y, !0, !0));
								r$2.elevation = i$2;
							}
						}
						this.terrainTile = i$1.tileID.canonical, this.terrainExaggeration = e$1;
					}
				}
				updateDEM(t$1, e$1, r$1, n$1) {
					let i$1 = e$1._dem._modifiedForSources[n$1];
					if (void 0 === i$1 && (e$1._dem._modifiedForSources[n$1] = [], i$1 = e$1._dem._modifiedForSources[n$1]), i$1.includes(r$1.canonical)) return;
					const s$1 = e$1._dem.dim;
					i$1.push(r$1.canonical);
					let o$1 = !1;
					for (const t$2 of this.getNodesInfo()) {
						const r$2 = t$2.node;
						if (!r$2.footprint || !r$2.footprint.grid) continue;
						const n$2 = r$2.footprint.grid, i$2 = e$1.tileCoordToPixel(n$2.min.x, n$2.min.y), a$1 = e$1.tileCoordToPixel(n$2.max.x, n$2.max.y), l$1 = Math.min(Math.min(s$1 - a$1.y, i$2.x), Math.min(i$2.y, s$1 - a$1.x));
						if (l$1 < 0) continue;
						const u$1 = Ft(l$1, 2, 5);
						let c$1 = Math.max(0, i$2.x - u$1), h$1 = Math.max(0, i$2.y - u$1), p$1 = Math.min(a$1.x + u$1, s$1 - 1), d$1 = Math.min(a$1.y + u$1, s$1 - 1);
						for (let t$3 = h$1; t$3 <= d$1; ++t$3) for (let e$2 = c$1; e$2 <= p$1; ++e$2) Ev[t$3 * s$1 + e$2] = 255;
						let f$1 = 0, m$1 = 0;
						for (let t$3 = 0; t$3 < n$2.cellsY; ++t$3) for (let r$3 = 0; r$3 < n$2.cellsX; ++r$3) {
							if (!n$2.cells[t$3 * n$2.cellsX + r$3]) continue;
							const i$3 = e$1.tileCoordToPixel(n$2.min.x + r$3 / n$2.xScale, n$2.min.y + t$3 / n$2.yScale), o$2 = e$1.tileCoordToPixel(n$2.min.x + (r$3 + 1) / n$2.xScale, n$2.min.y + (t$3 + 1) / n$2.yScale);
							for (let t$4 = i$3.y; t$4 <= Math.min(o$2.y + 1, s$1 - 1); ++t$4) for (let r$4 = i$3.x; r$4 <= Math.min(o$2.x + 1, s$1 - 1); ++r$4) 255 === Ev[t$4 * s$1 + r$4] && (Ev[t$4 * s$1 + r$4] = 0, f$1 += e$1.getElevationAtPixel(r$4, t$4), m$1++);
						}
						const y$1 = f$1 / m$1;
						c$1 = Math.max(1, i$2.x - u$1), h$1 = Math.max(1, i$2.y - u$1), p$1 = Math.min(a$1.x + u$1, s$1 - 2), d$1 = Math.min(a$1.y + u$1, s$1 - 2), o$1 = !0;
						for (let t$3 = h$1; t$3 <= d$1; ++t$3) for (let r$3 = c$1; r$3 <= p$1; ++r$3) 0 === Ev[t$3 * s$1 + r$3] && (Tv[t$3 * s$1 + r$3] = e$1._dem.set(r$3, t$3, y$1));
						for (let t$3 = 1; t$3 < u$1; ++t$3) {
							c$1 = Math.max(1, i$2.x - t$3), h$1 = Math.max(1, i$2.y - t$3), p$1 = Math.min(a$1.x + t$3, s$1 - 2), d$1 = Math.min(a$1.y + t$3, s$1 - 2);
							for (let r$3 = h$1; r$3 <= d$1; ++r$3) for (let n$3 = c$1; n$3 <= p$1; ++n$3) {
								const i$3 = r$3 * s$1 + n$3;
								if (255 === Ev[i$3]) {
									let o$2 = 0, a$2 = 0, l$2 = -1, c$2 = -1;
									for (let e$2 = -1; e$2 <= 1; ++e$2) for (let i$4 = -1; i$4 <= 1; ++i$4) {
										const u$2 = (r$3 + e$2) * s$1 + n$3 + i$4;
										if (Ev[u$2] >= t$3) continue;
										const h$2 = Tv[u$2], p$2 = Math.abs(h$2);
										p$2 > a$2 && (o$2 = h$2, a$2 = p$2, l$2 = i$4, c$2 = e$2);
									}
									if (a$2 > .1) {
										const s$2 = 1 - (t$3 + .5 * Math.abs(l$2 * c$2)) / u$1;
										let a$3 = e$1._dem.get(n$3, r$3) + o$2 * s$2;
										const h$2 = e$1._dem.get(n$3 + l$2, r$3 + c$2), p$2 = e$1._dem.get(n$3 - l$2, r$3 - c$2, !0);
										(a$3 - h$2) * (a$3 - p$2) > 0 && (a$3 = (h$2 + p$2) / 2), Tv[i$3] = e$1._dem.set(n$3, r$3, a$3), Ev[i$3] = t$3;
									}
								}
							}
						}
					}
					o$1 && (e$1._demTile.needsDEMTextureUpload = !0, e$1._dem._timestamp = ye.now());
				}
				setFilter(t$1) {
					this.filter = t$1 ? No(t$1) : null;
				}
				getNodesInfo() {
					return this.filter ? this.nodesInfo.filter(((t$1) => this.filter.filter(new Io(this.id.overscaledZ, { worldview: this.worldview }), t$1.feature, this.id.canonical))) : this.nodesInfo;
				}
				destroy() {
					const t$1 = this.getNodesInfo();
					for (const e$1 of t$1) nm(e$1.node), im(e$1.node);
				}
				isEmpty() {
					return !this.nodesInfo.length;
				}
				updateReplacement(t$1, e$1) {
					if (e$1.updateTime === this.replacementUpdateTime) return;
					this.replacementUpdateTime = e$1.updateTime;
					const r$1 = e$1.getReplacementRegionsForTile(t$1.toUnwrapped());
					for (const t$2 of this.getNodesInfo()) {
						const e$2 = t$2.node.footprint;
						t$2.hiddenByReplacement = !!e$2 && !r$1.find(((t$3) => t$3.footprint === e$2));
					}
				}
				getHeightAtTileCoord(t$1, e$1) {
					const r$1 = [], n$1 = [
						0,
						0,
						0
					], i$1 = u([]);
					for (const s$1 of this.getNodesInfo()) {
						const o$1 = s$1.node.meshes[0], a$1 = o$1.transformedAabb;
						if (t$1 < a$1.min[0] || e$1 < a$1.min[1] || t$1 > a$1.max[0] || e$1 > a$1.max[1]) continue;
						if (!0 === s$1.node.hidden) return {
							height: Infinity,
							maxHeight: s$1.feature.properties.height,
							hidden: !1,
							verticalScale: s$1.evaluatedScale[2]
						};
						c(i$1, s$1.node.globalMatrix), n$1[0] = t$1, n$1[1] = e$1, j(n$1, n$1, i$1);
						const l$1 = (n$1[0] - o$1.aabb.min[0]) / (o$1.aabb.max[0] - o$1.aabb.min[0]) * Yf | 0, u$1 = Math.min(63, (n$1[1] - o$1.aabb.min[1]) / (o$1.aabb.max[1] - o$1.aabb.min[1]) * Yf | 0) * Yf + Math.min(63, l$1), h$1 = o$1.heightmap[u$1];
						if (!(h$1 < 0 && s$1.node.footprint)) {
							if (s$1.hiddenByReplacement) return;
							return {
								height: h$1,
								maxHeight: s$1.feature.properties.height,
								hidden: !1,
								verticalScale: s$1.evaluatedScale[2]
							};
						}
						if (s$1.node.footprint.grid.query(new It(t$1, e$1), new It(t$1, e$1), r$1), r$1.length > 0) return {
							height: void 0,
							maxHeight: s$1.feature.properties.height,
							hidden: s$1.hiddenByReplacement,
							verticalScale: s$1.evaluatedScale[2]
						};
					}
				}
			}
			function Lv(t$1, e$1) {
				return t$1 instanceof $s && !t$1.isLightConstant && e$1;
			}
			function Ov(t$1, e$1, r$1, n$1, i$1, s$1, o$1, a$1) {
				let l$1 = (61440 & e$1 | (61440 & e$1) >> 4) >> 8, u$1 = (3840 & e$1 | (3840 & e$1) >> 4) >> 4, c$1 = 240 & e$1 | (240 & e$1) >> 4;
				r$1[3] > 0 && (l$1 = pr(l$1, 255 * r$1[0], r$1[3]), u$1 = pr(u$1, 255 * r$1[1], r$1[3]), c$1 = pr(c$1, 255 * r$1[2], r$1[3]));
				const h$1 = l$1 << 8 | u$1, p$1 = c$1 << 8 | Math.floor(255 * n$1[3]), d$1 = function(t$2) {
					const e$2 = Ft(t$2, 0, 2);
					return Math.min(Math.round(.5 * e$2 * 255), 255);
				}(n$1[2]) << 8 | 15 * n$1[0] << 4 | 15 * n$1[1], f$1 = Ft(i$1[0], 0, 1), m$1 = Ft(i$1[1], 0, 1), y$1 = Ft(i$1[2], 0, 1), g$1 = Ft(i$1[3], 0, 1);
				let x$1, v$1, b$1, w$1;
				if (f$1 !== m$1 && o$1 !== s$1 && m$1 !== f$1) {
					const t$2 = o$1 - s$1;
					v$1 = 1 / (t$2 * (m$1 - f$1)), b$1 = -(s$1 + t$2 * f$1) / (t$2 * (m$1 - f$1));
					const e$2 = Ft(i$1[4], -1, 1);
					w$1 = Math.pow(10, e$2), x$1 = 255 * y$1 << 8 | 255 * g$1;
				} else x$1 = 65535, v$1 = 0, b$1 = 1, w$1 = 1;
				if (t$1.emplaceBack(h$1, p$1, d$1, x$1, v$1, b$1, w$1), a$1) {
					const t$2 = a$1.length;
					a$1.clear();
					for (let e$2 = 0; e$2 < t$2; e$2++) a$1.emplaceBack(h$1, p$1, d$1, x$1, v$1, b$1, w$1);
				}
			}
			function Uv(t$1, e$1, r$1) {
				const n$1 = t$1.node;
				let i$1 = 0;
				const s$1 = r$1 & Kf.HasMeshoptCompression;
				for (const r$2 of n$1.meshes) {
					if (n$1.lights && n$1.lightMeshIndex === i$1) continue;
					if (!r$2.featureData) continue;
					r$2.featureArray = new Ha(), r$2.featureArray.reserve(r$2.featureData.length);
					let o$1 = e$1;
					for (const e$2 of r$2.featureData) {
						const i$2 = s$1 ? 65535 & e$2 : e$2 >> 16 & 65535, a$1 = s$1 ? e$2 >> 16 & 65535 : 65535 & e$2, l$1 = (15 & a$1) < 8 ? 15 & a$1 : 0, u$1 = t$1.evaluatedRMEA[l$1], c$1 = t$1.evaluatedColor[l$1], h$1 = t$1.emissionHeightBasedParams[l$1];
						let p$1;
						if (o$1 && 2 === l$1 && n$1.lights && (p$1 = new Ha(), p$1.resize(10 * n$1.lights.length)), Ov(r$2.featureArray, i$2, c$1, u$1, h$1, r$2.aabb.min[2], r$2.aabb.max[2], p$1), p$1 && o$1) {
							o$1 = !1;
							const t$2 = n$1.meshes[n$1.lightMeshIndex];
							t$2.featureArray = p$1, t$2.featureArray._trim();
						}
					}
					r$2.featureArray._trim(), i$1++;
				}
			}
			Qs(Rv, "Tiled3dModelBucket", { omit: ["layers"] }), Qs(Dv, "Tiled3dModelFeature");
			const Nv = [
				"id",
				"tile",
				"layer",
				"source",
				"sourceLayer",
				"state"
			];
			class jv {
				constructor(t$1, e$1, r$1, n$1, i$1) {
					this.type = "Feature", this._vectorTileFeature = t$1, this._z = e$1, this._x = r$1, this._y = n$1, this.properties = t$1 ? t$1.properties : {}, this.id = i$1;
				}
				clone() {
					const t$1 = new jv(this._vectorTileFeature, this._z, this._x, this._y, this.id);
					return this.state && (t$1.state = Object.assign({}, this.state)), this.layer && (t$1.layer = Object.assign({}, this.layer)), this.source && (t$1.source = this.source), this.sourceLayer && (t$1.sourceLayer = this.sourceLayer), t$1;
				}
				get geometry() {
					return void 0 === this._geometry && this._vectorTileFeature && (this._geometry = this._vectorTileFeature.toGeoJSON(this._x, this._y, this._z).geometry), this._geometry;
				}
				set geometry(t$1) {
					this._geometry = t$1;
				}
				toJSON() {
					const t$1 = {
						type: "Feature",
						state: void 0,
						geometry: this.geometry,
						properties: this.properties
					};
					for (const e$1 of Nv) void 0 !== this[e$1] && (t$1[e$1] = this[e$1]);
					return t$1;
				}
			}
			class $v extends nr {
				constructor(t$1, e$1, r$1, n$1) {
					super(), this.id = t$1, this.type = "model", this.models = [], this._loaded = !1, this._options = e$1, this._modelsInfo = /* @__PURE__ */ new Map();
				}
				load() {
					const t$1 = [];
					for (const e$1 in this._options.models) {
						const r$1 = this._options.models[e$1], n$1 = this._modelsInfo.get(e$1);
						if (n$1) {
							const t$2 = n$1.model;
							t$2.position = null != r$1.position ? new iu(r$1.position[0], r$1.position[1]) : new iu(0, 0), t$2.orientation = null != r$1.orientation ? r$1.orientation : [
								0,
								0,
								0
							], n$1.modelSpec = r$1, $v.applyModelSpecification(t$2, r$1), t$2.computeBoundsAndApplyParent(), this.models.push(t$2);
						} else {
							const n$2 = kf(this.map._requestManager.transformRequest(r$1.uri, Ce.Model).url).then(((t$2) => {
								if (!t$2) return;
								const n$3 = pm(t$2), i$1 = new Qf(e$1, r$1.uri, r$1.position, r$1.orientation, n$3);
								$v.applyModelSpecification(i$1, r$1), i$1.computeBoundsAndApplyParent(), this.models.push(i$1), this._modelsInfo.set(e$1, {
									modelSpec: r$1,
									model: i$1
								});
							})).catch(((t$2) => {
								this.fire(new tr(/* @__PURE__ */ new Error(`Could not load model ${e$1} from ${r$1.uri}: ${t$2.message}`)));
							}));
							t$1.push(n$2);
						}
					}
					Promise.allSettled(t$1).then((() => {
						this._loaded = !0, this.fire(new Qe("data", {
							dataType: "source",
							sourceDataType: "metadata"
						}));
					})).catch(((t$2) => {
						this._loaded = !0, this.fire(new tr(/* @__PURE__ */ new Error(`Could not load models: ${t$2.message}`)));
					}));
				}
				static applyModelSpecification(t$1, e$1) {
					e$1.nodeOverrides && $v.convertNodeOverrides(t$1, e$1.nodeOverrides), e$1.materialOverrides && $v.convertMaterialOverrides(t$1, e$1.materialOverrides), e$1.nodeOverrideNames && (t$1.nodeOverrideNames = [...e$1.nodeOverrideNames]), e$1.materialOverrideNames && (t$1.materialOverrideNames = [...e$1.materialOverrideNames]), e$1.featureProperties && (t$1.featureProperties = e$1.featureProperties);
				}
				static convertNodeOverrides(t$1, e$1) {
					if (Array.isArray(e$1) && e$1.every(((t$2) => "string" == typeof t$2))) {
						t$1.nodeOverrideNames = [];
						for (const r$1 of e$1) t$1.nodeOverrideNames.push(r$1);
					} else Object.entries(e$1).forEach((([e$2, r$1]) => {
						const n$1 = { orientation: [
							0,
							0,
							0
						] };
						if (r$1.hasOwnProperty("orientation")) {
							const t$2 = r$1.orientation;
							t$2 && (n$1.orientation = t$2);
						}
						t$1.nodeOverrides.set(e$2, n$1);
					}));
				}
				static convertMaterialOverrides(t$1, e$1) {
					if (Array.isArray(e$1) && e$1.every(((t$2) => "string" == typeof t$2))) {
						t$1.materialOverrideNames = [];
						for (const r$1 of e$1) t$1.materialOverrideNames.push(r$1);
					} else Object.entries(e$1).forEach((([e$2, r$1]) => {
						const n$1 = {
							color: new lr(1, 1, 1),
							colorMix: 0,
							emissionStrength: 0,
							opacity: 1
						}, i$1 = r$1["model-color"];
						void 0 !== i$1 && (n$1.color.r = i$1[0], n$1.color.g = i$1[1], n$1.color.b = i$1[2]);
						const s$1 = r$1["model-color-mix-intensity"];
						void 0 !== s$1 && (n$1.colorMix = s$1);
						const o$1 = r$1["model-emissive-strength"];
						void 0 !== o$1 && (n$1.emissionStrength = o$1);
						const a$1 = r$1["model-opacity"];
						void 0 !== a$1 && (n$1.opacity = a$1), t$1.materialOverrides.set(e$2, n$1);
					}));
				}
				onAdd(t$1) {
					this.map = t$1, this.load();
				}
				hasTransition() {
					return !1;
				}
				loaded() {
					return this._loaded;
				}
				getModels() {
					return this.models;
				}
				loadTile(t$1, e$1) {}
				serialize() {
					return this._options;
				}
				setProperty(t$1, e$1) {
					return !1;
				}
				reload() {
					const t$1 = ta(this.id, this.scope);
					this.map.style.clearSource(t$1), this.models = [], this._modelsInfo.clear(), this._loaded = !1, this.load();
				}
				setModels(t$1) {
					this.models = [];
					const e$1 = /* @__PURE__ */ new Map();
					for (const r$1 in t$1) {
						const n$1 = t$1[r$1];
						if (this._modelsInfo.has(r$1)) {
							const t$2 = this._modelsInfo.get(r$1);
							t$2 && t$2.modelSpec.uri === n$1.uri && e$1.set(r$1, t$2);
						}
					}
					this._modelsInfo = e$1, this._options.models = t$1, this._loaded = !1, this.load();
				}
			}
			function Gv(t$1, e$1, r$1, n$1) {
				const i$1 = 1 << t$1.z;
				e$1.lat = du((n$1 / Un + t$1.y) / i$1), e$1.lng = pu((r$1 / Un + t$1.x) / i$1);
			}
			function qv(t$1, e$1, r$1, n$1) {
				const i$1 = t$1.getNodesInfo()[e$1];
				if (!i$1 || i$1.hiddenByReplacement || !i$1.node.meshes) return;
				let s$1 = Number.MAX_VALUE;
				const o$1 = i$1.node, a$1 = r$1.tile, l$1 = n$1.calculatePosMatrix(a$1.tileID.toUnwrapped(), n$1.worldSize), u$1 = i$1.evaluatedScale;
				let c$1 = 0;
				n$1.elevation && o$1.elevation && (c$1 = o$1.elevation * n$1.elevation.exaggeration()), p(l$1, l$1, [
					(o$1.anchor ? o$1.anchor[0] : 0) * (u$1[0] - 1),
					(o$1.anchor ? o$1.anchor[1] : 0) * (u$1[1] - 1),
					c$1
				]), d(l$1, l$1, u$1);
				const f$1 = r$1.queryGeometry, m$1 = f$1.isPointQuery() ? f$1.screenBounds : f$1.screenGeometry, y$1 = function(t$2) {
					const e$2 = h([], l$1, t$2.globalMatrix);
					h(e$2, n$1.expandedFarZProjMatrix, e$2);
					for (let r$2 = 0; r$2 < t$2.meshes.length; ++r$2) {
						const i$2 = t$2.meshes[r$2];
						if (r$2 === t$2.lightMeshIndex) continue;
						const o$2 = Wf(m$1, n$1, e$2, i$2.aabb);
						null != o$2 && (s$1 = Math.min(o$2, s$1));
					}
					if (t$2.children) for (const e$3 of t$2.children) y$1(e$3);
				};
				if (y$1(o$1), s$1 === Number.MAX_VALUE) return;
				const g$1 = new iu(0, 0);
				return Gv(a$1.tileID.canonical, g$1, i$1.node.anchor[0], i$1.node.anchor[1]), {
					intersectionZ: s$1,
					position: g$1,
					feature: i$1.feature
				};
			}
			const Hv = {
				circle: class extends oa {
					constructor(t$1, e$1, r$1, n$1) {
						super(t$1, {
							layout: Ic || (Ic = new Do({
								"circle-sort-key": new Fo(Ro.layout_circle["circle-sort-key"]),
								"circle-elevation-reference": new Vo(Ro.layout_circle["circle-elevation-reference"]),
								visibility: new Vo(Ro.layout_circle.visibility)
							})),
							paint: Mc || (Mc = new Do({
								"circle-radius": new Fo(Ro.paint_circle["circle-radius"]),
								"circle-color": new Fo(Ro.paint_circle["circle-color"]),
								"circle-blur": new Fo(Ro.paint_circle["circle-blur"]),
								"circle-opacity": new Fo(Ro.paint_circle["circle-opacity"]),
								"circle-translate": new Vo(Ro.paint_circle["circle-translate"]),
								"circle-translate-anchor": new Vo(Ro.paint_circle["circle-translate-anchor"]),
								"circle-pitch-scale": new Vo(Ro.paint_circle["circle-pitch-scale"]),
								"circle-pitch-alignment": new Vo(Ro.paint_circle["circle-pitch-alignment"]),
								"circle-stroke-width": new Fo(Ro.paint_circle["circle-stroke-width"]),
								"circle-stroke-color": new Fo(Ro.paint_circle["circle-stroke-color"]),
								"circle-stroke-opacity": new Fo(Ro.paint_circle["circle-stroke-opacity"]),
								"circle-emissive-strength": new Vo(Ro.paint_circle["circle-emissive-strength"]),
								"circle-color-use-theme": new Fo({
									type: "string",
									default: "default",
									"property-type": "data-driven"
								}),
								"circle-stroke-color-use-theme": new Fo({
									type: "string",
									default: "default",
									"property-type": "data-driven"
								})
							}))
						}, e$1, r$1, n$1);
					}
					createBucket(t$1) {
						return new nc(t$1);
					}
					queryRadius(t$1) {
						const e$1 = t$1;
						return bc("circle-radius", this, e$1) + bc("circle-stroke-width", this, e$1) + wc(this.paint.get("circle-translate"));
					}
					queryIntersectsFeature(t$1, e$1, r$1, n$1, i$1, s$1, o$1, a$1) {
						const l$1 = Ac(this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), s$1.angle, t$1.pixelToTileUnitsFactor), u$1 = this.paint.get("circle-radius").evaluate(e$1, r$1) + this.paint.get("circle-stroke-width").evaluate(e$1, r$1);
						return uh(t$1, n$1, s$1, o$1, a$1, "map" === this.paint.get("circle-pitch-alignment"), "map" === this.paint.get("circle-pitch-scale"), l$1, u$1);
					}
					getProgramIds() {
						return ["circle"];
					}
					getDefaultProgramParams(t$1, e$1, r$1) {
						const n$1 = lh(this);
						return {
							config: new Ol(this, {
								zoom: e$1,
								lut: r$1
							}),
							defines: n$1,
							overrideFog: !1
						};
					}
					is3D(t$1) {
						return !t$1 && !!this.layout && "none" !== this.layout.get("circle-elevation-reference");
					}
					hasElevation() {
						return this.layout && "none" !== this.layout.get("circle-elevation-reference");
					}
				},
				heatmap: class extends oa {
					createBucket(t$1) {
						return new fh(t$1);
					}
					constructor(t$1, e$1, r$1, n$1) {
						super(t$1, {
							layout: mh || (mh = new Do({ visibility: new Vo(Ro.layout_heatmap.visibility) })),
							paint: yh || (yh = new Do({
								"heatmap-radius": new Fo(Ro.paint_heatmap["heatmap-radius"]),
								"heatmap-weight": new Fo(Ro.paint_heatmap["heatmap-weight"]),
								"heatmap-intensity": new Vo(Ro.paint_heatmap["heatmap-intensity"]),
								"heatmap-color": new Co(Ro.paint_heatmap["heatmap-color"]),
								"heatmap-opacity": new Vo(Ro.paint_heatmap["heatmap-opacity"]),
								"heatmap-color-use-theme": new Fo({
									type: "string",
									default: "default",
									"property-type": "data-driven"
								})
							}))
						}, e$1, r$1, n$1), this._updateColorRamp();
					}
					_handleSpecialPaintPropertyUpdate(t$1) {
						"heatmap-color" === t$1 && this._updateColorRamp();
					}
					_updateColorRamp() {
						this.colorRamp = Mh({
							expression: this._transitionablePaint._values["heatmap-color"].value.expression,
							evaluationKey: "heatmapDensity",
							image: this.colorRamp
						}), this.colorRampTexture = null;
					}
					resize() {
						this.heatmapFbo && (this.heatmapFbo.destroy(), this.heatmapFbo = null);
					}
					_clear() {
						this.heatmapFbo && (this.heatmapFbo.destroy(), this.heatmapFbo = null), this.colorRampTexture && (this.colorRampTexture.destroy(), this.colorRampTexture = null);
					}
					queryRadius(t$1) {
						return bc("heatmap-radius", this, t$1);
					}
					queryIntersectsFeature(t$1, e$1, r$1, n$1, i$1, s$1, o$1, a$1) {
						const l$1 = this.paint.get("heatmap-radius").evaluate(e$1, r$1);
						return uh(t$1, n$1, s$1, o$1, a$1, !0, !0, new It(0, 0), l$1);
					}
					hasOffscreenPass() {
						return 0 !== this.paint.get("heatmap-opacity") && "none" !== this.visibility;
					}
					getProgramIds() {
						return ["heatmap", "heatmapTexture"];
					}
					getDefaultProgramParams(t$1, e$1, r$1) {
						return "heatmap" === t$1 ? {
							config: new Ol(this, {
								zoom: e$1,
								lut: r$1
							}),
							overrideFog: !1
						} : {};
					}
				},
				hillshade: class extends oa {
					constructor(t$1, e$1, r$1, n$1) {
						super(t$1, {
							layout: gh || (gh = new Do({ visibility: new Vo(Ro.layout_hillshade.visibility) })),
							paint: xh || (xh = new Do({
								"hillshade-illumination-direction": new Vo(Ro.paint_hillshade["hillshade-illumination-direction"]),
								"hillshade-illumination-anchor": new Vo(Ro.paint_hillshade["hillshade-illumination-anchor"]),
								"hillshade-exaggeration": new Vo(Ro.paint_hillshade["hillshade-exaggeration"]),
								"hillshade-shadow-color": new Vo(Ro.paint_hillshade["hillshade-shadow-color"]),
								"hillshade-highlight-color": new Vo(Ro.paint_hillshade["hillshade-highlight-color"]),
								"hillshade-accent-color": new Vo(Ro.paint_hillshade["hillshade-accent-color"]),
								"hillshade-emissive-strength": new Vo(Ro.paint_hillshade["hillshade-emissive-strength"]),
								"hillshade-shadow-color-use-theme": new Fo({
									type: "string",
									default: "default",
									"property-type": "data-driven"
								}),
								"hillshade-highlight-color-use-theme": new Fo({
									type: "string",
									default: "default",
									"property-type": "data-driven"
								}),
								"hillshade-accent-color-use-theme": new Fo({
									type: "string",
									default: "default",
									"property-type": "data-driven"
								})
							}))
						}, e$1, r$1, n$1);
					}
					shouldRedrape() {
						return this.hasOffscreenPass() && "viewport" === this.paint.get("hillshade-illumination-anchor");
					}
					hasOffscreenPass() {
						return 0 !== this.paint.get("hillshade-exaggeration") && "none" !== this.visibility;
					}
					getProgramIds() {
						return ["hillshade", "hillshadePrepare"];
					}
					getDefaultProgramParams(t$1, e$1, r$1) {
						return { overrideFog: !1 };
					}
				},
				fill: class extends oa {
					constructor(t$1, e$1, r$1, n$1) {
						super(t$1, {
							layout: wp || (wp = new Do({
								"fill-sort-key": new Fo(Ro.layout_fill["fill-sort-key"]),
								visibility: new Vo(Ro.layout_fill.visibility),
								"fill-elevation-reference": new Vo(Ro.layout_fill["fill-elevation-reference"]),
								"fill-construct-bridge-guard-rail": new Fo(Ro.layout_fill["fill-construct-bridge-guard-rail"])
							})),
							paint: _p || (_p = new Do({
								"fill-antialias": new Vo(Ro.paint_fill["fill-antialias"]),
								"fill-opacity": new Fo(Ro.paint_fill["fill-opacity"]),
								"fill-color": new Fo(Ro.paint_fill["fill-color"]),
								"fill-outline-color": new Fo(Ro.paint_fill["fill-outline-color"]),
								"fill-translate": new Vo(Ro.paint_fill["fill-translate"]),
								"fill-translate-anchor": new Vo(Ro.paint_fill["fill-translate-anchor"]),
								"fill-pattern": new Fo(Ro.paint_fill["fill-pattern"]),
								"fill-pattern-cross-fade": new Vo(Ro.paint_fill["fill-pattern-cross-fade"]),
								"fill-emissive-strength": new Vo(Ro.paint_fill["fill-emissive-strength"]),
								"fill-z-offset": new Fo(Ro.paint_fill["fill-z-offset"]),
								"fill-bridge-guard-rail-color": new Fo(Ro.paint_fill["fill-bridge-guard-rail-color"]),
								"fill-tunnel-structure-color": new Fo(Ro.paint_fill["fill-tunnel-structure-color"]),
								"fill-color-use-theme": new Fo({
									type: "string",
									default: "default",
									"property-type": "data-driven"
								}),
								"fill-outline-color-use-theme": new Fo({
									type: "string",
									default: "default",
									"property-type": "data-driven"
								}),
								"fill-bridge-guard-rail-color-use-theme": new Fo({
									type: "string",
									default: "default",
									"property-type": "data-driven"
								}),
								"fill-tunnel-structure-color-use-theme": new Fo({
									type: "string",
									default: "default",
									"property-type": "data-driven"
								})
							}))
						}, e$1, r$1, n$1);
					}
					getProgramIds() {
						const t$1 = this.paint.get("fill-pattern"), e$1 = t$1 && t$1.constantOr(1), r$1 = [e$1 ? "fillPattern" : "fill"];
						return this.paint.get("fill-antialias") && r$1.push(e$1 && !this.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline"), r$1;
					}
					getDefaultProgramParams(t$1, e$1, r$1) {
						return {
							config: new Ol(this, {
								zoom: e$1,
								lut: r$1
							}),
							overrideFog: !1
						};
					}
					recalculate(t$1, e$1) {
						super.recalculate(t$1, e$1);
						const r$1 = this.paint._values["fill-outline-color"];
						"constant" === r$1.value.kind && void 0 === r$1.value.value && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]);
					}
					createBucket(t$1) {
						return new bp(t$1);
					}
					queryRadius() {
						return wc(this.paint.get("fill-translate"));
					}
					queryIntersectsFeature(t$1, e$1, r$1, n$1, i$1, s$1) {
						return !t$1.queryGeometry.isAboveHorizon && oc(_c(t$1.tilespaceGeometry, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), s$1.angle, t$1.pixelToTileUnitsFactor), n$1);
					}
					isTileClipped() {
						return 0 === this.paint.get("fill-z-offset").constantOr(1);
					}
					is3D(t$1) {
						if (0 !== this.paint.get("fill-z-offset").constantOr(1)) return !0;
						const e$1 = this.layout && "none" !== this.layout.get("fill-elevation-reference");
						return null != t$1 ? e$1 && !t$1 : e$1;
					}
					hasElevation() {
						return this.layout && "none" !== this.layout.get("fill-elevation-reference");
					}
					hasShadowPass() {
						return this.layout && "none" !== this.layout.get("fill-elevation-reference");
					}
				},
				"fill-extrusion": class extends oa {
					constructor(t$1, e$1, r$1, n$1) {
						super(t$1, {
							layout: kd || (kd = new Do({
								visibility: new Vo(Ro["layout_fill-extrusion"].visibility),
								"fill-extrusion-edge-radius": new Vo(Ro["layout_fill-extrusion"]["fill-extrusion-edge-radius"])
							})),
							paint: Bd || (Bd = new Do({
								"fill-extrusion-opacity": new Vo(Ro["paint_fill-extrusion"]["fill-extrusion-opacity"]),
								"fill-extrusion-color": new Fo(Ro["paint_fill-extrusion"]["fill-extrusion-color"]),
								"fill-extrusion-translate": new Vo(Ro["paint_fill-extrusion"]["fill-extrusion-translate"]),
								"fill-extrusion-translate-anchor": new Vo(Ro["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]),
								"fill-extrusion-pattern": new Fo(Ro["paint_fill-extrusion"]["fill-extrusion-pattern"]),
								"fill-extrusion-pattern-cross-fade": new Vo(Ro["paint_fill-extrusion"]["fill-extrusion-pattern-cross-fade"]),
								"fill-extrusion-height": new Fo(Ro["paint_fill-extrusion"]["fill-extrusion-height"]),
								"fill-extrusion-base": new Fo(Ro["paint_fill-extrusion"]["fill-extrusion-base"]),
								"fill-extrusion-height-alignment": new Vo(Ro["paint_fill-extrusion"]["fill-extrusion-height-alignment"]),
								"fill-extrusion-base-alignment": new Vo(Ro["paint_fill-extrusion"]["fill-extrusion-base-alignment"]),
								"fill-extrusion-vertical-gradient": new Vo(Ro["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]),
								"fill-extrusion-ambient-occlusion-intensity": new Vo(Ro["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-intensity"]),
								"fill-extrusion-ambient-occlusion-radius": new Vo(Ro["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-radius"]),
								"fill-extrusion-ambient-occlusion-wall-radius": new Vo(Ro["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-wall-radius"]),
								"fill-extrusion-ambient-occlusion-ground-radius": new Vo(Ro["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-ground-radius"]),
								"fill-extrusion-ambient-occlusion-ground-attenuation": new Vo(Ro["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-ground-attenuation"]),
								"fill-extrusion-flood-light-color": new Vo(Ro["paint_fill-extrusion"]["fill-extrusion-flood-light-color"]),
								"fill-extrusion-flood-light-intensity": new Vo(Ro["paint_fill-extrusion"]["fill-extrusion-flood-light-intensity"]),
								"fill-extrusion-flood-light-wall-radius": new Fo(Ro["paint_fill-extrusion"]["fill-extrusion-flood-light-wall-radius"]),
								"fill-extrusion-flood-light-ground-radius": new Fo(Ro["paint_fill-extrusion"]["fill-extrusion-flood-light-ground-radius"]),
								"fill-extrusion-flood-light-ground-attenuation": new Vo(Ro["paint_fill-extrusion"]["fill-extrusion-flood-light-ground-attenuation"]),
								"fill-extrusion-vertical-scale": new Vo(Ro["paint_fill-extrusion"]["fill-extrusion-vertical-scale"]),
								"fill-extrusion-rounded-roof": new Vo(Ro["paint_fill-extrusion"]["fill-extrusion-rounded-roof"]),
								"fill-extrusion-cutoff-fade-range": new Vo(Ro["paint_fill-extrusion"]["fill-extrusion-cutoff-fade-range"]),
								"fill-extrusion-emissive-strength": new Fo(Ro["paint_fill-extrusion"]["fill-extrusion-emissive-strength"]),
								"fill-extrusion-line-width": new Fo(Ro["paint_fill-extrusion"]["fill-extrusion-line-width"]),
								"fill-extrusion-cast-shadows": new Vo(Ro["paint_fill-extrusion"]["fill-extrusion-cast-shadows"]),
								"fill-extrusion-color-use-theme": new Fo({
									type: "string",
									default: "default",
									"property-type": "data-driven"
								}),
								"fill-extrusion-flood-light-color-use-theme": new Fo({
									type: "string",
									default: "default",
									"property-type": "data-driven"
								})
							}))
						}, e$1, r$1, n$1), this._stats = {
							numRenderedVerticesInShadowPass: 0,
							numRenderedVerticesInTransparentPass: 0
						};
					}
					createBucket(t$1) {
						return new gd(t$1);
					}
					queryRadius() {
						return wc(this.paint.get("fill-extrusion-translate"));
					}
					is3D(t$1) {
						return !0;
					}
					hasShadowPass() {
						return this.paint.get("fill-extrusion-cast-shadows");
					}
					cutoffRange() {
						return this.paint.get("fill-extrusion-cutoff-fade-range");
					}
					canCastShadows() {
						return !0;
					}
					getProgramIds() {
						return [this.paint.get("fill-extrusion-pattern").constantOr(1) ? "fillExtrusionPattern" : "fillExtrusion"];
					}
					queryIntersectsFeature(t$1, e$1, r$1, n$1, i$1, s$1, o$1, a$1, l$1) {
						const u$1 = Ac(this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), s$1.angle, t$1.pixelToTileUnitsFactor), c$1 = this.paint.get("fill-extrusion-height").evaluate(e$1, r$1), h$1 = this.paint.get("fill-extrusion-base").evaluate(e$1, r$1), p$1 = [0, 0], d$1 = a$1 && s$1.elevation, f$1 = s$1.elevation ? s$1.elevation.exaggeration() : 1, m$1 = t$1.tile.getBucket(this);
						if (d$1 && m$1 instanceof gd) {
							const t$2 = m$1.centroidVertexArray, e$2 = l$1 + 1;
							e$2 < t$2.length && (p$1[0] = t$2.geta_centroid_pos0(e$2), p$1[1] = t$2.geta_centroid_pos1(e$2));
						}
						if (0 === p$1[0] && 1 === p$1[1]) return !1;
						"globe" === s$1.projection.name && (n$1 = Sd([n$1], [new It(0, 0), new It(Un, Un)], t$1.tileID.canonical).map(((t$2) => t$2.polygon)).flat());
						const [g$1, x$1] = Ud(s$1, n$1, h$1, c$1, u$1, o$1, d$1 ? a$1 : null, p$1, f$1, s$1.center.lat, t$1.tileID.canonical), v$1 = t$1.queryGeometry;
						return Od(g$1, x$1, v$1.isPointQuery() ? v$1.screenBounds : v$1.screenGeometry);
					}
				},
				building: class extends oa {
					constructor(t$1, e$1, r$1, n$1) {
						super(t$1, {
							layout: Fm || (Fm = new Do({
								visibility: new Vo(Ro.layout_building.visibility),
								"building-facade": new Fo(Ro.layout_building["building-facade"]),
								"building-facade-floors": new Fo(Ro.layout_building["building-facade-floors"]),
								"building-facade-unit-width": new Fo(Ro.layout_building["building-facade-unit-width"]),
								"building-facade-window": new Fo(Ro.layout_building["building-facade-window"]),
								"building-roof-shape": new Fo(Ro.layout_building["building-roof-shape"]),
								"building-height": new Fo(Ro.layout_building["building-height"]),
								"building-base": new Fo(Ro.layout_building["building-base"]),
								"building-flood-light-wall-radius": new Fo(Ro.layout_building["building-flood-light-wall-radius"]),
								"building-flood-light-ground-radius": new Fo(Ro.layout_building["building-flood-light-ground-radius"]),
								"building-flip-roof-orientation": new Fo(Ro.layout_building["building-flip-roof-orientation"])
							})),
							paint: Cm || (Cm = new Do({
								"building-opacity": new Vo(Ro.paint_building["building-opacity"]),
								"building-ambient-occlusion-intensity": new Vo(Ro.paint_building["building-ambient-occlusion-intensity"]),
								"building-ambient-occlusion-ground-intensity": new Vo(Ro.paint_building["building-ambient-occlusion-ground-intensity"]),
								"building-ambient-occlusion-ground-radius": new Vo(Ro.paint_building["building-ambient-occlusion-ground-radius"]),
								"building-ambient-occlusion-ground-attenuation": new Vo(Ro.paint_building["building-ambient-occlusion-ground-attenuation"]),
								"building-vertical-scale": new Vo(Ro.paint_building["building-vertical-scale"]),
								"building-cast-shadows": new Vo(Ro.paint_building["building-cast-shadows"]),
								"building-color": new Fo(Ro.paint_building["building-color"]),
								"building-emissive-strength": new Fo(Ro.paint_building["building-emissive-strength"]),
								"building-facade-emissive-chance": new Vo(Ro.paint_building["building-facade-emissive-chance"]),
								"building-cutoff-fade-range": new Vo(Ro.paint_building["building-cutoff-fade-range"]),
								"building-flood-light-color": new Vo(Ro.paint_building["building-flood-light-color"]),
								"building-flood-light-intensity": new Vo(Ro.paint_building["building-flood-light-intensity"]),
								"building-flood-light-ground-attenuation": new Vo(Ro.paint_building["building-flood-light-ground-attenuation"]),
								"building-color-use-theme": new Fo({
									type: "string",
									default: "default",
									"property-type": "data-driven"
								}),
								"building-flood-light-color-use-theme": new Fo({
									type: "string",
									default: "default",
									"property-type": "data-driven"
								})
							}))
						}, e$1, r$1, n$1), this._stats = {
							numRenderedVerticesInShadowPass: 0,
							numRenderedVerticesInTransparentPass: 0
						};
					}
					createBucket(t$1) {
						return new Tm(t$1);
					}
					cutoffRange() {
						return this.paint.get("building-cutoff-fade-range");
					}
					hasShadowPass() {
						return this.paint.get("building-cast-shadows");
					}
					hasLightBeamPass() {
						return !0;
					}
					canCastShadows() {
						return !0;
					}
					is3D(t$1) {
						return !0;
					}
					queryRadius(t$1) {
						return 0;
					}
					queryIntersectsFeature(t$1, e$1, r$1, n$1, i$1, s$1, o$1, a$1, l$1) {
						let u$1 = this.layout.get("building-height").evaluate(e$1, r$1);
						const c$1 = this.layout.get("building-base").evaluate(e$1, r$1), h$1 = t$1.tile.getBucket(this).getFootprint(e$1);
						if (h$1) {
							if (0 !== h$1.hiddenFlags) return !1;
							u$1 = h$1.height;
						}
						const [p$1, d$1] = Ud(s$1, n$1, c$1, u$1, new It(0, 0), o$1, null, [0, 0], 1, s$1.center.lat, t$1.tileID.canonical), f$1 = t$1.queryGeometry;
						return Od(p$1, d$1, f$1.isPointQuery() ? f$1.screenBounds : f$1.screenGeometry);
					}
				},
				line: class extends oa {
					constructor(t$1, e$1, r$1, n$1) {
						const i$1 = iy();
						super(t$1, i$1, e$1, r$1, n$1), i$1.layout && (this.layout = new Eo(i$1.layout)), this.gradientVersion = 0, this.hasElevatedBuckets = !1, this.hasNonElevatedBuckets = !1;
					}
					_handleSpecialPaintPropertyUpdate(t$1) {
						if ("line-gradient" === t$1) {
							const t$2 = this._transitionablePaint._values["line-gradient"].value.expression;
							this.stepInterpolant = t$2._styleExpression && t$2._styleExpression.expression instanceof ki, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER;
						}
					}
					gradientExpression() {
						return this._transitionablePaint._values["line-gradient"].value.expression;
					}
					widthExpression() {
						return this._transitionablePaint._values["line-width"].value.expression;
					}
					emissiveStrengthExpression() {
						return this._transitionablePaint._values["line-emissive-strength"].value.expression;
					}
					recalculate(t$1, e$1) {
						super.recalculate(t$1, e$1), this.paint._values["line-floorwidth"] = (() => {
							if (oy) return oy;
							return oy = new sy(iy().paint.properties["line-width"].specification), oy.useIntegerZoom = !0, oy;
						})().possiblyEvaluate(this._transitioningPaint._values["line-width"].value, t$1);
					}
					createBucket(t$1) {
						return new Xm(t$1);
					}
					getProgramIds() {
						return [this.paint.get("line-pattern").constantOr(1) ? "linePattern" : "line"];
					}
					getDefaultProgramParams(t$1, e$1, r$1) {
						const n$1 = ey(this);
						return {
							config: new Ol(this, {
								zoom: e$1,
								lut: r$1
							}),
							defines: n$1,
							overrideFog: !1
						};
					}
					queryRadius(t$1) {
						const e$1 = t$1, r$1 = ay(bc("line-width", this, e$1), bc("line-gap-width", this, e$1)), n$1 = bc("line-offset", this, e$1);
						return r$1 / 2 + Math.abs(n$1) + wc(this.paint.get("line-translate"));
					}
					queryIntersectsFeature(t$1, e$1, r$1, n$1, i$1, s$1) {
						if (t$1.queryGeometry.isAboveHorizon) return !1;
						const o$1 = _c(t$1.tilespaceGeometry, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), s$1.angle, t$1.pixelToTileUnitsFactor), a$1 = t$1.pixelToTileUnitsFactor / 2 * ay(this.paint.get("line-width").evaluate(e$1, r$1), this.paint.get("line-gap-width").evaluate(e$1, r$1)), l$1 = this.paint.get("line-offset").evaluate(e$1, r$1);
						return l$1 && (n$1 = function(t$2, e$2) {
							const r$2 = [], n$2 = new It(0, 0);
							for (let i$2 = 0; i$2 < t$2.length; i$2++) {
								const s$2 = t$2[i$2], o$2 = [];
								for (let t$3 = 0; t$3 < s$2.length; t$3++) {
									const r$3 = s$2[t$3], i$3 = s$2[t$3 + 1], a$2 = 0 === t$3 ? n$2 : r$3.sub(s$2[t$3 - 1])._unit()._perp(), l$2 = t$3 === s$2.length - 1 ? n$2 : i$3.sub(r$3)._unit()._perp(), u$1 = a$2._add(l$2)._unit();
									u$1._mult(1 / (u$1.x * l$2.x + u$1.y * l$2.y)), o$2.push(u$1._mult(e$2)._add(r$3));
								}
								r$2.push(o$2);
							}
							return r$2;
						}(n$1, l$1 * t$1.pixelToTileUnitsFactor)), function(t$2, e$2, r$2) {
							for (let n$2 = 0; n$2 < e$2.length; n$2++) {
								const i$2 = e$2[n$2];
								if (t$2.length >= 3) {
									for (let e$3 = 0; e$3 < i$2.length; e$3++) if (mc(t$2, i$2[e$3])) return !0;
								}
								if (ac(t$2, i$2, r$2)) return !0;
							}
							return !1;
						}(o$1, n$1, a$1);
					}
					isTileClipped() {
						return this.hasNonElevatedBuckets;
					}
					isDraped(t$1) {
						return !this.hasElevatedBuckets || this.layout && "hd-road-markup" === this.layout.get("line-elevation-reference");
					}
					hasElevation() {
						return this.layout && "none" !== this.layout.get("line-elevation-reference");
					}
				},
				symbol: rv,
				background: class extends oa {
					constructor(t$1, e$1, r$1, n$1) {
						super(t$1, {
							layout: nv || (nv = new Do({ visibility: new Vo(Ro.layout_background.visibility) })),
							paint: iv || (iv = new Do({
								"background-pitch-alignment": new Vo(Ro.paint_background["background-pitch-alignment"]),
								"background-color": new Vo(Ro.paint_background["background-color"]),
								"background-pattern": new Vo(Ro.paint_background["background-pattern"]),
								"background-opacity": new Vo(Ro.paint_background["background-opacity"]),
								"background-emissive-strength": new Vo(Ro.paint_background["background-emissive-strength"]),
								"background-color-use-theme": new Fo({
									type: "string",
									default: "default",
									"property-type": "data-driven"
								})
							}))
						}, e$1, r$1, n$1);
					}
					getProgramIds() {
						return [this.paint.get("background-pattern") ? "backgroundPattern" : "background"];
					}
					getDefaultProgramParams(t$1, e$1, r$1) {
						return { overrideFog: !1 };
					}
					is3D(t$1) {
						return "viewport" === this.paint.get("background-pitch-alignment");
					}
				},
				raster: dv,
				"raster-particle": vv,
				sky: class extends oa {
					constructor(t$1, e$1, r$1, n$1) {
						super(t$1, {
							layout: yv || (yv = new Do({ visibility: new Vo(Ro.layout_sky.visibility) })),
							paint: gv || (gv = new Do({
								"sky-type": new Vo(Ro.paint_sky["sky-type"]),
								"sky-atmosphere-sun": new Vo(Ro.paint_sky["sky-atmosphere-sun"]),
								"sky-atmosphere-sun-intensity": new Vo(Ro.paint_sky["sky-atmosphere-sun-intensity"]),
								"sky-gradient-center": new Vo(Ro.paint_sky["sky-gradient-center"]),
								"sky-gradient-radius": new Vo(Ro.paint_sky["sky-gradient-radius"]),
								"sky-gradient": new Co(Ro.paint_sky["sky-gradient"]),
								"sky-atmosphere-halo-color": new Vo(Ro.paint_sky["sky-atmosphere-halo-color"]),
								"sky-atmosphere-color": new Vo(Ro.paint_sky["sky-atmosphere-color"]),
								"sky-opacity": new Vo(Ro.paint_sky["sky-opacity"]),
								"sky-gradient-use-theme": new Fo({
									type: "string",
									default: "default",
									"property-type": "data-driven"
								}),
								"sky-atmosphere-halo-color-use-theme": new Fo({
									type: "string",
									default: "default",
									"property-type": "data-driven"
								}),
								"sky-atmosphere-color-use-theme": new Fo({
									type: "string",
									default: "default",
									"property-type": "data-driven"
								})
							}))
						}, e$1, r$1, n$1), this._updateColorRamp();
					}
					_clear() {
						this.skyboxFbo && (this.skyboxFbo.destroy(), this.skyboxFbo = null), this.colorRampTexture && (this.colorRampTexture.destroy(), this.colorRampTexture = null), this._skyboxInvalidated = !0;
					}
					_handleSpecialPaintPropertyUpdate(t$1) {
						"sky-gradient" === t$1 ? this._updateColorRamp() : "sky-atmosphere-sun" !== t$1 && "sky-atmosphere-halo-color" !== t$1 && "sky-atmosphere-color" !== t$1 && "sky-atmosphere-sun-intensity" !== t$1 || (this._skyboxInvalidated = !0);
					}
					_updateColorRamp() {
						this.colorRamp = Mh({
							expression: this._transitionablePaint._values["sky-gradient"].value.expression,
							evaluationKey: "skyRadialProgress"
						}), this.colorRampTexture && (this.colorRampTexture.destroy(), this.colorRampTexture = null);
					}
					needsSkyboxCapture(t$1) {
						if (this._skyboxInvalidated || !this.skyboxTexture || !this.skyboxGeometry) return !0;
						if (!this.paint.get("sky-atmosphere-sun")) {
							const e$1 = t$1.style.light.properties.get("position");
							return this._lightPosition.azimuthal !== e$1.azimuthal || this._lightPosition.polar !== e$1.polar;
						}
						return !1;
					}
					getCenter(t$1, e$1) {
						if ("atmosphere" === this.paint.get("sky-type")) {
							const r$2 = this.paint.get("sky-atmosphere-sun"), n$1 = !r$2, i$1 = t$1.style.light, s$1 = i$1.properties.get("position");
							return n$1 && "viewport" === i$1.properties.get("anchor") && Xt("The sun direction is attached to a light with viewport anchor, lighting may behave unexpectedly."), n$1 ? wv(s$1.azimuthal, 90 - s$1.polar, e$1) : wv(r$2[0], 90 - r$2[1], e$1);
						}
						const r$1 = this.paint.get("sky-gradient-center");
						return wv(r$1[0], 90 - r$1[1], e$1);
					}
					isSky() {
						return !0;
					}
					markSkyboxValid(t$1) {
						this._skyboxInvalidated = !1, this._lightPosition = t$1.style.light.properties.get("position");
					}
					hasOffscreenPass() {
						return !0;
					}
					getProgramIds() {
						const t$1 = this.paint.get("sky-type");
						return "atmosphere" === t$1 ? ["skyboxCapture", "skybox"] : "gradient" === t$1 ? ["skyboxGradient"] : null;
					}
				},
				slot: class extends oa {
					constructor(t$1, e$1, r$1, n$1) {
						super(t$1, { paint: xv || (xv = new Do({})) }, e$1, null);
					}
				},
				model: class extends oa {
					constructor(t$1, e$1, r$1, n$1) {
						super(t$1, {
							layout: kv || (kv = new Do({
								visibility: new Vo(Ro.layout_model.visibility),
								"model-id": new Fo(Ro.layout_model["model-id"])
							})),
							paint: Bv || (Bv = new Do({
								"model-opacity": new Fo(Ro.paint_model["model-opacity"]),
								"model-rotation": new Fo(Ro.paint_model["model-rotation"]),
								"model-scale": new Fo(Ro.paint_model["model-scale"]),
								"model-translation": new Fo(Ro.paint_model["model-translation"]),
								"model-color": new Fo(Ro.paint_model["model-color"]),
								"model-color-mix-intensity": new Fo(Ro.paint_model["model-color-mix-intensity"]),
								"model-type": new Vo(Ro.paint_model["model-type"]),
								"model-cast-shadows": new Vo(Ro.paint_model["model-cast-shadows"]),
								"model-receive-shadows": new Vo(Ro.paint_model["model-receive-shadows"]),
								"model-ambient-occlusion-intensity": new Vo(Ro.paint_model["model-ambient-occlusion-intensity"]),
								"model-emissive-strength": new Fo(Ro.paint_model["model-emissive-strength"]),
								"model-roughness": new Fo(Ro.paint_model["model-roughness"]),
								"model-height-based-emissive-strength-multiplier": new Fo(Ro.paint_model["model-height-based-emissive-strength-multiplier"]),
								"model-cutoff-fade-range": new Vo(Ro.paint_model["model-cutoff-fade-range"]),
								"model-front-cutoff": new Vo(Ro.paint_model["model-front-cutoff"]),
								"model-elevation-reference": new Vo(Ro.paint_model["model-elevation-reference"]),
								"model-color-use-theme": new Fo({
									type: "string",
									default: "default",
									"property-type": "data-driven"
								})
							}))
						}, e$1, r$1, n$1), this.layer = t$1, this._stats = {
							numRenderedVerticesInShadowPass: 0,
							numRenderedVerticesInTransparentPass: 0
						};
					}
					createBucket(t$1) {
						return new Pv(t$1);
					}
					getProgramIds() {
						return ["model"];
					}
					is3D(t$1) {
						return !0;
					}
					hasShadowPass() {
						return !0;
					}
					canCastShadows() {
						return !0;
					}
					hasLightBeamPass() {
						return !0;
					}
					cutoffRange() {
						return this.paint.get("model-cutoff-fade-range");
					}
					queryRadius(t$1) {
						return t$1 instanceof Rv ? Un - 1 : 0;
					}
					queryRenderedFeatures(t$1, e$1, r$1) {
						const n$1 = e$1.getSource();
						if (!(n$1 && n$1 instanceof $v)) return {};
						const i$1 = n$1, s$1 = {};
						s$1[this.id] = [];
						const o$1 = s$1[this.id];
						let a$1 = 0;
						for (const n$2 of i$1.models) {
							const i$2 = e$1.getFeatureState(this.sourceLayer, n$2.id), s$2 = {
								type: "Unknown",
								id: n$2.id,
								properties: n$2.featureProperties
							}, l$1 = this.paint.get("model-rotation").evaluate(s$2, i$2), u$1 = this.paint.get("model-scale").evaluate(s$2, i$2), c$1 = this.paint.get("model-translation").evaluate(s$2, i$2), p$1 = this.paint.get("model-elevation-reference");
							let d$1 = [];
							Jf(d$1, n$2, r$1, n$2.position, l$1, u$1, c$1, "ground" === p$1, "ground" === p$1, !1), "globe" === r$1.projection.name && (d$1 = Zf(d$1, r$1));
							const f$1 = h([], r$1.projMatrix, d$1), m$1 = Wf(t$1.isPointQuery() ? t$1.screenBounds : t$1.screenGeometry, r$1, f$1, n$2.aabb);
							if (null != m$1) {
								const t$2 = new jv(void 0, 0, 0, 0, n$2.id);
								t$2.layer = this.layer, t$2.properties = structuredClone(n$2.featureProperties), t$2.properties.layer = this.id, t$2.properties.uri = n$2.uri, t$2.properties.orientation = n$2.orientation, t$2.sourceLayer = this.sourceLayer, t$2.geometry = {
									type: "Point",
									coordinates: [n$2.position.lng, n$2.position.lat]
								}, t$2.state = i$2, t$2.source = this.source, o$1.push({
									featureIndex: a$1,
									feature: t$2,
									intersectionZ: m$1
								});
							}
							++a$1;
						}
						return s$1;
					}
					queryIntersectsFeature(t$1, e$1, r$1, n$1, i$1, s$1) {
						if (!this.modelManager) return !1;
						const o$1 = this.modelManager, a$1 = t$1.tile.getBucket(this);
						if (!(a$1 && a$1 instanceof Pv)) return !1;
						for (const r$2 in a$1.instancesPerModel) {
							const n$2 = a$1.instancesPerModel[r$2], i$2 = void 0 !== e$1.id ? e$1.id : e$1.properties && e$1.properties.hasOwnProperty("id") ? e$1.properties.id : void 0;
							if (n$2.idToFeaturesIndex.hasOwnProperty(i$2)) {
								const e$2 = n$2.features[n$2.idToFeaturesIndex[i$2]], l$1 = o$1.getModel(r$2, this.scope);
								if (!l$1) return !1;
								let u$1 = [];
								const c$1 = new iu(0, 0), p$1 = a$1.canonical;
								let d$1 = Number.MAX_VALUE;
								for (let r$3 = 0; r$3 < e$2.instancedDataCount; ++r$3) {
									const i$3 = 16 * (e$2.instancedDataOffset + r$3), o$2 = n$2.instancedDataArray.float32, a$2 = [
										o$2[i$3 + 4],
										o$2[i$3 + 5],
										o$2[i$3 + 6]
									];
									Gv(p$1, c$1, Math.floor(o$2[i$3]), Math.floor(o$2[i$3 + 1])), Jf(u$1, l$1, s$1, c$1, e$2.rotation, e$2.scale, a$2, !1, !1, !1), "globe" === s$1.projection.name && (u$1 = Zf(u$1, s$1));
									const f$1 = h([], s$1.projMatrix, u$1), m$1 = t$1.queryGeometry, y$1 = Wf(m$1.isPointQuery() ? m$1.screenBounds : m$1.screenGeometry, s$1, f$1, l$1.aabb);
									null != y$1 && (d$1 = Math.min(y$1, d$1));
								}
								return d$1 !== Number.MAX_VALUE && d$1;
							}
						}
						return !1;
					}
					_handleOverridablePaintPropertyUpdate(t$1, e$1, r$1) {
						return !(!this.layout || e$1.isDataDriven() || r$1.isDataDriven() || "model-color" !== t$1 && "model-color-mix-intensity" !== t$1 && "model-rotation" !== t$1 && "model-scale" !== t$1 && "model-translation" !== t$1 && "model-emissive-strength" !== t$1);
					}
					_isPropertyZoomDependent(t$1) {
						const e$1 = this._transitionablePaint._values[t$1];
						return null != e$1 && null != e$1.value && null != e$1.value.expression && e$1.value.expression instanceof Gs;
					}
					isZoomDependent() {
						return this._isPropertyZoomDependent("model-scale") || this._isPropertyZoomDependent("model-rotation") || this._isPropertyZoomDependent("model-translation");
					}
				},
				clip: class extends oa {
					constructor(t$1, e$1, r$1, n$1) {
						super(t$1, {
							layout: Ap || (Ap = new Do({
								"clip-layer-types": new Vo(Ro.layout_clip["clip-layer-types"]),
								"clip-layer-scope": new Vo(Ro.layout_clip["clip-layer-scope"])
							})),
							paint: Ip || (Ip = new Do({}))
						}, e$1, r$1, n$1);
					}
					recalculate(t$1, e$1) {
						super.recalculate(t$1, e$1);
					}
					createBucket(t$1) {
						return new Pp(t$1);
					}
					is3D(t$1) {
						return !0;
					}
				}
			}, Xv = new lr(0, 0, 0), Zv = {
				PATH_RULE_NON_ZERO: 1,
				PATH_RULE_EVEN_ODD: 2
			}, Wv = {
				LINE_CAP_BUTT: 1,
				LINE_CAP_ROUND: 2,
				LINE_CAP_SQUARE: 3
			}, Yv = {
				LINE_JOIN_MITER: 1,
				LINE_JOIN_MITER_CLIP: 2,
				LINE_JOIN_ROUND: 3,
				LINE_JOIN_BEVEL: 4
			}, Kv = { PAINT_ORDER_FILL_AND_STROKE: 1 }, Jv = {
				PATH_COMMAND_MOVE: 1,
				PATH_COMMAND_LINE: 2,
				PATH_COMMAND_QUAD: 3,
				PATH_COMMAND_CUBIC: 4,
				PATH_COMMAND_CLOSE: 5
			}, Qv = { MASK_TYPE_LUMINANCE: 1 };
			function tb(t$1, e$1, r$1) {
				1 === t$1 && e$1.icons.push(function(t$2, e$2) {
					return function(t$3) {
						if (t$3.usvg_tree.height || (t$3.usvg_tree.height = t$3.usvg_tree.width), !t$3.metadata) return t$3;
						const { metadata: e$3 } = t$3;
						if (e$3.content_area) {
							const { content_area: r$2 } = e$3;
							r$2.left ??= 0, r$2.top ??= r$2.left, r$2.width ??= t$3.usvg_tree.width, r$2.height ??= r$2.width;
						}
						if (e$3.text_placeholder) {
							const { text_placeholder: t$4 } = e$3;
							t$4.top ??= t$4.left, t$4.height ??= t$4.width;
						}
						return e$3.stretch_x && e$3.stretch_x.length && eb(e$3, "x"), e$3.stretch_y && e$3.stretch_y.length && eb(e$3, "y"), t$3;
					}(t$2.readFields(rb, { name: void 0 }, e$2));
				}(r$1, r$1.readVarint() + r$1.pos));
			}
			function eb(t$1, e$1) {
				const r$1 = [], n$1 = t$1[`stretch_${e$1}`];
				let i$1 = null;
				for (let t$2 = 0; t$2 < n$1.length; t$2++) null === i$1 ? i$1 = 0 === r$1.length ? n$1[0] : r$1[r$1.length - 1][1] + n$1[t$2] : (r$1.push([i$1, i$1 + n$1[t$2]]), i$1 = null);
				t$1[`stretch_${e$1}_areas`] = r$1;
			}
			function rb(t$1, e$1, r$1) {
				1 === t$1 ? e$1.name = r$1.readString() : 2 === t$1 ? e$1.metadata = function(t$2, e$2) {
					return t$2.readFields(nb, {
						stretch_x: null,
						stretch_y: null,
						stretch_x_areas: null,
						stretch_y_areas: null,
						variables: []
					}, e$2);
				}(r$1, r$1.readVarint() + r$1.pos) : 3 === t$1 && (e$1.usvg_tree = function(t$2, e$2) {
					return t$2.readFields(ab, {
						width: 20,
						children: [],
						linear_gradients: [],
						radial_gradients: [],
						clip_paths: [],
						masks: []
					}, e$2);
				}(r$1, r$1.readVarint() + r$1.pos), e$1.data = "usvg_tree");
			}
			function nb(t$1, e$1, r$1) {
				1 === t$1 ? e$1.stretch_x = r$1.readPackedVarint() : 2 === t$1 ? e$1.stretch_y = r$1.readPackedVarint() : 3 === t$1 ? e$1.content_area = ib(r$1, r$1.readVarint() + r$1.pos) : 4 === t$1 ? e$1.variables.push(function(t$2, e$2) {
					return t$2.readFields(ob, { name: void 0 }, e$2);
				}(r$1, r$1.readVarint() + r$1.pos)) : 5 === t$1 && (e$1.text_placeholder = ib(r$1, r$1.readVarint() + r$1.pos));
			}
			function ib(t$1, e$1) {
				return t$1.readFields(sb, {}, e$1);
			}
			function sb(t$1, e$1, r$1) {
				1 === t$1 ? e$1.left = r$1.readVarint() : 2 === t$1 ? e$1.width = r$1.readVarint() : 3 === t$1 ? e$1.top = r$1.readVarint() : 4 === t$1 && (e$1.height = r$1.readVarint());
			}
			function ob(t$1, e$1, r$1) {
				1 === t$1 ? e$1.name = r$1.readString() : 2 === t$1 && (e$1.rgb_color = mb(r$1.readVarint()), e$1.value = "rgb_color");
			}
			function ab(t$1, e$1, r$1) {
				1 === t$1 ? e$1.width = e$1.height = r$1.readVarint() : 2 === t$1 ? e$1.height = r$1.readVarint() : 3 === t$1 ? e$1.children.push(lb(r$1, r$1.readVarint() + r$1.pos)) : 4 === t$1 ? e$1.linear_gradients.push(function(t$2, e$2) {
					return t$2.readFields(gb, {
						spread_method: 1,
						stops: [],
						x1: 0,
						y1: 0,
						x2: 1,
						y2: 0
					}, e$2);
				}(r$1, r$1.readVarint() + r$1.pos)) : 5 === t$1 ? e$1.radial_gradients.push(function(t$2, e$2) {
					return t$2.readFields(bb, {
						spread_method: 1,
						stops: [],
						cx: .5,
						cy: .5,
						r: .5,
						fx: .5,
						fy: .5,
						fr: 0
					}, e$2);
				}(r$1, r$1.readVarint() + r$1.pos)) : 7 === t$1 ? e$1.clip_paths.push(function(t$2, e$2) {
					return t$2.readFields(wb, { children: [] }, e$2);
				}(r$1, r$1.readVarint() + r$1.pos)) : 8 === t$1 && e$1.masks.push(function(t$2, e$2) {
					const r$2 = t$2.readFields(_b, {
						left: 0,
						width: 20,
						mask_type: Qv.MASK_TYPE_LUMINANCE,
						children: []
					}, e$2);
					return r$2.height ??= r$2.width, r$2.top ??= r$2.left, r$2;
				}(r$1, r$1.readVarint() + r$1.pos));
			}
			function lb(t$1, e$1) {
				return t$1.readFields(ub, {}, e$1);
			}
			function ub(t$1, e$1, r$1) {
				1 === t$1 ? (e$1.group = function(t$2, e$2) {
					return t$2.readFields(cb, {
						opacity: 255,
						children: []
					}, e$2);
				}(r$1, r$1.readVarint() + r$1.pos), e$1.node = "group") : 2 === t$1 && (e$1.path = function(t$2, e$2) {
					return t$2.readFields(db, {
						paint_order: 1,
						commands: [],
						step: 1,
						diffs: [],
						rule: Zv.PATH_RULE_NON_ZERO
					}, e$2);
				}(r$1, r$1.readVarint() + r$1.pos), e$1.node = "path");
			}
			function cb(t$1, e$1, r$1) {
				1 === t$1 ? e$1.transform = hb(r$1, r$1.readVarint() + r$1.pos) : 2 === t$1 ? e$1.opacity = r$1.readVarint() : 5 === t$1 ? e$1.clip_path_idx = r$1.readVarint() : 6 === t$1 ? e$1.mask_idx = r$1.readVarint() : 7 === t$1 && e$1.children.push(lb(r$1, r$1.readVarint() + r$1.pos));
			}
			function hb(t$1, e$1) {
				return t$1.readFields(pb, {
					sx: 1,
					ky: 0,
					kx: 0,
					sy: 1,
					tx: 0,
					ty: 0
				}, e$1);
			}
			function pb(t$1, e$1, r$1) {
				1 === t$1 ? e$1.sx = r$1.readFloat() : 2 === t$1 ? e$1.ky = r$1.readFloat() : 3 === t$1 ? e$1.kx = r$1.readFloat() : 4 === t$1 ? e$1.sy = r$1.readFloat() : 5 === t$1 ? e$1.tx = r$1.readFloat() : 6 === t$1 && (e$1.ty = r$1.readFloat());
			}
			function db(t$1, e$1, r$1) {
				1 === t$1 ? e$1.fill = function(t$2, e$2) {
					return t$2.readFields(fb, {
						rgb_color: Xv,
						paint: "rgb_color",
						opacity: 255
					}, e$2);
				}(r$1, r$1.readVarint() + r$1.pos) : 2 === t$1 ? e$1.stroke = function(t$2, e$2) {
					return t$2.readFields(yb, {
						rgb_color: Xv,
						paint: "rgb_color",
						dasharray: [],
						dashoffset: 0,
						miterlimit: 4,
						opacity: 255,
						width: 1,
						linecap: 1,
						linejoin: 1
					}, e$2);
				}(r$1, r$1.readVarint() + r$1.pos) : 3 === t$1 ? e$1.paint_order = r$1.readVarint() : 5 === t$1 ? r$1.readPackedVarint(e$1.commands) : 6 === t$1 ? e$1.step = r$1.readFloat() : 7 === t$1 ? r$1.readPackedSVarint(e$1.diffs) : 8 === t$1 && (e$1.rule = r$1.readVarint());
			}
			function fb(t$1, e$1, r$1) {
				1 === t$1 ? (e$1.rgb_color = mb(r$1.readVarint()), e$1.paint = "rgb_color") : 2 === t$1 ? (e$1.linear_gradient_idx = r$1.readVarint(), e$1.paint = "linear_gradient_idx") : 3 === t$1 ? (e$1.radial_gradient_idx = r$1.readVarint(), e$1.paint = "radial_gradient_idx") : 5 === t$1 && (e$1.opacity = r$1.readVarint());
			}
			function mb(t$1) {
				return new lr((t$1 >> 16 & 255) / 255, (t$1 >> 8 & 255) / 255, (255 & t$1) / 255, 1);
			}
			function yb(t$1, e$1, r$1) {
				1 === t$1 ? (e$1.rgb_color = mb(r$1.readVarint()), e$1.paint = "rgb_color") : 2 === t$1 ? (e$1.linear_gradient_idx = r$1.readVarint(), e$1.paint = "linear_gradient_idx") : 3 === t$1 ? (e$1.radial_gradient_idx = r$1.readVarint(), e$1.paint = "radial_gradient_idx") : 5 === t$1 ? r$1.readPackedFloat(e$1.dasharray) : 6 === t$1 ? e$1.dashoffset = r$1.readFloat() : 7 === t$1 ? e$1.miterlimit = r$1.readFloat() : 8 === t$1 ? e$1.opacity = r$1.readVarint() : 9 === t$1 ? e$1.width = r$1.readFloat() : 10 === t$1 ? e$1.linecap = r$1.readVarint() : 11 === t$1 && (e$1.linejoin = r$1.readVarint());
			}
			function gb(t$1, e$1, r$1) {
				1 === t$1 ? e$1.transform = hb(r$1, r$1.readVarint() + r$1.pos) : 2 === t$1 ? e$1.spread_method = r$1.readVarint() : 3 === t$1 ? e$1.stops.push(xb(r$1, r$1.readVarint() + r$1.pos)) : 4 === t$1 ? e$1.x1 = r$1.readFloat() : 5 === t$1 ? e$1.y1 = r$1.readFloat() : 6 === t$1 ? e$1.x2 = r$1.readFloat() : 7 === t$1 && (e$1.y2 = r$1.readFloat());
			}
			function xb(t$1, e$1) {
				return t$1.readFields(vb, {
					offset: 0,
					opacity: 255,
					rgb_color: Xv
				}, e$1);
			}
			function vb(t$1, e$1, r$1) {
				1 === t$1 ? e$1.offset = r$1.readFloat() : 2 === t$1 ? e$1.opacity = r$1.readVarint() : 3 === t$1 && (e$1.rgb_color = mb(r$1.readVarint()));
			}
			function bb(t$1, e$1, r$1) {
				1 === t$1 ? e$1.transform = hb(r$1, r$1.readVarint() + r$1.pos) : 2 === t$1 ? e$1.spread_method = r$1.readVarint() : 3 === t$1 ? e$1.stops.push(xb(r$1, r$1.readVarint() + r$1.pos)) : 4 === t$1 ? e$1.cx = r$1.readFloat() : 5 === t$1 ? e$1.cy = r$1.readFloat() : 6 === t$1 ? e$1.r = r$1.readFloat() : 7 === t$1 ? e$1.fx = r$1.readFloat() : 8 === t$1 ? e$1.fy = r$1.readFloat() : 9 === t$1 && (e$1.fr = r$1.readFloat());
			}
			function wb(t$1, e$1, r$1) {
				1 === t$1 ? e$1.transform = hb(r$1, r$1.readVarint() + r$1.pos) : 2 === t$1 ? e$1.clip_path_idx = r$1.readVarint() : 3 === t$1 && e$1.children.push(lb(r$1, r$1.readVarint() + r$1.pos));
			}
			function _b(t$1, e$1, r$1) {
				1 === t$1 ? e$1.left = e$1.top = r$1.readFloat() : 2 === t$1 ? e$1.width = e$1.height = r$1.readFloat() : 3 === t$1 ? e$1.top = r$1.readFloat() : 4 === t$1 ? e$1.height = r$1.readFloat() : 5 === t$1 ? e$1.mask_type = r$1.readVarint() : 6 === t$1 ? e$1.mask_idx = r$1.readVarint() : 7 === t$1 && e$1.children.push(lb(r$1, r$1.readVarint() + r$1.pos));
			}
			class Ab {
				static calculate(t$1 = {}, e$1 = []) {
					const r$1 = /* @__PURE__ */ new Map(), n$1 = /* @__PURE__ */ new Map();
					if (0 === Object.keys(t$1).length) return r$1;
					e$1.forEach(((t$2) => {
						n$1.set(t$2.name, t$2.rgb_color || new lr(0, 0, 0));
					}));
					for (const [e$2, i$1] of Object.entries(t$1)) n$1.has(e$2) ? r$1.set(n$1.get(e$2).toString(), i$1) : console.warn(`Ignoring unknown image variable "${e$2}"`);
					return r$1;
				}
			}
			function Ib(t$1, e$1 = 255, r$1) {
				const n$1 = e$1 / 255, i$1 = t$1.toString(), s$1 = r$1.has(i$1) ? r$1.get(i$1).clone() : t$1.clone();
				return s$1.a *= n$1, s$1.toString();
			}
			function Mb(t$1, e$1) {
				if (!me()) {
					const r$1 = document.createElement("canvas");
					return r$1.width = t$1, r$1.height = e$1, r$1;
				}
				return new OffscreenCanvas(t$1, e$1);
			}
			let Sb, Pb = null;
			function kb(t$1, e$1, r$1, n$1, i$1) {
				for (const s$1 of n$1.children) Bb(t$1, e$1, r$1, s$1, i$1);
			}
			function Bb(t$1, e$1, r$1, n$1, i$1) {
				n$1.group ? (t$1.save(), function(t$2, e$2, r$2, n$2, i$2) {
					const s$1 = null != n$2.mask_idx ? r$2.masks[n$2.mask_idx] : null, o$1 = null != n$2.clip_path_idx ? r$2.clip_paths[n$2.clip_path_idx] : null;
					if (n$2.transform && (e$2 = Lb(n$2.transform).preMultiplySelf(e$2)), !function(t$3, e$3, r$3) {
						return 255 !== t$3.opacity || e$3 || r$3;
					}(n$2, null != o$1, null != s$1)) return void kb(t$2, e$2, r$2, n$2, i$2);
					const a$1 = Mb(t$2.canvas.width, t$2.canvas.height), l$1 = a$1.getContext("2d");
					kb(l$1, e$2, r$2, n$2, i$2), o$1 && Db(l$1, e$2, r$2, o$1), s$1 && Rb(l$1, e$2, r$2, s$1, i$2), t$2.globalAlpha = n$2.opacity / 255, t$2.drawImage(a$1, 0, 0);
				}(t$1, e$1, r$1, n$1.group, i$1), t$1.restore()) : n$1.path && (t$1.save(), function(t$2, e$2, r$2, n$2, i$2) {
					t$2.setTransform(e$2), n$2.paint_order === Kv.PAINT_ORDER_FILL_AND_STROKE ? (zb(t$2, r$2, n$2, i$2), Eb(t$2, r$2, n$2, i$2)) : (Eb(t$2, r$2, n$2, i$2), zb(t$2, r$2, n$2, i$2));
				}(t$1, e$1, r$1, n$1.path, i$1), t$1.restore());
			}
			function zb(t$1, e$1, r$1, n$1) {
				const i$1 = r$1.fill;
				if (!i$1) return;
				const s$1 = i$1.opacity / 255;
				switch (t$1.save(), t$1.beginPath(), Ob(r$1, t$1), i$1.paint) {
					case "rgb_color":
						t$1.fillStyle = Ib(i$1.rgb_color, i$1.opacity, n$1);
						break;
					case "linear_gradient_idx": {
						const r$2 = e$1.linear_gradients[i$1.linear_gradient_idx];
						r$2.transform && t$1.setTransform(Lb(r$2.transform).preMultiplySelf(t$1.getTransform())), t$1.fillStyle = Vb(t$1, r$2, s$1, n$1);
						break;
					}
					case "radial_gradient_idx": {
						const r$2 = e$1.radial_gradients[i$1.radial_gradient_idx];
						r$2.transform && t$1.setTransform(Lb(r$2.transform).preMultiplySelf(t$1.getTransform())), t$1.fillStyle = Fb(t$1, r$2, s$1, n$1);
					}
				}
				t$1.fill(Tb(r$1)), t$1.restore();
			}
			function Tb(t$1) {
				return t$1.rule === Zv.PATH_RULE_NON_ZERO ? "nonzero" : t$1.rule === Zv.PATH_RULE_EVEN_ODD ? "evenodd" : void 0;
			}
			function Eb(t$1, e$1, r$1, n$1) {
				const i$1 = r$1.stroke;
				if (!i$1) return;
				const s$1 = Ub(r$1);
				t$1.lineWidth = i$1.width, t$1.miterLimit = i$1.miterlimit, t$1.setLineDash(i$1.dasharray), t$1.lineDashOffset = i$1.dashoffset;
				const o$1 = i$1.opacity / 255;
				switch (i$1.paint) {
					case "rgb_color":
						t$1.strokeStyle = Ib(i$1.rgb_color, i$1.opacity, n$1);
						break;
					case "linear_gradient_idx":
						t$1.strokeStyle = Vb(t$1, e$1.linear_gradients[i$1.linear_gradient_idx], o$1, n$1, !0);
						break;
					case "radial_gradient_idx": t$1.strokeStyle = Fb(t$1, e$1.radial_gradients[i$1.radial_gradient_idx], o$1, n$1, !0);
				}
				switch (i$1.linejoin) {
					case Yv.LINE_JOIN_MITER_CLIP:
					case Yv.LINE_JOIN_MITER:
						t$1.lineJoin = "miter";
						break;
					case Yv.LINE_JOIN_ROUND:
						t$1.lineJoin = "round";
						break;
					case Yv.LINE_JOIN_BEVEL: t$1.lineJoin = "bevel";
				}
				switch (i$1.linecap) {
					case Wv.LINE_CAP_BUTT:
						t$1.lineCap = "butt";
						break;
					case Wv.LINE_CAP_ROUND:
						t$1.lineCap = "round";
						break;
					case Wv.LINE_CAP_SQUARE: t$1.lineCap = "square";
				}
				t$1.stroke(s$1);
			}
			function Vb(t$1, e$1, r$1, n$1, i$1 = !1) {
				if (1 === e$1.stops.length) {
					const t$2 = e$1.stops[0];
					return Ib(t$2.rgb_color, t$2.opacity * r$1, n$1);
				}
				const { x1: s$1, y1: o$1, x2: a$1, y2: l$1 } = e$1;
				let u$1 = new DOMPoint(s$1, o$1), c$1 = new DOMPoint(a$1, l$1);
				if (i$1) {
					const t$2 = Lb(e$1.transform);
					u$1 = t$2.transformPoint(u$1), c$1 = t$2.transformPoint(c$1);
				}
				const h$1 = t$1.createLinearGradient(u$1.x, u$1.y, c$1.x, c$1.y);
				for (const t$2 of e$1.stops) h$1.addColorStop(t$2.offset, Ib(t$2.rgb_color, t$2.opacity * r$1, n$1));
				return h$1;
			}
			function Fb(t$1, e$1, r$1, n$1, i$1 = !1) {
				if (1 === e$1.stops.length) {
					const t$2 = e$1.stops[0];
					return Ib(t$2.rgb_color, t$2.opacity * r$1, n$1);
				}
				const s$1 = Lb(e$1.transform), { fx: o$1, fy: a$1, fr: l$1, cx: u$1, cy: c$1, r: h$1 } = e$1;
				let p$1 = new DOMPoint(o$1, a$1), d$1 = new DOMPoint(u$1, c$1), f$1 = l$1, m$1 = h$1;
				if (i$1) {
					p$1 = s$1.transformPoint(p$1), d$1 = s$1.transformPoint(d$1);
					const t$2 = (s$1.a + s$1.d) / 2;
					f$1 = l$1 * t$2, m$1 = e$1.r * t$2;
				}
				const y$1 = t$1.createRadialGradient(p$1.x, p$1.y, f$1, d$1.x, d$1.y, m$1);
				for (const t$2 of e$1.stops) y$1.addColorStop(t$2.offset, Ib(t$2.rgb_color, t$2.opacity * r$1, n$1));
				return y$1;
			}
			function Cb(t$1, e$1, r$1, n$1) {
				const i$1 = n$1.transform ? Lb(n$1.transform).preMultiplySelf(e$1) : e$1, s$1 = Mb(t$1.canvas.width, t$1.canvas.height), o$1 = s$1.getContext("2d");
				for (const t$2 of n$1.children) if (t$2.group) Cb(o$1, i$1, r$1, t$2.group);
				else if (t$2.path) {
					const e$2 = t$2.path, r$2 = new Path2D();
					r$2.addPath(Ub(e$2), i$1), o$1.fill(r$2, Tb(e$2));
				}
				const a$1 = null != n$1.clip_path_idx ? r$1.clip_paths[n$1.clip_path_idx] : null;
				a$1 && Db(o$1, i$1, r$1, a$1), t$1.globalCompositeOperation = "source-over", t$1.drawImage(s$1, 0, 0);
			}
			function Db(t$1, e$1, r$1, n$1) {
				const i$1 = Mb(t$1.canvas.width, t$1.canvas.height);
				Cb(i$1.getContext("2d"), e$1, r$1, n$1), t$1.globalCompositeOperation = "destination-in", t$1.drawImage(i$1, 0, 0);
			}
			function Rb(t$1, e$1, r$1, n$1, i$1) {
				if (0 === n$1.children.length) return;
				const s$1 = null != n$1.mask_idx ? r$1.masks[n$1.mask_idx] : null;
				s$1 && Rb(t$1, e$1, r$1, s$1, i$1);
				const o$1 = t$1.canvas.width, a$1 = t$1.canvas.height, l$1 = Mb(o$1, a$1), u$1 = l$1.getContext("2d"), c$1 = n$1.width, h$1 = n$1.height, p$1 = n$1.left, d$1 = n$1.top, f$1 = new Path2D(), m$1 = new Path2D();
				m$1.rect(p$1, d$1, c$1, h$1), f$1.addPath(m$1, e$1), u$1.clip(f$1);
				for (const t$2 of n$1.children) Bb(u$1, e$1, r$1, t$2, i$1);
				const y$1 = u$1.getImageData(0, 0, o$1, a$1), g$1 = y$1.data;
				if (n$1.mask_type === Qv.MASK_TYPE_LUMINANCE) for (let t$2 = 0; t$2 < g$1.length; t$2 += 4) g$1[t$2 + 3] = g$1[t$2 + 3] / 255 * (.2126 * g$1[t$2] + .7152 * g$1[t$2 + 1] + .0722 * g$1[t$2 + 2]);
				u$1.putImageData(y$1, 0, 0), t$1.globalCompositeOperation = "destination-in", t$1.drawImage(l$1, 0, 0);
			}
			function Lb(t$1) {
				return t$1 ? new DOMMatrix([
					t$1.sx,
					t$1.ky,
					t$1.kx,
					t$1.sy,
					t$1.tx,
					t$1.ty
				]) : new DOMMatrix();
			}
			function Ob(t$1, e$1) {
				const r$1 = t$1.step;
				let n$1 = t$1.diffs[0] * r$1, i$1 = t$1.diffs[1] * r$1;
				e$1.moveTo(n$1, i$1);
				for (let s$1 = 0, o$1 = 2; s$1 < t$1.commands.length; s$1++) switch (t$1.commands[s$1]) {
					case Jv.PATH_COMMAND_MOVE:
						n$1 += t$1.diffs[o$1++] * r$1, i$1 += t$1.diffs[o$1++] * r$1, e$1.moveTo(n$1, i$1);
						break;
					case Jv.PATH_COMMAND_LINE:
						n$1 += t$1.diffs[o$1++] * r$1, i$1 += t$1.diffs[o$1++] * r$1, e$1.lineTo(n$1, i$1);
						break;
					case Jv.PATH_COMMAND_QUAD: {
						const s$2 = n$1 + t$1.diffs[o$1++] * r$1, a$1 = i$1 + t$1.diffs[o$1++] * r$1;
						n$1 = s$2 + t$1.diffs[o$1++] * r$1, i$1 = a$1 + t$1.diffs[o$1++] * r$1, e$1.quadraticCurveTo(s$2, a$1, n$1, i$1);
						break;
					}
					case Jv.PATH_COMMAND_CUBIC: {
						const s$2 = n$1 + t$1.diffs[o$1++] * r$1, a$1 = i$1 + t$1.diffs[o$1++] * r$1, l$1 = s$2 + t$1.diffs[o$1++] * r$1, u$1 = a$1 + t$1.diffs[o$1++] * r$1;
						n$1 = l$1 + t$1.diffs[o$1++] * r$1, i$1 = u$1 + t$1.diffs[o$1++] * r$1, e$1.bezierCurveTo(s$2, a$1, l$1, u$1, n$1, i$1);
						break;
					}
					case Jv.PATH_COMMAND_CLOSE: e$1.closePath();
				}
				return e$1;
			}
			function Ub(t$1) {
				return Ob(t$1, new Path2D());
			}
			class Nb {
				constructor(t$1) {
					this.capacity = t$1, this.cache = /* @__PURE__ */ new Map();
				}
				get(t$1) {
					if (!this.cache.has(t$1)) return;
					const e$1 = this.cache.get(t$1);
					return this.cache.delete(t$1), this.cache.set(t$1, e$1), e$1;
				}
				put(t$1, e$1) {
					this.cache.has(t$1) ? this.cache.delete(t$1) : this.cache.size === this.capacity && this.cache.delete(this.cache.keys().next().value), this.cache.set(t$1, e$1);
				}
				delete(t$1) {
					this.cache.delete(t$1);
				}
			}
			Qs(Nb, "LRUCache");
			class jb {
				constructor() {
					this.cacheMap = /* @__PURE__ */ new Map(), this.cacheDependenciesMap = /* @__PURE__ */ new Map();
				}
				static _getImage(t$1) {
					return new Ah(t$1, t$1.data);
				}
				getFromCache(t$1, e$1, r$1) {
					return this.cacheMap.has(r$1) || this.cacheMap.set(r$1, new Nb(150)), this.cacheMap.get(r$1).get(ta(t$1.toString(), e$1));
				}
				setInCache(t$1, e$1, r$1, n$1) {
					this.cacheDependenciesMap.has(n$1) || this.cacheDependenciesMap.set(n$1, /* @__PURE__ */ new Map()), this.cacheMap.has(n$1) || this.cacheMap.set(n$1, new Nb(150));
					const i$1 = this.cacheDependenciesMap.get(n$1), s$1 = ta(t$1.id.toString(), r$1);
					i$1.get(s$1) || i$1.set(s$1, /* @__PURE__ */ new Set());
					const o$1 = this.cacheMap.get(n$1), a$1 = t$1.toString();
					i$1.get(s$1).add(a$1), o$1.put(ta(t$1.toString(), r$1), e$1);
				}
				removeImagesFromCacheByIds(t$1, e$1, r$1 = 0) {
					if (!this.cacheMap.has(r$1) || !this.cacheDependenciesMap.has(r$1)) return;
					const n$1 = this.cacheMap.get(r$1), i$1 = this.cacheDependenciesMap.get(r$1);
					for (const r$2 of t$1) {
						const t$2 = ta(r$2.toString(), e$1);
						if (i$1.has(t$2)) {
							for (const e$2 of i$1.get(t$2)) n$1.delete(e$2);
							i$1.delete(t$2);
						}
					}
				}
				rasterize(t$1, e$1, r$1, n$1) {
					const i$1 = this.getFromCache(t$1, r$1, n$1);
					if (i$1) return i$1.clone();
					const s$1 = function(t$2, e$2) {
						const r$2 = Ab.calculate(e$2.params, t$2.metadata ? t$2.metadata.variables : []), n$2 = t$2.usvg_tree, i$2 = n$2.width, s$2 = n$2.height, o$2 = Math.max(1, Math.round(i$2 * e$2.sx)), a$1 = Math.max(1, Math.round(s$2 * e$2.sy)), l$1 = new DOMMatrix([
							o$2 / i$2,
							0,
							0,
							a$1 / s$2,
							0,
							0
						]);
						return null === Pb && (Pb = Mb(10, 10), Sb = Pb.getContext("2d", { willReadFrequently: !0 })), Pb.width = o$2, Pb.height = a$1, kb(Sb, l$1, n$2, n$2, r$2), Sb.getImageData(0, 0, o$2, a$1);
					}(e$1.icon, t$1), o$1 = jb._getImage(s$1);
					return this.setInCache(t$1, o$1, r$1, n$1), o$1.clone();
				}
			}
			class $b {
				constructor(t$1) {
					this.size = t$1, this.minimums = [], this.maximums = [], this.leaves = [];
				}
				getElevation(t$1, e$1) {
					const r$1 = this.toIdx(t$1, e$1);
					return {
						min: this.minimums[r$1],
						max: this.maximums[r$1]
					};
				}
				isLeaf(t$1, e$1) {
					return this.leaves[this.toIdx(t$1, e$1)];
				}
				toIdx(t$1, e$1) {
					return e$1 * this.size + t$1;
				}
			}
			function Gb(t$1, e$1, r$1, n$1) {
				let i$1 = 0, s$1 = Number.MAX_VALUE;
				for (let o$1 = 0; o$1 < 3; o$1++) if (Math.abs(n$1[o$1]) < 1e-15) {
					if (r$1[o$1] < t$1[o$1] || r$1[o$1] > e$1[o$1]) return null;
				} else {
					const a$1 = 1 / n$1[o$1];
					let l$1 = (t$1[o$1] - r$1[o$1]) * a$1, u$1 = (e$1[o$1] - r$1[o$1]) * a$1;
					if (l$1 > u$1) {
						const t$2 = l$1;
						l$1 = u$1, u$1 = t$2;
					}
					if (l$1 > i$1 && (i$1 = l$1), u$1 < s$1 && (s$1 = u$1), i$1 > s$1) return null;
				}
				return i$1;
			}
			function qb(t$1, e$1, r$1, n$1, i$1, s$1, o$1, a$1, l$1, u$1, c$1) {
				const h$1 = n$1 - t$1, p$1 = i$1 - e$1, d$1 = s$1 - r$1, f$1 = o$1 - t$1, m$1 = a$1 - e$1, y$1 = l$1 - r$1, g$1 = c$1[1] * y$1 - c$1[2] * m$1, x$1 = c$1[2] * f$1 - c$1[0] * y$1, v$1 = c$1[0] * m$1 - c$1[1] * f$1, b$1 = h$1 * g$1 + p$1 * x$1 + d$1 * v$1;
				if (Math.abs(b$1) < 1e-15) return null;
				const w$1 = 1 / b$1, _$1 = u$1[0] - t$1, A$1 = u$1[1] - e$1, I$1 = u$1[2] - r$1, M$1 = (_$1 * g$1 + A$1 * x$1 + I$1 * v$1) * w$1;
				if (M$1 < 0 || M$1 > 1) return null;
				const S$1 = A$1 * d$1 - I$1 * p$1, P$1 = I$1 * h$1 - _$1 * d$1, k$1 = _$1 * p$1 - A$1 * h$1, B$1 = (c$1[0] * S$1 + c$1[1] * P$1 + c$1[2] * k$1) * w$1;
				return B$1 < 0 || M$1 + B$1 > 1 ? null : (f$1 * S$1 + m$1 * P$1 + y$1 * k$1) * w$1;
			}
			function Hb(t$1, e$1, r$1) {
				return (t$1 - e$1) / (r$1 - e$1);
			}
			function Xb(t$1, e$1, r$1, n$1, i$1, s$1, o$1, a$1, l$1) {
				const u$1 = 1 << r$1, c$1 = s$1 - n$1, h$1 = o$1 - i$1, p$1 = (t$1 + 1) / u$1 * c$1 + n$1, d$1 = (e$1 + 0) / u$1 * h$1 + i$1, f$1 = (e$1 + 1) / u$1 * h$1 + i$1;
				a$1[0] = (t$1 + 0) / u$1 * c$1 + n$1, a$1[1] = d$1, l$1[0] = p$1, l$1[1] = f$1;
			}
			class Zb {
				constructor(t$1) {
					if (this.maximums = [], this.minimums = [], this.leaves = [], this.childOffsets = [], this.nodeCount = 0, this.dem = t$1, this._siblingOffset = [
						[0, 0],
						[1, 0],
						[0, 1],
						[1, 1]
					], !this.dem) return;
					const e$1 = function(t$2) {
						const e$2 = Math.ceil(Math.log2(t$2.dim / 8)), r$2 = [];
						let n$2 = Math.ceil(Math.pow(2, e$2));
						const i$1 = 1 / n$2, s$1 = (t$3, e$3, r$3, n$3, i$2) => {
							const s$2 = n$3 ? 1 : 0, o$2 = (t$3 + 1) * r$3 - s$2, a$2 = e$3 * r$3, l$1 = (e$3 + 1) * r$3 - s$2;
							i$2[0] = t$3 * r$3, i$2[1] = a$2, i$2[2] = o$2, i$2[3] = l$1;
						};
						let o$1 = new $b(n$2);
						const a$1 = [];
						for (let e$3 = 0; e$3 < n$2 * n$2; e$3++) {
							s$1(e$3 % n$2, Math.floor(e$3 / n$2), i$1, !1, a$1);
							const r$3 = Yb(a$1[0], a$1[1], t$2), l$1 = Yb(a$1[2], a$1[1], t$2), u$1 = Yb(a$1[2], a$1[3], t$2), c$1 = Yb(a$1[0], a$1[3], t$2);
							o$1.minimums.push(Math.min(r$3, l$1, u$1, c$1)), o$1.maximums.push(Math.max(r$3, l$1, u$1, c$1)), o$1.leaves.push(1);
						}
						for (r$2.push(o$1), n$2 /= 2; n$2 >= 1; n$2 /= 2) {
							const t$3 = r$2[r$2.length - 1];
							o$1 = new $b(n$2);
							for (let e$3 = 0; e$3 < n$2 * n$2; e$3++) {
								s$1(e$3 % n$2, Math.floor(e$3 / n$2), 2, !0, a$1);
								const r$3 = t$3.getElevation(a$1[0], a$1[1]), i$2 = t$3.getElevation(a$1[2], a$1[1]), l$1 = t$3.getElevation(a$1[2], a$1[3]), u$1 = t$3.getElevation(a$1[0], a$1[3]), c$1 = t$3.isLeaf(a$1[0], a$1[1]), h$1 = t$3.isLeaf(a$1[2], a$1[1]), p$1 = t$3.isLeaf(a$1[2], a$1[3]), d$1 = t$3.isLeaf(a$1[0], a$1[3]), f$1 = Math.min(r$3.min, i$2.min, l$1.min, u$1.min), m$1 = Math.max(r$3.max, i$2.max, l$1.max, u$1.max), y$1 = c$1 && h$1 && p$1 && d$1;
								o$1.maximums.push(m$1), o$1.minimums.push(f$1), o$1.leaves.push(m$1 - f$1 <= 5 && y$1 ? 1 : 0);
							}
							r$2.push(o$1);
						}
						return r$2;
					}(this.dem), r$1 = e$1.length - 1, n$1 = e$1[r$1];
					this._addNode(n$1.minimums[0], n$1.maximums[0], n$1.leaves[0]), this._construct(e$1, 0, 0, r$1, 0);
				}
				raycastRoot(t$1, e$1, r$1, n$1, i$1, s$1, o$1 = 1) {
					return Gb([
						t$1,
						e$1,
						-100
					], [
						r$1,
						n$1,
						this.maximums[0] * o$1
					], i$1, s$1);
				}
				raycast(t$1, e$1, r$1, n$1, i$1, s$1, o$1 = 1) {
					if (!this.nodeCount) return null;
					const a$1 = this.raycastRoot(t$1, e$1, r$1, n$1, i$1, s$1, o$1);
					if (null == a$1) return null;
					const l$1 = [], u$1 = [], c$1 = [], h$1 = [], p$1 = [{
						idx: 0,
						t: a$1,
						nodex: 0,
						nodey: 0,
						depth: 0
					}];
					for (; p$1.length > 0;) {
						const { idx: a$2, t: d$1, nodex: f$1, nodey: m$1, depth: y$1 } = p$1.pop();
						if (this.leaves[a$2]) {
							Xb(f$1, m$1, y$1, t$1, e$1, r$1, n$1, c$1, h$1);
							const a$3 = 1 << y$1, l$2 = (f$1 + 0) / a$3, u$2 = (f$1 + 1) / a$3, p$2 = (m$1 + 0) / a$3, g$2 = (m$1 + 1) / a$3, x$1 = Yb(l$2, p$2, this.dem) * o$1, v$1 = Yb(u$2, p$2, this.dem) * o$1, b$1 = Yb(u$2, g$2, this.dem) * o$1, w$1 = Yb(l$2, g$2, this.dem) * o$1, _$1 = qb(c$1[0], c$1[1], x$1, h$1[0], c$1[1], v$1, h$1[0], h$1[1], b$1, i$1, s$1), A$1 = qb(h$1[0], h$1[1], b$1, c$1[0], h$1[1], w$1, c$1[0], c$1[1], x$1, i$1, s$1), I$1 = Math.min(null !== _$1 ? _$1 : Number.MAX_VALUE, null !== A$1 ? A$1 : Number.MAX_VALUE);
							if (I$1 !== Number.MAX_VALUE) return I$1;
							{
								const t$2 = V([], i$1, s$1, d$1);
								if (Wb(x$1, v$1, w$1, b$1, Hb(t$2[0], c$1[0], h$1[0]), Hb(t$2[1], c$1[1], h$1[1])) >= t$2[2]) return d$1;
							}
							continue;
						}
						let g$1 = 0;
						for (let p$2 = 0; p$2 < this._siblingOffset.length; p$2++) {
							Xb((f$1 << 1) + this._siblingOffset[p$2][0], (m$1 << 1) + this._siblingOffset[p$2][1], y$1 + 1, t$1, e$1, r$1, n$1, c$1, h$1), c$1[2] = -100, h$1[2] = this.maximums[this.childOffsets[a$2] + p$2] * o$1;
							const d$2 = Gb(c$1, h$1, i$1, s$1);
							if (null != d$2) {
								const t$2 = d$2;
								l$1[p$2] = t$2;
								let e$2 = !1;
								for (let r$2 = 0; r$2 < g$1 && !e$2; r$2++) t$2 >= l$1[u$1[r$2]] && (u$1.splice(r$2, 0, p$2), e$2 = !0);
								e$2 || (u$1[g$1] = p$2), g$1++;
							}
						}
						for (let t$2 = 0; t$2 < g$1; t$2++) {
							const e$2 = u$1[t$2];
							p$1.push({
								idx: this.childOffsets[a$2] + e$2,
								t: l$1[e$2],
								nodex: (f$1 << 1) + this._siblingOffset[e$2][0],
								nodey: (m$1 << 1) + this._siblingOffset[e$2][1],
								depth: y$1 + 1
							});
						}
					}
					return null;
				}
				_addNode(t$1, e$1, r$1) {
					return this.minimums.push(t$1), this.maximums.push(e$1), this.leaves.push(r$1), this.childOffsets.push(0), this.nodeCount++;
				}
				_construct(t$1, e$1, r$1, n$1, i$1) {
					if (1 === t$1[n$1].isLeaf(e$1, r$1)) return;
					this.childOffsets[i$1] || (this.childOffsets[i$1] = this.nodeCount);
					const s$1 = n$1 - 1, o$1 = t$1[s$1];
					let a$1 = 0, l$1 = 0;
					for (let t$2 = 0; t$2 < this._siblingOffset.length; t$2++) {
						const n$2 = 2 * e$1 + this._siblingOffset[t$2][0], i$2 = 2 * r$1 + this._siblingOffset[t$2][1], s$2 = o$1.getElevation(n$2, i$2), u$1 = o$1.isLeaf(n$2, i$2), c$1 = this._addNode(s$2.min, s$2.max, u$1);
						u$1 && (a$1 |= 1 << t$2), l$1 || (l$1 = c$1);
					}
					for (let n$2 = 0; n$2 < this._siblingOffset.length; n$2++) a$1 & 1 << n$2 || this._construct(t$1, 2 * e$1 + this._siblingOffset[n$2][0], 2 * r$1 + this._siblingOffset[n$2][1], s$1, l$1 + n$2);
				}
			}
			function Wb(t$1, e$1, r$1, n$1, i$1, s$1) {
				return pr(pr(t$1, r$1, s$1), pr(e$1, n$1, s$1), i$1);
			}
			function Yb(t$1, e$1, r$1) {
				const n$1 = r$1.dim, i$1 = Ft(t$1 * n$1 - .5, 0, n$1 - 1), s$1 = Ft(e$1 * n$1 - .5, 0, n$1 - 1), o$1 = Math.floor(i$1), a$1 = Math.floor(s$1), l$1 = Math.min(o$1 + 1, n$1 - 1), u$1 = Math.min(a$1 + 1, n$1 - 1);
				return Wb(r$1.get(o$1, a$1), r$1.get(l$1, a$1), r$1.get(o$1, u$1), r$1.get(l$1, u$1), i$1 - o$1, s$1 - a$1);
			}
			const Kb = {
				mapbox: [
					6553.6,
					25.6,
					.1,
					1e4
				],
				terrarium: [
					256,
					1,
					1 / 256,
					32768
				]
			};
			function Jb(t$1, e$1, r$1) {
				return (256 * t$1 * 256 + 256 * e$1 + r$1) / 10 - 1e4;
			}
			function Qb(t$1, e$1, r$1) {
				return 256 * t$1 + e$1 + r$1 / 256 - 32768;
			}
			class tw {
				get tree() {
					return this._tree || this._buildQuadTree(), this._tree;
				}
				constructor(t$1, e$1, r$1, n$1 = !1) {
					if (this.uid = t$1, e$1.height !== e$1.width) throw new RangeError("DEM tiles must be square");
					if (r$1 && "mapbox" !== r$1 && "terrarium" !== r$1) return void Xt(`"${r$1}" is not a valid encoding type. Valid types include "mapbox" and "terrarium".`);
					this.stride = e$1.height;
					const i$1 = this.dim = e$1.height - 2, s$1 = new Uint32Array(e$1.data.buffer);
					if (this.pixels = new Uint8Array(e$1.data.buffer), this.floatView = new Float32Array(e$1.data.buffer), this.borderReady = n$1, this._modifiedForSources = {}, !n$1) {
						for (let t$2 = 0; t$2 < i$1; t$2++) s$1[this._idx(-1, t$2)] = s$1[this._idx(0, t$2)], s$1[this._idx(i$1, t$2)] = s$1[this._idx(i$1 - 1, t$2)], s$1[this._idx(t$2, -1)] = s$1[this._idx(t$2, 0)], s$1[this._idx(t$2, i$1)] = s$1[this._idx(t$2, i$1 - 1)];
						s$1[this._idx(-1, -1)] = s$1[this._idx(0, 0)], s$1[this._idx(i$1, -1)] = s$1[this._idx(i$1 - 1, 0)], s$1[this._idx(-1, i$1)] = s$1[this._idx(0, i$1 - 1)], s$1[this._idx(i$1, i$1)] = s$1[this._idx(i$1 - 1, i$1 - 1)];
					}
					const o$1 = "terrarium" === r$1 ? Qb : Jb;
					for (let t$2 = 0; t$2 < s$1.length; ++t$2) {
						const e$2 = 4 * t$2;
						this.floatView[t$2] = o$1(this.pixels[e$2], this.pixels[e$2 + 1], this.pixels[e$2 + 2]);
					}
					this._timestamp = ye.now();
				}
				_buildQuadTree() {
					this._tree = new Zb(this);
				}
				get(t$1, e$1, r$1 = !1) {
					r$1 && (t$1 = Ft(t$1, -1, this.dim), e$1 = Ft(e$1, -1, this.dim));
					const n$1 = this._idx(t$1, e$1);
					return this.floatView[n$1];
				}
				set(t$1, e$1, r$1) {
					const n$1 = this._idx(t$1, e$1), i$1 = this.floatView[n$1];
					return this.floatView[n$1] = r$1, r$1 - i$1;
				}
				static getUnpackVector(t$1) {
					return Kb[t$1];
				}
				_idx(t$1, e$1) {
					if (t$1 < -1 || t$1 >= this.dim + 1 || e$1 < -1 || e$1 >= this.dim + 1) throw new RangeError("out of range source coordinates for DEM data");
					return (e$1 + 1) * this.stride + (t$1 + 1);
				}
				static pack(t$1, e$1) {
					const r$1 = [
						0,
						0,
						0,
						0
					], n$1 = tw.getUnpackVector(e$1);
					let i$1 = Math.floor((t$1 + n$1[3]) / n$1[2]);
					return r$1[2] = i$1 % 256, i$1 = Math.floor(i$1 / 256), r$1[1] = i$1 % 256, i$1 = Math.floor(i$1 / 256), r$1[0] = i$1, r$1;
				}
				getPixels() {
					return new Ih({
						width: this.stride,
						height: this.stride
					}, this.pixels);
				}
				backfillBorder(t$1, e$1, r$1) {
					if (this.dim !== t$1.dim) throw new Error("dem dimension mismatch");
					let n$1 = e$1 * this.dim, i$1 = e$1 * this.dim + this.dim, s$1 = r$1 * this.dim, o$1 = r$1 * this.dim + this.dim;
					switch (e$1) {
						case -1:
							n$1 = i$1 - 1;
							break;
						case 1: i$1 = n$1 + 1;
					}
					switch (r$1) {
						case -1:
							s$1 = o$1 - 1;
							break;
						case 1: o$1 = s$1 + 1;
					}
					const a$1 = -e$1 * this.dim, l$1 = -r$1 * this.dim;
					for (let e$2 = s$1; e$2 < o$1; e$2++) for (let r$2 = n$1; r$2 < i$1; r$2++) {
						const n$2 = 4 * this._idx(r$2, e$2), i$2 = 4 * this._idx(r$2 + a$1, e$2 + l$1);
						this.pixels[n$2 + 0] = t$1.pixels[i$2 + 0], this.pixels[n$2 + 1] = t$1.pixels[i$2 + 1], this.pixels[n$2 + 2] = t$1.pixels[i$2 + 2], this.pixels[n$2 + 3] = t$1.pixels[i$2 + 3];
					}
				}
				onDeserialize() {
					this._tree && (this._tree.dem = this);
				}
			}
			function ew(t$1, e$1, r$1) {
				1 === t$1 ? e$1.headerLength = r$1.readFixed32() : 2 === t$1 ? e$1.x = r$1.readVarint() : 3 === t$1 ? e$1.y = r$1.readVarint() : 4 === t$1 ? e$1.z = r$1.readVarint() : 5 === t$1 && e$1.layers.push(function(t$2, e$2) {
					return t$2.readFields(ow, {
						version: 0,
						name: "",
						units: "",
						tileSize: 0,
						buffer: 0,
						pixelFormat: 0,
						dataIndex: []
					}, e$2);
				}(r$1, r$1.readVarint() + r$1.pos));
			}
			function rw(t$1, e$1, r$1) {
				1 === t$1 ? (e$1.delta_filter = function(t$2, e$2) {
					return t$2.readFields(nw, { blockSize: 0 }, e$2);
				}(r$1, r$1.readVarint() + r$1.pos), e$1.filter = "delta_filter") : 2 === t$1 ? (r$1.readVarint(), e$1.filter = "zigzag_filter") : 3 === t$1 ? (r$1.readVarint(), e$1.filter = "bitshuffle_filter") : 4 === t$1 && (r$1.readVarint(), e$1.filter = "byteshuffle_filter");
			}
			function nw(t$1, e$1, r$1) {
				1 === t$1 && (e$1.blockSize = r$1.readVarint());
			}
			function iw(t$1, e$1, r$1) {
				1 === t$1 ? (r$1.readVarint(), e$1.codec = "gzip_data") : 2 === t$1 ? (r$1.readVarint(), e$1.codec = "jpeg_image") : 3 === t$1 ? (r$1.readVarint(), e$1.codec = "webp_image") : 4 === t$1 && (r$1.readVarint(), e$1.codec = "png_image");
			}
			function sw(t$1, e$1, r$1) {
				let n$1 = 0, i$1 = 0;
				1 === t$1 ? e$1.firstByte = r$1.readFixed64() : 2 === t$1 ? e$1.lastByte = r$1.readFixed64() : 3 === t$1 ? e$1.filters.push(function(t$2, e$2) {
					return t$2.readFields(rw, {}, e$2);
				}(r$1, r$1.readVarint() + r$1.pos)) : 4 === t$1 ? e$1.codec = function(t$2, e$2) {
					return t$2.readFields(iw, {}, e$2);
				}(r$1, r$1.readVarint() + r$1.pos) : 5 === t$1 ? i$1 = r$1.readFloat() : 6 === t$1 ? n$1 = r$1.readFloat() : 7 === t$1 ? e$1.bands.push(r$1.readString()) : 8 === t$1 ? e$1.offset = r$1.readDouble() : 9 === t$1 && (e$1.scale = r$1.readDouble()), 0 === e$1.offset && (e$1.offset = i$1), 0 === e$1.scale && (e$1.scale = n$1);
			}
			function ow(t$1, e$1, r$1) {
				1 === t$1 ? e$1.version = r$1.readVarint() : 2 === t$1 ? e$1.name = r$1.readString() : 3 === t$1 ? e$1.units = r$1.readString() : 4 === t$1 ? e$1.tileSize = r$1.readVarint() : 5 === t$1 ? e$1.buffer = r$1.readVarint() : 6 === t$1 ? e$1.pixelFormat = r$1.readVarint() : 7 === t$1 && e$1.dataIndex.push(function(t$2, e$2) {
					return t$2.readFields(sw, {
						firstByte: 0,
						lastByte: 0,
						filters: [],
						codec: null,
						offset: 0,
						scale: 0,
						bands: []
					}, e$2);
				}(r$1, r$1.readVarint() + r$1.pos));
			}
			function aw(t$1, e$1, r$1) {
				if (2 === t$1) (function(t$2, e$2, r$2) {
					t$2.readFields(lw, r$2, e$2);
				})(r$1, r$1.readVarint() + r$1.pos, e$1);
				else if (3 === t$1) throw new Error("Not implemented");
			}
			function lw(t$1, e$1, r$1) {
				if (1 === t$1) {
					let t$2 = 0;
					const n$1 = r$1.readVarint() + r$1.pos;
					for (; r$1.pos < n$1;) e$1[t$2++] = r$1.readVarint();
				}
			}
			function uw(t$1, e$1) {
				if (4 !== e$1.length) throw new Error(`Expected data of dimension 4 but got ${e$1.length}.`);
				let r$1 = e$1[3];
				for (let n$1 = 2; n$1 >= 1; n$1--) {
					const i$1 = 1 === n$1 ? 1 : 0, s$1 = 2 === n$1 ? 1 : 0;
					for (let n$2 = 0; n$2 < e$1[0]; n$2++) {
						const o$1 = e$1[1] * n$2;
						for (let n$3 = i$1; n$3 < e$1[1]; n$3++) {
							const i$2 = e$1[2] * (n$3 + o$1);
							for (let n$4 = s$1; n$4 < e$1[2]; n$4++) {
								const s$2 = e$1[3] * (n$4 + i$2);
								for (let n$5 = 0; n$5 < e$1[3]; n$5++) {
									const e$2 = s$2 + n$5;
									t$1[e$2] += t$1[e$2 - r$1];
								}
							}
						}
					}
					r$1 *= e$1[n$1];
				}
				return t$1;
			}
			function cw(t$1) {
				for (let e$1 = 0, r$1 = t$1.length; e$1 < r$1; e$1++) t$1[e$1] = t$1[e$1] >>> 1 ^ -(1 & t$1[e$1]);
				return t$1;
			}
			function hw(t$1, e$1) {
				switch (e$1) {
					case "uint32": return t$1;
					case "uint16":
						for (let e$2 = 0; e$2 < t$1.length; e$2 += 2) {
							const r$1 = t$1[e$2], n$1 = t$1[e$2 + 1];
							t$1[e$2] = (240 & r$1) >> 4 | (61440 & r$1) >> 8 | (240 & n$1) << 4 | 61440 & n$1, t$1[e$2 + 1] = 15 & r$1 | (3840 & r$1) >> 4 | (15 & n$1) << 8 | (3840 & n$1) << 4;
						}
						return t$1;
					case "uint8":
						for (let e$2 = 0; e$2 < t$1.length; e$2 += 4) {
							const r$1 = t$1[e$2], n$1 = t$1[e$2 + 1], i$1 = t$1[e$2 + 2], s$1 = t$1[e$2 + 3];
							t$1[e$2 + 0] = (192 & r$1) >> 6 | (192 & n$1) >> 4 | (192 & i$1) >> 2 | 192 & s$1, t$1[e$2 + 1] = (48 & r$1) >> 4 | (48 & n$1) >> 2 | 48 & i$1 | (48 & s$1) << 2, t$1[e$2 + 2] = (12 & r$1) >> 2 | 12 & n$1 | (12 & i$1) << 2 | (12 & s$1) << 4, t$1[e$2 + 3] = 3 & r$1 | (3 & n$1) << 2 | (3 & i$1) << 4 | (3 & s$1) << 6;
						}
						return t$1;
					default: throw new Error(`Invalid pixel format, "${e$1}"`);
				}
			}
			Qs(tw, "DEMData"), Qs(Zb, "DemMinMaxQuadTree", { omit: ["dem"] });
			var pw = Uint8Array, dw = Uint16Array, fw = Int32Array, mw = new pw([
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				1,
				1,
				1,
				1,
				2,
				2,
				2,
				2,
				3,
				3,
				3,
				3,
				4,
				4,
				4,
				4,
				5,
				5,
				5,
				5,
				0,
				0,
				0,
				0
			]), yw = new pw([
				0,
				0,
				0,
				0,
				1,
				1,
				2,
				2,
				3,
				3,
				4,
				4,
				5,
				5,
				6,
				6,
				7,
				7,
				8,
				8,
				9,
				9,
				10,
				10,
				11,
				11,
				12,
				12,
				13,
				13,
				0,
				0
			]), gw = new pw([
				16,
				17,
				18,
				0,
				8,
				7,
				9,
				6,
				10,
				5,
				11,
				4,
				12,
				3,
				13,
				2,
				14,
				1,
				15
			]), xw = function(t$1, e$1) {
				for (var r$1 = new dw(31), n$1 = 0; n$1 < 31; ++n$1) r$1[n$1] = e$1 += 1 << t$1[n$1 - 1];
				var i$1 = new fw(r$1[30]);
				for (n$1 = 1; n$1 < 30; ++n$1) for (var s$1 = r$1[n$1]; s$1 < r$1[n$1 + 1]; ++s$1) i$1[s$1] = s$1 - r$1[n$1] << 5 | n$1;
				return {
					b: r$1,
					r: i$1
				};
			}, vw = xw(mw, 2), bw = vw.b, ww = vw.r;
			bw[28] = 258, ww[258] = 28;
			for (var _w = xw(yw, 0).b, Aw = new dw(32768), Iw = 0; Iw < 32768; ++Iw) {
				var Mw = (43690 & Iw) >> 1 | (21845 & Iw) << 1;
				Aw[Iw] = ((65280 & (Mw = (61680 & (Mw = (52428 & Mw) >> 2 | (13107 & Mw) << 2)) >> 4 | (3855 & Mw) << 4)) >> 8 | (255 & Mw) << 8) >> 1;
			}
			var Sw = function(t$1, e$1, r$1) {
				for (var n$1 = t$1.length, i$1 = 0, s$1 = new dw(e$1); i$1 < n$1; ++i$1) t$1[i$1] && ++s$1[t$1[i$1] - 1];
				var o$1, a$1 = new dw(e$1);
				for (i$1 = 1; i$1 < e$1; ++i$1) a$1[i$1] = a$1[i$1 - 1] + s$1[i$1 - 1] << 1;
				o$1 = new dw(1 << e$1);
				var l$1 = 15 - e$1;
				for (i$1 = 0; i$1 < n$1; ++i$1) if (t$1[i$1]) for (var u$1 = i$1 << 4 | t$1[i$1], c$1 = e$1 - t$1[i$1], h$1 = a$1[t$1[i$1] - 1]++ << c$1, p$1 = h$1 | (1 << c$1) - 1; h$1 <= p$1; ++h$1) o$1[Aw[h$1] >> l$1] = u$1;
				return o$1;
			}, Pw = new pw(288);
			for (Iw = 0; Iw < 144; ++Iw) Pw[Iw] = 8;
			for (Iw = 144; Iw < 256; ++Iw) Pw[Iw] = 9;
			for (Iw = 256; Iw < 280; ++Iw) Pw[Iw] = 7;
			for (Iw = 280; Iw < 288; ++Iw) Pw[Iw] = 8;
			var kw = new pw(32);
			for (Iw = 0; Iw < 32; ++Iw) kw[Iw] = 5;
			var Bw = Sw(Pw, 9), zw = Sw(kw, 5), Tw = function(t$1) {
				for (var e$1 = t$1[0], r$1 = 1; r$1 < t$1.length; ++r$1) t$1[r$1] > e$1 && (e$1 = t$1[r$1]);
				return e$1;
			}, Ew = function(t$1, e$1, r$1) {
				var n$1 = e$1 / 8 | 0;
				return (t$1[n$1] | t$1[n$1 + 1] << 8) >> (7 & e$1) & r$1;
			}, Vw = function(t$1, e$1) {
				var r$1 = e$1 / 8 | 0;
				return (t$1[r$1] | t$1[r$1 + 1] << 8 | t$1[r$1 + 2] << 16) >> (7 & e$1);
			}, Fw = [
				"unexpected EOF",
				"invalid block type",
				"invalid length/literal",
				"invalid distance",
				"stream finished",
				"no stream handler",
				,
				"no callback",
				"invalid UTF-8 data",
				"extra field too long",
				"date not in range 1980-2099",
				"filename too long",
				"stream finishing",
				"invalid zip data"
			], Cw = function(t$1, e$1, r$1) {
				var n$1 = new Error(e$1 || Fw[t$1]);
				if (n$1.code = t$1, Error.captureStackTrace && Error.captureStackTrace(n$1, Cw), !r$1) throw n$1;
				return n$1;
			}, Dw = new pw(0), Rw = "undefined" != typeof TextDecoder && new TextDecoder();
			try {
				Rw.decode(Dw, { stream: !0 });
			} catch (t$1) {}
			const Lw = { gzip_data: "gzip" };
			class Ow extends Error {
				constructor(t$1) {
					super(t$1), this.name = "MRTError";
				}
			}
			const Uw = {
				0: "uint32",
				1: "uint32",
				2: "uint16",
				3: "uint8"
			}, Nw = {
				uint32: 1,
				uint16: 2,
				uint8: 4
			}, jw = {
				uint32: Uint32Array,
				uint16: Uint16Array,
				uint8: Uint8Array
			};
			let $w;
			class Gw {
				constructor(t$1 = 5) {
					this.x = NaN, this.y = NaN, this.z = NaN, this.layers = {}, this._cacheSize = t$1;
				}
				getLayer(t$1) {
					const e$1 = this.layers[t$1];
					if (!e$1) throw new Ow(`Layer '${t$1}' not found`);
					return e$1;
				}
				getHeaderLength(t$1) {
					const e$1 = new Uint8Array(t$1), r$1 = new DataView(t$1);
					if (13 !== e$1[0]) throw new Ow("File is not a valid MRT.");
					return r$1.getUint32(1, !0);
				}
				parseHeader(t$1) {
					const e$1 = new Uint8Array(t$1), r$1 = this.getHeaderLength(t$1);
					if (e$1.length < r$1) throw new Ow(`Expected header with length >= ${r$1} but got buffer of length ${e$1.length}`);
					const n$1 = new $w(e$1.subarray(0, r$1)).readFields(ew, {
						headerLength: 0,
						x: 0,
						y: 0,
						z: 0,
						layers: []
					}, void 0);
					if (!isNaN(this.x) && (this.x !== n$1.x || this.y !== n$1.y || this.z !== n$1.z)) throw new Ow(`Invalid attempt to parse header ${n$1.z}/${n$1.x}/${n$1.y} for tile ${this.z}/${this.x}/${this.y}`);
					this.x = n$1.x, this.y = n$1.y, this.z = n$1.z;
					for (const t$2 of n$1.layers) this.layers[t$2.name] = new qw(t$2, { cacheSize: this._cacheSize });
					return this;
				}
				createDecodingTask(t$1) {
					const e$1 = [], r$1 = this.getLayer(t$1.layerName);
					for (let n$1 of t$1.blockIndices) {
						const i$1 = r$1.dataIndex[n$1], s$1 = i$1.firstByte - t$1.firstByte, o$1 = i$1.lastByte - t$1.firstByte;
						if (r$1._blocksInProgress.has(n$1)) continue;
						const a$1 = {
							layerName: r$1.name,
							firstByte: s$1,
							lastByte: o$1,
							pixelFormat: r$1.pixelFormat,
							blockIndex: n$1,
							blockShape: [i$1.bands.length].concat(r$1.bandShape),
							buffer: r$1.buffer,
							codec: i$1.codec.codec,
							filters: i$1.filters.map(((t$2) => t$2.filter))
						};
						r$1._blocksInProgress.add(n$1), e$1.push(a$1);
					}
					return new Hw(e$1, (() => {
						e$1.forEach(((t$2) => r$1._blocksInProgress.delete(t$2.blockIndex)));
					}), ((t$2, n$1) => {
						if (e$1.forEach(((t$3) => r$1._blocksInProgress.delete(t$3.blockIndex))), t$2) throw t$2;
						n$1.forEach(((t$3) => {
							this.getLayer(t$3.layerName).processDecodedData(t$3);
						}));
					}));
				}
			}
			class qw {
				constructor({ version: t$1, name: e$1, units: r$1, tileSize: n$1, pixelFormat: i$1, buffer: s$1, dataIndex: o$1 }, a$1) {
					if (this.version = t$1, 1 !== this.version) throw new Ow(`Cannot parse raster layer encoded with MRT version ${t$1}`);
					this.name = e$1, this.units = r$1, this.tileSize = n$1, this.buffer = s$1, this.pixelFormat = Uw[i$1], this.dataIndex = o$1, this.bandShape = [
						n$1 + 2 * s$1,
						n$1 + 2 * s$1,
						Nw[this.pixelFormat]
					], this._decodedBlocks = new Nb(a$1 ? a$1.cacheSize : 5), this._blocksInProgress = /* @__PURE__ */ new Set();
				}
				get dimension() {
					return Nw[this.pixelFormat];
				}
				get cacheSize() {
					return this._decodedBlocks.capacity;
				}
				getBandList() {
					return this.dataIndex.map((({ bands: t$1 }) => t$1)).flat();
				}
				processDecodedData(t$1) {
					const e$1 = t$1.blockIndex.toString();
					this._decodedBlocks.get(e$1) || this._decodedBlocks.put(e$1, t$1.data);
				}
				getBlockForBand(t$1) {
					let e$1 = 0;
					switch (typeof t$1) {
						case "string":
							for (const [r$1, n$1] of this.dataIndex.entries()) {
								for (const [i$1, s$1] of n$1.bands.entries()) if (s$1 === t$1) return {
									bandIndex: e$1 + i$1,
									blockIndex: r$1,
									blockBandIndex: i$1
								};
								e$1 += n$1.bands.length;
							}
							break;
						case "number":
							for (const [r$1, n$1] of this.dataIndex.entries()) {
								if (t$1 >= e$1 && t$1 < e$1 + n$1.bands.length) return {
									bandIndex: t$1,
									blockIndex: r$1,
									blockBandIndex: t$1 - e$1
								};
								e$1 += n$1.bands.length;
							}
							break;
						default: throw new Ow(`Invalid band \`${JSON.stringify(t$1)}\`. Expected string or integer.`);
					}
					return {
						blockIndex: -1,
						blockBandIndex: -1
					};
				}
				getDataRange(t$1) {
					let e$1 = Infinity, r$1 = -Infinity;
					const n$1 = [], i$1 = /* @__PURE__ */ new Set();
					for (const s$1 of t$1) {
						const { blockIndex: t$2 } = this.getBlockForBand(s$1);
						if (t$2 < 0) throw new Ow(`Invalid band: ${JSON.stringify(s$1)}`);
						const o$1 = this.dataIndex[t$2];
						n$1.includes(t$2) || n$1.push(t$2), i$1.add(t$2), e$1 = Math.min(e$1, o$1.firstByte), r$1 = Math.max(r$1, o$1.lastByte);
					}
					if (i$1.size > this.cacheSize) throw new Ow(`Number of blocks to decode (${i$1.size}) exceeds cache size (${this.cacheSize}).`);
					return {
						layerName: this.name,
						firstByte: e$1,
						lastByte: r$1,
						blockIndices: n$1
					};
				}
				hasBand(t$1) {
					const { blockIndex: e$1 } = this.getBlockForBand(t$1);
					return e$1 >= 0;
				}
				hasDataForBand(t$1) {
					const { blockIndex: e$1 } = this.getBlockForBand(t$1);
					return e$1 >= 0 && !!this._decodedBlocks.get(e$1.toString());
				}
				getBandView(t$1) {
					const { blockIndex: e$1, blockBandIndex: r$1 } = this.getBlockForBand(t$1);
					if (e$1 < 0) throw new Ow(`Band not found: ${JSON.stringify(t$1)}`);
					const n$1 = this._decodedBlocks.get(e$1.toString());
					if (!n$1) throw new Ow(`Data for band ${JSON.stringify(t$1)} of layer "${this.name}" not decoded.`);
					const i$1 = this.dataIndex[e$1], s$1 = this.bandShape.reduce(((t$2, e$2) => t$2 * e$2), 1), o$1 = r$1 * s$1, a$1 = n$1.subarray(o$1, o$1 + s$1);
					return {
						data: a$1,
						bytes: new Uint8Array(a$1.buffer).subarray(a$1.byteOffset, a$1.byteOffset + a$1.byteLength),
						tileSize: this.tileSize,
						buffer: this.buffer,
						pixelFormat: this.pixelFormat,
						dimension: this.dimension,
						offset: i$1.offset,
						scale: i$1.scale
					};
				}
			}
			Gw.setPbf = function(t$1) {
				$w = t$1;
			};
			class Hw {
				constructor(t$1, e$1, r$1) {
					this.tasks = t$1, this._onCancel = e$1, this._onComplete = r$1, this._finalized = !1;
				}
				cancel() {
					this._finalized || (this._onCancel(), this._finalized = !0);
				}
				complete(t$1, e$1) {
					this._finalized || (this._onComplete(t$1, e$1), this._finalized = !0);
				}
			}
			Gw.performDecoding = function(t$1, e$1) {
				const r$1 = new Uint8Array(t$1);
				return Promise.all(e$1.tasks.map(((t$2) => {
					const { layerName: e$2, firstByte: n$1, lastByte: i$1, pixelFormat: s$1, blockShape: o$1, blockIndex: a$1, filters: l$1, codec: u$1 } = t$2, c$1 = r$1.subarray(n$1, i$1 + 1), h$1 = new Uint32Array(o$1[0] * o$1[1] * o$1[2]);
					let p$1;
					if ("gzip_data" !== u$1) throw new Ow(`Unhandled codec: ${u$1}`);
					return p$1 = function(t$3, e$3) {
						if (!globalThis.DecompressionStream && "gzip_data" === e$3) return Promise.resolve(((s$2 = function(t$4) {
							31 == t$4[0] && 139 == t$4[1] && 8 == t$4[2] || Cw(6, "invalid gzip data");
							var e$4 = t$4[3], r$3 = 10;
							4 & e$4 && (r$3 += 2 + (t$4[10] | t$4[11] << 8));
							for (var n$3 = (e$4 >> 3 & 1) + (e$4 >> 4 & 1); n$3 > 0; n$3 -= !t$4[r$3++]);
							return r$3 + (2 & e$4);
						}(i$2 = t$3)) + 8 > i$2.length && Cw(6, "invalid gzip data"), function(t$4, e$4, r$3, n$3) {
							var i$3 = t$4.length;
							if (!i$3 || e$4.f && !e$4.l) return r$3 || new pw(0);
							var s$3 = !r$3, o$3 = s$3 || 2 != e$4.i, a$3 = e$4.i;
							s$3 && (r$3 = new pw(3 * i$3));
							var l$2, u$2, c$2 = function(t$5) {
								var e$5 = r$3.length;
								if (t$5 > e$5) {
									var n$4 = new pw(Math.max(2 * e$5, t$5));
									n$4.set(r$3), r$3 = n$4;
								}
							}, h$2 = e$4.f || 0, p$2 = e$4.p || 0, d$1 = e$4.b || 0, f$1 = e$4.l, m$1 = e$4.d, y$1 = e$4.m, g$1 = e$4.n, x$1 = 8 * i$3;
							do {
								if (!f$1) {
									h$2 = Ew(t$4, p$2, 1);
									var v$1 = Ew(t$4, p$2 + 1, 3);
									if (p$2 += 3, !v$1) {
										var b$1 = t$4[(T$1 = 4 + ((p$2 + 7) / 8 | 0)) - 4] | t$4[T$1 - 3] << 8, w$1 = T$1 + b$1;
										if (w$1 > i$3) {
											a$3 && Cw(0);
											break;
										}
										o$3 && c$2(d$1 + b$1), r$3.set(t$4.subarray(T$1, w$1), d$1), e$4.b = d$1 += b$1, e$4.p = p$2 = 8 * w$1, e$4.f = h$2;
										continue;
									}
									if (1 == v$1) f$1 = Bw, m$1 = zw, y$1 = 9, g$1 = 5;
									else if (2 == v$1) {
										var _$1 = Ew(t$4, p$2, 31) + 257, A$1 = Ew(t$4, p$2 + 10, 15) + 4, I$1 = _$1 + Ew(t$4, p$2 + 5, 31) + 1;
										p$2 += 14;
										for (var M$1 = new pw(I$1), S$1 = new pw(19), P$1 = 0; P$1 < A$1; ++P$1) S$1[gw[P$1]] = Ew(t$4, p$2 + 3 * P$1, 7);
										p$2 += 3 * A$1;
										var k$1 = Tw(S$1), B$1 = (1 << k$1) - 1, z$1 = Sw(S$1, k$1);
										for (P$1 = 0; P$1 < I$1;) {
											var T$1, E$1 = z$1[Ew(t$4, p$2, B$1)];
											if (p$2 += 15 & E$1, (T$1 = E$1 >> 4) < 16) M$1[P$1++] = T$1;
											else {
												var V$1 = 0, F$1 = 0;
												for (16 == T$1 ? (F$1 = 3 + Ew(t$4, p$2, 3), p$2 += 2, V$1 = M$1[P$1 - 1]) : 17 == T$1 ? (F$1 = 3 + Ew(t$4, p$2, 7), p$2 += 3) : 18 == T$1 && (F$1 = 11 + Ew(t$4, p$2, 127), p$2 += 7); F$1--;) M$1[P$1++] = V$1;
											}
										}
										var C$1 = M$1.subarray(0, _$1), D$1 = M$1.subarray(_$1);
										y$1 = Tw(C$1), g$1 = Tw(D$1), f$1 = Sw(C$1, y$1), m$1 = Sw(D$1, g$1);
									} else Cw(1);
									if (p$2 > x$1) {
										a$3 && Cw(0);
										break;
									}
								}
								o$3 && c$2(d$1 + 131072);
								for (var R$1 = (1 << y$1) - 1, L$1 = (1 << g$1) - 1, O$1 = p$2;; O$1 = p$2) {
									var U$1 = (V$1 = f$1[Vw(t$4, p$2) & R$1]) >> 4;
									if ((p$2 += 15 & V$1) > x$1) {
										a$3 && Cw(0);
										break;
									}
									if (V$1 || Cw(2), U$1 < 256) r$3[d$1++] = U$1;
									else {
										if (256 == U$1) {
											O$1 = p$2, f$1 = null;
											break;
										}
										var N$1 = U$1 - 254;
										U$1 > 264 && (N$1 = Ew(t$4, p$2, (1 << (G$1 = mw[P$1 = U$1 - 257])) - 1) + bw[P$1], p$2 += G$1);
										var j$1 = m$1[Vw(t$4, p$2) & L$1], $$1 = j$1 >> 4;
										if (j$1 || Cw(3), p$2 += 15 & j$1, D$1 = _w[$$1], $$1 > 3) {
											var G$1 = yw[$$1];
											D$1 += Vw(t$4, p$2) & (1 << G$1) - 1, p$2 += G$1;
										}
										if (p$2 > x$1) {
											a$3 && Cw(0);
											break;
										}
										o$3 && c$2(d$1 + 131072);
										var q$1 = d$1 + N$1;
										if (d$1 < D$1) {
											var H$1 = 0 - D$1, X$1 = Math.min(D$1, q$1);
											for (H$1 + d$1 < 0 && Cw(3); d$1 < X$1; ++d$1) r$3[d$1] = (void 0)[H$1 + d$1];
										}
										for (; d$1 < q$1; ++d$1) r$3[d$1] = r$3[d$1 - D$1];
									}
								}
								e$4.l = f$1, e$4.p = O$1, e$4.b = d$1, e$4.f = h$2, f$1 && (h$2 = 1, e$4.m = y$1, e$4.d = m$1, e$4.n = g$1);
							} while (!h$2);
							return d$1 != r$3.length && s$3 ? (l$2 = r$3, (null == (u$2 = d$1) || u$2 > l$2.length) && (u$2 = l$2.length), new pw(l$2.subarray(0, u$2))) : r$3.subarray(0, d$1);
						}(i$2.subarray(s$2, -8), { i: 2 }, new pw(((r$2 = i$2)[(n$2 = r$2.length) - 4] | r$2[n$2 - 3] << 8 | r$2[n$2 - 2] << 16 | r$2[n$2 - 1] << 24) >>> 0))));
						var r$2, n$2, i$2, s$2;
						const o$2 = Lw[e$3];
						if (!o$2) throw new Error(`Unhandled codec: ${e$3}`);
						const a$2 = new globalThis.DecompressionStream(o$2);
						return new Response(new Blob([t$3]).stream().pipeThrough(a$2)).arrayBuffer().then(((t$4) => new Uint8Array(t$4)));
					}(c$1, u$1).then(((t$3) => (function(t$4, e$3) {
						t$4.readFields(aw, e$3);
					}(new $w(t$3), h$1), new jw[s$1](h$1.buffer)))), p$1.then(((t$3) => {
						for (let e$3 = l$1.length - 1; e$3 >= 0; e$3--) switch (l$1[e$3]) {
							case "delta_filter":
								uw(t$3, o$1);
								break;
							case "zigzag_filter":
								cw(t$3);
								break;
							case "bitshuffle_filter":
								hw(t$3, s$1);
								break;
							default: throw new Ow(`Unhandled filter "${l$1[e$3]}"`);
						}
						return {
							layerName: e$2,
							blockIndex: a$1,
							data: t$3
						};
					})).catch(((t$3) => {
						throw t$3;
					}));
				})));
			}, Qs(Hw, "MRTDecodingBatch", { omit: ["_onCancel", "_onComplete"] }), Qs(Gw, "MapboxRasterTile"), Qs(qw, "MapboxRasterLayer", { omit: ["_blocksInProgress"] });
			class Xw {
				constructor(t$1) {
					this._stringToNumber = {}, this._numberToString = [];
					for (let e$1 = 0; e$1 < t$1.length; e$1++) {
						const r$1 = t$1[e$1];
						this._stringToNumber[r$1] = e$1, this._numberToString[e$1] = r$1;
					}
				}
				encode(t$1) {
					return this._stringToNumber[t$1];
				}
				decode(t$1) {
					return this._numberToString[t$1];
				}
			}
			class Zw {
				constructor(t$1, e$1) {
					this.tileID = t$1, this.x = t$1.canonical.x, this.y = t$1.canonical.y, this.z = t$1.canonical.z, this.grid = new Ks(Un, 16, 0), this.featureIndexArray = new il(), this.promoteId = e$1, this.is3DTile = !1, this.serializedLayersCache = /* @__PURE__ */ new Map();
				}
				insert(t$1, e$1, r$1, n$1, i$1, s$1 = 0, o$1 = 0) {
					const a$1 = this.featureIndexArray.length;
					this.featureIndexArray.emplaceBack(r$1, n$1, i$1, s$1);
					const l$1 = this.grid;
					for (let t$2 = 0; t$2 < e$1.length; t$2++) {
						const r$2 = e$1[t$2], n$2 = [
							Infinity,
							Infinity,
							-Infinity,
							-Infinity
						];
						for (let t$3 = 0; t$3 < r$2.length; t$3++) {
							const e$2 = r$2[t$3];
							n$2[0] = Math.min(n$2[0], e$2.x), n$2[1] = Math.min(n$2[1], e$2.y), n$2[2] = Math.max(n$2[2], e$2.x), n$2[3] = Math.max(n$2[3], e$2.y);
						}
						0 !== o$1 && (n$2[0] -= o$1, n$2[1] -= o$1, n$2[2] += o$1, n$2[3] += o$1), n$2[0] < Un && n$2[1] < Un && n$2[2] >= 0 && n$2[3] >= 0 && l$1.insert(a$1, n$2[0], n$2[1], n$2[2], n$2[3]);
					}
				}
				loadVTLayers() {
					if (!this.vtLayers) {
						this.vtLayers = new Cu(new Sy(this.rawTileData)).layers, this.sourceLayerCoder = new Xw(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"]), this.vtFeatures = {};
						for (const t$1 in this.vtLayers) this.vtFeatures[t$1] = [];
					}
					return this.vtLayers;
				}
				query(t$1, e$1) {
					const { tilespaceGeometry: r$1, transform: n$1, tileTransform: i$1, pixelPosMatrix: s$1, availableImages: o$1, worldview: a$1 } = e$1;
					this.loadVTLayers(), this.serializedLayersCache.clear();
					const l$1 = e$1.queryRadius ? e$1.queryRadius : 0, u$1 = r$1.bufferedTilespaceBounds, c$1 = this.grid.query(u$1.min.x, u$1.min.y, u$1.max.x, u$1.max.y, ((t$2, e$2, n$2, i$2) => yc(r$1.bufferedTilespaceGeometry, t$2 - l$1, e$2 - l$1, n$2 + l$1, i$2 + l$1)));
					c$1.sort(Yw);
					let h$1 = null;
					n$1.elevation && c$1.length > 0 && (h$1 = zv.create(n$1.elevation, this.tileID));
					const p$1 = {};
					let d$1;
					for (let e$2 = 0; e$2 < c$1.length; e$2++) {
						const l$2 = c$1[e$2];
						if (l$2 === d$1) continue;
						d$1 = l$2;
						const u$2 = this.featureIndexArray.get(l$2);
						let f$1 = null;
						this.is3DTile ? this.loadMatchingModelFeature(p$1, u$2, t$1, r$1, n$1, a$1) : this.loadMatchingFeature(p$1, u$2, t$1, o$1, a$1, ((t$2, e$3, o$2, a$2 = 0) => (f$1 || (f$1 = ku(t$2, this.tileID.canonical, i$1)), e$3.queryIntersectsFeature(r$1, t$2, o$2, f$1, this.z, n$1, s$1, h$1, a$2))));
					}
					return p$1;
				}
				loadMatchingFeature(t$1, e$1, r$1, n$1, i$1, s$1) {
					const { featureIndex: o$1, bucketIndex: a$1, sourceLayerIndex: l$1, layoutVertexArrayOffset: u$1 } = e$1, c$1 = this.bucketLayerIDs[a$1], h$1 = r$1.layers, p$1 = Object.keys(h$1);
					if (p$1.length && !qt(p$1, c$1)) return;
					const d$1 = r$1.sourceCache, f$1 = this.sourceLayerCoder.decode(l$1), m$1 = this.vtLayers[f$1].feature(o$1), y$1 = this.getId(m$1, f$1);
					for (let e$2 = 0; e$2 < c$1.length; e$2++) {
						const r$2 = c$1[e$2];
						if (!h$1[r$2]) continue;
						const { styleLayer: a$2, targets: l$2 } = h$1[r$2];
						let p$2 = {};
						void 0 !== y$1 && (p$2 = d$1.getFeatureState(a$2.sourceLayer, y$1));
						const f$2 = !s$1 || s$1(m$1, a$2, p$2, u$1);
						if (!f$2) continue;
						const g$1 = new jv(m$1, this.z, this.x, this.y, y$1);
						g$1.tile = this.tileID.canonical, g$1.state = p$2;
						let x$1 = this.serializedLayersCache.get(r$2);
						x$1 || (x$1 = a$2.serialize(), x$1.id = r$2, this.serializedLayersCache.set(r$2, x$1)), g$1.source = x$1.source, g$1.sourceLayer = x$1["source-layer"], g$1.layer = Object.assign({}, x$1), g$1.layer.paint = Ww(x$1.paint, a$2.paint, m$1, p$2, n$1), g$1.layer.layout = Ww(x$1.layout, a$2.layout, m$1, p$2, n$1);
						let v$1 = !1;
						for (const t$2 of l$2) {
							this.updateFeatureProperties(g$1, t$2);
							const { filter: e$3 } = t$2;
							if (e$3) {
								if (m$1.properties = g$1.properties, e$3.needGeometry) {
									const t$3 = Bu(m$1, !0);
									if (!e$3.filter(new Io(this.tileID.overscaledZ, { worldview: i$1 }), t$3, this.tileID.canonical)) continue;
								} else if (!e$3.filter(new Io(this.tileID.overscaledZ, { worldview: i$1 }), m$1)) continue;
							}
							v$1 = !0, t$2.targetId && this.addFeatureVariant(g$1, t$2);
						}
						v$1 && this.appendToResult(t$1, r$2, o$1, g$1, f$2);
					}
				}
				loadMatchingModelFeature(t$1, e$1, r$1, n$1, i$1, s$1) {
					const { featureIndex: o$1, bucketIndex: a$1 } = e$1, l$1 = this.bucketLayerIDs[a$1], u$1 = r$1.layers, c$1 = Object.keys(u$1);
					if (!c$1.length || qt(c$1, l$1)) for (let e$2 = 0; e$2 < l$1.length; e$2++) {
						const a$2 = l$1[e$2], { styleLayer: c$2, targets: h$1 } = u$1[a$2];
						if ("model" !== c$2.type) continue;
						const p$1 = n$1.tile, d$1 = p$1.getBucket(c$2);
						if (!(d$1 && d$1 instanceof Rv)) continue;
						const f$1 = qv(d$1, o$1, n$1, i$1);
						if (!f$1) continue;
						const { z: m$1, x: y$1, y: g$1 } = p$1.tileID.canonical, { feature: x$1, intersectionZ: v$1, position: b$1 } = f$1;
						let w$1 = {};
						void 0 !== x$1.id && (w$1 = r$1.sourceCache.getFeatureState(c$2.sourceLayer, x$1.id));
						const _$1 = new jv({}, m$1, y$1, g$1, x$1.id);
						_$1.tile = this.tileID.canonical, _$1.state = w$1, _$1.properties = x$1.properties, _$1.geometry = {
							type: "Point",
							coordinates: [b$1.lng, b$1.lat]
						};
						let A$1 = this.serializedLayersCache.get(a$2);
						A$1 || (A$1 = c$2.serialize(), A$1.id = a$2, this.serializedLayersCache.set(a$2, A$1)), _$1.source = A$1.source, _$1.sourceLayer = A$1["source-layer"], _$1.layer = Object.assign({}, A$1);
						let I$1 = !1;
						for (const t$2 of h$1) {
							this.updateFeatureProperties(_$1, t$2);
							const { filter: e$3 } = t$2;
							if (e$3) {
								if (x$1.properties = _$1.properties, e$3.needGeometry) {
									if (!e$3.filter(new Io(this.tileID.overscaledZ, { worldview: s$1 }), x$1, this.tileID.canonical)) continue;
								} else if (!e$3.filter(new Io(this.tileID.overscaledZ, { worldview: s$1 }), x$1)) continue;
							}
							I$1 = !0, t$2.targetId && this.addFeatureVariant(_$1, t$2);
						}
						I$1 && this.appendToResult(t$1, a$2, o$1, _$1, v$1);
					}
				}
				updateFeatureProperties(t$1, e$1, r$1) {
					if (e$1.properties) {
						const n$1 = {};
						for (const i$1 in e$1.properties) {
							const s$1 = e$1.properties[i$1].evaluate({ zoom: this.z }, t$1._vectorTileFeature, t$1.state, t$1.tile, r$1);
							null != s$1 && (n$1[i$1] = s$1);
						}
						t$1.properties = n$1;
					}
				}
				addFeatureVariant(t$1, e$1, r$1) {
					const n$1 = {
						target: e$1.target,
						namespace: e$1.namespace,
						uniqueFeatureID: e$1.uniqueFeatureID
					};
					e$1.properties && (n$1.properties = t$1.properties), t$1.variants = t$1.variants || {}, t$1.variants[e$1.targetId] = t$1.variants[e$1.targetId] || [], t$1.variants[e$1.targetId].push(n$1);
				}
				appendToResult(t$1, e$1, r$1, n$1, i$1) {
					let s$1 = t$1[e$1];
					void 0 === s$1 && (s$1 = t$1[e$1] = []), s$1.push({
						featureIndex: r$1,
						feature: n$1,
						intersectionZ: i$1
					});
				}
				lookupSymbolFeatures(t$1, e$1, r$1, n$1, i$1, s$1) {
					const o$1 = {};
					this.loadVTLayers();
					for (const a$1 of t$1) this.loadMatchingFeature(o$1, {
						bucketIndex: e$1,
						sourceLayerIndex: r$1,
						featureIndex: a$1,
						layoutVertexArrayOffset: 0
					}, n$1, i$1, s$1);
					return o$1;
				}
				loadFeature(t$1) {
					const { featureIndex: e$1, sourceLayerIndex: r$1 } = t$1;
					this.loadVTLayers();
					const n$1 = this.sourceLayerCoder.decode(r$1), i$1 = this.vtFeatures[n$1];
					if (i$1[e$1]) return i$1[e$1];
					const s$1 = this.vtLayers[n$1].feature(e$1);
					return i$1[e$1] = s$1, s$1;
				}
				hasLayer(t$1) {
					for (const e$1 of this.bucketLayerIDs) for (const r$1 of e$1) if (t$1 === r$1) return !0;
					return !1;
				}
				getId(t$1, e$1) {
					let r$1 = t$1.id;
					if (this.promoteId) {
						const n$1 = Array.isArray(this.promoteId) || "object" != typeof this.promoteId ? this.promoteId : this.promoteId[e$1];
						if (null != n$1) if (Array.isArray(n$1)) {
							if (!this.promoteIdExpression) {
								const t$2 = js(n$1);
								if ("success" !== t$2.result) {
									Xt(`Failed to create expression for promoteId: ${t$2.value.map(((t$3) => `${t$3.key}: ${t$3.message}`)).join(", ")}`);
									return;
								}
								this.promoteIdExpression = t$2.value;
							}
							r$1 = this.promoteIdExpression.evaluate({ zoom: 0 }, t$1);
						} else r$1 = t$1.properties[n$1];
						"boolean" == typeof r$1 && (r$1 = Number(r$1));
					}
					return r$1;
				}
			}
			function Ww(t$1, e$1, r$1, n$1, i$1) {
				return jt(t$1, ((t$2, s$1) => {
					const o$1 = e$1 instanceof Eo ? e$1.get(s$1) : null;
					return o$1 && o$1.evaluate ? o$1.evaluate(r$1, n$1, void 0, i$1) : o$1;
				}));
			}
			function Yw(t$1, e$1) {
				return e$1 - t$1;
			}
			Qs(Zw, "FeatureIndex", { omit: ["rawTileData", "sourceLayerCoder"] });
			const Kw = [
				Int8Array,
				Uint8Array,
				Uint8ClampedArray,
				Int16Array,
				Uint16Array,
				Int32Array,
				Uint32Array,
				Float32Array,
				Float64Array
			];
			class Jw {
				static from(t$1) {
					if (!(t$1 instanceof ArrayBuffer)) throw new Error("Data must be an instance of ArrayBuffer.");
					const [e$1, r$1] = new Uint8Array(t$1, 0, 2);
					if (219 !== e$1) throw new Error("Data does not appear to be in a KDBush format.");
					const n$1 = r$1 >> 4;
					if (1 !== n$1) throw new Error(`Got v${n$1} data when expected v1.`);
					const i$1 = Kw[15 & r$1];
					if (!i$1) throw new Error("Unrecognized array type.");
					const [s$1] = new Uint16Array(t$1, 2, 1), [o$1] = new Uint32Array(t$1, 4, 1);
					return new Jw(o$1, s$1, i$1, t$1);
				}
				constructor(t$1, e$1 = 64, r$1 = Float64Array, n$1) {
					if (isNaN(t$1) || t$1 < 0) throw new Error(`Unpexpected numItems value: ${t$1}.`);
					this.numItems = +t$1, this.nodeSize = Math.min(Math.max(+e$1, 2), 65535), this.ArrayType = r$1, this.IndexArrayType = t$1 < 65536 ? Uint16Array : Uint32Array;
					const i$1 = Kw.indexOf(this.ArrayType), s$1 = 2 * t$1 * this.ArrayType.BYTES_PER_ELEMENT, o$1 = t$1 * this.IndexArrayType.BYTES_PER_ELEMENT, a$1 = (8 - o$1 % 8) % 8;
					if (i$1 < 0) throw new Error(`Unexpected typed array class: ${r$1}.`);
					n$1 && n$1 instanceof ArrayBuffer ? (this.data = n$1, this.ids = new this.IndexArrayType(this.data, 8, t$1), this.coords = new this.ArrayType(this.data, 8 + o$1 + a$1, 2 * t$1), this._pos = 2 * t$1, this._finished = !0) : (this.data = new ArrayBuffer(8 + s$1 + o$1 + a$1), this.ids = new this.IndexArrayType(this.data, 8, t$1), this.coords = new this.ArrayType(this.data, 8 + o$1 + a$1, 2 * t$1), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, 16 + i$1]), new Uint16Array(this.data, 2, 1)[0] = e$1, new Uint32Array(this.data, 4, 1)[0] = t$1);
				}
				add(t$1, e$1) {
					const r$1 = this._pos >> 1;
					return this.ids[r$1] = r$1, this.coords[this._pos++] = t$1, this.coords[this._pos++] = e$1, r$1;
				}
				finish() {
					const t$1 = this._pos >> 1;
					if (t$1 !== this.numItems) throw new Error(`Added ${t$1} items when expected ${this.numItems}.`);
					return Qw(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
				}
				range(t$1, e$1, r$1, n$1) {
					if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
					const { ids: i$1, coords: s$1, nodeSize: o$1 } = this, a$1 = [
						0,
						i$1.length - 1,
						0
					], l$1 = [];
					for (; a$1.length;) {
						const u$1 = a$1.pop() || 0, c$1 = a$1.pop() || 0, h$1 = a$1.pop() || 0;
						if (c$1 - h$1 <= o$1) {
							for (let o$2 = h$1; o$2 <= c$1; o$2++) {
								const a$2 = s$1[2 * o$2], u$2 = s$1[2 * o$2 + 1];
								a$2 >= t$1 && a$2 <= r$1 && u$2 >= e$1 && u$2 <= n$1 && l$1.push(i$1[o$2]);
							}
							continue;
						}
						const p$1 = h$1 + c$1 >> 1, d$1 = s$1[2 * p$1], f$1 = s$1[2 * p$1 + 1];
						d$1 >= t$1 && d$1 <= r$1 && f$1 >= e$1 && f$1 <= n$1 && l$1.push(i$1[p$1]), (0 === u$1 ? t$1 <= d$1 : e$1 <= f$1) && (a$1.push(h$1), a$1.push(p$1 - 1), a$1.push(1 - u$1)), (0 === u$1 ? r$1 >= d$1 : n$1 >= f$1) && (a$1.push(p$1 + 1), a$1.push(c$1), a$1.push(1 - u$1));
					}
					return l$1;
				}
				within(t$1, e$1, r$1) {
					if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
					const { ids: n$1, coords: i$1, nodeSize: s$1 } = this, o$1 = [
						0,
						n$1.length - 1,
						0
					], a$1 = [], l$1 = r$1 * r$1;
					for (; o$1.length;) {
						const u$1 = o$1.pop() || 0, c$1 = o$1.pop() || 0, h$1 = o$1.pop() || 0;
						if (c$1 - h$1 <= s$1) {
							for (let r$2 = h$1; r$2 <= c$1; r$2++) n_(i$1[2 * r$2], i$1[2 * r$2 + 1], t$1, e$1) <= l$1 && a$1.push(n$1[r$2]);
							continue;
						}
						const p$1 = h$1 + c$1 >> 1, d$1 = i$1[2 * p$1], f$1 = i$1[2 * p$1 + 1];
						n_(d$1, f$1, t$1, e$1) <= l$1 && a$1.push(n$1[p$1]), (0 === u$1 ? t$1 - r$1 <= d$1 : e$1 - r$1 <= f$1) && (o$1.push(h$1), o$1.push(p$1 - 1), o$1.push(1 - u$1)), (0 === u$1 ? t$1 + r$1 >= d$1 : e$1 + r$1 >= f$1) && (o$1.push(p$1 + 1), o$1.push(c$1), o$1.push(1 - u$1));
					}
					return a$1;
				}
			}
			function Qw(t$1, e$1, r$1, n$1, i$1, s$1) {
				if (i$1 - n$1 <= r$1) return;
				const o$1 = n$1 + i$1 >> 1;
				t_(t$1, e$1, o$1, n$1, i$1, s$1), Qw(t$1, e$1, r$1, n$1, o$1 - 1, 1 - s$1), Qw(t$1, e$1, r$1, o$1 + 1, i$1, 1 - s$1);
			}
			function t_(t$1, e$1, r$1, n$1, i$1, s$1) {
				for (; i$1 > n$1;) {
					if (i$1 - n$1 > 600) {
						const o$2 = i$1 - n$1 + 1, a$2 = r$1 - n$1 + 1, l$2 = Math.log(o$2), u$1 = .5 * Math.exp(2 * l$2 / 3), c$1 = .5 * Math.sqrt(l$2 * u$1 * (o$2 - u$1) / o$2) * (a$2 - o$2 / 2 < 0 ? -1 : 1);
						t_(t$1, e$1, r$1, Math.max(n$1, Math.floor(r$1 - a$2 * u$1 / o$2 + c$1)), Math.min(i$1, Math.floor(r$1 + (o$2 - a$2) * u$1 / o$2 + c$1)), s$1);
					}
					const o$1 = e$1[2 * r$1 + s$1];
					let a$1 = n$1, l$1 = i$1;
					for (e_(t$1, e$1, n$1, r$1), e$1[2 * i$1 + s$1] > o$1 && e_(t$1, e$1, n$1, i$1); a$1 < l$1;) {
						for (e_(t$1, e$1, a$1, l$1), a$1++, l$1--; e$1[2 * a$1 + s$1] < o$1;) a$1++;
						for (; e$1[2 * l$1 + s$1] > o$1;) l$1--;
					}
					e$1[2 * n$1 + s$1] === o$1 ? e_(t$1, e$1, n$1, l$1) : (l$1++, e_(t$1, e$1, l$1, i$1)), l$1 <= r$1 && (n$1 = l$1 + 1), r$1 <= l$1 && (i$1 = l$1 - 1);
				}
			}
			function e_(t$1, e$1, r$1, n$1) {
				r_(t$1, r$1, n$1), r_(e$1, 2 * r$1, 2 * n$1), r_(e$1, 2 * r$1 + 1, 2 * n$1 + 1);
			}
			function r_(t$1, e$1, r$1) {
				const n$1 = t$1[e$1];
				t$1[e$1] = t$1[r$1], t$1[r$1] = n$1;
			}
			function n_(t$1, e$1, r$1, n$1) {
				const i$1 = t$1 - r$1, s$1 = e$1 - n$1;
				return i$1 * i$1 + s$1 * s$1;
			}
			t.$ = Qr, t.A = Rr, t.B = ta, t.C = 2, t.D = Zd, t.E = nr, t.F = _g, t.G = bg, t.H = Yr, t.I = ir, t.J = Lo, t.K = Wr, t.L = Jr, t.M = Ts, t.N = ks, t.O = zs, t.P = It, t.Q = Ns, t.R = Ce, t.S = Oo, t.T = Tf, t.U = js, t.V = Av, t.W = qs, t.X = vi, t.Y = gi, t.Z = xi, t._ = sn, t.a = function(t$1) {
				return oe.API_CDN_URL_REGEX.test(t$1);
			}, t.a$ = du, t.a0 = Kr, t.a1 = ar, t.a2 = Uo, t.a3 = class extends Av {}, t.a4 = Es, t.a5 = Bs, t.a6 = Ro, t.a7 = function(t$1) {
				const e$1 = t$1.value;
				return e$1 ? Kr(e$1) ? Iv(e$1, !0) ? [] : [new Av(t$1.key, e$1, `invalid url "${e$1}"`)] : [new Av(t$1.key, e$1, `string expected, "${Wr(e$1)}" found`)] : [];
			}, t.a8 = Po, t.a9 = Do, t.aA = Ft, t.aB = h, t.aC = Q, t.aD = Hl, t.aE = mc, t.aF = uu, t.aG = _u, t.aH = function(t$1, e$1) {
				const r$1 = {};
				for (let n$1 = 0; n$1 < e$1.length; n$1++) {
					const i$1 = e$1[n$1];
					i$1 in t$1 && (r$1[i$1] = t$1[i$1]);
				}
				return r$1;
			}, t.aI = su, t.aJ = cu, t.aK = class {
				constructor(t$1) {
					this.entries = {}, this.scheduler = t$1;
				}
				request(t$1, e$1, r$1, n$1) {
					const i$1 = this.entries[t$1] = this.entries[t$1] || { callbacks: [] };
					if (i$1.result) {
						const [t$2, r$2] = i$1.result;
						return this.scheduler ? this.scheduler.add((() => {
							n$1(t$2, r$2);
						}), e$1) : n$1(t$2, r$2), () => {};
					}
					return i$1.callbacks.push(n$1), i$1.cancel || (i$1.cancel = r$1(((r$2, n$2) => {
						i$1.result = [r$2, n$2];
						for (const t$2 of i$1.callbacks) this.scheduler ? this.scheduler.add((() => {
							t$2(r$2, n$2);
						}), e$1) : t$2(r$2, n$2);
						setTimeout((() => delete this.entries[t$1]), 3e3);
					}))), () => {
						i$1.result || (i$1.callbacks = i$1.callbacks.filter(((t$2) => t$2 !== n$1)), i$1.callbacks.length || (i$1.cancel(), delete this.entries[t$1]));
					};
				}
			}, t.aL = function(t$1, e$1, r$1) {
				const n$1 = JSON.stringify(t$1.request);
				return t$1.data && (this.deduped.entries[n$1] = { result: [null, t$1.data] }), this.deduped.request(n$1, {
					type: "parseTile",
					isSymbolTile: t$1.isSymbolTile,
					zoom: t$1.tileZoom
				}, ((e$2) => {
					const n$2 = Oe(t$1.request, ((t$2, n$3, i$1) => {
						t$2 ? e$2(t$2) : n$3 && e$2(null, {
							rawData: n$3,
							vectorTile: r$1 ? void 0 : new Cu(new Sy(n$3)),
							responseHeaders: new Map(i$1.entries())
						});
					}));
					return () => {
						n$2.cancel(), e$2();
					};
				}), e$1);
			}, t.aM = function(t$1) {
				return t$1 ? {
					cacheControl: t$1.get("Cache-Control"),
					expires: t$1.get("Expires")
				} : {
					cacheControl: void 0,
					expires: void 0
				};
			}, t.aN = De, t.aO = function(t$1) {
				Pe++, Pe > we && (t$1.getActor().send("enforceCacheSizeLimit", be), Pe = 0);
			}, t.aP = function(t$1) {
				return t$1 <= 1 ? 1 : Math.pow(2, Math.floor(Math.log2(t$1)));
			}, t.aQ = Bc, t.aR = dv, t.aS = vv, t.aT = iu, t.aU = hv, t.aV = function(t$1, e$1) {
				const r$1 = document.createElement("video");
				r$1.muted = !0, r$1.onloadstart = function() {
					e$1(null, r$1);
				};
				for (let e$2 = 0; e$2 < t$1.length; e$2++) {
					const n$1 = document.createElement("source");
					Ue(t$1[e$2]) || (r$1.crossOrigin = "Anonymous"), n$1.src = t$1[e$2], r$1.appendChild(n$1);
				}
				return { cancel: () => {} };
			}, t.aW = Ef, t.aX = $v, t.aY = Nt, t.aZ = yx, t.a_ = pu, t.aa = Vo, t.ab = class {
				constructor(t$1) {
					this.specification = t$1;
				}
				possiblyEvaluate(t$1, e$1) {
					return Yt(t$1.expression.evaluate(e$1));
				}
				interpolate(t$1, e$1, r$1) {
					return {
						x: pr(t$1.x, e$1.x, r$1),
						y: pr(t$1.y, e$1.y, r$1),
						z: pr(t$1.z, e$1.z, r$1),
						azimuthal: pr(t$1.azimuthal, e$1.azimuthal, r$1),
						polar: pr(t$1.polar, e$1.polar, r$1)
					};
				}
			}, t.ac = Io, t.ad = Gs, t.ae = bu, t.af = j, t.ag = I, t.ah = Ct, t.ai = Eo, t.aj = eh, t.ak = pr, t.al = Un, t.am = dr, t.an = kt, t.ao = lr, t.ap = class {
				constructor(t$1) {
					this.specification = t$1;
				}
				possiblyEvaluate(t$1, e$1) {
					return function([t$2, e$2]) {
						const r$1 = Yt([
							1,
							t$2,
							e$2
						]);
						return {
							x: r$1.x,
							y: r$1.y,
							z: r$1.z
						};
					}(t$1.expression.evaluate(e$1));
				}
				interpolate(t$1, e$1, r$1) {
					return {
						x: pr(t$1.x, e$1.x, r$1),
						y: pr(t$1.y, e$1.y, r$1),
						z: pr(t$1.z, e$1.z, r$1)
					};
				}
			}, t.aq = function(t$1, e$1, r$1 = 0, n$1 = !0) {
				const i$1 = new It(r$1, r$1), s$1 = t$1.sub(i$1), o$1 = e$1.add(i$1), a$1 = [
					s$1,
					new It(o$1.x, s$1.y),
					o$1,
					new It(s$1.x, o$1.y)
				];
				return n$1 && a$1.push(s$1.clone()), a$1;
			}, t.ar = function(t$1, e$1) {
				const r$1 = [];
				for (let n$1 = 0; n$1 < t$1.length; n$1++) {
					const i$1 = Dt(n$1 - 1, -1, t$1.length - 1), s$1 = Dt(n$1 + 1, -1, t$1.length - 1), o$1 = t$1[n$1], a$1 = t$1[s$1], l$1 = t$1[i$1].sub(o$1).unit(), u$1 = a$1.sub(o$1).unit(), c$1 = u$1.angleWithSep(l$1.x, l$1.y), h$1 = l$1.add(u$1).unit().mult(-1 * e$1 / Math.sin(c$1 / 2));
					r$1.push(o$1.add(h$1));
				}
				return r$1;
			}, t.as = gx, t.at = yc, t.au = function(t$1, e$1, r$1 = 0) {
				return M(((e$1.x - r$1) * t$1.scale - t$1.x) * Un, (e$1.y * t$1.scale - t$1.y) * Un, fu(e$1.z, e$1.y));
			}, t.av = X, t.aw = L, t.ax = qu, t.ay = Km, t.az = function(t$1) {
				let e$1 = Infinity, r$1 = Infinity, n$1 = -Infinity, i$1 = -Infinity;
				for (const s$1 of t$1) e$1 = Math.min(e$1, s$1.x), r$1 = Math.min(r$1, s$1.y), n$1 = Math.max(n$1, s$1.x), i$1 = Math.max(i$1, s$1.y);
				return {
					min: new It(e$1, r$1),
					max: new It(n$1, i$1)
				};
			}, t.b = function(t$1) {
				return oe.API_FONTS_REGEX.test(t$1);
			}, t.b$ = Xp, t.b0 = Fa, t.b1 = ma, t.b2 = Ot, t.b3 = Ya, t.b4 = Wx, t.b5 = function() {
				Ao.isLoading() || Ao.isLoaded() || "deferred" !== wo() || _o();
			}, t.b6 = No, t.b7 = Bu, t.b8 = jv, t.b9 = Jt, t.bA = u, t.bB = y, t.bC = a, t.bD = function(t$1, e$1) {
				const { x: r$1, y: n$1 } = t$1.point, i$1 = th(r$1, n$1, t$1.worldSize / t$1._pixelsPerMercatorPixel, 0, 0);
				return h(i$1, i$1, Kc(Nc(e$1)));
			}, t.bE = n, t.bF = q, t.bG = F, t.bH = V, t.bI = U, t.bJ = O, t.bK = hg, t.bL = $y, t.bM = cg, t.bN = function(t$1, e$1, r$1, n$1, i$1) {
				const s$1 = 5 * e$1 + 2;
				t$1.float32[s$1 + 0] = r$1, t$1.float32[s$1 + 1] = n$1, t$1.float32[s$1 + 2] = i$1;
			}, t.bO = qx, t.bP = ct, t.bQ = ft, t.bR = pt, t.bS = bt, t.bT = Dt, t.bU = function(t$1, e$1, n$1, i$1) {
				var s$1 = new r(4);
				return s$1[0] = t$1, s$1[1] = e$1, s$1[2] = n$1, s$1[3] = i$1, s$1;
			}, t.bV = class {
				isDataAvailableAtPoint(t$1) {
					const e$1 = this._source();
					if (this.isUsingMockSource() || !e$1 || t$1.y < 0 || t$1.y > 1) return !1;
					const r$1 = e$1.getSource().maxzoom, n$1 = 1 << r$1, i$1 = Math.floor(t$1.x), s$1 = Math.floor((t$1.x - i$1) * n$1), o$1 = Math.floor(t$1.y * n$1), a$1 = this.findDEMTileFor(new Bc(r$1, i$1, r$1, s$1, o$1));
					return !(!a$1 || !a$1.dem);
				}
				getAtPointOrZero(t$1, e$1 = 0) {
					return this.getAtPoint(t$1, e$1) || 0;
				}
				getAtPoint(t$1, e$1, r$1 = !0) {
					if (this.isUsingMockSource()) return null;
					e$1 ??= null;
					const n$1 = this._source();
					if (!n$1) return e$1;
					if (t$1.y < 0 || t$1.y > 1) return e$1;
					const i$1 = n$1.getSource().maxzoom, s$1 = 1 << i$1, o$1 = Math.floor(t$1.x), a$1 = t$1.x - o$1, l$1 = new Bc(i$1, o$1, i$1, Math.floor(a$1 * s$1), Math.floor(t$1.y * s$1)), u$1 = this.findDEMTileFor(l$1);
					if (!u$1 || !u$1.dem) return e$1;
					const c$1 = u$1.dem, h$1 = 1 << u$1.tileID.canonical.z, p$1 = (a$1 * h$1 - u$1.tileID.canonical.x) * c$1.dim, d$1 = (t$1.y * h$1 - u$1.tileID.canonical.y) * c$1.dim, f$1 = Math.floor(p$1), m$1 = Math.floor(d$1);
					return (r$1 ? this.exaggeration() : 1) * pr(pr(c$1.get(f$1, m$1), c$1.get(f$1, m$1 + 1), d$1 - m$1), pr(c$1.get(f$1 + 1, m$1), c$1.get(f$1 + 1, m$1 + 1), d$1 - m$1), p$1 - f$1);
				}
				static getAtTileOffset(t$1, e$1, r$1, n$1) {
					const i$1 = 1 << t$1.canonical.z;
					return n$1 ? n$1.pointElevation(e$1) : r$1 ? r$1.getAtPointOrZero(new bu(t$1.wrap + (t$1.canonical.x + e$1.x / Un) / i$1, (t$1.canonical.y + e$1.y / Un) / i$1)) : 0;
				}
				static getAtTileOffsetFunc(t$1, e$1, r$1, n$1) {
					return (i$1, s$1, o$1) => {
						const a$1 = this.getAtTileOffset(t$1, i$1, s$1, o$1), l$1 = n$1.upVector(t$1.canonical, i$1.x, i$1.y);
						return E(l$1, l$1, a$1 * n$1.upVectorScale(t$1.canonical, e$1, r$1).metersToTile), l$1;
					};
				}
				getForTilePoints(t$1, e$1, r$1, n$1) {
					if (this.isUsingMockSource()) return !1;
					const i$1 = zv.create(this, t$1, n$1);
					return !!i$1 && (e$1.forEach(((t$2) => {
						t$2[2] = this.exaggeration() * i$1.getElevationAt(t$2[0], t$2[1], r$1);
					})), !0);
				}
				getMinMaxForTile(t$1) {
					if (this.isUsingMockSource()) return null;
					const e$1 = this.findDEMTileFor(t$1);
					if (!e$1 || !e$1.dem) return null;
					const r$1 = e$1.dem.tree, n$1 = e$1.tileID, i$1 = 1 << t$1.canonical.z - n$1.canonical.z;
					let s$1 = t$1.canonical.x / i$1 - n$1.canonical.x, o$1 = t$1.canonical.y / i$1 - n$1.canonical.y, a$1 = 0;
					for (let e$2 = 0; e$2 < t$1.canonical.z - n$1.canonical.z && !r$1.leaves[a$1]; e$2++) {
						s$1 *= 2, o$1 *= 2;
						const t$2 = 2 * Math.floor(o$1) + Math.floor(s$1);
						a$1 = r$1.childOffsets[a$1] + t$2, s$1 %= 1, o$1 %= 1;
					}
					return {
						min: this.exaggeration() * r$1.minimums[a$1],
						max: this.exaggeration() * r$1.maximums[a$1]
					};
				}
				getMinElevationBelowMSL() {
					throw new Error("Pure virtual method called.");
				}
				raycast(t$1, e$1, r$1) {
					throw new Error("Pure virtual method called.");
				}
				pointCoordinate(t$1) {
					throw new Error("Pure virtual method called.");
				}
				_source() {
					throw new Error("Pure virtual method called.");
				}
				isUsingMockSource() {
					throw new Error("Pure virtual method called.");
				}
				exaggeration() {
					throw new Error("Pure virtual method called.");
				}
				findDEMTileFor(t$1) {
					throw new Error("Pure virtual method called.");
				}
				get visibleDemTiles() {
					throw new Error("Getter must be implemented in subclass.");
				}
				getMinMaxForVisibleTiles() {
					const t$1 = this.visibleDemTiles;
					if (0 === t$1.length) return null;
					let e$1 = !1, r$1 = Number.MAX_VALUE, n$1 = Number.MIN_VALUE;
					for (const i$1 of t$1) {
						const t$2 = this.getMinMaxForTile(i$1.tileID);
						t$2 && (r$1 = Math.min(r$1, t$2.min), n$1 = Math.max(n$1, t$2.max), e$1 = !0);
					}
					return e$1 ? {
						min: r$1,
						max: n$1
					} : null;
				}
			}, t.bW = Fd, t.bX = ic, t.bY = xy, t.bZ = Lp, t.b_ = _v, t.ba = Xm, t.bb = bp, t.bc = ku, t.bd = da, t.be = Ga, t.bf = Cc, t.bg = hl, t.bh = zh, t.bi = av, t.bj = function(t$1, e$1) {
				const r$1 = eh(e$1.zoom);
				if (0 === r$1) return Nc(t$1);
				const n$1 = qc(t$1), i$1 = Hc(n$1), s$1 = uu(n$1.getWest()) * e$1.worldSize, o$1 = uu(n$1.getEast()) * e$1.worldSize, a$1 = cu(n$1.getNorth()) * e$1.worldSize, l$1 = cu(n$1.getSouth()) * e$1.worldSize, u$1 = [
					s$1,
					a$1,
					0
				], h$1 = [
					o$1,
					a$1,
					0
				], p$1 = [
					s$1,
					l$1,
					0
				], d$1 = [
					o$1,
					l$1,
					0
				], f$1 = c([], e$1.globeMatrix);
				return j(u$1, u$1, f$1), j(h$1, h$1, f$1), j(p$1, p$1, f$1), j(d$1, d$1, f$1), i$1[0] = jc(i$1[0], p$1, r$1), i$1[1] = jc(i$1[1], d$1, r$1), i$1[2] = jc(i$1[2], h$1, r$1), i$1[3] = jc(i$1[3], u$1, r$1), Ju.fromPoints(i$1);
			}, t.bk = Yc, t.bl = c, t.bm = Xc, t.bn = jc, t.bo = fa, t.bp = Fc, t.bq = g, t.br = p, t.bs = Gw, t.bt = Sy, t.bu = Oe, t.bv = function(t$1, e$1) {
				const r$1 = [];
				for (const n$1 in t$1) n$1 in e$1 || r$1.push(n$1);
				return r$1;
			}, t.bw = Rt, t.bx = [
				"type",
				"source",
				"source-layer",
				"minzoom",
				"maxzoom",
				"filter",
				"layout"
			], t.by = Mt, t.bz = l, t.c = le, t.c$ = function(t$1, e$1, r$1) {
				let n$1 = 0;
				for (let r$2 = 0; r$2 < 2; ++r$2) {
					const i$1 = 0;
					t$1[r$2] > i$1 && (n$1 += (t$1[r$2] - i$1) * (t$1[r$2] - i$1)), e$1[r$2] < i$1 && (n$1 += (i$1 - e$1[r$2]) * (i$1 - e$1[r$2]));
				}
				return n$1;
			}, t.c0 = Zp, t.c1 = tg, t.c2 = Zg, t.c3 = sx, t.c4 = Jw, t.c5 = E, t.c6 = W, t.c7 = et, t.c8 = function(t$1, e$1, r$1) {
				r$1 *= .5;
				var n$1 = e$1[0], i$1 = e$1[1], s$1 = e$1[2], o$1 = e$1[3], a$1 = Math.sin(r$1), l$1 = Math.cos(r$1);
				return t$1[0] = n$1 * l$1 + i$1 * a$1, t$1[1] = i$1 * l$1 - n$1 * a$1, t$1[2] = s$1 * l$1 + o$1 * a$1, t$1[3] = o$1 * l$1 - s$1 * a$1, t$1;
			}, t.c9 = rt, t.cA = _, t.cB = Ku, t.cC = Nf, t.cD = Pc, t.cE = Gc, t.cF = function(t$1, e$1, r$1, n$1, i$1, s$1, o$1, a$1, l$1) {
				if ("globe" === l$1.name) return Gc(t$1, e$1, new Pc(r$1, n$1, i$1), !1);
				const u$1 = yx({
					z: r$1,
					x: n$1,
					y: i$1
				}, l$1);
				return new Ju([
					(s$1 + u$1.x / u$1.scale) * e$1,
					e$1 * (u$1.y / u$1.scale),
					o$1
				], [
					(s$1 + u$1.x2 / u$1.scale) * e$1,
					e$1 * (u$1.y2 / u$1.scale),
					a$1
				]);
			}, t.cG = function(t$1, e$1, r$1) {
				return t$1[0] = Math.min(e$1[0], r$1[0]), t$1[1] = Math.min(e$1[1], r$1[1]), t$1[2] = Math.min(e$1[2], r$1[2]), t$1[3] = Math.min(e$1[3], r$1[3]), t$1;
			}, t.cH = function(t$1, e$1, r$1) {
				return t$1[0] = Math.max(e$1[0], r$1[0]), t$1[1] = Math.max(e$1[1], r$1[1]), t$1[2] = Math.max(e$1[2], r$1[2]), t$1[3] = Math.max(e$1[3], r$1[3]), t$1;
			}, t.cI = function(t$1) {
				return zt[Math.round((t$1 + 45 + 360) % 360 / 90) % 4];
			}, t.cJ = mu, t.cK = K, t.cL = Zl, t.cM = function(t$1) {
				const e$1 = u(new Float64Array(16));
				h(e$1, t$1.pixelMatrix, t$1.globeMatrix);
				const r$1 = [
					0,
					Jl,
					0
				], n$1 = [
					0,
					Ql,
					0
				];
				return j(r$1, r$1, e$1), j(n$1, n$1, e$1), [r$1[0] > 0 && r$1[0] <= t$1.width && r$1[1] > 0 && r$1[1] <= t$1.height && !nh(t$1, new iu(t$1.center.lat, 90)), n$1[0] > 0 && n$1[0] <= t$1.width && n$1[1] > 0 && n$1[1] <= t$1.height && !nh(t$1, new iu(t$1.center.lat, -90))];
			}, t.cN = function(t$1, e$1) {
				const { scale: r$1 } = t$1.tileTransform, n$1 = r$1 * Un / (t$1.tileSize * Math.pow(2, e$1.zoom - t$1.tileID.overscaledZ + t$1.tileID.canonical.z));
				return function(t$2, e$2, r$2) {
					var n$2 = e$2[1], i$1 = e$2[2], s$1 = e$2[3], o$1 = r$2[0], a$1 = r$2[1];
					return t$2[0] = e$2[0] * o$1, t$2[1] = n$2 * o$1, t$2[2] = i$1 * a$1, t$2[3] = s$1 * a$1, t$2;
				}(new Float32Array(4), e$1.inverseAdjustmentMatrix, [n$1, n$1]);
			}, t.cO = jf, t.cP = w, t.cQ = Uf, t.cR = function(t$1) {
				const e$1 = Uf(t$1, !0);
				return n([], [
					e$1[0],
					e$1[1],
					e$1[4],
					e$1[5]
				]);
			}, t.cS = d, t.cT = Hu, t.cU = f, t.cV = function(t$1) {
				const { x: e$1, y: r$1 } = t$1.point, { lng: n$1, lat: i$1 } = t$1._center;
				return th(e$1, r$1, t$1.worldSize, n$1, i$1);
			}, t.cW = B, t.cX = Bt, t.cY = zc, t.cZ = gc, t.c_ = Xl, t.ca = te, t.cb = function(t$1, e$1) {
				return t$1[0] = -e$1[0], t$1[1] = -e$1[1], t$1[2] = -e$1[2], t$1[3] = e$1[3], t$1;
			}, t.cc = b, t.cd = function(t$1, e$1, r$1, n$1, i$1) {
				var s$1 = 1 / Math.tan(e$1 / 2);
				if (t$1[0] = s$1 / r$1, t$1[1] = 0, t$1[2] = 0, t$1[3] = 0, t$1[4] = 0, t$1[5] = s$1, t$1[6] = 0, t$1[7] = 0, t$1[8] = 0, t$1[9] = 0, t$1[11] = -1, t$1[12] = 0, t$1[13] = 0, t$1[15] = 0, null != i$1 && i$1 !== Infinity) {
					var o$1 = 1 / (n$1 - i$1);
					t$1[10] = (i$1 + n$1) * o$1, t$1[14] = 2 * i$1 * n$1 * o$1;
				} else t$1[10] = -1, t$1[14] = -2 * n$1;
				return t$1;
			}, t.ce = function(t$1, e$1, r$1, n$1, i$1, s$1, o$1) {
				var a$1 = 1 / (e$1 - r$1), l$1 = 1 / (n$1 - i$1), u$1 = 1 / (s$1 - o$1);
				return t$1[0] = -2 * a$1, t$1[1] = 0, t$1[2] = 0, t$1[3] = 0, t$1[4] = 0, t$1[5] = -2 * l$1, t$1[6] = 0, t$1[7] = 0, t$1[8] = 0, t$1[9] = 0, t$1[10] = 2 * u$1, t$1[11] = 0, t$1[12] = (e$1 + r$1) * a$1, t$1[13] = (i$1 + n$1) * l$1, t$1[14] = (o$1 + s$1) * u$1, t$1[15] = 1, t$1;
			}, t.cf = hu, t.cg = function(t$1, e$1, r$1) {
				t$1[4 * e$1 + 0] = r$1[0], t$1[4 * e$1 + 1] = r$1[1], t$1[4 * e$1 + 2] = r$1[2], t$1[4 * e$1 + 3] = r$1[3];
			}, t.ch = wl, t.ci = Il, t.cj = _l, t.ck = Al, t.cl = kl, t.cm = Lx, t.cn = function() {
				var t$1 = new r(4);
				return r != Float32Array && (t$1[1] = 0, t$1[2] = 0), t$1[0] = 1, t$1[3] = 1, t$1;
			}, t.co = function(t$1, e$1, r$1) {
				var n$1 = e$1[0], i$1 = e$1[1], s$1 = e$1[2], o$1 = e$1[3], a$1 = Math.sin(r$1), l$1 = Math.cos(r$1);
				return t$1[0] = n$1 * l$1 + s$1 * a$1, t$1[1] = i$1 * l$1 + o$1 * a$1, t$1[2] = n$1 * -a$1 + s$1 * l$1, t$1[3] = i$1 * -a$1 + o$1 * l$1, t$1;
			}, t.cp = function(t$1, e$1) {
				return t$1[0] === e$1[0] && t$1[1] === e$1[1] && t$1[2] === e$1[2] && t$1[3] === e$1[3];
			}, t.cq = H, t.cr = function(t$1) {
				var e$1 = t$1[0], r$1 = t$1[1], n$1 = t$1[2], i$1 = t$1[3];
				return Math.sqrt(e$1 * e$1 + r$1 * r$1 + n$1 * n$1 + i$1 * i$1);
			}, t.cs = at, t.ct = G, t.cu = kc, t.cv = 3, t.cw = 2, t.cx = 7, t.cy = 6, t.cz = N, t.d = function(t$1) {
				return oe.API_TILEJSON_REGEX.test(t$1);
			}, t.d$ = class {
				constructor(t$1, e$1, r$1, n$1) {
					this.context = t$1, this.format = n$1, this.size = r$1, this.texture = t$1.gl.createTexture();
					const [i$1, s$1, o$1] = this.size, { gl: a$1 } = t$1;
					a$1.bindTexture(a$1.TEXTURE_3D, this.texture), t$1.pixelStoreUnpackFlipY.set(!1), t$1.pixelStoreUnpack.set(1), t$1.pixelStoreUnpackPremultiplyAlpha.set(!1), "data" in e$1 && e$1.data && a$1.texImage3D(a$1.TEXTURE_3D, 0, this.format, i$1, s$1, o$1, 0, Bf(this.format), zf(this.format), e$1.data);
				}
				bind(t$1, e$1) {
					const { context: r$1 } = this, { gl: n$1 } = r$1;
					n$1.bindTexture(n$1.TEXTURE_3D, this.texture), t$1 !== this.minFilter && (n$1.texParameteri(n$1.TEXTURE_3D, n$1.TEXTURE_MAG_FILTER, t$1), n$1.texParameteri(n$1.TEXTURE_3D, n$1.TEXTURE_MIN_FILTER, t$1), this.minFilter = t$1), e$1 !== this.wrapS && (n$1.texParameteri(n$1.TEXTURE_3D, n$1.TEXTURE_WRAP_S, e$1), n$1.texParameteri(n$1.TEXTURE_3D, n$1.TEXTURE_WRAP_T, e$1), this.wrapS = e$1);
				}
				destroy() {
					const { gl: t$1 } = this.context;
					t$1.deleteTexture(this.texture), this.texture = null;
				}
			}, t.d0 = function(t$1) {
				return t$1 * t$1 * t$1 * t$1 * t$1;
			}, t.d1 = lu, t.d2 = 45, t.d3 = Ml, t.d4 = function(t$1, e$1, r$1) {
				const n$1 = Math.sqrt(t$1 * t$1 + e$1 * e$1 + r$1 * r$1), i$1 = n$1 > 0 ? Math.acos(r$1 / n$1) * Pt : 0;
				let s$1 = 0 !== t$1 || 0 !== e$1 ? Math.atan2(-e$1, -t$1) * Pt + 90 : 0;
				return s$1 < 0 && (s$1 += 360), [
					n$1,
					s$1,
					i$1
				];
			}, t.d5 = M, t.d6 = Yt, t.d7 = vu, t.d8 = P, t.d9 = Ju, t.dA = function(t$1) {
				return t$1({
					pluginStatus: yo,
					pluginURL: go
				}), bo.on("pluginStateChange", t$1), t$1;
			}, t.dB = Sl, t.dC = class extends bl {
				constructor(t$1) {
					super(t$1), this.current = Bl;
				}
				set(t$1, e$1, r$1) {
					if (this.fetchUniformLocation(t$1, e$1)) {
						for (let t$2 = 0; t$2 < 9; t$2++) if (r$1[t$2] !== this.current[t$2]) {
							this.current = r$1, this.gl.uniformMatrix3fv(this.location, !1, r$1);
							break;
						}
					}
				}
			}, t.dD = Tt, t.dE = function(t$1, e$1, r$1) {
				const n$1 = eh(r$1.zoom), i$1 = t$1.style.map._antialias, s$1 = t$1.terrain && t$1.terrain.exaggeration() > 0;
				return 0 === n$1 && !i$1 && !s$1;
			}, t.dF = function(t$1) {
				const e$1 = t$1.pixelsPerMeter, r$1 = e$1 / hu(1, t$1.center.lat), n$1 = u(new Float64Array(16));
				return p(n$1, n$1, [
					t$1.point.x,
					t$1.point.y,
					0
				]), d(n$1, n$1, [
					r$1,
					r$1,
					e$1
				]), Float32Array.from(n$1);
			}, t.dG = qc, t.dH = function(t$1) {
				const e$1 = mu - 5;
				t$1 = Ft(t$1, -e$1, e$1) / e$1 * 90;
				const r$1 = Math.pow(Math.abs(Math.sin(kt(t$1))), 3);
				return Math.round(r$1 * (Kl.length - 1));
			}, t.dI = function(t$1, e$1, r$1, n$1) {
				const i$1 = e$1.getNorth(), s$1 = e$1.getSouth(), a$1 = e$1.getWest(), l$1 = e$1.getEast(), u$1 = 1 << t$1.z, c$1 = l$1 - a$1, h$1 = i$1 - s$1, p$1 = c$1 / Yl, d$1 = -h$1 / Kl[r$1], f$1 = [
					0,
					p$1,
					0,
					d$1,
					0,
					0,
					i$1,
					a$1,
					0
				];
				if (t$1.z > 0) {
					const t$2 = 180 / n$1;
					o(f$1, f$1, [
						t$2 / c$1 + 1,
						0,
						0,
						0,
						t$2 / h$1 + 1,
						0,
						-.5 * t$2 / p$1,
						.5 * t$2 / d$1,
						1
					]);
				}
				return f$1[2] = u$1, f$1[5] = t$1.x, f$1[8] = t$1.y, f$1;
			}, t.dJ = Nc, t.dK = function(t$1, e$1, r$1) {
				const n$1 = u(new Float64Array(16)), i$1 = (e$1 / (1 << t$1) - .5) * Math.PI * 2;
				return m(n$1, r$1.globeMatrix, i$1), Float32Array.from(n$1);
			}, t.dL = Ih, t.dM = Dc, t.dN = function(t$1, e$1) {
				return [
					Math.pow(t$1[0], 2.2) * e$1,
					Math.pow(t$1[1], 2.2) * e$1,
					Math.pow(t$1[2], 2.2) * e$1
				];
			}, t.dO = i, t.dP = function(t$1, e$1) {
				var r$1 = Math.sin(e$1), n$1 = Math.cos(e$1);
				return t$1[0] = n$1, t$1[1] = r$1, t$1[2] = 0, t$1[3] = -r$1, t$1[4] = n$1, t$1[5] = 0, t$1[6] = 0, t$1[7] = 0, t$1[8] = 1, t$1;
			}, t.dQ = $, t.dR = Qc, t.dS = ne, t.dT = ie, t.dU = 256, t.dV = function(t$1, e$1) {
				const r$1 = [
					0,
					0,
					0
				];
				return j(r$1, r$1, Yc(Nc(e$1.canonical))), j(r$1, r$1, t$1), r$1;
			}, t.dW = (t$1) => ({
				u_matrix: new kl(t$1),
				u_texsize: new Al(t$1),
				u_pixels_to_tile_units: new Tl(t$1),
				u_device_pixel_ratio: new _l(t$1),
				u_width_scale: new _l(t$1),
				u_floor_width_scale: new _l(t$1),
				u_image: new wl(t$1),
				u_units_to_pixels: new Al(t$1),
				u_tile_units_to_pixels: new _l(t$1),
				u_alpha_discard_threshold: new _l(t$1),
				u_trim_offset: new Al(t$1),
				u_trim_fade_range: new Al(t$1),
				u_trim_color: new Ml(t$1),
				u_zbias_factor: new _l(t$1),
				u_tile_to_meter: new _l(t$1),
				u_ground_shadow_factor: new Il(t$1),
				u_pattern_transition: new _l(t$1)
			}), t.dX = (t$1) => ({
				u_matrix: new kl(t$1),
				u_pixels_to_tile_units: new Tl(t$1),
				u_device_pixel_ratio: new _l(t$1),
				u_width_scale: new _l(t$1),
				u_floor_width_scale: new _l(t$1),
				u_units_to_pixels: new Al(t$1),
				u_dash_image: new wl(t$1),
				u_gradient_image: new wl(t$1),
				u_image_height: new _l(t$1),
				u_texsize: new Al(t$1),
				u_tile_units_to_pixels: new _l(t$1),
				u_alpha_discard_threshold: new _l(t$1),
				u_trim_offset: new Al(t$1),
				u_trim_fade_range: new Al(t$1),
				u_trim_color: new Ml(t$1),
				u_zbias_factor: new _l(t$1),
				u_tile_to_meter: new _l(t$1),
				u_ground_shadow_factor: new Il(t$1)
			}), t.dY = (t$1) => ({
				u_camera_to_center_distance: new _l(t$1),
				u_extrude_scale: new Tl(t$1),
				u_device_pixel_ratio: new _l(t$1),
				u_matrix: new kl(t$1),
				u_inv_rot_matrix: new kl(t$1),
				u_merc_center: new Al(t$1),
				u_tile_id: new Il(t$1),
				u_zoom_transition: new _l(t$1),
				u_up_dir: new Il(t$1),
				u_emissive_strength: new _l(t$1)
			}), t.dZ = Ea, t.d_ = gy, t.da = k, t.db = function(t$1) {
				return [
					Math.pow(t$1[0], 1 / 2.2),
					Math.pow(t$1[1], 1 / 2.2),
					Math.pow(t$1[2], 1 / 2.2)
				];
			}, t.dc = kf, t.dd = pm, t.de = Qf, t.df = Iv, t.dg = function(t$1, e$1) {
				return t$1.readFields(tb, { icons: [] }, e$1);
			}, t.dh = Kd, t.di = zg, t.dj = Bg, t.dk = Re, t.dl = xo, t.dm = xe, t.dn = Je, t.dp = Gt, t.dq = function(t$1) {
				const e$1 = t$1.indexOf(Qo);
				return e$1 >= 0 ? t$1.slice(0, e$1) : t$1;
			}, t.dr = function(t$1) {
				return t$1.indexOf(Qo) >= 0;
			}, t.ds = function(t$1) {
				const e$1 = t$1.lastIndexOf(Qo);
				return e$1 >= 0 ? t$1.slice(e$1 + 1) : "";
			}, t.dt = function(t$1) {
				const e$1 = [], r$1 = t$1.id;
				return void 0 === r$1 && e$1.push({ message: `layers.${r$1}: missing required property "id"` }), void 0 === t$1.render && e$1.push({ message: `layers.${r$1}: missing required method "render"` }), t$1.renderingMode && "2d" !== t$1.renderingMode && "3d" !== t$1.renderingMode && e$1.push({ message: `layers.${r$1}: property "renderingMode" must be either "2d" or "3d"` }), e$1;
			}, t.du = function(t$1, e$1, r$1, n$1) {
				return "custom" === t$1.type ? new bv(t$1, e$1) : new Hv[t$1.type](t$1, e$1, r$1, n$1);
			}, t.dv = $t, t.dw = function(t$1) {
				const e$1 = t$1.indexOf(Qo);
				return e$1 >= 0 ? t$1.slice(e$1 + 1) : "";
			}, t.dx = class extends jv {
				constructor(t$1, e$1) {
					super(t$1._vectorTileFeature, t$1._z, t$1._x, t$1._y, t$1.id), t$1.state && (this.state = Object.assign({}, t$1.state)), this.target = e$1.target, this.namespace = e$1.namespace, e$1.properties && (this.properties = e$1.properties), this.target && ("featuresetId" in this.target && !this.target.importId || "layerId" in this.target) && (this.source = t$1.source, this.sourceLayer = t$1.sourceLayer, this.layer = t$1.layer);
				}
				toJSON() {
					const t$1 = super.toJSON();
					return t$1.target = this.target, t$1.namespace = this.namespace, t$1;
				}
			}, t.dy = bo, t.dz = Le, t.e = oe, t.e$ = S, t.e0 = lh, t.e1 = (t$1, e$1, r$1, n$1, i$1, s$1) => {
				const o$1 = t$1.transform, a$1 = "globe" === o$1.projection.name;
				let l$1;
				if ("map" === s$1.paint.get("circle-pitch-alignment")) if (a$1) {
					const t$2 = Qc(o$1.zoom, e$1.canonical) * o$1._pixelsPerMercatorPixel;
					l$1 = Float32Array.from([
						t$2,
						0,
						0,
						t$2
					]);
				} else l$1 = o$1.calculatePixelsToTileUnitsMatrix(r$1);
				else l$1 = new Float32Array([
					o$1.pixelsToGLUnits[0],
					0,
					0,
					o$1.pixelsToGLUnits[1]
				]);
				const u$1 = {
					u_camera_to_center_distance: t$1.transform.getCameraToCenterDistance(o$1.projection),
					u_matrix: t$1.translatePosMatrix(e$1.projMatrix, r$1, s$1.paint.get("circle-translate"), s$1.paint.get("circle-translate-anchor")),
					u_device_pixel_ratio: ye.devicePixelRatio,
					u_extrude_scale: l$1,
					u_inv_rot_matrix: ah,
					u_merc_center: [0, 0],
					u_tile_id: [
						0,
						0,
						0
					],
					u_zoom_transition: 0,
					u_up_dir: [
						0,
						0,
						0
					],
					u_emissive_strength: s$1.paint.get("circle-emissive-strength")
				};
				if (a$1) {
					u$1.u_inv_rot_matrix = n$1, u$1.u_merc_center = i$1, u$1.u_tile_id = [
						e$1.canonical.x,
						e$1.canonical.y,
						1 << e$1.canonical.z
					], u$1.u_zoom_transition = eh(o$1.zoom);
					const t$2 = i$1[0] * Un, r$2 = i$1[1] * Un;
					u$1.u_up_dir = o$1.projection.upVector(new Pc(0, 0, 0), t$2, r$2);
				}
				return u$1;
			}, t.e2 = ey, t.e3 = Lr, t.e4 = (t$1, e$1, r$1, n$1, i$1, s$1, o$1, a$1, l$1, u$1) => {
				const c$1 = t$1.transform, h$1 = c$1.pitch < 15 ? Jm(.07, .7, Ft((14 - c$1.zoom) / 5, 0, 1)) : .07, p$1 = "none" === r$1.paint.get("line-trim-color-use-theme").constantOr("default");
				return {
					u_matrix: ty(t$1, e$1, r$1, n$1),
					u_texsize: e$1.imageAtlasTexture ? e$1.imageAtlasTexture.size : [0, 0],
					u_pixels_to_tile_units: c$1.calculatePixelsToTileUnitsMatrix(e$1),
					u_device_pixel_ratio: i$1,
					u_width_scale: s$1,
					u_floor_width_scale: o$1,
					u_image: 0,
					u_tile_units_to_pixels: Qm(e$1, c$1),
					u_units_to_pixels: [1 / c$1.pixelsToGLUnits[0], 1 / c$1.pixelsToGLUnits[1]],
					u_alpha_discard_threshold: 0,
					u_trim_offset: a$1,
					u_trim_fade_range: r$1.paint.get("line-trim-fade-range"),
					u_trim_color: r$1.paint.get("line-trim-color").toPremultipliedRenderColor(p$1 ? null : r$1.lut).toArray01(),
					u_zbias_factor: h$1,
					u_tile_to_meter: vu(e$1.tileID.canonical, 0),
					u_ground_shadow_factor: l$1,
					u_pattern_transition: u$1
				};
			}, t.e5 = (t$1, e$1, r$1, n$1, i$1, s$1, o$1, a$1, l$1, u$1) => {
				const c$1 = t$1.transform, h$1 = c$1.calculatePixelsToTileUnitsMatrix(e$1), p$1 = "none" === r$1.paint.get("line-trim-color-use-theme").constantOr("default"), d$1 = c$1.pitch < 15 ? Jm(.07, .7, Ft((14 - c$1.zoom) / 5, 0, 1)) : .07;
				return {
					u_matrix: ty(t$1, e$1, r$1, n$1),
					u_pixels_to_tile_units: h$1,
					u_device_pixel_ratio: s$1,
					u_width_scale: o$1,
					u_floor_width_scale: a$1,
					u_units_to_pixels: [1 / c$1.pixelsToGLUnits[0], 1 / c$1.pixelsToGLUnits[1]],
					u_dash_image: 0,
					u_gradient_image: 1,
					u_image_height: i$1,
					u_texsize: ry(r$1) && e$1.lineAtlasTexture ? e$1.lineAtlasTexture.size : [0, 0],
					u_tile_units_to_pixels: Qm(e$1, t$1.transform),
					u_alpha_discard_threshold: 0,
					u_trim_offset: l$1,
					u_trim_fade_range: r$1.paint.get("line-trim-fade-range"),
					u_trim_color: r$1.paint.get("line-trim-color").toPremultipliedRenderColor(p$1 ? null : r$1.lut).toArray01(),
					u_zbias_factor: d$1,
					u_tile_to_meter: vu(e$1.tileID.canonical, 0),
					u_ground_shadow_factor: u$1
				};
			}, t.e6 = Ut, t.e7 = Mh, t.e8 = fu, t.e9 = Tc, t.eA = function(t$1, r$1) {
				var n$1 = 2 * Math.acos(r$1[3]), i$1 = Math.sin(n$1 / 2);
				return i$1 > e ? (t$1[0] = r$1[0] / i$1, t$1[1] = r$1[1] / i$1, t$1[2] = r$1[2] / i$1) : (t$1[0] = 1, t$1[1] = 0, t$1[2] = 0), n$1;
			}, t.eB = Gv, t.eC = Jf, t.eD = Zf, t.eE = [
				1,
				1,
				1
			], t.eF = zv, t.eG = Y, t.eH = function(t$1, e$1, r$1, n$1) {
				var i$1 = e$1[0], s$1 = e$1[1], o$1 = e$1[2], a$1 = e$1[3];
				return t$1[0] = i$1 + n$1 * (r$1[0] - i$1), t$1[1] = s$1 + n$1 * (r$1[1] - s$1), t$1[2] = o$1 + n$1 * (r$1[2] - o$1), t$1[3] = a$1 + n$1 * (r$1[3] - a$1), t$1;
			}, t.eI = Kf, t.eJ = Ba, t.eK = ja, t.eL = function(t$1, e$1, n$1, i$1, s$1, o$1, a$1, l$1, u$1, c$1, h$1, p$1, d$1, f$1, m$1, y$1) {
				var g$1 = new r(16);
				return g$1[0] = t$1, g$1[1] = e$1, g$1[2] = n$1, g$1[3] = i$1, g$1[4] = s$1, g$1[5] = o$1, g$1[6] = a$1, g$1[7] = l$1, g$1[8] = u$1, g$1[9] = c$1, g$1[10] = h$1, g$1[11] = p$1, g$1[12] = d$1, g$1[13] = f$1, g$1[14] = m$1, g$1[15] = y$1, g$1;
			}, t.eM = ru, t.eN = Na, t.eO = Ua, t.eP = class {
				constructor() {
					this._updateTime = 0, this._sourceIds = [], this._activeRegions = [], this._prevRegions = [], this._globalClipBounds = {
						min: new It(Infinity, Infinity),
						max: new It(-Infinity, -Infinity)
					};
				}
				clear() {
					this._activeRegions.length > 0 && ++this._updateTime, this._activeRegions = [], this._prevRegions = [];
				}
				get updateTime() {
					return this._updateTime;
				}
				getReplacementRegionsForTile(t$1, e$1 = !1) {
					const r$1 = $p(new It(0, 0), new It(Un, Un), t$1), n$1 = [];
					if (e$1 && !Np(r$1, this._globalClipBounds)) return n$1;
					for (const e$2 of this._activeRegions) {
						if (e$2.hiddenByOverlap) continue;
						if (!Np(r$1, e$2)) continue;
						const i$1 = Gp(e$2.min, e$2.max, t$1);
						n$1.push({
							min: i$1.min,
							max: i$1.max,
							sourceId: this._sourceIds[e$2.priority],
							footprint: e$2.footprint,
							footprintTileId: e$2.tileId,
							order: e$2.order,
							clipMask: e$2.clipMask,
							clipScope: e$2.clipScope
						});
					}
					return n$1;
				}
				setSources(t$1) {
					this._setSources(t$1.map(((t$2) => ({
						getSourceId: () => t$2.cache.id,
						getFootprints: () => {
							const e$1 = [];
							for (const r$1 of t$2.cache.getVisibleCoordinates()) {
								const n$1 = t$2.cache.getTile(r$1).buckets[t$2.layer];
								n$1 && n$1.updateFootprints(r$1.toUnwrapped(), e$1);
							}
							return e$1;
						},
						getOrder: () => t$2.order,
						getClipMask: () => t$2.clipMask,
						getClipScope: () => t$2.clipScope
					}))));
				}
				_addSource(t$1) {
					const e$1 = t$1.getFootprints();
					if (0 === e$1.length) return;
					const r$1 = t$1.getOrder(), n$1 = t$1.getClipMask(), i$1 = t$1.getClipScope();
					for (const t$2 of e$1) {
						if (!t$2.footprint) continue;
						const e$2 = $p(t$2.footprint.min, t$2.footprint.max, t$2.id);
						this._activeRegions.push({
							min: e$2.min,
							max: e$2.max,
							hiddenByOverlap: !1,
							priority: this._sourceIds.length,
							tileId: t$2.id,
							footprint: t$2.footprint,
							order: r$1,
							clipMask: n$1,
							clipScope: i$1
						});
					}
					this._sourceIds.push(t$1.getSourceId());
				}
				_computeReplacement() {
					this._activeRegions.sort(((t$2, e$1) => t$2.priority - e$1.priority || Op(t$2.min, e$1.min) || Op(t$2.max, e$1.max) || t$2.order - e$1.order || t$2.clipMask - e$1.clipMask || function(t$3, e$2) {
						const r$1 = (t$4, e$3) => t$4 + e$3;
						return t$3.length - e$2.length || t$3.reduce(r$1, "").localeCompare(e$2.reduce(r$1, ""));
					}(t$2.clipScope, e$1.clipScope)));
					let t$1 = this._activeRegions.length !== this._prevRegions.length;
					if (!t$1) {
						let e$1 = 0;
						for (; !t$1 && e$1 !== this._activeRegions.length;) {
							const r$1 = this._activeRegions[e$1], n$1 = this._prevRegions[e$1];
							t$1 = r$1.priority !== n$1.priority || !Up(r$1, n$1) || r$1.order !== n$1.order || r$1.clipMask !== n$1.clipMask || !Mt(r$1.clipScope, n$1.clipScope), this._activeRegions[e$1].hiddenByOverlap = n$1.hiddenByOverlap, ++e$1;
						}
					}
					if (t$1) {
						++this._updateTime;
						for (const t$3 of this._activeRegions) t$3.order !== Dp && (this._globalClipBounds.min.x = Math.min(this._globalClipBounds.min.x, t$3.min.x), this._globalClipBounds.min.y = Math.min(this._globalClipBounds.min.y, t$3.min.y), this._globalClipBounds.max.x = Math.max(this._globalClipBounds.max.x, t$3.max.x), this._globalClipBounds.max.y = Math.max(this._globalClipBounds.max.y, t$3.max.y));
						const t$2 = (t$3) => {
							const e$1 = this._activeRegions;
							if (t$3 >= e$1.length) return t$3;
							const r$1 = e$1[t$3].priority;
							for (; t$3 < e$1.length && e$1[t$3].priority === r$1;) ++t$3;
							return t$3;
						};
						if (this._sourceIds.length > 1) {
							let e$1 = 0, r$1 = t$2(e$1);
							for (; e$1 !== r$1;) {
								let n$1 = e$1;
								const i$1 = e$1;
								for (; n$1 !== r$1;) {
									const t$3 = this._activeRegions[n$1];
									t$3.hiddenByOverlap = !1;
									for (let e$2 = 0; e$2 < i$1; e$2++) {
										const r$2 = this._activeRegions[e$2];
										if (!r$2.hiddenByOverlap && t$3.order === Dp && Np(t$3, r$2) && (t$3.hiddenByOverlap = Hp(t$3.footprint, t$3.tileId, r$2.footprint, r$2.tileId), t$3.hiddenByOverlap)) break;
									}
									++n$1;
								}
								e$1 = r$1, r$1 = t$2(e$1);
							}
						}
					}
				}
				_setSources(t$1) {
					[this._prevRegions, this._activeRegions] = [this._activeRegions, []], this._sourceIds = [];
					for (let e$1 = t$1.length - 1; e$1 >= 0; e$1--) this._addSource(t$1[e$1]);
					this._computeReplacement();
				}
			}, t.eQ = Dp, t.eR = class {
				constructor(t$1) {
					this._createGrid(t$1), this._createPoles(t$1);
				}
				destroy() {
					this._poleIndexBuffer.destroy(), this._gridBuffer.destroy(), this._gridIndexBuffer.destroy(), this._poleNorthVertexBuffer.destroy(), this._poleSouthVertexBuffer.destroy();
					for (const t$1 of this._poleSegments) t$1.destroy();
					for (const t$1 of this._gridSegments) t$1.withSkirts.destroy(), t$1.withoutSkirts.destroy();
				}
				_fillGridMeshWithLods(t$1, e$1) {
					const r$1 = new da(), n$1 = new Fa(), i$1 = [], s$1 = t$1 + 1 + 2, o$1 = e$1[0] + 1, a$1 = e$1[0] + 1 + (1 + e$1.length), l$1 = (t$2, e$2, r$2) => {
						let n$2 = t$2 === s$1 - 1 ? t$2 - 2 : 0 === t$2 ? t$2 : t$2 - 1;
						return n$2 += r$2 ? 24575 : 0, [n$2, e$2];
					};
					for (let t$2 = 0; t$2 < s$1; ++t$2) r$1.emplaceBack(...l$1(t$2, 0, !0));
					for (let t$2 = 0; t$2 < o$1; ++t$2) for (let e$2 = 0; e$2 < s$1; ++e$2) r$1.emplaceBack(...l$1(e$2, t$2, (0 === e$2 || e$2 === s$1 - 1) && !0));
					for (let t$2 = 0; t$2 < e$1.length; ++t$2) {
						const n$2 = e$1[t$2];
						for (let t$3 = 0; t$3 < s$1; ++t$3) r$1.emplaceBack(...l$1(t$3, n$2, !0));
					}
					for (let t$2 = 0; t$2 < e$1.length; ++t$2) {
						const o$2 = n$1.length, l$2 = e$1[t$2] + 1 + 2, u$1 = new Fa();
						for (let r$2 = 0; r$2 < l$2 - 1; r$2++) {
							const i$2 = r$2 === l$2 - 2, o$3 = i$2 ? s$1 * (a$1 - e$1.length + t$2 - r$2) : s$1;
							for (let t$3 = 0; t$3 < s$1 - 1; t$3++) {
								const e$2 = r$2 * s$1 + t$3;
								0 === r$2 || i$2 || 0 === t$3 || t$3 === s$1 - 2 ? (u$1.emplaceBack(e$2 + 1, e$2, e$2 + o$3), u$1.emplaceBack(e$2 + o$3, e$2 + o$3 + 1, e$2 + 1)) : (n$1.emplaceBack(e$2 + 1, e$2, e$2 + o$3), n$1.emplaceBack(e$2 + o$3, e$2 + o$3 + 1, e$2 + 1));
							}
						}
						const c$1 = hl.simpleSegment(0, o$2, r$1.length, n$1.length - o$2);
						for (let t$3 = 0; t$3 < u$1.uint16.length; t$3 += 3) n$1.emplaceBack(u$1.uint16[t$3], u$1.uint16[t$3 + 1], u$1.uint16[t$3 + 2]);
						const h$1 = hl.simpleSegment(0, o$2, r$1.length, n$1.length - o$2);
						i$1.push({
							withoutSkirts: c$1,
							withSkirts: h$1
						});
					}
					return {
						vertices: r$1,
						indices: n$1,
						segments: i$1
					};
				}
				_createGrid(t$1) {
					const e$1 = this._fillGridMeshWithLods(Yl, Kl);
					this._gridSegments = e$1.segments, this._gridBuffer = t$1.createVertexBuffer(e$1.vertices, Cc.members), this._gridIndexBuffer = t$1.createIndexBuffer(e$1.indices, !0);
				}
				_createPoles(t$1) {
					const e$1 = new Fa();
					for (let t$2 = 0; t$2 <= Yl; t$2++) e$1.emplaceBack(0, t$2 + 1, t$2 + 2);
					this._poleIndexBuffer = t$1.createIndexBuffer(e$1, !0);
					const r$1 = new La(), n$1 = new La(), i$1 = new La(), s$1 = new La();
					this._poleSegments = [];
					for (let t$2 = 0, e$2 = 0; t$2 < Xl; t$2++) {
						const o$1 = 360 / (1 << t$2);
						r$1.emplaceBack(0, -Hl, 0, .5, 0), n$1.emplaceBack(0, -Hl, 0, .5, 1), i$1.emplaceBack(0, -Hl, 0, .5, .5), s$1.emplaceBack(0, -Hl, 0, .5, .5);
						for (let t$3 = 0; t$3 <= Yl; t$3++) {
							let e$3 = t$3 / Yl, a$1 = 0;
							const l$1 = pr(0, o$1, e$3), [u$1, c$1, h$1] = tu(sh, oh, l$1, Hl);
							r$1.emplaceBack(u$1, c$1, h$1, e$3, a$1), n$1.emplaceBack(u$1, c$1, h$1, e$3, 1 - a$1);
							const p$1 = kt(l$1);
							e$3 = .5 + .5 * Math.sin(p$1), a$1 = .5 + .5 * Math.cos(p$1), i$1.emplaceBack(u$1, c$1, h$1, e$3, a$1), s$1.emplaceBack(u$1, c$1, h$1, e$3, 1 - a$1);
						}
						this._poleSegments.push(hl.simpleSegment(e$2, 0, 66, 64)), e$2 += 66;
					}
					this._poleNorthVertexBuffer = t$1.createVertexBuffer(r$1, Vc, !1), this._poleSouthVertexBuffer = t$1.createVertexBuffer(n$1, Vc, !1), this._texturedPoleNorthVertexBuffer = t$1.createVertexBuffer(i$1, Vc, !1), this._texturedPoleSouthVertexBuffer = t$1.createVertexBuffer(s$1, Vc, !1);
				}
				getGridBuffers(t$1, e$1) {
					return [
						this._gridBuffer,
						this._gridIndexBuffer,
						e$1 ? this._gridSegments[t$1].withSkirts : this._gridSegments[t$1].withoutSkirts
					];
				}
				getPoleBuffers(t$1, e$1) {
					return [
						e$1 ? this._texturedPoleNorthVertexBuffer : this._poleNorthVertexBuffer,
						e$1 ? this._texturedPoleSouthVertexBuffer : this._poleSouthVertexBuffer,
						this._poleIndexBuffer,
						this._poleSegments[t$1]
					];
				}
			}, t.eS = Rp, t.eT = Et, t.eU = function() {
				return !!document.fullscreenElement || !!document.webkitFullscreenElement;
			}, t.eV = Vt, t.eW = xu, t.eX = function(t$1, e$1, r$1) {
				return t$1[0] = e$1[0] / r$1[0], t$1[1] = e$1[1] / r$1[1], t$1[2] = e$1[2] / r$1[2], t$1;
			}, t.eY = Z, t.eZ = eu, t.e_ = D, t.ea = gd, t.eb = Md, t.ec = nd, t.ed = sd, t.ee = id, t.ef = gu, t.eg = function(t$1, e$1) {
				if (t$1 === e$1) {
					var r$1 = e$1[1], n$1 = e$1[2], i$1 = e$1[3], s$1 = e$1[6], o$1 = e$1[7], a$1 = e$1[11];
					t$1[1] = e$1[4], t$1[2] = e$1[8], t$1[3] = e$1[12], t$1[4] = r$1, t$1[6] = e$1[9], t$1[7] = e$1[13], t$1[8] = n$1, t$1[9] = s$1, t$1[11] = e$1[14], t$1[12] = i$1, t$1[13] = o$1, t$1[14] = a$1;
				} else t$1[0] = e$1[0], t$1[1] = e$1[4], t$1[2] = e$1[8], t$1[3] = e$1[12], t$1[4] = e$1[1], t$1[5] = e$1[5], t$1[6] = e$1[9], t$1[7] = e$1[13], t$1[8] = e$1[2], t$1[9] = e$1[6], t$1[10] = e$1[10], t$1[11] = e$1[14], t$1[12] = e$1[3], t$1[13] = e$1[7], t$1[14] = e$1[11], t$1[15] = e$1[15];
				return t$1;
			}, t.eh = pv, t.ei = ha, t.ej = Xa, t.ek = 256, t.el = Kc, t.em = wa, t.en = m, t.eo = function(t$1, e$1) {
				return t$1[0] = e$1[0], t$1[1] = e$1[1], t$1[2] = e$1[2], t$1[3] = e$1[4], t$1[4] = e$1[5], t$1[5] = e$1[6], t$1[6] = e$1[8], t$1[7] = e$1[9], t$1[8] = e$1[10], t$1;
			}, t.ep = La, t.eq = ys, t.er = Oa, t.es = function(t$1, e$1, r$1, n$1, i$1) {
				return Ft((t$1 - e$1) / (r$1 - e$1) * (i$1 - n$1) + n$1, n$1, i$1);
			}, t.et = nt, t.eu = function(t$1, e$1) {
				var r$1 = e$1[0], n$1 = e$1[1], i$1 = e$1[2], s$1 = e$1[3], o$1 = e$1[4], a$1 = e$1[5], l$1 = e$1[6], u$1 = e$1[7], c$1 = e$1[8], h$1 = c$1 * o$1 - a$1 * u$1, p$1 = -c$1 * s$1 + a$1 * l$1, d$1 = u$1 * s$1 - o$1 * l$1, f$1 = r$1 * h$1 + n$1 * p$1 + i$1 * d$1;
				return f$1 ? (t$1[0] = h$1 * (f$1 = 1 / f$1), t$1[1] = (-c$1 * n$1 + i$1 * u$1) * f$1, t$1[2] = (a$1 * n$1 - i$1 * o$1) * f$1, t$1[3] = p$1 * f$1, t$1[4] = (c$1 * r$1 - i$1 * l$1) * f$1, t$1[5] = (-a$1 * r$1 + i$1 * s$1) * f$1, t$1[6] = d$1 * f$1, t$1[7] = (-u$1 * r$1 + n$1 * l$1) * f$1, t$1[8] = (o$1 * r$1 - n$1 * s$1) * f$1, t$1) : null;
			}, t.ev = 2, t.ew = R, t.ex = tt, t.ey = v, t.ez = function(t$1, e$1) {
				var n$1 = new r(3);
				v(n$1, e$1);
				var i$1 = 1 / n$1[0], s$1 = 1 / n$1[1], o$1 = 1 / n$1[2], a$1 = e$1[0] * i$1, l$1 = e$1[1] * s$1, u$1 = e$1[2] * o$1, c$1 = e$1[4] * i$1, h$1 = e$1[5] * s$1, p$1 = e$1[6] * o$1, d$1 = e$1[8] * i$1, f$1 = e$1[9] * s$1, m$1 = e$1[10] * o$1, y$1 = a$1 + h$1 + m$1, g$1 = 0;
				return y$1 > 0 ? (g$1 = 2 * Math.sqrt(y$1 + 1), t$1[3] = .25 * g$1, t$1[0] = (p$1 - f$1) / g$1, t$1[1] = (d$1 - u$1) / g$1, t$1[2] = (l$1 - c$1) / g$1) : a$1 > h$1 && a$1 > m$1 ? (g$1 = 2 * Math.sqrt(1 + a$1 - h$1 - m$1), t$1[3] = (p$1 - f$1) / g$1, t$1[0] = .25 * g$1, t$1[1] = (l$1 + c$1) / g$1, t$1[2] = (d$1 + u$1) / g$1) : h$1 > m$1 ? (g$1 = 2 * Math.sqrt(1 + h$1 - a$1 - m$1), t$1[3] = (d$1 - u$1) / g$1, t$1[0] = (l$1 + c$1) / g$1, t$1[1] = .25 * g$1, t$1[2] = (p$1 + f$1) / g$1) : (g$1 = 2 * Math.sqrt(1 + m$1 - a$1 - h$1), t$1[3] = (l$1 - c$1) / g$1, t$1[0] = (d$1 + u$1) / g$1, t$1[1] = (p$1 + f$1) / g$1, t$1[2] = .25 * g$1), t$1;
			}, t.f = function(t$1) {
				return btoa(encodeURIComponent(t$1).replace(/%([0-9A-F]{2})/g, ((t$2, e$1) => String.fromCharCode(Number("0x" + e$1)))));
			}, t.f0 = function([t$1, e$1, r$1]) {
				const n$1 = Math.hypot(t$1, e$1, r$1), i$1 = Math.atan2(t$1, r$1), s$1 = .5 * Math.PI - Math.acos(-e$1 / n$1);
				return new iu(Bt(i$1), Bt(s$1));
			}, t.f1 = J, t.f2 = Gf, t.f3 = function(t$1) {
				const e$1 = t$1.navigator ? t$1.navigator.userAgent : null;
				return !!function(t$2) {
					if (null == Qt) {
						const e$2 = t$2.navigator ? t$2.navigator.userAgent : null;
						Qt = !!t$2.safari || !(!e$2 || !(/\b(iPad|iPhone|iPod)\b/.test(e$2) || e$2.match("Safari") && !e$2.match("Chrome")));
					}
					return Qt;
				}(t$1) && !(!e$1 || !(e$1.match("Version/15.4") || e$1.match("Version/15.5") || e$1.match(/CPU (OS|iPhone OS) (15_4|15_5) like Mac OS X/)));
			}, t.f4 = function(t$1, e$1) {
				be = t$1, we = e$1;
			}, t.f5 = nh, t.f6 = rh, t.f7 = function(t$1) {
				const e$1 = [
					0,
					0,
					0
				], r$1 = u(new Float64Array(16));
				return h(r$1, t$1.pixelMatrix, t$1.globeMatrix), j(e$1, e$1, r$1), new It(e$1[0], e$1[1]);
			}, t.f8 = function() {
				const t$1 = Wd;
				t$1 && (t$1.isPreloaded() && 1 === t$1.numActive() ? (t$1.release(Hd), Wd = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"));
			}, t.f9 = function() {
				Kd().acquire(Hd);
			}, t.fA = tw, t.fB = zu, t.fC = function(t$1) {
				let e$1 = 0;
				if (new Uint32Array(t$1, 0, 1)[0] !== wf) {
					const r$1 = new Uint32Array(t$1, 0, 7), [, , n$1, i$1, s$1, o$1] = r$1;
					e$1 = r$1.byteLength + i$1 + s$1 + o$1 + s$1, (n$1 !== t$1.byteLength || e$1 >= t$1.byteLength) && Xt("Invalid b3dm header information.");
				}
				return Pf(t$1, e$1);
			}, t.fD = function(t$1, e$1) {
				const r$1 = pm(t$1);
				for (const t$2 of r$1) {
					for (const e$2 of t$2.meshes) dm(e$2);
					t$2.lights && (t$2.lightMeshIndex = t$2.meshes.length, t$2.meshes.push(mm(t$2.lights, e$1)));
				}
				return r$1;
			}, t.fE = Rv, t.fF = Kt, t.fG = Gd, t.fH = Ao, t.fI = fo, t.fJ = function(t$1) {
				Se(), Ae?.then(((e$1) => {
					e$1.keys().then(((r$1) => {
						for (let n$1 = 0; n$1 < r$1.length - t$1; n$1++) e$1.delete(r$1[n$1]).catch(((t$2) => Xt(t$2.message)));
					})).catch(((t$2) => Xt(t$2.message)));
				})).catch(((t$2) => Xt(t$2.message)));
			}, t.fa = wo, t.fb = function(t$1, e$1, r$1 = !1) {
				if (yo === fo.deferred || yo === fo.loading || yo === fo.loaded) throw new Error("setRTLTextPlugin cannot be called multiple times.");
				go = ye.resolveURL(t$1), yo = fo.deferred, mo = e$1, vo(), r$1 || _o();
			}, t.fc = function(t$1) {
				nf = ye.resolveURL(t$1), of || (of = new Zd(Kd(), new nr())), of.broadcast("setMeshoptUrl", nf);
			}, t.fd = hf, t.fe = function(t$1) {
				ef = ye.resolveURL(t$1), of || (of = new Zd(Kd(), new nr())), of.broadcast("setDracoUrl", ef);
			}, t.ff = cf, t.fg = qd, t.fh = function(t$1) {
				const e$1 = Me();
				if (!e$1) return;
				const r$1 = e$1.delete(ve);
				t$1 && r$1.then((() => t$1())).catch(t$1);
			}, t.fi = Xd, t.fj = Qs, t.fk = _h, t.fl = kg, t.fm = Xw, t.fn = Zw, t.fo = $m, t.fp = Ru, t.fq = "hd_road_elevation", t.fr = ec, t.fs = jt, t.ft = lp, t.fu = Ag, t.fv = wg, t.fw = function(t$1, e$1, r$1, n$1, i$1, s$1, o$1, a$1 = 1, l$1, u$1, c$1) {
				t$1.createArrays(), t$1.tilePixelRatio = Un / (512 * t$1.overscaling), t$1.compareText = {}, t$1.iconsNeedLinear = !1;
				const h$1 = t$1.layers[0].layout, p$1 = t$1.layers[0]._unevaluatedLayout._values, d$1 = {};
				d$1.scaleFactor = a$1, d$1.textSizeScaleRange = h$1.get("text-size-scale-range"), d$1.iconSizeScaleRange = h$1.get("icon-size-scale-range");
				const [f$1, m$1] = d$1.textSizeScaleRange, [y$1, g$1] = d$1.iconSizeScaleRange;
				d$1.textScaleFactor = Ft(d$1.scaleFactor, f$1, m$1), d$1.iconScaleFactor = Ft(d$1.scaleFactor, y$1, g$1);
				const x$1 = p$1["text-size"], v$1 = p$1["icon-size"];
				if ("composite" === t$1.textSizeData.kind) {
					const { minZoom: e$2, maxZoom: r$2 } = t$1.textSizeData;
					d$1.compositeTextSizes = [x$1.possiblyEvaluate(new Io(e$2, { worldview: c$1 }), s$1), x$1.possiblyEvaluate(new Io(r$2, { worldview: c$1 }), s$1)];
				}
				if ("composite" === t$1.iconSizeData.kind) {
					const { minZoom: e$2, maxZoom: r$2 } = t$1.iconSizeData;
					d$1.compositeIconSizes = [v$1.possiblyEvaluate(new Io(e$2, { worldview: c$1 }), s$1), v$1.possiblyEvaluate(new Io(r$2, { worldview: c$1 }), s$1)];
				}
				d$1.layoutTextSize = x$1.possiblyEvaluate(new Io(o$1 + 1, { worldview: c$1 }), s$1), d$1.layoutIconSize = v$1.possiblyEvaluate(new Io(o$1 + 1, { worldview: c$1 }), s$1), d$1.textMaxSize = x$1.possiblyEvaluate(new Io(18, { worldview: c$1 }), s$1);
				const b$1 = h$1.get("symbol-placement"), w$1 = "map" === h$1.get("text-rotation-alignment") && "point" !== b$1, _$1 = h$1.get("text-size");
				let A$1 = !1;
				const I$1 = [];
				for (const o$2 of t$1.features) {
					const a$2 = h$1.get("text-font").evaluate(o$2, {}, s$1).join(","), f$2 = _$1.evaluate(o$2, {}, s$1) * d$1.textScaleFactor, m$2 = d$1.layoutTextSize.evaluate(o$2, {}, s$1) * d$1.textScaleFactor, y$2 = d$1.layoutIconSize.evaluate(o$2, {}, s$1) * d$1.iconScaleFactor, g$2 = {
						horizontal: {},
						vertical: void 0
					}, x$2 = o$2.text;
					let v$2, M$1 = [0, 0];
					if (x$2) {
						const n$2 = x$2.toString(), u$2 = h$1.get("text-letter-spacing").evaluate(o$2, {}, s$1) * xy, c$2 = h$1.get("text-line-height").evaluate(o$2, {}, s$1) * xy, p$2 = so(n$2) ? u$2 : 0, d$2 = h$1.get("text-anchor").evaluate(o$2, {}, s$1), y$3 = h$1.get("text-variable-anchor");
						if (!y$3) {
							const t$2 = h$1.get("text-radial-offset").evaluate(o$2, {}, s$1);
							if (t$2) M$1 = Zg(d$2, [t$2 * xy, qg]);
							else {
								const t$3 = h$1.get("text-offset").evaluate(o$2, {}, s$1);
								M$1 = [t$3[0] * xy, t$3[1] * xy];
							}
						}
						let v$3 = w$1 ? "center" : h$1.get("text-justify").evaluate(o$2, {}, s$1);
						const _$2 = "point" === b$1, A$2 = _$2 ? h$1.get("text-max-width").evaluate(o$2, {}, s$1) * xy : Infinity, I$2 = (s$2) => {
							t$1.allowVerticalPlacement && io(n$2) && (g$2.vertical = Hy(x$2, e$1, r$1, i$1, a$2, A$2, c$2, d$2, s$2, p$2, M$1, $y.vertical, !0, m$2, f$2, l$1));
						};
						if (!w$1 && y$3) {
							const t$2 = "auto" === v$3 ? y$3.map(((t$3) => sx(t$3))) : [v$3];
							let n$3 = !1;
							for (let s$2 = 0; s$2 < t$2.length; s$2++) {
								const o$3 = t$2[s$2];
								if (!g$2.horizontal[o$3]) if (n$3) g$2.horizontal[o$3] = g$2.horizontal[0];
								else {
									const t$3 = Hy(x$2, e$1, r$1, i$1, a$2, A$2, c$2, "center", o$3, p$2, M$1, $y.horizontal, !1, m$2, f$2, l$1);
									t$3 && (g$2.horizontal[o$3] = t$3, n$3 = 1 === t$3.positionedLines.length);
								}
							}
							I$2("left");
						} else {
							if ("auto" === v$3 && (v$3 = sx(d$2)), _$2 || h$1.get("text-writing-mode").indexOf("horizontal") >= 0 || !io(n$2)) {
								const t$2 = Hy(x$2, e$1, r$1, i$1, a$2, A$2, c$2, d$2, v$3, p$2, M$1, $y.horizontal, !1, m$2, f$2, l$1);
								t$2 && (g$2.horizontal[v$3] = t$2);
							}
							I$2(_$2 ? "left" : v$3);
						}
					}
					let S$1, P$1, k$1, B$1, z$1, T$1, E$1 = !1;
					const V$1 = h$1.get("icon-text-fit").evaluate(o$2, {}, s$1);
					if (o$2.icon && o$2.icon.hasPrimary()) {
						const e$2 = tx(o$2.icon, t$1.iconSizeData, p$1["icon-size"], s$1, t$1.zoom, o$2, l$1, d$1.iconScaleFactor, c$1);
						S$1 = e$2.iconPrimary, k$1 = e$2.iconSecondary;
						const r$2 = S$1.toString();
						if (P$1 = n$1.get(r$2), P$1 && (z$1 = h$1.get("icon-offset").evaluate(o$2, {}, s$1), T$1 = h$1.get("icon-anchor").evaluate(o$2, {}, s$1), v$2 = ng(i$1.get(r$2), k$1 ? i$1.get(k$1.toString()) : void 0, z$1, T$1), E$1 = P$1.sdf, void 0 === t$1.sdfIcons ? t$1.sdfIcons = P$1.sdf : t$1.sdfIcons !== P$1.sdf && Xt("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (P$1.pixelRatio !== t$1.pixelRatio || 0 !== h$1.get("icon-rotate").constantOr(1)) && (t$1.iconsNeedLinear = !0)), k$1) {
							const t$2 = k$1.toString();
							B$1 = n$1.get(t$2);
						}
					}
					A$1 = A$1 || !(!o$2.icon || !o$2.icon.hasSecondary());
					const F$1 = hx(g$2.horizontal) || g$2.vertical;
					t$1.iconsInText || (t$1.iconsInText = !!F$1 && F$1.iconsInText);
					const C$1 = m$2 * d$1.textScaleFactor / xy, { defaultShapedIcon: D$1, verticallyShapedIcon: R$1 } = ox(t$1, v$2, h$1, o$2, s$1, g$2, C$1, z$1, V$1);
					"none" !== V$1 && v$2 && (sg(v$2) || og(v$2)) && (Jg(0, P$1, S$1, v$2, D$1, V$1, u$1, n$1, i$1), Jg(0, B$1, k$1, v$2, D$1, V$1, u$1, n$1, i$1), R$1 && (Jg(0, P$1, S$1, v$2, R$1, V$1, u$1, n$1, i$1), Jg(0, B$1, k$1, v$2, R$1, V$1, u$1, n$1, i$1))), v$2 = D$1;
					const { iconBBox: L$1, iconVerticalBBox: O$1, textBBox: U$1, textVerticalBBox: N$1 } = Wg(t$1, v$2, R$1, h$1, o$2, s$1, y$2, z$1, d$1, i$1, T$1, g$2, m$2, M$1);
					I$1.push({
						feature: o$2,
						shapedTextOrientations: g$2,
						shapedText: F$1,
						shapedIcon: v$2,
						iconPrimary: S$1,
						iconSecondary: k$1,
						iconOffset: z$1,
						iconAnchor: T$1,
						verticallyShapedIcon: R$1,
						layoutTextSize: m$2,
						layoutIconSize: y$2,
						textOffset: M$1,
						isSDFIcon: E$1,
						iconTextFit: V$1,
						iconCollisionBounds: L$1,
						iconVerticalCollisionBounds: O$1,
						textCollisionBounds: U$1,
						textVerticalCollisionBounds: N$1
					});
				}
				return {
					featureData: I$1,
					sizes: d$1,
					hasAnySecondaryIcon: A$1,
					textAlongLine: w$1,
					symbolPlacement: b$1
				};
			}, t.fx = Ig, t.fy = function(t$1, e$1, r$1, n$1, i$1, s$1, o$1, a$1, l$1, u$1) {
				t$1.iconAtlasPositions = u$1.iconPositions;
				const { featureData: c$1, hasAnySecondaryIcon: h$1, sizes: p$1, textAlongLine: d$1, symbolPlacement: f$1 } = e$1;
				for (const e$2 of c$1) {
					const { shapedIcon: r$2, verticallyShapedIcon: s$2, feature: c$2, shapedTextOrientations: m$1, shapedText: y$1, layoutTextSize: g$1, textOffset: x$1, isSDFIcon: v$1, iconPrimary: b$1, iconSecondary: w$1, iconTextFit: _$1, iconOffset: A$1, iconCollisionBounds: I$1, iconVerticalCollisionBounds: M$1, textCollisionBounds: S$1 } = e$2;
					rx(r$2, u$1.iconPositions, b$1, w$1), rx(s$2, u$1.iconPositions, b$1, w$1), nx(m$1, u$1.iconPositions), ex(b$1, w$1, u$1.iconPositions), (y$1 || r$2) && ax(t$1, c$2, m$1, r$2, s$2, l$1, p$1, g$1, 0, x$1, v$1, n$1, i$1, o$1, a$1, h$1, _$1, A$1, d$1, f$1, I$1, M$1, S$1);
				}
				r$1 && t$1.generateCollisionDebugBuffers(s$1, t$1.collisionBoxArray, p$1.textScaleFactor);
			}, t.fz = Cu, t.g = function(t$1, e$1) {
				return Le(Object.assign(t$1, { method: "GET" }), e$1);
			}, t.h = function(t$1) {
				return 0 === t$1.indexOf("mapbox:");
			}, t.i = function(t$1) {
				return oe.API_STYLE_REGEX.test(t$1) && !le(t$1);
			}, t.j = ae, t.k = ke, t.l = function(t$1) {
				return decodeURIComponent(atob(t$1).split("").map(((t$2) => "%" + ("00" + t$2.charCodeAt(0).toString(16)).slice(-2))).join(""));
			}, t.m = function(t$1, e$1) {
				return Le(Object.assign(t$1, { type: "json" }), e$1);
			}, t.n = Ge, t.o = ye, t.p = function(t$1, e$1) {
				return Le(Object.assign(t$1, { method: "POST" }), e$1);
			}, t.q = Ah, t.r = me, t.s = function(t$1) {
				try {
					const e$1 = self[t$1];
					return e$1.setItem("_mapbox_test_", 1), e$1.removeItem("_mapbox_test_"), !0;
				} catch (t$2) {
					return !1;
				}
			}, t.t = function() {
				return Yd || (Yd = new Xd("ImageRasterizer")), Yd;
			}, t.u = function() {
				return function t$1(e$1) {
					return e$1 ? (e$1 ^ Math.random() * (16 >> e$1 / 4)).toString(16) : ([1e7] + -[1e3] + -4e3 + -8e3 + -1e11).replace(/[018]/g, t$1);
				}();
			}, t.v = function(t$1) {
				return !!t$1 && /^[0-9a-f]{8}-[0-9a-f]{4}-[4][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(t$1);
			}, t.w = Xt, t.x = jb, t.y = tr, t.z = Qe;
		}));
		define$1(["./shared"], (function(e) {
			function t(e$1) {
				const t$1 = e$1 ? e$1.url.toString() : void 0;
				return t$1 ? performance.getEntriesByName(t$1) : [];
			}
			function s(e$1) {
				if ("number" == typeof e$1 || "boolean" == typeof e$1 || "string" == typeof e$1 || null == e$1) return JSON.stringify(e$1);
				if (Array.isArray(e$1)) {
					let t$2 = "[";
					for (const i$1 of e$1) t$2 += `${s(i$1)},`;
					return `${t$2}]`;
				}
				let t$1 = "{";
				for (const i$1 of Object.keys(e$1).sort()) t$1 += `${i$1}:${s(e$1[i$1])},`;
				return `${t$1}}`;
			}
			function i(t$1) {
				let i$1 = "";
				for (const o$1 of e.bx) i$1 += `/${s(t$1[o$1])}`;
				return i$1;
			}
			class o {
				constructor(e$1) {
					this.keyCache = {}, this._layers = {}, this._layerConfigs = {}, e$1 && this.replace(e$1);
				}
				replace(e$1, t$1) {
					this._layerConfigs = {}, this._layers = {}, this.update(e$1, [], t$1);
				}
				update(t$1, o$1, n$1) {
					this._options = n$1;
					for (const s$1 of t$1) this._layerConfigs[s$1.id] = s$1, (this._layers[s$1.id] = e.du(s$1, this.scope, null, this._options)).compileFilter(n$1), this.keyCache[s$1.id] && delete this.keyCache[s$1.id];
					for (const e$1 of o$1) delete this.keyCache[e$1], delete this._layerConfigs[e$1], delete this._layers[e$1];
					this.familiesBySource = {};
					const r$1 = function(e$1, t$2) {
						const o$2 = {};
						for (let n$3 = 0; n$3 < e$1.length; n$3++) {
							const r$2 = e$1[n$3];
							let a$1 = t$2 && t$2[r$2.id];
							a$1 || ("symbol" === r$2.type ? a$1 = r$2.id : (a$1 = i(r$2), "line" === r$2.type && r$2.paint && function e$2(t$3) {
								return "string" == typeof t$3 && "line-progress" === t$3 || (Array.isArray(t$3) ? t$3.some(e$2) : !(!t$3 || "object" != typeof t$3) && Object.values(t$3).some(e$2));
							}(r$2.paint["line-width"]) && (a$1 += `/${s(r$2.paint["line-width"])}`))), t$2 && (t$2[r$2.id] = a$1);
							let l$1 = o$2[a$1];
							l$1 || (l$1 = o$2[a$1] = []), l$1.push(r$2);
						}
						const n$2 = [];
						for (const e$2 in o$2) n$2.push(o$2[e$2]);
						return n$2;
					}(Object.values(this._layerConfigs), this.keyCache);
					for (const e$1 of r$1) {
						const t$2 = e$1.map(((e$2) => this._layers[e$2.id])), s$1 = t$2[0];
						if ("none" === s$1.visibility) continue;
						const i$1 = s$1.source || "";
						let o$2 = this.familiesBySource[i$1];
						o$2 || (o$2 = this.familiesBySource[i$1] = {});
						const n$2 = s$1.sourceLayer || "_geojsonTileLayer";
						let r$2 = o$2[n$2];
						r$2 || (r$2 = o$2[n$2] = []), r$2.push(t$2);
					}
				}
			}
			const n = 1 * e.fl;
			class r {
				constructor(t$1) {
					const s$1 = {}, i$1 = [];
					for (const e$1 in t$1) {
						const o$2 = t$1[e$1], r$2 = s$1[e$1] = {};
						for (const e$2 in o$2.glyphs) {
							const t$2 = o$2.glyphs[+e$2];
							if (!t$2 || 0 === t$2.bitmap.width || 0 === t$2.bitmap.height) continue;
							const s$2 = t$2.metrics.localGlyph ? n : 1, a$2 = {
								x: 0,
								y: 0,
								w: t$2.bitmap.width + 2 * s$2,
								h: t$2.bitmap.height + 2 * s$2
							};
							i$1.push(a$2), r$2[e$2] = a$2;
						}
					}
					const { w: o$1, h: r$1 } = e.G(i$1), a$1 = new e.fk({
						width: o$1 || 1,
						height: r$1 || 1
					});
					for (const i$2 in t$1) {
						const o$2 = t$1[i$2];
						for (const t$2 in o$2.glyphs) {
							const r$2 = o$2.glyphs[+t$2];
							if (!r$2 || 0 === r$2.bitmap.width || 0 === r$2.bitmap.height) continue;
							const l$1 = s$1[i$2][t$2], c$1 = r$2.metrics.localGlyph ? n : 1;
							e.fk.copy(r$2.bitmap, a$1, {
								x: 0,
								y: 0
							}, {
								x: l$1.x + c$1,
								y: l$1.y + c$1
							}, r$2.bitmap);
						}
					}
					this.image = a$1, this.positions = s$1;
				}
			}
			function a(e$1, t$1, s$1) {
				e$1[t$1] ? s$1 && (e$1[t$1].center = s$1) : e$1[t$1] = {
					floorIds: /* @__PURE__ */ new Set(),
					center: s$1 || [0, 0],
					floors: {}
				};
			}
			function l(e$1, t$1, s$1, i$1) {
				for (const o$1 of t$1) a(e$1, o$1), e$1[o$1].floors[s$1] = i$1, e$1[o$1].floorIds.add(s$1);
			}
			function c(e$1) {
				return {
					id: e$1.properties.id.toString(),
					center: e$1.properties.center.toString().split(";").map(Number)
				};
			}
			function h(e$1) {
				return {
					id: e$1.properties.id.toString(),
					isDefault: !!e$1.properties.is_default && e$1.properties.is_default,
					connections: e$1.properties.connected_floor_ids ? new Set(e$1.properties.connected_floor_ids.toString().split(";")) : /* @__PURE__ */ new Set(),
					conflicts: e$1.properties.conflicted_floor_ids ? new Set(e$1.properties.conflicted_floor_ids.toString().split(";")) : /* @__PURE__ */ new Set(),
					buildings: e$1.properties.building_ids ? new Set(e$1.properties.building_ids.toString().split(";")) : /* @__PURE__ */ new Set(),
					name: e$1.properties.name.toString(),
					zIndex: e$1.properties.z_index
				};
			}
			function u(e$1, t$1) {
				return t$1.every(((t$2) => e$1.properties && null != e$1.properties[t$2]));
			}
			function d(e$1) {
				return u(e$1, [
					"type",
					"id",
					"name"
				]) && "building" === e$1.properties.type;
			}
			function f(e$1) {
				return u(e$1, [
					"type",
					"id",
					"name",
					"z_index"
				]) && "floor" === e$1.properties.type;
			}
			e.fj(r, "GlyphAtlas");
			class p {
				constructor(t$1) {
					this.tileID = new e.aQ(t$1.tileID.overscaledZ, t$1.tileID.wrap, t$1.tileID.canonical.z, t$1.tileID.canonical.x, t$1.tileID.canonical.y), this.tileZoom = t$1.tileZoom, this.uid = t$1.uid, this.zoom = t$1.zoom, this.lut = t$1.lut, this.canonical = t$1.tileID.canonical, this.pixelRatio = t$1.pixelRatio, this.tileSize = t$1.tileSize, this.source = t$1.source, this.scope = t$1.scope, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = t$1.showCollisionBoxes, this.collectResourceTiming = !!t$1.request && t$1.request.collectResourceTiming, this.promoteId = t$1.promoteId, this.isSymbolTile = t$1.isSymbolTile, this.tileTransform = e.aZ(t$1.tileID.canonical, t$1.projection), this.projection = t$1.projection, this.worldview = t$1.worldview, this.localizableLayerIds = t$1.localizableLayerIds, this.brightness = t$1.brightness, this.extraShadowCaster = !!t$1.extraShadowCaster, this.tessellationStep = t$1.tessellationStep, this.scaleFactor = t$1.scaleFactor, this.worldview = t$1.worldview, this.indoor = t$1.indoor;
				}
				parse(t$1, s$1, i$1, o$1, n$1, u$1) {
					this.status = "parsing", this.data = t$1, this.collisionBoxArray = new e.b3();
					const p$1 = new e.fm(Object.keys(t$1.layers).sort()), m$1 = new e.fn(this.tileID, this.promoteId);
					m$1.bucketLayerIDs = [];
					const y$1 = {}, w$1 = new e.fo(256, 256), b$1 = {
						featureIndex: m$1,
						iconDependencies: /* @__PURE__ */ new Map(),
						patternDependencies: /* @__PURE__ */ new Map(),
						glyphDependencies: {},
						lineAtlas: w$1,
						availableImages: i$1,
						brightness: this.brightness,
						scaleFactor: this.scaleFactor,
						elevationFeatures: void 0,
						activeFloors: void 0
					};
					if (this.indoor) {
						const s$2 = this.indoor.indoorState.activeFloorsVisible, i$2 = function(t$2, s$3, i$3) {
							const o$2 = function(t$3, s$4) {
								if (!t$3) return e.w("No source layers defined in indoor specification"), s$4;
								if (0 === t$3.size) return s$4;
								const i$4 = t$3.difference(s$4);
								for (const t$4 of i$4) e.w(`Missing source layer required in indoor specification: ${t$4}`);
								return s$4.intersection(s$4);
							}(s$3.sourceLayers, new Set(Object.keys(t$2.layers))), n$2 = s$3.indoorState, r$1 = function(t$3, s$4, i$4, o$3) {
								const n$3 = /* @__PURE__ */ new Set(), r$2 = /* @__PURE__ */ new Set(), u$2 = /* @__PURE__ */ new Set(), p$2 = /* @__PURE__ */ new Map(), g$1 = {}, m$2 = (e$1) => {
									const t$4 = p$2.get(e$1) || /* @__PURE__ */ new Set();
									for (const s$5 of n$3) if ((p$2.get(s$5) || /* @__PURE__ */ new Set()).has(e$1) || t$4.has(s$5)) return !0;
									return !1;
								};
								for (const i$5 of s$4) {
									const s$5 = t$3.layers[i$5];
									if (s$5) for (let e$1 = 0; e$1 < s$5.length; e$1++) {
										const t$4 = s$5.feature(e$1);
										if (d(t$4)) {
											const { id: e$2, center: s$6 } = c(t$4);
											a(g$1, e$2, s$6), n$3.add(e$2);
										} else if (f(t$4)) {
											const { id: e$2, isDefault: s$6, connections: i$6, conflicts: a$1, buildings: c$1, name: d$1, zIndex: f$1 } = h(t$4);
											l(g$1, c$1, e$2, {
												name: d$1,
												zIndex: f$1
											}), p$2.set(e$2, a$1), (e$2 === o$3 || i$6.has(o$3)) && n$3.add(e$2), r$2.add(e$2), s$6 && u$2.add(e$2);
										}
									}
									else e.w(`indoor source layer not found: ${i$5}`);
								}
								if (i$4) for (const e$1 of i$4) r$2.has(e$1) && (m$2(e$1) || n$3.add(e$1));
								for (const e$1 of u$2) n$3.has(e$1) || m$2(e$1) || n$3.add(e$1);
								return {
									buildings: g$1,
									activeFloors: n$3
								};
							}(t$2, o$2, n$2.lastActiveFloors, n$2.selectedFloorId);
							return i$3.send("setIndoorData", r$1), r$1;
						}(t$1, this.indoor, n$1);
						b$1.activeFloors = s$2 ? i$2.activeFloors : void 0;
					}
					const x$1 = [], v$1 = s$1.familiesBySource[this.source];
					for (const s$2 in v$1) {
						const n$2 = t$1.layers[s$2];
						if (!n$2) continue;
						let r$1 = !1, a$1 = !1, l$1 = !1;
						for (const e$1 of v$1[s$2]) "symbol" === e$1[0].type ? r$1 = !0 : a$1 = !0, e$1[0].is3D() && "model" !== e$1[0].type && (l$1 = !0);
						if (this.extraShadowCaster && !l$1) continue;
						if (!0 === this.isSymbolTile && !r$1) continue;
						if (!1 === this.isSymbolTile && !a$1) continue;
						1 === n$2.version && e.w(`Vector tile source "${this.source}" layer "${s$2}" does not use vector tile spec v2 and therefore may have some rendering errors.`);
						const c$1 = p$1.encode(s$2), h$1 = [], u$2 = this.localizableLayerIds && this.localizableLayerIds.has(s$2);
						let d$1 = !1;
						for (let t$2 = 0, i$2 = 0; t$2 < n$2.length; t$2++) {
							const o$2 = n$2.feature(t$2), r$2 = m$1.getId(o$2, s$2), a$2 = o$2.properties ? o$2.properties.worldview : null;
							if (u$2 && this.worldview && "string" == typeof a$2) if ("all" === a$2) o$2.properties.$localized = !0;
							else {
								if (!a$2.split(",").includes(this.worldview)) continue;
								o$2.properties.$localized = !0, o$2.properties.worldview = this.worldview;
							}
							!d$1 && o$2.properties && o$2.properties.hasOwnProperty(e.fp) && (d$1 = !0), h$1.push({
								feature: o$2,
								id: r$2,
								index: i$2,
								sourceLayerIndex: c$1
							}), i$2++;
						}
						d$1 && !b$1.elevationFeatures && t$1.layers.hasOwnProperty(e.fq) && (b$1.elevationFeatures = e.fr.parseFrom(t$1.layers[e.fq], this.canonical));
						for (const t$2 of v$1[s$2]) {
							const s$3 = t$2[0];
							if (this.extraShadowCaster && (!s$3.is3D() || "model" === s$3.type)) continue;
							if (void 0 !== this.isSymbolTile && "symbol" === s$3.type !== this.isSymbolTile) continue;
							if (s$3.minzoom && this.zoom < Math.floor(s$3.minzoom)) continue;
							if (s$3.maxzoom && this.zoom >= s$3.maxzoom) continue;
							if ("none" === s$3.visibility) continue;
							g(t$2, this.zoom, b$1.brightness, i$1, this.worldview);
							const n$3 = y$1[s$3.id] = s$3.createBucket({
								index: m$1.bucketLayerIDs.length,
								layers: t$2,
								zoom: this.zoom,
								lut: this.lut,
								canonical: this.canonical,
								pixelRatio: this.pixelRatio,
								overscaling: this.overscaling,
								collisionBoxArray: this.collisionBoxArray,
								sourceLayerIndex: c$1,
								sourceID: this.source,
								projection: this.projection.spec,
								tessellationStep: this.tessellationStep,
								styleDefinedModelURLs: o$1,
								worldview: this.worldview,
								localizable: u$2
							});
							m$1.bucketLayerIDs.push(t$2.map(((t$3) => e.B(t$3.id, t$3.scope))));
							let r$2 = n$3.prepare ? n$3.prepare() : null;
							null != r$2 ? (r$2 = r$2.then((() => n$3.populate(h$1, b$1, this.tileID.canonical, this.tileTransform))), x$1.push(r$2)) : n$3.populate(h$1, b$1, this.tileID.canonical, this.tileTransform);
						}
					}
					const I$1 = () => {
						let s$2, o$2, a$1, l$1, c$1, h$1;
						w$1.trim();
						const d$1 = {
							type: "maybePrepare",
							isSymbolTile: this.isSymbolTile,
							zoom: this.zoom
						}, f$1 = () => {
							if (s$2) return this.status = "done", u$1(s$2);
							if (this.extraShadowCaster) this.status = "done", u$1(null, {
								buckets: Object.values(y$1).filter(((e$1) => !e$1.isEmpty())),
								featureIndex: m$1,
								collisionBoxArray: null,
								glyphAtlasImage: null,
								lineAtlas: null,
								imageAtlas: null,
								brightness: b$1.brightness,
								glyphMap: null,
								iconMap: null,
								glyphPositions: null
							});
							else if (o$2 && a$1 && l$1) {
								const t$2 = new r(o$2), s$3 = /* @__PURE__ */ new Map();
								for (const [t$3, i$2] of a$1.entries()) {
									const { imagePosition: o$3 } = e.fu(t$3, i$2, e.fv);
									s$3.set(t$3, o$3);
								}
								const u$2 = {};
								for (const n$2 in y$1) {
									const r$1 = y$1[n$2];
									r$1 instanceof e.b4 && (g(r$1.layers, this.zoom, b$1.brightness, i$1, this.worldview), u$2[n$2] = e.fw(r$1, o$2, t$2.positions, a$1, s$3, this.tileID.canonical, this.tileZoom, this.scaleFactor, this.pixelRatio, c$1, this.worldview));
								}
								const d$2 = {
									iconsPending: !0,
									patternsPending: !0
								};
								this.rasterizeIfNeeded(n$1, a$1, c$1, (() => {
									d$2.iconsPending = !1, x$2(u$2, t$2, d$2);
								})), this.rasterizeIfNeeded(n$1, l$1, h$1, (() => {
									d$2.patternsPending = !1, x$2(u$2, t$2, d$2);
								}));
							}
						}, x$2 = (t$2, s$3, o$3, n$2) => {
							if (o$3.iconsPending || o$3.patternsPending) return;
							const r$1 = new e.fx(a$1, l$1, this.lut);
							for (const s$4 in y$1) {
								const o$4 = y$1[s$4];
								if (s$4 in t$2) e.fy(o$4, t$2[s$4], this.showCollisionBoxes, i$1, this.tileID.canonical, this.tileZoom, this.projection, this.brightness, a$1, r$1);
								else if (o$4.hasPattern && (o$4 instanceof e.ba || o$4 instanceof e.bb || o$4 instanceof e.ea)) {
									g(o$4.layers, this.zoom, b$1.brightness, i$1, this.worldview);
									const e$1 = Object.fromEntries(r$1.patternPositions);
									o$4.addFeatures(b$1, this.tileID.canonical, e$1, i$1, this.tileTransform, this.brightness);
								}
							}
							this.status = "done", u$1(null, {
								buckets: Object.values(y$1).filter(((e$1) => !e$1.isEmpty())),
								featureIndex: m$1,
								collisionBoxArray: this.collisionBoxArray,
								glyphAtlasImage: s$3.image,
								lineAtlas: w$1,
								imageAtlas: r$1,
								brightness: b$1.brightness
							});
						};
						if (!this.extraShadowCaster) {
							const t$2 = e.fs(b$1.glyphDependencies, ((e$1) => Object.keys(e$1).map(Number)));
							Object.keys(t$2).length ? n$1.send("getGlyphs", {
								uid: this.uid,
								stacks: t$2
							}, ((e$1, t$3) => {
								s$2 || (s$2 = e$1, o$2 = t$3, f$1());
							}), void 0, !1, d$1) : o$2 = {};
							const i$2 = Array.from(b$1.iconDependencies.keys()).map(((t$3) => e.I.parse(t$3)));
							i$2.length ? n$1.send("getImages", {
								images: i$2,
								source: this.source,
								scope: this.scope,
								tileID: this.tileID,
								type: "icons"
							}, ((e$1, t$3) => {
								s$2 || (s$2 = e$1, a$1 = /* @__PURE__ */ new Map(), c$1 = this.updateImageMapAndGetImageTaskQueue(a$1, t$3, b$1.iconDependencies), f$1());
							}), void 0, !1, d$1) : (a$1 = /* @__PURE__ */ new Map(), c$1 = /* @__PURE__ */ new Map());
							const r$1 = Array.from(b$1.patternDependencies.keys()).map(((t$3) => e.I.parse(t$3)));
							r$1.length ? n$1.send("getImages", {
								images: r$1,
								source: this.source,
								scope: this.scope,
								tileID: this.tileID,
								type: "patterns"
							}, ((e$1, t$3) => {
								s$2 || (s$2 = e$1, l$1 = /* @__PURE__ */ new Map(), h$1 = this.updateImageMapAndGetImageTaskQueue(l$1, t$3, b$1.patternDependencies), f$1());
							}), void 0, !1, d$1) : (l$1 = /* @__PURE__ */ new Map(), h$1 = /* @__PURE__ */ new Map());
						}
						if (b$1.elevationFeatures && b$1.elevationFeatures.length > 0) {
							const s$3 = [];
							for (const t$2 of Object.values(y$1)) if (t$2 instanceof e.bb) {
								const e$1 = t$2.getUnevaluatedPortalGraph();
								e$1 && s$3.push(e$1);
							}
							const i$2 = e.ft.evaluate(s$3);
							for (const s$4 of Object.values(y$1)) if (s$4 instanceof e.bb) {
								const e$1 = t$1.layers[p$1.decode(s$4.sourceLayerIndex)];
								s$4.setEvaluatedPortalGraph(i$2, e$1, this.tileID.canonical, b$1.availableImages, b$1.brightness);
							}
						}
						f$1();
					};
					x$1.length > 0 ? Promise.allSettled(x$1).then(I$1).catch(u$1) : I$1();
				}
				updateParameters(t$1) {
					this.scaleFactor = t$1.scaleFactor, this.showCollisionBoxes = t$1.showCollisionBoxes, this.projection = t$1.projection, this.brightness = t$1.brightness, this.tileTransform = e.aZ(t$1.tileID.canonical, t$1.projection), this.extraShadowCaster = t$1.extraShadowCaster, this.lut = t$1.lut, this.worldview = t$1.worldview, this.indoor = t$1.indoor;
				}
				rasterizeIfNeeded(e$1, t$1, s$1, i$1) {
					Array.from(t$1.values()).some(((e$2) => e$2.usvg)) ? this.rasterize(e$1, t$1, s$1, i$1) : i$1();
				}
				updateImageMapAndGetImageTaskQueue(e$1, t$1, s$1) {
					const i$1 = /* @__PURE__ */ new Map();
					for (const o$1 of t$1.keys()) {
						const n$1 = s$1.get(o$1) || [];
						for (const s$2 of n$1) {
							const o$2 = s$2.toString(), n$2 = t$1.get(s$2.id.toString());
							n$2.usvg ? i$1.has(o$2) || (i$1.set(o$2, s$2), e$1.set(o$2, Object.assign({}, n$2))) : e$1.set(o$2, n$2);
						}
					}
					return i$1;
				}
				rasterize(e$1, t$1, s$1, i$1) {
					this.rasterizeTask = e$1.send("rasterizeImages", {
						scope: this.scope,
						tasks: s$1
					}, ((e$2, s$2) => {
						if (!e$2) for (const [e$3, i$2] of s$2.entries()) {
							const s$3 = Object.assign(t$1.get(e$3), { data: i$2 });
							t$1.set(e$3, s$3);
						}
						i$1();
					}));
				}
				cancelRasterize() {
					this.rasterizeTask && this.rasterizeTask.cancel();
				}
			}
			function g(t$1, s$1, i$1, o$1, n$1) {
				const r$1 = new e.ac(s$1, {
					brightness: i$1,
					worldview: n$1
				});
				for (const e$1 of t$1) e$1.recalculate(r$1, o$1);
			}
			class m extends e.E {
				constructor(t$1, s$1, i$1, o$1, n$1, r$1, a$1) {
					super(), this.actor = t$1, this.layerIndex = s$1, this.availableImages = i$1, this.availableModels = o$1, this.loadVectorData = r$1 || e.aL, this.loading = {}, this.loaded = {}, this.deduped = new e.aK(t$1.scheduler), this.isSpriteLoaded = n$1, this.scheduler = t$1.scheduler, this.brightness = a$1;
				}
				loadTile(s$1, i$1) {
					const o$1 = s$1.uid, n$1 = s$1 && s$1.request, r$1 = n$1 && n$1.collectResourceTiming, a$1 = this.loading[o$1] = new p(s$1);
					a$1.abort = this.loadVectorData(s$1, ((l$1, c$1) => {
						const h$1 = !this.loading[o$1];
						if (delete this.loading[o$1], a$1.cancelRasterize(), h$1 || l$1 || !c$1) return a$1.status = "done", h$1 || (this.loaded[o$1] = a$1), i$1(l$1);
						const u$1 = c$1.rawData, d$1 = {}, f$1 = e.aM(c$1.responseHeaders);
						f$1 && f$1.expires && (d$1.expires = f$1.expires), f$1 && f$1.cacheControl && (d$1.cacheControl = f$1.cacheControl), a$1.vectorTile = c$1.vectorTile || new e.fz(new e.bt(u$1));
						const p$1 = () => {
							a$1.parse(a$1.vectorTile, this.layerIndex, this.availableImages, this.availableModels, this.actor, ((e$1, s$2) => {
								if (e$1 || !s$2) return i$1(e$1);
								const o$2 = {};
								if (r$1) {
									const e$2 = t(n$1);
									e$2.length > 0 && (o$2.resourceTiming = JSON.parse(JSON.stringify(e$2)));
								}
								i$1(null, Object.assign({
									rawTileData: u$1.slice(0),
									responseHeaders: c$1.responseHeaders
								}, s$2, d$1, o$2));
							}));
						};
						this.isSpriteLoaded ? p$1() : this.once("isSpriteLoaded", (() => {
							this.scheduler ? this.scheduler.add(p$1, {
								type: "parseTile",
								isSymbolTile: s$1.isSymbolTile,
								zoom: s$1.tileZoom
							}) : p$1();
						})), this.loaded = this.loaded || {}, this.loaded[o$1] = a$1;
					}));
				}
				reloadTile(e$1, t$1) {
					const s$1 = this.loaded, i$1 = e$1.uid;
					if (s$1 && s$1[i$1]) {
						const o$1 = s$1[i$1];
						o$1.updateParameters(e$1);
						const n$1 = (e$2, s$2) => {
							const i$2 = o$1.reloadCallback;
							i$2 && (delete o$1.reloadCallback, o$1.parse(o$1.vectorTile, this.layerIndex, this.availableImages, this.availableModels, this.actor, i$2)), t$1(e$2, s$2);
						};
						"parsing" === o$1.status ? o$1.reloadCallback = n$1 : "done" === o$1.status && (o$1.vectorTile ? o$1.parse(o$1.vectorTile, this.layerIndex, this.availableImages, this.availableModels, this.actor, n$1) : n$1());
					} else t$1(null, void 0);
				}
				abortTile(e$1, t$1) {
					const s$1 = e$1.uid, i$1 = this.loading[s$1];
					i$1 && (i$1.abort && i$1.abort(), delete this.loading[s$1]), t$1();
				}
				removeTile(e$1, t$1) {
					const s$1 = this.loaded, i$1 = e$1.uid;
					s$1 && s$1[i$1] && delete s$1[i$1], t$1();
				}
			}
			class y {
				loadTile(t$1, s$1) {
					const { uid: i$1, encoding: o$1, rawImageData: n$1, padding: r$1 } = t$1, a$1 = ImageBitmap && n$1 instanceof ImageBitmap ? this.getImageData(n$1, r$1) : n$1;
					s$1(null, new e.fA(i$1, a$1, o$1, r$1 < 1));
				}
				reloadTile(e$1, t$1) {
					t$1(null, null);
				}
				abortTile(e$1, t$1) {
					t$1();
				}
				removeTile(e$1, t$1) {
					t$1();
				}
				getImageData(e$1, t$1) {
					this.offscreenCanvas && this.offscreenCanvasContext || (this.offscreenCanvas = new OffscreenCanvas(e$1.width, e$1.height), this.offscreenCanvasContext = this.offscreenCanvas.getContext("2d", { willReadFrequently: !0 })), this.offscreenCanvas.width = e$1.width, this.offscreenCanvas.height = e$1.height, this.offscreenCanvasContext.drawImage(e$1, 0, 0, e$1.width, e$1.height);
					const s$1 = this.offscreenCanvasContext.getImageData(-t$1, -t$1, e$1.width + 2 * t$1, e$1.height + 2 * t$1);
					return this.offscreenCanvasContext.clearRect(0, 0, this.offscreenCanvas.width, this.offscreenCanvas.height), s$1;
				}
			}
			e.bs.setPbf(e.bt);
			class w {
				constructor(t$1) {
					this._mrt = new e.bs(t$1.partial ? 30 : Infinity), this._isHeaderLoaded = !1, this.uid = t$1.uid, this.tileID = t$1.tileID, this.source = t$1.source;
				}
				parse(t$1, s$1) {
					const i$1 = this._mrt;
					this.status = "parsing", this._entireBuffer = t$1;
					try {
						i$1.parseHeader(t$1), this._isHeaderLoaded = !0;
						const o$1 = [];
						for (const s$2 in i$1.layers) {
							const n$1 = i$1.getLayer(s$2), r$1 = n$1.getDataRange(n$1.getBandList()), a$1 = i$1.createDecodingTask(r$1), l$1 = t$1.slice(r$1.firstByte, r$1.lastByte + 1), c$1 = e.bs.performDecoding(l$1, a$1).then(((e$1) => a$1.complete(null, e$1))).catch(((e$1) => a$1.complete(e$1, null)));
							o$1.push(c$1);
						}
						Promise.allSettled(o$1).then((() => s$1(null, i$1))).catch(((e$1) => s$1(e$1)));
					} catch (e$1) {
						s$1(e$1);
					}
				}
			}
			class b {
				constructor(e$1) {
					this.actor = e$1, this.loading = {}, this.loaded = {};
				}
				loadTile(t$1, s$1) {
					const i$1 = t$1.uid, o$1 = t$1.request, n$1 = this.loading[i$1] = new w(t$1), { cancel: r$1 } = e.bu(o$1, ((e$1, t$2, o$2) => {
						const r$2 = !this.loading[i$1];
						if (delete this.loading[i$1], r$2 || e$1 || !t$2) return n$1.status = "done", r$2 || (this.loaded[i$1] = n$1), s$1(e$1);
						n$1.parse(t$2, ((e$2, t$3) => {
							if (e$2 || !t$3) return s$1(e$2);
							s$1(null, t$3, o$2);
						})), this.loaded[i$1] = n$1;
					}));
					n$1.abort = r$1;
				}
				reloadTile(e$1, t$1) {
					t$1(null, void 0);
				}
				abortTile(e$1, t$1) {
					const s$1 = e$1.uid, i$1 = this.loading[s$1];
					i$1 && (i$1.abort && i$1.abort(), delete this.loading[s$1]), t$1();
				}
				removeTile(e$1, t$1) {
					const s$1 = e$1.uid;
					this.loaded[s$1] && delete this.loaded[s$1], t$1();
				}
				decodeRasterArray(t$1, s$1) {
					e.bs.performDecoding(t$1.buffer, t$1.task).then(((e$1) => s$1(null, e$1))).catch(((e$1) => s$1(e$1)));
				}
			}
			const x = e.fB.prototype.toGeoJSON;
			class v {
				constructor(t$1) {
					this._feature = t$1, this.extent = e.al, this.type = t$1.type, this.properties = t$1.tags, "id" in t$1 && !isNaN(t$1.id) && (this.id = parseInt(t$1.id, 10));
				}
				loadGeometry() {
					if (1 === this._feature.type) {
						const t$1 = [];
						for (const s$1 of this._feature.geometry) t$1.push([new e.P(s$1[0], s$1[1])]);
						return t$1;
					}
					{
						const t$1 = [];
						for (const s$1 of this._feature.geometry) {
							const i$1 = [];
							for (const t$2 of s$1) i$1.push(new e.P(t$2[0], t$2[1]));
							t$1.push(i$1);
						}
						return t$1;
					}
				}
				toGeoJSON(e$1, t$1, s$1) {
					return x.call(this, e$1, t$1, s$1);
				}
			}
			class I {
				constructor(t$1, s$1) {
					this.name = t$1, this.extent = e.al, this.length = s$1.length, this._jsonFeatures = s$1;
				}
				feature(e$1) {
					return new v(this._jsonFeatures[e$1]);
				}
			}
			class S {
				constructor(t$1) {
					this.layers = {}, this.extent = e.al;
					for (const e$1 of Object.keys(t$1)) this.layers[e$1] = new I(e$1, t$1[e$1]);
				}
			}
			const M = 64 / 4096, P = 128;
			class T {
				constructor() {
					this.features = /* @__PURE__ */ new Map();
				}
				clear() {
					this.features.clear();
				}
				load(e$1 = [], t$1) {
					for (const s$1 of e$1) {
						const e$2 = s$1.id;
						if (null == e$2) continue;
						let i$1 = this.features.get(e$2);
						i$1 && this.updateCache(i$1, t$1), s$1.geometry ? (i$1 = k(s$1), this.updateCache(i$1, t$1), this.features.set(e$2, i$1)) : this.features.delete(e$2), this.updateCache(i$1, t$1);
					}
				}
				updateCache(e$1, t$1) {
					for (const { canonical: s$1, uid: i$1 } of Object.values(t$1)) {
						const { z: o$1, x: n$1, y: r$1 } = s$1;
						_(e$1, Math.pow(2, o$1), n$1, r$1) && delete t$1[i$1];
					}
				}
				getTile(e$1, t$1, s$1) {
					const i$1 = Math.pow(2, e$1), o$1 = [];
					for (const e$2 of this.features.values()) _(e$2, i$1, t$1, s$1) && o$1.push(D(e$2, i$1, t$1, s$1));
					return { features: o$1 };
				}
				getFeatures() {
					return [...this.features.values()];
				}
			}
			function _({ minX: e$1, minY: t$1, maxX: s$1, maxY: i$1 }, o$1, n$1, r$1) {
				return e$1 < (n$1 + 1 + M) / o$1 && t$1 < (r$1 + 1 + M) / o$1 && s$1 > (n$1 - M) / o$1 && i$1 > (r$1 - M) / o$1;
			}
			function k(e$1) {
				const { id: t$1, geometry: s$1, properties: i$1 } = e$1;
				if (!s$1) return;
				if ("GeometryCollection" === s$1.type) throw new Error("GeometryCollection not supported in dynamic mode.");
				const { type: o$1, coordinates: n$1 } = s$1, r$1 = {
					id: t$1,
					type: 1,
					geometry: [],
					tags: i$1,
					minX: Infinity,
					minY: Infinity,
					maxX: -Infinity,
					maxY: -Infinity
				}, a$1 = r$1.geometry;
				if ("Point" === o$1) L(n$1, a$1, r$1);
				else if ("MultiPoint" === o$1) for (const e$2 of n$1) L(e$2, a$1, r$1);
				else if ("LineString" === o$1) r$1.type = 2, z(n$1, a$1, r$1);
				else if ("MultiLineString" === o$1) r$1.type = 2, C(n$1, a$1, r$1);
				else if ("Polygon" === o$1) r$1.type = 3, C(n$1, a$1, r$1, !0);
				else {
					if ("MultiPolygon" !== o$1) throw new Error("Input data is not a valid GeoJSON object.");
					r$1.type = 3;
					for (const e$2 of n$1) C(e$2, a$1, r$1, !0);
				}
				return r$1;
			}
			function L([t$1, s$1], i$1, o$1) {
				const n$1 = e.aF(t$1);
				let r$1 = e.aJ(s$1);
				r$1 = r$1 < 0 ? 0 : r$1 > 1 ? 1 : r$1, i$1.push(n$1, r$1), o$1.minX = Math.min(o$1.minX, n$1), o$1.minY = Math.min(o$1.minY, r$1), o$1.maxX = Math.max(o$1.maxX, n$1), o$1.maxY = Math.max(o$1.maxY, r$1);
			}
			function z(e$1, t$1, s$1, i$1 = !1, o$1 = !1) {
				const n$1 = [];
				for (const t$2 of e$1) L(t$2, n$1, s$1);
				t$1.push(n$1), i$1 && function(e$2, t$2) {
					let s$2 = 0;
					for (let t$3 = 0, i$2 = e$2.length, o$2 = i$2 - 2; t$3 < i$2; o$2 = t$3, t$3 += 2) s$2 += (e$2[t$3] - e$2[o$2]) * (e$2[t$3 + 1] + e$2[o$2 + 1]);
					if (s$2 > 0 === t$2) for (let t$3 = 0, s$3 = e$2.length; t$3 < s$3 / 2; t$3 += 2) {
						const i$2 = e$2[t$3], o$2 = e$2[t$3 + 1];
						e$2[t$3] = e$2[s$3 - 2 - t$3], e$2[t$3 + 1] = e$2[s$3 - 1 - t$3], e$2[s$3 - 2 - t$3] = i$2, e$2[s$3 - 1 - t$3] = o$2;
					}
				}(n$1, o$1);
			}
			function C(e$1, t$1, s$1, i$1 = !1) {
				for (let o$1 = 0; o$1 < e$1.length; o$1++) z(e$1[o$1], t$1, s$1, i$1, 0 === o$1);
			}
			function D(t$1, s$1, i$1, o$1) {
				const { id: n$1, type: r$1, geometry: a$1, tags: l$1 } = t$1, c$1 = [];
				if (1 === r$1) (function(t$2, s$2, i$2, o$2, n$2) {
					for (let r$2 = 0; r$2 < t$2.length; r$2 += 2) {
						const a$2 = Math.round(e.al * (t$2[r$2 + 0] * s$2 - i$2)), l$2 = Math.round(e.al * (t$2[r$2 + 1] * s$2 - o$2));
						n$2.push([a$2, l$2]);
					}
				})(a$1, s$1, i$1, o$1, c$1);
				else if (2 === r$1) for (const e$1 of a$1) j(e$1, s$1, i$1, o$1, c$1);
				else if (3 === r$1) for (const e$1 of a$1) O(e$1, s$1, i$1, o$1, c$1);
				return {
					id: n$1,
					type: r$1,
					geometry: c$1,
					tags: l$1
				};
			}
			function j(t$1, s$1, i$1, o$1, n$1) {
				const r$1 = -P, a$1 = e.al + P;
				let l$1;
				for (let c$1 = 0; c$1 < t$1.length - 2; c$1 += 2) {
					let h$1 = Math.round(e.al * (t$1[c$1 + 0] * s$1 - i$1)), u$1 = Math.round(e.al * (t$1[c$1 + 1] * s$1 - o$1)), d$1 = Math.round(e.al * (t$1[c$1 + 2] * s$1 - i$1)), f$1 = Math.round(e.al * (t$1[c$1 + 3] * s$1 - o$1));
					const p$1 = d$1 - h$1, g$1 = f$1 - u$1;
					h$1 < r$1 && d$1 < r$1 || (h$1 < r$1 ? (u$1 += Math.round(g$1 * ((r$1 - h$1) / p$1)), h$1 = r$1) : d$1 < r$1 && (f$1 = u$1 + Math.round(g$1 * ((r$1 - h$1) / p$1)), d$1 = r$1), u$1 < r$1 && f$1 < r$1 || (u$1 < r$1 ? (h$1 += Math.round(p$1 * ((r$1 - u$1) / g$1)), u$1 = r$1) : f$1 < r$1 && (d$1 = h$1 + Math.round(p$1 * ((r$1 - u$1) / g$1)), f$1 = r$1), h$1 >= a$1 && d$1 >= a$1 || (h$1 >= a$1 ? (u$1 += Math.round(g$1 * ((a$1 - h$1) / p$1)), h$1 = a$1) : d$1 >= a$1 && (f$1 = u$1 + Math.round(g$1 * ((a$1 - h$1) / p$1)), d$1 = a$1), u$1 >= a$1 && f$1 >= a$1 || (u$1 >= a$1 ? (h$1 += Math.round(p$1 * ((a$1 - u$1) / g$1)), u$1 = a$1) : f$1 >= a$1 && (d$1 = h$1 + Math.round(p$1 * ((a$1 - u$1) / g$1)), f$1 = a$1), l$1 && h$1 === l$1[l$1.length - 1][0] && u$1 === l$1[l$1.length - 1][1] || (l$1 = [[h$1, u$1]], n$1.push(l$1)), l$1.push([d$1, f$1])))));
				}
			}
			function O(t$1, s$1, i$1, o$1, n$1) {
				const r$1 = (i$1 - M) / s$1, a$1 = (o$1 - M) / s$1, l$1 = (i$1 + 1 + M) / s$1, c$1 = (o$1 + 1 + M) / s$1;
				function h$1(e$1, t$2) {
					let s$2 = 0;
					return e$1 < r$1 ? s$2 |= 1 : e$1 > l$1 && (s$2 |= 2), t$2 < a$1 ? s$2 |= 4 : t$2 > c$1 && (s$2 |= 8), s$2;
				}
				let u$1 = [];
				for (let e$1 = 1; e$1 <= 8; e$1 *= 2) {
					let s$2 = t$1[t$1.length - 2], i$2 = t$1[t$1.length - 1], o$2 = !(h$1(s$2, i$2) & e$1);
					for (let n$2 = 0; n$2 < t$1.length; n$2 += 2) {
						const d$2 = t$1[n$2], f$1 = t$1[n$2 + 1], p$1 = !(h$1(d$2, f$1) & e$1);
						p$1 !== o$2 && (8 & e$1 ? u$1.push(s$2 + (d$2 - s$2) * (c$1 - i$2) / (f$1 - i$2), c$1) : 4 & e$1 ? u$1.push(s$2 + (d$2 - s$2) * (a$1 - i$2) / (f$1 - i$2), a$1) : 2 & e$1 ? u$1.push(l$1, i$2 + (f$1 - i$2) * (l$1 - s$2) / (d$2 - s$2)) : 1 & e$1 && u$1.push(r$1, i$2 + (f$1 - i$2) * (r$1 - s$2) / (d$2 - s$2))), p$1 && u$1.push(d$2, f$1), s$2 = d$2, i$2 = f$1, o$2 = p$1;
					}
					if (!(t$1 = u$1).length || 8 === e$1) break;
					u$1 = [];
				}
				const d$1 = [];
				for (let t$2 = 0; t$2 < u$1.length; t$2 += 2) d$1.push([Math.round(e.al * (u$1[t$2] * s$1 - i$1)), Math.round(e.al * (u$1[t$2 + 1] * s$1 - o$1))]);
				n$1.push(d$1);
			}
			function F({ name: t$1, features: s$1 }, i$1) {
				i$1.writeStringField(1, t$1), i$1.writeVarintField(5, e.al);
				const o$1 = /* @__PURE__ */ new Map(), n$1 = /* @__PURE__ */ new Map(), r$1 = {
					keys: o$1,
					values: n$1,
					feature: null
				};
				for (const e$1 of s$1) r$1.feature = e$1, i$1.writeMessage(2, A, r$1);
				for (const e$1 of o$1.keys()) i$1.writeStringField(3, e$1);
				for (const e$1 of n$1.keys()) i$1.writeMessage(4, R, e$1);
			}
			function A(e$1, t$1) {
				const s$1 = e$1.feature;
				void 0 !== s$1.id && Number.isSafeInteger(+s$1.id) && t$1.writeVarintField(1, +s$1.id), s$1.tags && t$1.writeMessage(2, Z, e$1), t$1.writeVarintField(3, s$1.type), t$1.writeMessage(4, E, s$1);
			}
			function Z({ keys: e$1, values: t$1, feature: s$1 }, i$1) {
				for (const o$1 of Object.keys(s$1.tags)) {
					let n$1 = s$1.tags[o$1];
					if (null === n$1) continue;
					let r$1 = e$1.get(o$1);
					void 0 === r$1 && (r$1 = e$1.size, e$1.set(o$1, r$1)), i$1.writeVarint(r$1);
					const a$1 = typeof n$1;
					"string" !== a$1 && "boolean" !== a$1 && "number" !== a$1 && (n$1 = JSON.stringify(n$1));
					let l$1 = t$1.get(n$1);
					void 0 === l$1 && (l$1 = t$1.size, t$1.set(n$1, l$1)), i$1.writeVarint(l$1);
				}
			}
			function B(e$1, t$1) {
				return (t$1 << 3) + (7 & e$1);
			}
			function N(e$1) {
				return e$1 << 1 ^ e$1 >> 31;
			}
			function E(e$1, t$1) {
				const { geometry: s$1, type: i$1 } = e$1;
				let o$1 = 0, n$1 = 0;
				if (1 === i$1) {
					t$1.writeVarint(B(1, s$1.length));
					for (const e$2 of s$1) {
						const s$2 = e$2[0] - o$1, i$2 = e$2[1] - n$1;
						t$1.writeVarint(N(s$2)), t$1.writeVarint(N(i$2)), o$1 += s$2, n$1 += i$2;
					}
				} else for (const e$2 of s$1) {
					t$1.writeVarint(B(1, 1));
					const s$2 = e$2.length - (3 === i$1 ? 1 : 0);
					for (let i$2 = 0; i$2 < s$2; i$2++) {
						1 === i$2 && t$1.writeVarint(B(2, s$2 - 1));
						const r$1 = e$2[i$2][0] - o$1, a$1 = e$2[i$2][1] - n$1;
						t$1.writeVarint(N(r$1)), t$1.writeVarint(N(a$1)), o$1 += r$1, n$1 += a$1;
					}
					3 === i$1 && t$1.writeVarint(B(7, 1));
				}
			}
			function R(e$1, t$1) {
				const s$1 = typeof e$1;
				"string" === s$1 ? t$1.writeStringField(1, e$1) : "boolean" === s$1 ? t$1.writeBooleanField(7, e$1) : "number" === s$1 && (e$1 % 1 != 0 ? t$1.writeDoubleField(3, e$1) : e$1 < 0 ? t$1.writeSVarintField(6, e$1) : t$1.writeVarintField(5, e$1));
			}
			const Y = {
				minZoom: 0,
				maxZoom: 16,
				minPoints: 2,
				radius: 40,
				extent: 512,
				nodeSize: 64,
				log: !1,
				generateId: !1,
				reduce: null,
				map: (e$1) => e$1
			}, X = Math.fround || (J = new Float32Array(1), (e$1) => (J[0] = +e$1, J[0]));
			var J;
			const G = 3, H = 5, $ = 6;
			class V {
				constructor(e$1) {
					this.options = Object.assign(Object.create(Y), e$1), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
				}
				load(e$1) {
					const { log: t$1, minZoom: s$1, maxZoom: i$1 } = this.options;
					t$1 && console.time("total time");
					const o$1 = `prepare ${e$1.length} points`;
					t$1 && console.time(o$1), this.points = e$1;
					const n$1 = [];
					for (let t$2 = 0; t$2 < e$1.length; t$2++) {
						const s$2 = e$1[t$2];
						if (!s$2.geometry) continue;
						const [i$2, o$2] = s$2.geometry.coordinates, r$2 = X(W(i$2)), a$1 = X(Q(o$2));
						n$1.push(r$2, a$1, Infinity, t$2, -1, 1), this.options.reduce && n$1.push(0);
					}
					let r$1 = this.trees[i$1 + 1] = this._createTree(n$1);
					t$1 && console.timeEnd(o$1);
					for (let e$2 = i$1; e$2 >= s$1; e$2--) {
						const s$2 = +Date.now();
						r$1 = this.trees[e$2] = this._createTree(this._cluster(r$1, e$2)), t$1 && console.log("z%d: %d clusters in %dms", e$2, r$1.numItems, +Date.now() - s$2);
					}
					return t$1 && console.timeEnd("total time"), this;
				}
				getClusters(e$1, t$1) {
					let s$1 = ((e$1[0] + 180) % 360 + 360) % 360 - 180;
					const i$1 = Math.max(-90, Math.min(90, e$1[1]));
					let o$1 = 180 === e$1[2] ? 180 : ((e$1[2] + 180) % 360 + 360) % 360 - 180;
					const n$1 = Math.max(-90, Math.min(90, e$1[3]));
					if (e$1[2] - e$1[0] >= 360) s$1 = -180, o$1 = 180;
					else if (s$1 > o$1) {
						const e$2 = this.getClusters([
							s$1,
							i$1,
							180,
							n$1
						], t$1), r$2 = this.getClusters([
							-180,
							i$1,
							o$1,
							n$1
						], t$1);
						return e$2.concat(r$2);
					}
					const r$1 = this.trees[this._limitZoom(t$1)], a$1 = r$1.range(W(s$1), Q(n$1), W(o$1), Q(i$1)), l$1 = r$1.data, c$1 = [];
					for (const e$2 of a$1) {
						const t$2 = this.stride * e$2;
						c$1.push(l$1[t$2 + H] > 1 ? U(l$1, t$2, this.clusterProps) : this.points[l$1[t$2 + G]]);
					}
					return c$1;
				}
				getChildren(e$1) {
					const t$1 = this._getOriginId(e$1), s$1 = this._getOriginZoom(e$1), i$1 = "No cluster with the specified id.", o$1 = this.trees[s$1];
					if (!o$1) throw new Error(i$1);
					const n$1 = o$1.data;
					if (t$1 * this.stride >= n$1.length) throw new Error(i$1);
					const r$1 = this.options.radius / (this.options.extent * Math.pow(2, s$1 - 1)), a$1 = o$1.within(n$1[t$1 * this.stride], n$1[t$1 * this.stride + 1], r$1), l$1 = [];
					for (const t$2 of a$1) {
						const s$2 = t$2 * this.stride;
						n$1[s$2 + 4] === e$1 && l$1.push(n$1[s$2 + H] > 1 ? U(n$1, s$2, this.clusterProps) : this.points[n$1[s$2 + G]]);
					}
					if (0 === l$1.length) throw new Error(i$1);
					return l$1;
				}
				getLeaves(e$1, t$1, s$1) {
					const i$1 = [];
					return this._appendLeaves(i$1, e$1, t$1 = t$1 || 10, s$1 = s$1 || 0, 0), i$1;
				}
				getTile(e$1, t$1, s$1) {
					const i$1 = this.trees[this._limitZoom(e$1)], o$1 = Math.pow(2, e$1), { extent: n$1, radius: r$1 } = this.options, a$1 = r$1 / n$1, l$1 = (s$1 - a$1) / o$1, c$1 = (s$1 + 1 + a$1) / o$1, h$1 = { features: [] };
					return this._addTileFeatures(i$1.range((t$1 - a$1) / o$1, l$1, (t$1 + 1 + a$1) / o$1, c$1), i$1.data, t$1, s$1, o$1, h$1), 0 === t$1 && this._addTileFeatures(i$1.range(1 - a$1 / o$1, l$1, 1, c$1), i$1.data, o$1, s$1, o$1, h$1), t$1 === o$1 - 1 && this._addTileFeatures(i$1.range(0, l$1, a$1 / o$1, c$1), i$1.data, -1, s$1, o$1, h$1), h$1.features.length ? h$1 : null;
				}
				getClusterExpansionZoom(e$1) {
					let t$1 = this._getOriginZoom(e$1) - 1;
					for (; t$1 <= this.options.maxZoom;) {
						const s$1 = this.getChildren(e$1);
						if (t$1++, 1 !== s$1.length) break;
						e$1 = s$1[0].properties.cluster_id;
					}
					return t$1;
				}
				_appendLeaves(e$1, t$1, s$1, i$1, o$1) {
					const n$1 = this.getChildren(t$1);
					for (const t$2 of n$1) {
						const n$2 = t$2.properties;
						if (n$2 && n$2.cluster ? o$1 + n$2.point_count <= i$1 ? o$1 += n$2.point_count : o$1 = this._appendLeaves(e$1, n$2.cluster_id, s$1, i$1, o$1) : o$1 < i$1 ? o$1++ : e$1.push(t$2), e$1.length === s$1) break;
					}
					return o$1;
				}
				_createTree(t$1) {
					const s$1 = new e.c4(t$1.length / this.stride | 0, this.options.nodeSize, Float32Array);
					for (let e$1 = 0; e$1 < t$1.length; e$1 += this.stride) s$1.add(t$1[e$1], t$1[e$1 + 1]);
					return s$1.finish(), s$1.data = t$1, s$1;
				}
				_addTileFeatures(e$1, t$1, s$1, i$1, o$1, n$1) {
					for (const r$1 of e$1) {
						const e$2 = r$1 * this.stride, a$1 = t$1[e$2 + H] > 1;
						let l$1, c$1, h$1;
						if (a$1) l$1 = q(t$1, e$2, this.clusterProps), c$1 = t$1[e$2], h$1 = t$1[e$2 + 1];
						else {
							const s$2 = this.points[t$1[e$2 + G]];
							l$1 = s$2.properties;
							const [i$2, o$2] = s$2.geometry.coordinates;
							c$1 = W(i$2), h$1 = Q(o$2);
						}
						const u$1 = {
							type: 1,
							geometry: [[Math.round(this.options.extent * (c$1 * o$1 - s$1)), Math.round(this.options.extent * (h$1 * o$1 - i$1))]],
							tags: l$1
						};
						let d$1;
						d$1 = a$1 || this.options.generateId ? t$1[e$2 + G] : this.points[t$1[e$2 + G]].id, void 0 !== d$1 && (u$1.id = d$1), n$1.features.push(u$1);
					}
				}
				_limitZoom(e$1) {
					return Math.max(this.options.minZoom, Math.min(Math.floor(+e$1), this.options.maxZoom + 1));
				}
				_cluster(e$1, t$1) {
					const { radius: s$1, extent: i$1, reduce: o$1, minPoints: n$1 } = this.options, r$1 = s$1 / (i$1 * Math.pow(2, t$1)), a$1 = e$1.data, l$1 = [], c$1 = this.stride;
					for (let s$2 = 0; s$2 < a$1.length; s$2 += c$1) {
						if (a$1[s$2 + 2] <= t$1) continue;
						a$1[s$2 + 2] = t$1;
						const i$2 = a$1[s$2], h$1 = a$1[s$2 + 1], u$1 = e$1.within(a$1[s$2], a$1[s$2 + 1], r$1), d$1 = a$1[s$2 + H];
						let f$1 = d$1;
						for (const e$2 of u$1) {
							const s$3 = e$2 * c$1;
							a$1[s$3 + 2] > t$1 && (f$1 += a$1[s$3 + H]);
						}
						if (f$1 > d$1 && f$1 >= n$1) {
							let e$2, n$2 = i$2 * d$1, r$2 = h$1 * d$1, p$1 = -1;
							const g$1 = (s$2 / c$1 << 5) + (t$1 + 1) + this.points.length;
							for (const i$3 of u$1) {
								const l$2 = i$3 * c$1;
								if (a$1[l$2 + 2] <= t$1) continue;
								a$1[l$2 + 2] = t$1;
								const h$2 = a$1[l$2 + H];
								n$2 += a$1[l$2] * h$2, r$2 += a$1[l$2 + 1] * h$2, a$1[l$2 + 4] = g$1, o$1 && (e$2 || (e$2 = this._map(a$1, s$2, !0), p$1 = this.clusterProps.length, this.clusterProps.push(e$2)), o$1(e$2, this._map(a$1, l$2)));
							}
							a$1[s$2 + 4] = g$1, l$1.push(n$2 / f$1, r$2 / f$1, Infinity, g$1, -1, f$1), o$1 && l$1.push(p$1);
						} else {
							for (let e$2 = 0; e$2 < c$1; e$2++) l$1.push(a$1[s$2 + e$2]);
							if (f$1 > 1) for (const e$2 of u$1) {
								const s$3 = e$2 * c$1;
								if (!(a$1[s$3 + 2] <= t$1)) {
									a$1[s$3 + 2] = t$1;
									for (let e$3 = 0; e$3 < c$1; e$3++) l$1.push(a$1[s$3 + e$3]);
								}
							}
						}
					}
					return l$1;
				}
				_getOriginId(e$1) {
					return e$1 - this.points.length >> 5;
				}
				_getOriginZoom(e$1) {
					return (e$1 - this.points.length) % 32;
				}
				_map(e$1, t$1, s$1) {
					if (e$1[t$1 + H] > 1) {
						const i$2 = this.clusterProps[e$1[t$1 + $]];
						return s$1 ? Object.assign({}, i$2) : i$2;
					}
					const i$1 = this.points[e$1[t$1 + G]].properties, o$1 = this.options.map(i$1);
					return s$1 && o$1 === i$1 ? Object.assign({}, o$1) : o$1;
				}
			}
			function U(e$1, t$1, s$1) {
				return {
					type: "Feature",
					id: e$1[t$1 + G],
					properties: q(e$1, t$1, s$1),
					geometry: {
						type: "Point",
						coordinates: [(i$1 = e$1[t$1], 360 * (i$1 - .5)), K(e$1[t$1 + 1])]
					}
				};
				var i$1;
			}
			function q(e$1, t$1, s$1) {
				const i$1 = e$1[t$1 + H], o$1 = i$1 >= 1e4 ? `${Math.round(i$1 / 1e3)}k` : i$1 >= 1e3 ? Math.round(i$1 / 100) / 10 + "k" : i$1, n$1 = e$1[t$1 + $], r$1 = -1 === n$1 ? {} : Object.assign({}, s$1[n$1]);
				return Object.assign(r$1, {
					cluster: !0,
					cluster_id: e$1[t$1 + G],
					point_count: i$1,
					point_count_abbreviated: o$1
				});
			}
			function W(e$1) {
				return e$1 / 360 + .5;
			}
			function Q(e$1) {
				const t$1 = Math.sin(e$1 * Math.PI / 180), s$1 = .5 - .25 * Math.log((1 + t$1) / (1 - t$1)) / Math.PI;
				return s$1 < 0 ? 0 : s$1 > 1 ? 1 : s$1;
			}
			function K(e$1) {
				const t$1 = (180 - 360 * e$1) * Math.PI / 180;
				return 360 * Math.atan(Math.exp(t$1)) / Math.PI - 90;
			}
			function ee(e$1, t$1, s$1, i$1) {
				let o$1 = i$1;
				const n$1 = t$1 + (s$1 - t$1 >> 1);
				let r$1, a$1 = s$1 - t$1;
				const l$1 = e$1[t$1], c$1 = e$1[t$1 + 1], h$1 = e$1[s$1], u$1 = e$1[s$1 + 1];
				for (let i$2 = t$1 + 3; i$2 < s$1; i$2 += 3) {
					const t$2 = te(e$1[i$2], e$1[i$2 + 1], l$1, c$1, h$1, u$1);
					if (t$2 > o$1) r$1 = i$2, o$1 = t$2;
					else if (t$2 === o$1) {
						const e$2 = Math.abs(i$2 - n$1);
						e$2 < a$1 && (r$1 = i$2, a$1 = e$2);
					}
				}
				o$1 > i$1 && (r$1 - t$1 > 3 && ee(e$1, t$1, r$1, i$1), e$1[r$1 + 2] = o$1, s$1 - r$1 > 3 && ee(e$1, r$1, s$1, i$1));
			}
			function te(e$1, t$1, s$1, i$1, o$1, n$1) {
				let r$1 = o$1 - s$1, a$1 = n$1 - i$1;
				if (0 !== r$1 || 0 !== a$1) {
					const l$1 = ((e$1 - s$1) * r$1 + (t$1 - i$1) * a$1) / (r$1 * r$1 + a$1 * a$1);
					l$1 > 1 ? (s$1 = o$1, i$1 = n$1) : l$1 > 0 && (s$1 += r$1 * l$1, i$1 += a$1 * l$1);
				}
				return r$1 = e$1 - s$1, a$1 = t$1 - i$1, r$1 * r$1 + a$1 * a$1;
			}
			function se(e$1, t$1, s$1, i$1) {
				const o$1 = {
					id: e$1 ?? null,
					type: t$1,
					geometry: s$1,
					tags: i$1,
					minX: Infinity,
					minY: Infinity,
					maxX: -Infinity,
					maxY: -Infinity
				};
				if ("Point" === t$1 || "MultiPoint" === t$1 || "LineString" === t$1) ie(o$1, s$1);
				else if ("Polygon" === t$1) ie(o$1, s$1[0]);
				else if ("MultiLineString" === t$1) for (const e$2 of s$1) ie(o$1, e$2);
				else if ("MultiPolygon" === t$1) for (const e$2 of s$1) ie(o$1, e$2[0]);
				return o$1;
			}
			function ie(e$1, t$1) {
				for (let s$1 = 0; s$1 < t$1.length; s$1 += 3) e$1.minX = Math.min(e$1.minX, t$1[s$1]), e$1.minY = Math.min(e$1.minY, t$1[s$1 + 1]), e$1.maxX = Math.max(e$1.maxX, t$1[s$1]), e$1.maxY = Math.max(e$1.maxY, t$1[s$1 + 1]);
			}
			function oe(e$1, t$1, s$1, i$1) {
				if (!t$1.geometry) return;
				const o$1 = t$1.geometry.coordinates;
				if (o$1 && 0 === o$1.length) return;
				const n$1 = t$1.geometry.type, r$1 = Math.pow(s$1.tolerance / ((1 << s$1.maxZoom) * s$1.extent), 2);
				let a$1 = [], l$1 = t$1.id;
				if (s$1.promoteId ? l$1 = t$1.properties[s$1.promoteId] : s$1.generateId && (l$1 = i$1 || 0), "Point" === n$1) ne(o$1, a$1);
				else if ("MultiPoint" === n$1) for (const e$2 of o$1) ne(e$2, a$1);
				else if ("LineString" === n$1) re(o$1, a$1, r$1, !1);
				else if ("MultiLineString" === n$1) {
					if (s$1.lineMetrics) {
						for (const s$2 of o$1) a$1 = [], re(s$2, a$1, r$1, !1), e$1.push(se(l$1, "LineString", a$1, t$1.properties));
						return;
					}
					ae(o$1, a$1, r$1, !1);
				} else if ("Polygon" === n$1) ae(o$1, a$1, r$1, !0);
				else {
					if ("MultiPolygon" !== n$1) {
						if ("GeometryCollection" === n$1) {
							for (const o$2 of t$1.geometry.geometries) oe(e$1, {
								id: l$1,
								geometry: o$2,
								properties: t$1.properties
							}, s$1, i$1);
							return;
						}
						throw new Error("Input data is not a valid GeoJSON object.");
					}
					for (const e$2 of o$1) {
						const t$2 = [];
						ae(e$2, t$2, r$1, !0), a$1.push(t$2);
					}
				}
				e$1.push(se(l$1, n$1, a$1, t$1.properties));
			}
			function ne(e$1, t$1) {
				t$1.push(le(e$1[0]), ce(e$1[1]), 0);
			}
			function re(e$1, t$1, s$1, i$1) {
				let o$1, n$1, r$1 = 0;
				for (let s$2 = 0; s$2 < e$1.length; s$2++) {
					const a$2 = le(e$1[s$2][0]), l$1 = ce(e$1[s$2][1]);
					t$1.push(a$2, l$1, 0), s$2 > 0 && (r$1 += i$1 ? (o$1 * l$1 - a$2 * n$1) / 2 : Math.sqrt(Math.pow(a$2 - o$1, 2) + Math.pow(l$1 - n$1, 2))), o$1 = a$2, n$1 = l$1;
				}
				const a$1 = t$1.length - 3;
				t$1[2] = 1, ee(t$1, 0, a$1, s$1), t$1[a$1 + 2] = 1, t$1.size = Math.abs(r$1), t$1.start = 0, t$1.end = t$1.size;
			}
			function ae(e$1, t$1, s$1, i$1) {
				for (let o$1 = 0; o$1 < e$1.length; o$1++) {
					const n$1 = [];
					re(e$1[o$1], n$1, s$1, i$1), t$1.push(n$1);
				}
			}
			function le(e$1) {
				return e$1 / 360 + .5;
			}
			function ce(e$1) {
				const t$1 = Math.sin(e$1 * Math.PI / 180), s$1 = .5 - .25 * Math.log((1 + t$1) / (1 - t$1)) / Math.PI;
				return s$1 < 0 ? 0 : s$1 > 1 ? 1 : s$1;
			}
			function he(e$1, t$1, s$1, i$1, o$1, n$1, r$1, a$1) {
				if (i$1 /= t$1, n$1 >= (s$1 /= t$1) && r$1 < i$1) return e$1;
				if (r$1 < s$1 || n$1 >= i$1) return null;
				const l$1 = [];
				for (const t$2 of e$1) {
					const e$2 = t$2.geometry;
					let n$2 = t$2.type;
					const r$2 = 0 === o$1 ? t$2.minX : t$2.minY, c$1 = 0 === o$1 ? t$2.maxX : t$2.maxY;
					if (r$2 >= s$1 && c$1 < i$1) {
						l$1.push(t$2);
						continue;
					}
					if (c$1 < s$1 || r$2 >= i$1) continue;
					let h$1 = [];
					if ("Point" === n$2 || "MultiPoint" === n$2) ue(e$2, h$1, s$1, i$1, o$1);
					else if ("LineString" === n$2) de(e$2, h$1, s$1, i$1, o$1, !1, a$1.lineMetrics);
					else if ("MultiLineString" === n$2) pe(e$2, h$1, s$1, i$1, o$1, !1);
					else if ("Polygon" === n$2) pe(e$2, h$1, s$1, i$1, o$1, !0);
					else if ("MultiPolygon" === n$2) for (const t$3 of e$2) {
						const e$3 = [];
						pe(t$3, e$3, s$1, i$1, o$1, !0), e$3.length && h$1.push(e$3);
					}
					if (h$1.length) {
						if (a$1.lineMetrics && "LineString" === n$2) {
							for (const e$3 of h$1) l$1.push(se(t$2.id, n$2, e$3, t$2.tags));
							continue;
						}
						"LineString" !== n$2 && "MultiLineString" !== n$2 || (1 === h$1.length ? (n$2 = "LineString", h$1 = h$1[0]) : n$2 = "MultiLineString"), "Point" !== n$2 && "MultiPoint" !== n$2 || (n$2 = 3 === h$1.length ? "Point" : "MultiPoint"), l$1.push(se(t$2.id, n$2, h$1, t$2.tags));
					}
				}
				return l$1.length ? l$1 : null;
			}
			function ue(e$1, t$1, s$1, i$1, o$1) {
				for (let n$1 = 0; n$1 < e$1.length; n$1 += 3) {
					const r$1 = e$1[n$1 + o$1];
					r$1 >= s$1 && r$1 <= i$1 && ge(t$1, e$1[n$1], e$1[n$1 + 1], e$1[n$1 + 2]);
				}
			}
			function de(e$1, t$1, s$1, i$1, o$1, n$1, r$1) {
				let a$1 = fe(e$1);
				const l$1 = 0 === o$1 ? me : ye;
				let c$1, h$1, u$1 = e$1.start;
				for (let d$2 = 0; d$2 < e$1.length - 3; d$2 += 3) {
					const f$2 = e$1[d$2], p$2 = e$1[d$2 + 1], g$2 = e$1[d$2 + 2], m$1 = e$1[d$2 + 3], y$1 = e$1[d$2 + 4], w$1 = 0 === o$1 ? f$2 : p$2, b$1 = 0 === o$1 ? m$1 : y$1;
					let x$1 = !1;
					r$1 && (c$1 = Math.sqrt(Math.pow(f$2 - m$1, 2) + Math.pow(p$2 - y$1, 2))), w$1 < s$1 ? b$1 > s$1 && (h$1 = l$1(a$1, f$2, p$2, m$1, y$1, s$1), r$1 && (a$1.start = u$1 + c$1 * h$1)) : w$1 > i$1 ? b$1 < i$1 && (h$1 = l$1(a$1, f$2, p$2, m$1, y$1, i$1), r$1 && (a$1.start = u$1 + c$1 * h$1)) : ge(a$1, f$2, p$2, g$2), b$1 < s$1 && w$1 >= s$1 && (h$1 = l$1(a$1, f$2, p$2, m$1, y$1, s$1), x$1 = !0), b$1 > i$1 && w$1 <= i$1 && (h$1 = l$1(a$1, f$2, p$2, m$1, y$1, i$1), x$1 = !0), !n$1 && x$1 && (r$1 && (a$1.end = u$1 + c$1 * h$1), t$1.push(a$1), a$1 = fe(e$1)), r$1 && (u$1 += c$1);
				}
				let d$1 = e$1.length - 3;
				const f$1 = e$1[d$1], p$1 = e$1[d$1 + 1], g$1 = 0 === o$1 ? f$1 : p$1;
				g$1 >= s$1 && g$1 <= i$1 && ge(a$1, f$1, p$1, e$1[d$1 + 2]), d$1 = a$1.length - 3, n$1 && d$1 >= 3 && (a$1[d$1] !== a$1[0] || a$1[d$1 + 1] !== a$1[1]) && ge(a$1, a$1[0], a$1[1], a$1[2]), a$1.length && t$1.push(a$1);
			}
			function fe(e$1) {
				const t$1 = [];
				return t$1.size = e$1.size, t$1.start = e$1.start, t$1.end = e$1.end, t$1;
			}
			function pe(e$1, t$1, s$1, i$1, o$1, n$1) {
				for (const r$1 of e$1) de(r$1, t$1, s$1, i$1, o$1, n$1, !1);
			}
			function ge(e$1, t$1, s$1, i$1) {
				e$1.push(t$1, s$1, i$1);
			}
			function me(e$1, t$1, s$1, i$1, o$1, n$1) {
				const r$1 = (n$1 - t$1) / (i$1 - t$1);
				return ge(e$1, n$1, s$1 + (o$1 - s$1) * r$1, 1), r$1;
			}
			function ye(e$1, t$1, s$1, i$1, o$1, n$1) {
				const r$1 = (n$1 - s$1) / (o$1 - s$1);
				return ge(e$1, t$1 + (i$1 - t$1) * r$1, n$1, 1), r$1;
			}
			function we(e$1, t$1) {
				const s$1 = [];
				for (let i$1 = 0; i$1 < e$1.length; i$1++) {
					const o$1 = e$1[i$1], n$1 = o$1.type;
					let r$1;
					if ("Point" === n$1 || "MultiPoint" === n$1 || "LineString" === n$1) r$1 = be(o$1.geometry, t$1);
					else if ("MultiLineString" === n$1 || "Polygon" === n$1) {
						r$1 = [];
						for (const e$2 of o$1.geometry) r$1.push(be(e$2, t$1));
					} else if ("MultiPolygon" === n$1) {
						r$1 = [];
						for (const e$2 of o$1.geometry) {
							const s$2 = [];
							for (const i$2 of e$2) s$2.push(be(i$2, t$1));
							r$1.push(s$2);
						}
					}
					s$1.push(se(o$1.id, n$1, r$1, o$1.tags));
				}
				return s$1;
			}
			function be(e$1, t$1) {
				const s$1 = [];
				s$1.size = e$1.size, void 0 !== e$1.start && (s$1.start = e$1.start, s$1.end = e$1.end);
				for (let i$1 = 0; i$1 < e$1.length; i$1 += 3) s$1.push(e$1[i$1] + t$1, e$1[i$1 + 1], e$1[i$1 + 2]);
				return s$1;
			}
			function xe(e$1, t$1) {
				if (e$1.transformed) return e$1;
				const s$1 = 1 << e$1.z, i$1 = e$1.x, o$1 = e$1.y;
				for (const n$1 of e$1.features) {
					const e$2 = n$1.geometry, r$1 = n$1.type;
					if (n$1.geometry = [], 1 === r$1) for (let r$2 = 0; r$2 < e$2.length; r$2 += 2) n$1.geometry.push(ve(e$2[r$2], e$2[r$2 + 1], t$1, s$1, i$1, o$1));
					else for (let r$2 = 0; r$2 < e$2.length; r$2++) {
						const a$1 = [];
						for (let n$2 = 0; n$2 < e$2[r$2].length; n$2 += 2) a$1.push(ve(e$2[r$2][n$2], e$2[r$2][n$2 + 1], t$1, s$1, i$1, o$1));
						n$1.geometry.push(a$1);
					}
				}
				return e$1.transformed = !0, e$1;
			}
			function ve(e$1, t$1, s$1, i$1, o$1, n$1) {
				return [Math.round(s$1 * (e$1 * i$1 - o$1)), Math.round(s$1 * (t$1 * i$1 - n$1))];
			}
			function Ie(e$1, t$1, s$1, i$1, o$1) {
				const n$1 = t$1 === o$1.maxZoom ? 0 : o$1.tolerance / ((1 << t$1) * o$1.extent), r$1 = {
					features: [],
					numPoints: 0,
					numSimplified: 0,
					numFeatures: e$1.length,
					source: null,
					x: s$1,
					y: i$1,
					z: t$1,
					transformed: !1,
					minX: 2,
					minY: 1,
					maxX: -1,
					maxY: 0
				};
				for (const t$2 of e$1) Se(r$1, t$2, n$1, o$1);
				return r$1;
			}
			function Se(e$1, t$1, s$1, i$1) {
				const o$1 = t$1.geometry, n$1 = t$1.type, r$1 = [];
				if (e$1.minX = Math.min(e$1.minX, t$1.minX), e$1.minY = Math.min(e$1.minY, t$1.minY), e$1.maxX = Math.max(e$1.maxX, t$1.maxX), e$1.maxY = Math.max(e$1.maxY, t$1.maxY), "Point" === n$1 || "MultiPoint" === n$1) for (let t$2 = 0; t$2 < o$1.length; t$2 += 3) r$1.push(o$1[t$2], o$1[t$2 + 1]), e$1.numPoints++, e$1.numSimplified++;
				else if ("LineString" === n$1) Me(r$1, o$1, e$1, s$1, !1, !1);
				else if ("MultiLineString" === n$1 || "Polygon" === n$1) for (let t$2 = 0; t$2 < o$1.length; t$2++) Me(r$1, o$1[t$2], e$1, s$1, "Polygon" === n$1, 0 === t$2);
				else if ("MultiPolygon" === n$1) for (let t$2 = 0; t$2 < o$1.length; t$2++) {
					const i$2 = o$1[t$2];
					for (let t$3 = 0; t$3 < i$2.length; t$3++) Me(r$1, i$2[t$3], e$1, s$1, !0, 0 === t$3);
				}
				if (r$1.length) {
					let s$2 = t$1.tags || null;
					if ("LineString" === n$1 && i$1.lineMetrics) {
						s$2 = {};
						for (const e$2 in t$1.tags) s$2[e$2] = t$1.tags[e$2];
						s$2.mapbox_clip_start = o$1.start / o$1.size, s$2.mapbox_clip_end = o$1.end / o$1.size;
					}
					const a$1 = {
						geometry: r$1,
						type: "Polygon" === n$1 || "MultiPolygon" === n$1 ? 3 : "LineString" === n$1 || "MultiLineString" === n$1 ? 2 : 1,
						tags: s$2
					};
					null !== t$1.id && (a$1.id = t$1.id), e$1.features.push(a$1);
				}
			}
			function Me(e$1, t$1, s$1, i$1, o$1, n$1) {
				const r$1 = i$1 * i$1;
				if (i$1 > 0 && t$1.size < (o$1 ? r$1 : i$1)) return void (s$1.numPoints += t$1.length / 3);
				const a$1 = [];
				for (let e$2 = 0; e$2 < t$1.length; e$2 += 3) (0 === i$1 || t$1[e$2 + 2] > r$1) && (s$1.numSimplified++, a$1.push(t$1[e$2], t$1[e$2 + 1])), s$1.numPoints++;
				o$1 && function(e$2, t$2) {
					let s$2 = 0;
					for (let t$3 = 0, i$2 = e$2.length, o$2 = i$2 - 2; t$3 < i$2; o$2 = t$3, t$3 += 2) s$2 += (e$2[t$3] - e$2[o$2]) * (e$2[t$3 + 1] + e$2[o$2 + 1]);
					if (s$2 > 0 === t$2) for (let t$3 = 0, s$3 = e$2.length; t$3 < s$3 / 2; t$3 += 2) {
						const i$2 = e$2[t$3], o$2 = e$2[t$3 + 1];
						e$2[t$3] = e$2[s$3 - 2 - t$3], e$2[t$3 + 1] = e$2[s$3 - 1 - t$3], e$2[s$3 - 2 - t$3] = i$2, e$2[s$3 - 1 - t$3] = o$2;
					}
				}(a$1, n$1), e$1.push(a$1);
			}
			const Pe = {
				maxZoom: 14,
				indexMaxZoom: 5,
				indexMaxPoints: 1e5,
				tolerance: 3,
				extent: 4096,
				buffer: 64,
				lineMetrics: !1,
				promoteId: null,
				generateId: !1,
				debug: 0
			};
			class Te {
				constructor(e$1, t$1) {
					const s$1 = (t$1 = this.options = function(e$2, t$2) {
						for (const s$2 in t$2) e$2[s$2] = t$2[s$2];
						return e$2;
					}(Object.create(Pe), t$1)).debug;
					if (s$1 && console.time("preprocess data"), t$1.maxZoom < 0 || t$1.maxZoom > 24) throw new Error("maxZoom should be in the 0-24 range");
					if (t$1.promoteId && t$1.generateId) throw new Error("promoteId and generateId cannot be used together.");
					let i$1 = function(e$2, t$2) {
						const s$2 = [];
						if ("FeatureCollection" === e$2.type) for (let i$2 = 0; i$2 < e$2.features.length; i$2++) oe(s$2, e$2.features[i$2], t$2, i$2);
						else oe(s$2, "Feature" === e$2.type ? e$2 : { geometry: e$2 }, t$2);
						return s$2;
					}(e$1, t$1);
					this.tiles = {}, this.tileCoords = [], s$1 && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", t$1.indexMaxZoom, t$1.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), i$1 = function(e$2, t$2) {
						const s$2 = t$2.buffer / t$2.extent;
						let i$2 = e$2;
						const o$1 = he(e$2, 1, -1 - s$2, s$2, 0, -1, 2, t$2), n$1 = he(e$2, 1, 1 - s$2, 2 + s$2, 0, -1, 2, t$2);
						return (o$1 || n$1) && (i$2 = he(e$2, 1, -s$2, 1 + s$2, 0, -1, 2, t$2) || [], o$1 && (i$2 = we(o$1, 1).concat(i$2)), n$1 && (i$2 = i$2.concat(we(n$1, -1)))), i$2;
					}(i$1, t$1), i$1.length && this.splitTile(i$1, 0, 0, 0), s$1 && (i$1.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)));
				}
				splitTile(e$1, t$1, s$1, i$1, o$1, n$1, r$1) {
					const a$1 = [
						e$1,
						t$1,
						s$1,
						i$1
					], l$1 = this.options, c$1 = l$1.debug;
					for (; a$1.length;) {
						i$1 = a$1.pop(), s$1 = a$1.pop(), t$1 = a$1.pop(), e$1 = a$1.pop();
						const h$1 = 1 << t$1, u$1 = _e(t$1, s$1, i$1);
						let d$1 = this.tiles[u$1];
						if (!d$1 && (c$1 > 1 && console.time("creation"), d$1 = this.tiles[u$1] = Ie(e$1, t$1, s$1, i$1, l$1), this.tileCoords.push({
							z: t$1,
							x: s$1,
							y: i$1
						}), c$1)) {
							c$1 > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", t$1, s$1, i$1, d$1.numFeatures, d$1.numPoints, d$1.numSimplified), console.timeEnd("creation"));
							const e$2 = `z${t$1}`;
							this.stats[e$2] = (this.stats[e$2] || 0) + 1, this.total++;
						}
						if (d$1.source = e$1, null == o$1) {
							if (t$1 === l$1.indexMaxZoom || d$1.numPoints <= l$1.indexMaxPoints) continue;
						} else {
							if (t$1 === l$1.maxZoom || t$1 === o$1) continue;
							if (null != o$1) {
								const e$2 = o$1 - t$1;
								if (s$1 !== n$1 >> e$2 || i$1 !== r$1 >> e$2) continue;
							}
						}
						if (d$1.source = null, 0 === e$1.length) continue;
						c$1 > 1 && console.time("clipping");
						const f$1 = .5 * l$1.buffer / l$1.extent, p$1 = .5 - f$1, g$1 = .5 + f$1, m$1 = 1 + f$1;
						let y$1 = null, w$1 = null, b$1 = null, x$1 = null, v$1 = he(e$1, h$1, s$1 - f$1, s$1 + g$1, 0, d$1.minX, d$1.maxX, l$1), I$1 = he(e$1, h$1, s$1 + p$1, s$1 + m$1, 0, d$1.minX, d$1.maxX, l$1);
						e$1 = null, v$1 && (y$1 = he(v$1, h$1, i$1 - f$1, i$1 + g$1, 1, d$1.minY, d$1.maxY, l$1), w$1 = he(v$1, h$1, i$1 + p$1, i$1 + m$1, 1, d$1.minY, d$1.maxY, l$1), v$1 = null), I$1 && (b$1 = he(I$1, h$1, i$1 - f$1, i$1 + g$1, 1, d$1.minY, d$1.maxY, l$1), x$1 = he(I$1, h$1, i$1 + p$1, i$1 + m$1, 1, d$1.minY, d$1.maxY, l$1), I$1 = null), c$1 > 1 && console.timeEnd("clipping"), a$1.push(y$1 || [], t$1 + 1, 2 * s$1, 2 * i$1), a$1.push(w$1 || [], t$1 + 1, 2 * s$1, 2 * i$1 + 1), a$1.push(b$1 || [], t$1 + 1, 2 * s$1 + 1, 2 * i$1), a$1.push(x$1 || [], t$1 + 1, 2 * s$1 + 1, 2 * i$1 + 1);
					}
				}
				getTile(e$1, t$1, s$1) {
					e$1 = +e$1, t$1 = +t$1, s$1 = +s$1;
					const { extent: o$1, debug: n$1 } = this.options;
					if (e$1 < 0 || e$1 > 24) return null;
					const r$1 = 1 << e$1, a$1 = _e(e$1, t$1 = t$1 + r$1 & r$1 - 1, s$1);
					if (this.tiles[a$1]) return xe(this.tiles[a$1], o$1);
					n$1 > 1 && console.log("drilling down to z%d-%d-%d", e$1, t$1, s$1);
					let l$1, c$1 = e$1, h$1 = t$1, u$1 = s$1;
					for (; !l$1 && c$1 > 0;) c$1--, h$1 >>= 1, u$1 >>= 1, l$1 = this.tiles[_e(c$1, h$1, u$1)];
					return l$1 && l$1.source ? (n$1 > 1 && (console.log("found parent tile z%d-%d-%d", c$1, h$1, u$1), console.time("drilling down")), this.splitTile(l$1.source, c$1, h$1, u$1, e$1, t$1, s$1), n$1 > 1 && console.timeEnd("drilling down"), this.tiles[a$1] ? xe(this.tiles[a$1], o$1) : null) : null;
				}
			}
			function _e(e$1, t$1, s$1) {
				return 32 * ((1 << e$1) * s$1 + t$1) + e$1;
			}
			function ke(t$1, s$1) {
				const i$1 = t$1.tileID.canonical;
				if (!this._geoJSONIndex) return void s$1(null, null);
				const o$1 = this._geoJSONIndex.getTile(i$1.z, i$1.x, i$1.y);
				if (!o$1) return void s$1(null, null);
				const n$1 = (e$1) => e$1.tags && "3d_elevation_id" in e$1.tags && "source" in e$1.tags && "elevation" === e$1.tags.source, r$1 = o$1.features.filter(((e$1) => n$1(e$1)));
				let a$1 = { _geojsonTileLayer: o$1.features };
				r$1.length > 0 && (a$1 = {
					_geojsonTileLayer: o$1.features.filter(((e$1) => !n$1(e$1))),
					hd_road_elevation: r$1
				});
				const l$1 = new S(a$1), c$1 = function(t$2) {
					const s$2 = new e.bt();
					for (const e$1 of Object.keys(t$2)) s$2.writeMessage(3, F, {
						name: e$1,
						features: t$2[e$1]
					});
					return s$2.finish();
				}(a$1).buffer;
				s$1(null, {
					vectorTile: l$1,
					rawData: c$1
				});
			}
			class Le extends m {
				constructor(e$1, t$1, s$1, i$1, o$1, n$1, r$1) {
					super(e$1, t$1, s$1, i$1, o$1, ke, r$1), n$1 && (this.loadGeoJSON = n$1), this._dynamicIndex = new T();
				}
				loadData(s$1, i$1) {
					const o$1 = s$1 && s$1.request, n$1 = o$1 && o$1.collectResourceTiming;
					this._geoJSONIndex = null, this.loadGeoJSON(s$1, ((r$1, a$1) => {
						if (r$1 || !a$1) return i$1(r$1);
						if ("object" != typeof a$1) return i$1(/* @__PURE__ */ new Error(`Input data given to '${s$1.source}' is not a valid GeoJSON object.`));
						{
							try {
								if (s$1.filter) {
									const t$1 = e.U(s$1.filter, {
										type: "boolean",
										"property-type": "data-driven",
										overridable: !1,
										transition: !1
									});
									if ("error" === t$1.result) throw new Error(t$1.value.map(((e$1) => `${e$1.key}: ${e$1.message}`)).join(", "));
									a$1.features = a$1.features.filter(((e$1) => t$1.value.evaluate({ zoom: 0 }, e$1)));
								}
								s$1.dynamic ? ("Feature" === a$1.type && (a$1 = {
									type: "FeatureCollection",
									features: [a$1]
								}), s$1.append || (this._dynamicIndex.clear(), this.loaded = {}), this._dynamicIndex.load(a$1.features, this.loaded), s$1.cluster && (a$1.features = this._dynamicIndex.getFeatures())) : this.loaded = {}, this._geoJSONIndex = s$1.cluster ? new V(function({ superclusterOptions: t$1, clusterProperties: s$2 }) {
									if (!s$2 || !t$1) return t$1;
									const i$2 = {}, o$2 = {}, n$2 = {
										accumulated: null,
										zoom: 0
									}, r$3 = { properties: null }, a$2 = Object.keys(s$2);
									for (const t$2 of a$2) {
										const [n$3, r$4] = s$2[t$2], a$3 = e.U(r$4), l$1 = e.U("string" == typeof n$3 ? [
											n$3,
											["accumulated"],
											["get", t$2]
										] : n$3);
										i$2[t$2] = a$3.value, o$2[t$2] = l$1.value;
									}
									return t$1.map = (e$1) => {
										r$3.properties = e$1;
										const t$2 = {};
										for (const e$2 of a$2) t$2[e$2] = i$2[e$2].evaluate(n$2, r$3);
										return t$2;
									}, t$1.reduce = (e$1, t$2) => {
										r$3.properties = t$2;
										for (const t$3 of a$2) n$2.accumulated = e$1[t$3], e$1[t$3] = o$2[t$3].evaluate(n$2, r$3);
									}, t$1;
								}(s$1)).load(a$1.features) : s$1.dynamic ? this._dynamicIndex : function(e$1, t$1) {
									return new Te(e$1, t$1);
								}(a$1, s$1.geojsonVtOptions);
							} catch (e$1) {
								return i$1(e$1);
							}
							const r$2 = {};
							if (n$1) {
								const e$1 = t(o$1);
								e$1 && (r$2.resourceTiming = {}, r$2.resourceTiming[s$1.source] = JSON.parse(JSON.stringify(e$1)));
							}
							i$1(null, r$2);
						}
					}));
				}
				reloadTile(e$1, t$1) {
					const s$1 = this.loaded;
					return s$1 && s$1[e$1.uid] ? e$1.partial ? t$1(null, void 0) : super.reloadTile(e$1, t$1) : this.loadTile(e$1, t$1);
				}
				loadGeoJSON(t$1, s$1) {
					if (t$1.request) e.m(t$1.request, s$1);
					else {
						if ("string" != typeof t$1.data) return s$1(/* @__PURE__ */ new Error(`Input data given to '${t$1.source}' is not a valid GeoJSON object.`));
						setTimeout((() => {
							try {
								return s$1(null, JSON.parse(t$1.data));
							} catch (e$1) {
								return s$1(/* @__PURE__ */ new Error(`Input data given to '${t$1.source}' is not a valid GeoJSON object.`));
							}
						}), 0);
					}
				}
				getClusterExpansionZoom(e$1, t$1) {
					try {
						t$1(null, this._geoJSONIndex.getClusterExpansionZoom(e$1.clusterId));
					} catch (e$2) {
						t$1(e$2);
					}
				}
				getClusterChildren(e$1, t$1) {
					try {
						t$1(null, this._geoJSONIndex.getChildren(e$1.clusterId));
					} catch (e$2) {
						t$1(e$2);
					}
				}
				getClusterLeaves(e$1, t$1) {
					try {
						t$1(null, this._geoJSONIndex.getLeaves(e$1.clusterId, e$1.limit, e$1.offset));
					} catch (e$2) {
						t$1(e$2);
					}
				}
			}
			class ze {
				constructor(t$1, s$1, i$1) {
					this.tileID = new e.aQ(t$1.tileID.overscaledZ, t$1.tileID.wrap, t$1.tileID.canonical.z, t$1.tileID.canonical.x, t$1.tileID.canonical.y), this.tileZoom = t$1.tileZoom, this.uid = t$1.uid, this.zoom = t$1.zoom, this.canonical = t$1.tileID.canonical, this.pixelRatio = t$1.pixelRatio, this.tileSize = t$1.tileSize, this.source = t$1.source, this.overscaling = this.tileID.overscaleFactor(), this.projection = t$1.projection, this.brightness = s$1, this.worldview = i$1;
				}
				parse(t$1, s$1, i$1, o$1) {
					this.status = "parsing";
					const n$1 = new e.aQ(i$1.tileID.overscaledZ, i$1.tileID.wrap, i$1.tileID.canonical.z, i$1.tileID.canonical.x, i$1.tileID.canonical.y), r$1 = [], a$1 = s$1.familiesBySource[i$1.source], l$1 = new e.fn(n$1, i$1.promoteId);
					l$1.bucketLayerIDs = [], l$1.is3DTile = !0, e.fC(t$1).then(((t$2) => {
						if (!t$2) return o$1(/* @__PURE__ */ new Error("Could not parse tile"));
						const s$2 = t$2.json.extensionsUsed && t$2.json.extensionsUsed.includes("MAPBOX_mesh_features") || t$2.json.asset.extras && t$2.json.asset.extras.MAPBOX_mesh_features, c$1 = t$2.json.extensionsUsed && t$2.json.extensionsUsed.includes("EXT_meshopt_compression"), h$1 = new e.ac(this.zoom, {
							brightness: this.brightness,
							worldview: this.worldview
						});
						for (const o$2 in a$1) for (const u$1 of a$1[o$2]) {
							const o$3 = u$1[0];
							l$1.bucketLayerIDs.push(u$1.map(((t$3) => e.B(t$3.id, t$3.scope)))), o$3.recalculate(h$1, []);
							const a$2 = e.fD(t$2, 1 / e.d7(i$1.tileID.canonical)), d$1 = new e.fE(u$1, a$2, n$1, s$2, c$1, this.brightness, l$1, this.worldview);
							s$2 || (d$1.needsUpload = !0), r$1.push(d$1), d$1.evaluate(o$3);
						}
						this.status = "done", o$1(null, {
							buckets: r$1,
							featureIndex: l$1,
							collisionBoxArray: null,
							glyphAtlasImage: null,
							lineAtlas: null,
							imageAtlas: null,
							brightness: null
						});
					})).catch(((e$1) => o$1(new Error(e$1.message))));
				}
			}
			class Ce {
				constructor(e$1, t$1, s$1, i$1, o$1, n$1, r$1, a$1) {
					this.actor = e$1, this.layerIndex = t$1, this.availableImages = s$1, this.availableModels = i$1, this.brightness = r$1, this.loading = {}, this.loaded = {}, this.worldview = a$1;
				}
				loadTile(t$1, s$1) {
					const i$1 = t$1.uid, o$1 = this.loading[i$1] = new ze(t$1, this.brightness, this.worldview);
					e.bu(t$1.request, ((e$1, n$1) => {
						const r$1 = !this.loading[i$1];
						return delete this.loading[i$1], r$1 || e$1 ? (o$1.status = "done", r$1 || (this.loaded[i$1] = o$1), s$1(e$1)) : n$1 && 0 !== n$1.byteLength ? void o$1.parse(n$1, this.layerIndex, t$1, ((e$2, t$2) => {
							o$1.status = "done", this.loaded = this.loaded || {}, this.loaded[i$1] = o$1, e$2 || !t$2 ? s$1(e$2) : s$1(null, t$2);
						})) : (o$1.status = "done", this.loaded[i$1] = o$1, s$1());
					}));
				}
				reloadTile(e$1, t$1) {
					const s$1 = this.loaded, i$1 = e$1.uid;
					if (s$1 && s$1[i$1]) {
						const o$1 = s$1[i$1];
						o$1.projection = e$1.projection, o$1.brightness = e$1.brightness;
						const n$1 = (s$2, i$2) => {
							o$1.reloadCallback && (delete o$1.reloadCallback, this.loadTile(e$1, t$1)), t$1(s$2, i$2);
						};
						"parsing" === o$1.status ? o$1.reloadCallback = n$1 : "done" === o$1.status && this.loadTile(e$1, t$1);
					}
				}
				abortTile(e$1, t$1) {
					const s$1 = e$1.uid;
					this.loading[s$1] && delete this.loading[s$1], t$1();
				}
				removeTile(e$1, t$1) {
					const s$1 = this.loaded, i$1 = e$1.uid;
					s$1 && s$1[i$1] && delete s$1[i$1], t$1();
				}
			}
			class De {
				constructor(t$1) {
					this.self = t$1, this.actor = new e.fG(t$1, this), this.layerIndexes = {}, this.availableImages = {}, this.availableModels = {}, this.isSpriteLoaded = {}, this.imageRasterizer = new e.x(), this.rtlPluginParsingListeners = [], this.projections = {}, this.defaultProjection = e.cm({ name: "mercator" }), this.workerSourceTypes = {
						vector: m,
						geojson: Le,
						"raster-dem": y,
						"raster-array": b,
						"batched-model": Ce
					}, this.workerSources = {}, this.self.registerWorkerSource = (e$1, t$2) => {
						if (this.workerSourceTypes[e$1]) throw new Error(`Worker source with name "${e$1}" already registered.`);
						this.workerSourceTypes[e$1] = t$2;
					}, this.self.registerRTLTextPlugin = (t$2) => {
						if (e.fH.isParsed()) throw new Error("RTL text plugin already registered.");
						e.fH.setState({
							pluginStatus: e.fI.parsed,
							pluginURL: e.fH.getPluginURL()
						}), e.fH.applyArabicShaping = t$2.applyArabicShaping, e.fH.processBidirectionalText = t$2.processBidirectionalText, e.fH.processStyledBidirectionalText = t$2.processStyledBidirectionalText;
						for (const e$1 of this.rtlPluginParsingListeners) e$1(null, !0);
						this.rtlPluginParsingListeners = [];
					};
				}
				clearCaches(e$1, t$1, s$1) {
					delete this.layerIndexes[e$1], delete this.availableImages[e$1], delete this.availableModels[e$1], delete this.workerSources[e$1], s$1();
				}
				checkIfReady(e$1, t$1, s$1) {
					s$1();
				}
				setReferrer(e$1, t$1) {
					this.referrer = t$1;
				}
				spriteLoaded(t$1, s$1) {
					this.isSpriteLoaded[t$1] || (this.isSpriteLoaded[t$1] = {});
					const { scope: i$1, isLoaded: o$1 } = s$1;
					if (this.isSpriteLoaded[t$1][i$1] = o$1, this.workerSources[t$1] && this.workerSources[t$1][i$1]) for (const s$2 in this.workerSources[t$1][i$1]) {
						const n$1 = this.workerSources[t$1][i$1][s$2];
						for (const t$2 in n$1) {
							const s$3 = n$1[t$2];
							s$3 instanceof m && (s$3.isSpriteLoaded = o$1, s$3.fire(new e.z("isSpriteLoaded")));
						}
					}
				}
				setImages(e$1, t$1, s$1) {
					this.availableImages[e$1] || (this.availableImages[e$1] = {});
					const { scope: i$1, images: o$1 } = t$1;
					if (this.availableImages[e$1][i$1] = o$1, this.workerSources[e$1] && this.workerSources[e$1][i$1]) {
						for (const t$2 in this.workerSources[e$1][i$1]) {
							const s$2 = this.workerSources[e$1][i$1][t$2];
							for (const e$2 in s$2) s$2[e$2].availableImages = o$1;
						}
						s$1();
					} else s$1();
				}
				setModels(e$1, { scope: t$1, models: s$1 }, i$1) {
					if (this.availableModels[e$1] || (this.availableModels[e$1] = {}), this.availableModels[e$1][t$1] = s$1, this.workerSources[e$1] && this.workerSources[e$1][t$1]) {
						for (const i$2 in this.workerSources[e$1][t$1]) {
							const o$1 = this.workerSources[e$1][t$1][i$2];
							for (const e$2 in o$1) o$1[e$2].availableModels = s$1;
						}
						i$1();
					} else i$1();
				}
				setProjection(t$1, s$1) {
					this.projections[t$1] = e.cm(s$1);
				}
				setBrightness(e$1, t$1, s$1) {
					this.brightness = t$1, s$1();
				}
				setWorldview(e$1, t$1, s$1) {
					this.worldview = t$1, s$1();
				}
				setLayers(e$1, t$1, s$1) {
					this.getLayerIndex(e$1, t$1.scope).replace(t$1.layers, t$1.options), s$1();
				}
				updateLayers(e$1, t$1, s$1) {
					this.getLayerIndex(e$1, t$1.scope).update(t$1.layers, t$1.removedIds, t$1.options), s$1();
				}
				loadTile(e$1, t$1, s$1) {
					t$1.projection = this.projections[e$1] || this.defaultProjection, this.getWorkerSource(e$1, t$1.type, t$1.source, t$1.scope).loadTile(t$1, s$1);
				}
				decodeRasterArray(e$1, t$1, s$1) {
					this.getWorkerSource(e$1, t$1.type, t$1.source, t$1.scope).decodeRasterArray(t$1, s$1);
				}
				reloadTile(e$1, t$1, s$1) {
					t$1.projection = this.projections[e$1] || this.defaultProjection, this.getWorkerSource(e$1, t$1.type, t$1.source, t$1.scope).reloadTile(t$1, s$1);
				}
				abortTile(e$1, t$1, s$1) {
					this.getWorkerSource(e$1, t$1.type, t$1.source, t$1.scope).abortTile(t$1, s$1);
				}
				removeTile(e$1, t$1, s$1) {
					this.getWorkerSource(e$1, t$1.type, t$1.source, t$1.scope).removeTile(t$1, s$1);
				}
				removeSource(e$1, t$1, s$1) {
					if (!(this.workerSources[e$1] && this.workerSources[e$1][t$1.scope] && this.workerSources[e$1][t$1.scope][t$1.type] && this.workerSources[e$1][t$1.scope][t$1.type][t$1.source])) return;
					const i$1 = this.workerSources[e$1][t$1.scope][t$1.type][t$1.source];
					delete this.workerSources[e$1][t$1.scope][t$1.type][t$1.source], void 0 !== i$1.removeSource ? i$1.removeSource(t$1, s$1) : s$1();
				}
				loadWorkerSource(e$1, t$1, s$1) {
					try {
						this.self.importScripts(t$1.url), s$1();
					} catch (e$2) {
						s$1(e$2);
					}
				}
				syncRTLPluginState(t$1, s$1, i$1) {
					if (e.fH.isParsed()) i$1(null, !0);
					else if (e.fH.isParsing()) this.rtlPluginParsingListeners.push(i$1);
					else try {
						e.fH.setState(s$1);
						const t$2 = e.fH.getPluginURL();
						!e.fH.isLoaded() || e.fH.isParsed() || e.fH.isParsing() || null == t$2 || (e.fH.setState({
							pluginStatus: e.fI.parsing,
							pluginURL: e.fH.getPluginURL()
						}), this.self.importScripts(t$2), e.fH.isParsed() ? i$1(null, !0) : this.rtlPluginParsingListeners.push(i$1));
					} catch (e$1) {
						i$1(e$1);
					}
				}
				setDracoUrl(e$1, t$1) {
					this.dracoUrl = t$1;
				}
				getAvailableImages(e$1, t$1) {
					this.availableImages[e$1] || (this.availableImages[e$1] = {});
					let s$1 = this.availableImages[e$1][t$1];
					return s$1 || (s$1 = []), s$1;
				}
				getAvailableModels(e$1, t$1) {
					this.availableModels[e$1] || (this.availableModels[e$1] = {});
					let s$1 = this.availableModels[e$1][t$1];
					return s$1 || (s$1 = {}), s$1;
				}
				getLayerIndex(e$1, t$1) {
					this.layerIndexes[e$1] || (this.layerIndexes[e$1] = {});
					let s$1 = this.layerIndexes[e$1][t$1];
					return s$1 || (s$1 = this.layerIndexes[e$1][t$1] = new o(), s$1.scope = t$1), s$1;
				}
				getWorkerSource(e$1, t$1, s$1, i$1) {
					const o$1 = this.workerSources;
					return o$1[e$1] || (o$1[e$1] = {}), o$1[e$1][i$1] || (o$1[e$1][i$1] = {}), o$1[e$1][i$1][t$1] || (o$1[e$1][i$1][t$1] = {}), this.isSpriteLoaded[e$1] || (this.isSpriteLoaded[e$1] = {}), o$1[e$1][i$1][t$1][s$1] || (o$1[e$1][i$1][t$1][s$1] = new this.workerSourceTypes[t$1]({
						send: (t$2, s$2, i$2, o$2, n$1, r$1) => this.actor.send(t$2, s$2, i$2, e$1, n$1, r$1),
						scheduler: this.actor.scheduler
					}, this.getLayerIndex(e$1, i$1), this.getAvailableImages(e$1, i$1), this.getAvailableModels(e$1, i$1), this.isSpriteLoaded[e$1][i$1], void 0, this.brightness, this.worldview)), o$1[e$1][i$1][t$1][s$1];
				}
				rasterizeImagesWorker(e$1, t$1, s$1) {
					const i$1 = /* @__PURE__ */ new Map();
					for (const [s$2, { image: o$1, imageVariant: n$1 }] of t$1.tasks.entries()) {
						const r$1 = this.imageRasterizer.rasterize(n$1, o$1, t$1.scope, e$1);
						i$1.set(s$2, r$1);
					}
					s$1(void 0, i$1);
				}
				removeRasterizedImages(e$1, t$1, s$1) {
					this.imageRasterizer.removeImagesFromCacheByIds(t$1.imageIds, t$1.scope, e$1), s$1();
				}
				enforceCacheSizeLimit(t$1, s$1) {
					e.fJ(s$1);
				}
				getWorkerPerformanceMetrics(e$1, t$1, s$1) {
					s$1(void 0, void 0);
				}
			}
			return e.fF(self) && (self.worker = new De(self)), De;
		}));
		define$1(["./shared"], (function(e) {
			var t = "3.17.0";
			const i = {
				create: "create",
				load: "load",
				fullLoad: "fullLoad"
			}, o = {
				mark(e$1) {
					performance.mark(e$1);
				},
				measure(e$1, t$1, i$1) {
					performance.measure(e$1, t$1, i$1);
				}
			};
			function s(t$1) {
				const i$1 = t$1.name.split("?")[0];
				return e.a(i$1) && i$1.includes("mapbox-gl.js") ? "javascript" : e.a(i$1) && i$1.includes("mapbox-gl.css") ? "css" : e.b(i$1) ? "fontRange" : e.c(i$1) ? "sprite" : e.i(i$1) ? "style" : e.d(i$1) ? "tilejson" : "other";
			}
			var r, n = {}, a = function() {
				if (r) return n;
				function e$1(e$2) {
					return !t$1(e$2);
				}
				function t$1(t$2) {
					return "undefined" == typeof window || "undefined" == typeof document ? "not a browser" : function() {
						if (!("Worker" in window && "Blob" in window && "URL" in window)) return !1;
						var e$2, t$3, i$2 = new Blob([""], { type: "text/javascript" }), o$2 = URL.createObjectURL(i$2);
						try {
							t$3 = new Worker(o$2), e$2 = !0;
						} catch (t$4) {
							e$2 = !1;
						}
						return t$3 && t$3.terminate(), URL.revokeObjectURL(o$2), e$2;
					}() ? function() {
						var e$2 = document.createElement("canvas");
						e$2.width = e$2.height = 1;
						var t$3 = e$2.getContext("2d");
						if (!t$3) return !1;
						var i$2 = t$3.getImageData(0, 0, 1, 1);
						return i$2 && i$2.width === e$2.width;
					}() ? (void 0 === i$1[o$1 = t$2 && t$2.failIfMajorPerformanceCaveat] && (i$1[o$1] = function(t$3) {
						var i$2, o$2 = function(t$4) {
							var i$3 = document.createElement("canvas"), o$3 = Object.create(e$1.webGLContextAttributes);
							return o$3.failIfMajorPerformanceCaveat = t$4, i$3.getContext("webgl2", o$3);
						}(t$3);
						if (!o$2) return !1;
						try {
							i$2 = o$2.createShader(o$2.VERTEX_SHADER);
						} catch (e$2) {
							return !1;
						}
						return !(!i$2 || o$2.isContextLost()) && (o$2.shaderSource(i$2, "void main() {}"), o$2.compileShader(i$2), !0 === o$2.getShaderParameter(i$2, o$2.COMPILE_STATUS));
					}(o$1)), i$1[o$1] ? document.documentMode ? "insufficient ECMAScript 6 support" : void 0 : "insufficient WebGL2 support") : "insufficient Canvas/getImageData support" : "insufficient worker support";
					var o$1;
				}
				r = 1, n.supported = e$1, n.notSupportedReason = t$1;
				var i$1 = {};
				return e$1.webGLContextAttributes = {
					antialias: !1,
					alpha: !0,
					stencil: !0,
					depth: !0
				}, n;
			}();
			function l(e$1, t$1, i$1) {
				const o$1 = document.createElement(e$1);
				return null != t$1 && (o$1.className = t$1), i$1 && i$1.appendChild(o$1), o$1;
			}
			function c(e$1, t$1, i$1) {
				const o$1 = document.createElementNS("http://www.w3.org/2000/svg", e$1);
				for (const e$2 of Object.keys(t$1)) o$1.setAttributeNS(null, e$2, String(t$1[e$2]));
				return i$1 && i$1.appendChild(o$1), o$1;
			}
			const h = "undefined" != typeof document ? document.documentElement && document.documentElement.style : null, d = h && void 0 !== h.userSelect ? "userSelect" : "WebkitUserSelect";
			let u;
			function _() {
				h && d && (u = h[d], h[d] = "none");
			}
			function p() {
				h && d && (h[d] = u);
			}
			function f(e$1) {
				e$1.preventDefault(), e$1.stopPropagation(), window.removeEventListener("click", f, !0);
			}
			function m() {
				window.addEventListener("click", f, !0), window.setTimeout((() => {
					window.removeEventListener("click", f, !0);
				}), 0);
			}
			function g(e$1, t$1) {
				return x(e$1, e$1.getBoundingClientRect(), t$1);
			}
			function v(e$1, t$1) {
				const i$1 = e$1.getBoundingClientRect(), o$1 = [];
				for (let s$1 = 0; s$1 < t$1.length; s$1++) o$1.push(x(e$1, i$1, t$1[s$1]));
				return o$1;
			}
			function y(e$1) {
				return /firefox/i.test(navigator.userAgent) && /macintosh/i.test(navigator.userAgent) && 2 === e$1.button && e$1.ctrlKey ? 0 : e$1.button;
			}
			function x(t$1, i$1, o$1) {
				const s$1 = t$1.offsetWidth === i$1.width ? 1 : t$1.offsetWidth / i$1.width;
				return new e.P((o$1.clientX - i$1.left) * s$1, (o$1.clientY - i$1.top) * s$1);
			}
			const b = "01", w = "NO_ACCESS_TOKEN";
			class T {
				constructor(e$1, t$1, i$1) {
					this._transformRequestFn = e$1, this._customAccessToken = t$1, this._silenceAuthErrors = !!i$1, this._createSkuToken();
				}
				_createSkuToken() {
					const e$1 = function() {
						let e$2 = "";
						for (let t$1 = 0; t$1 < 10; t$1++) e$2 += "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"[Math.floor(62 * Math.random())];
						return {
							token: [
								"1",
								b,
								e$2
							].join(""),
							tokenExpiresAt: Date.now() + 432e5
						};
					}();
					this._skuToken = e$1.token, this._skuTokenExpiresAt = e$1.tokenExpiresAt;
				}
				_isSkuTokenExpired() {
					return Date.now() > this._skuTokenExpiresAt;
				}
				transformRequest(e$1, t$1) {
					return this._transformRequestFn && this._transformRequestFn(e$1, t$1) || { url: e$1 };
				}
				normalizeStyleURL(i$1, o$1) {
					if (!e.h(i$1)) return i$1;
					const s$1 = S(i$1);
					return s$1.params.push(`sdk=js-${t}`), s$1.path = `/styles/v1${s$1.path}`, this._makeAPIURL(s$1, this._customAccessToken || o$1);
				}
				normalizeGlyphsURL(t$1, i$1) {
					if (!e.h(t$1)) return t$1;
					const o$1 = S(t$1);
					return o$1.path = `/fonts/v1${o$1.path}`, this._makeAPIURL(o$1, this._customAccessToken || i$1);
				}
				normalizeModelURL(t$1, i$1) {
					if (!e.h(t$1)) return t$1;
					const o$1 = S(t$1);
					return o$1.path = `/models/v1${o$1.path}`, this._makeAPIURL(o$1, this._customAccessToken || i$1);
				}
				normalizeSourceURL(t$1, i$1, o$1, s$1) {
					if (!e.h(t$1)) return t$1;
					const r$1 = S(t$1);
					return r$1.path = `/v4/${r$1.authority}.json`, r$1.params.push("secure"), o$1 && r$1.params.push(`language=${o$1}`), s$1 && r$1.params.push(`worldview=${s$1}`), this._makeAPIURL(r$1, this._customAccessToken || i$1);
				}
				normalizeIconsetURL(t$1, i$1) {
					const o$1 = S(t$1);
					return e.h(t$1) ? (o$1.path = `/styles/v1${o$1.path}/iconset.pbf`, this._makeAPIURL(o$1, this._customAccessToken || i$1)) : I(o$1);
				}
				normalizeSpriteURL(t$1, i$1, o$1, s$1) {
					const r$1 = S(t$1);
					return e.h(t$1) ? (r$1.path = `/styles/v1${r$1.path}/sprite${i$1}${o$1}`, this._makeAPIURL(r$1, this._customAccessToken || s$1)) : (r$1.path += `${i$1}${o$1}`, I(r$1));
				}
				normalizeTileURL(t$1, i$1, o$1) {
					if (this._isSkuTokenExpired() && this._createSkuToken(), t$1 && !e.h(t$1)) return t$1;
					const s$1 = S(t$1);
					s$1.path = s$1.path.replace(/(\.(png|jpg)\d*)(?=$)/, `${i$1 || o$1 && "raster" !== s$1.authority && 512 === o$1 ? "@2x" : ""}${e.k.supported ? ".webp" : "$1"}`), "raster" === s$1.authority ? s$1.path = `/${e.e.RASTER_URL_PREFIX}${s$1.path}` : "rasterarrays" === s$1.authority ? s$1.path = `/${e.e.RASTERARRAYS_URL_PREFIX}${s$1.path}` : "3dtiles" === s$1.authority ? s$1.path = `/${e.e.TILES3D_URL_PREFIX}${s$1.path}` : (s$1.path = s$1.path.replace(/^.+\/v4\//, "/"), s$1.path = `/${e.e.TILE_URL_VERSION}${s$1.path}`);
					const r$1 = this._customAccessToken || function(e$1) {
						for (const t$2 of e$1) {
							const e$2 = t$2.match(/^access_token=(.*)$/);
							if (e$2) return e$2[1];
						}
						return null;
					}(s$1.params) || e.e.ACCESS_TOKEN;
					return e.e.REQUIRE_ACCESS_TOKEN && r$1 && this._skuToken && s$1.params.push(`sku=${this._skuToken}`), this._makeAPIURL(s$1, r$1);
				}
				canonicalizeTileURL(t$1, i$1) {
					const o$1 = S(t$1);
					if (!o$1.path.match(/^(\/v4\/|\/(raster|rasterarrays)\/v1\/)/) || !o$1.path.match(/\.[\w]+$/)) return t$1;
					let s$1 = "mapbox://";
					o$1.path.match(/^\/raster\/v1\//) ? s$1 += `raster/${o$1.path.replace(`/${e.e.RASTER_URL_PREFIX}/`, "")}` : o$1.path.match(/^\/rasterarrays\/v1\//) ? s$1 += `rasterarrays/${o$1.path.replace(`/${e.e.RASTERARRAYS_URL_PREFIX}/`, "")}` : s$1 += `tiles/${o$1.path.replace(`/${e.e.TILE_URL_VERSION}/`, "")}`;
					let r$1 = o$1.params;
					return i$1 && (r$1 = r$1.filter(((e$1) => !e$1.match(/^access_token=/)))), r$1.length && (s$1 += `?${r$1.join("&")}`), s$1;
				}
				canonicalizeTileset(t$1, i$1) {
					const o$1 = !!i$1 && e.h(i$1), s$1 = [];
					for (const i$2 of t$1.tiles || []) e.j(i$2) ? s$1.push(this.canonicalizeTileURL(i$2, o$1)) : s$1.push(i$2);
					return s$1;
				}
				_makeAPIURL(t$1, i$1) {
					const o$1 = "See https://docs.mapbox.com/api/overview/#access-tokens-and-token-scopes", s$1 = S(e.e.API_URL);
					if (t$1.protocol = s$1.protocol, t$1.authority = s$1.authority, "http" === t$1.protocol) {
						const e$1 = t$1.params.indexOf("secure");
						e$1 >= 0 && t$1.params.splice(e$1, 1);
					}
					if ("/" !== s$1.path && (t$1.path = `${s$1.path}${t$1.path}`), !e.e.REQUIRE_ACCESS_TOKEN) return I(t$1);
					if (i$1 = i$1 || e.e.ACCESS_TOKEN, !this._silenceAuthErrors) {
						if (!i$1) throw new Error(`An API access token is required to use Mapbox GL. ${o$1}`);
						if ("s" === i$1[0]) throw new Error(`Use a public access token (pk.*) with Mapbox GL, not a secret access token (sk.*). ${o$1}`);
					}
					return t$1.params = t$1.params.filter(((e$1) => -1 === e$1.indexOf("access_token"))), t$1.params.push(`access_token=${i$1 || ""}`), I(t$1);
				}
			}
			const E = /^(\w+):\/\/([^/?]*)(\/[^?]+)?\??(.+)?/;
			function S(e$1) {
				const t$1 = e$1.match(E);
				if (!t$1) throw new Error("Unable to parse URL object");
				return {
					protocol: t$1[1],
					authority: t$1[2],
					path: t$1[3] || "/",
					params: t$1[4] ? t$1[4].split("&") : []
				};
			}
			function I(e$1) {
				const t$1 = e$1.params.length ? `?${e$1.params.join("&")}` : "";
				return `${e$1.protocol}://${e$1.authority}${e$1.path}${t$1}`;
			}
			const C = "mapbox.eventData";
			function R(t$1) {
				if (!t$1) return null;
				const i$1 = t$1.split(".");
				if (!i$1 || 3 !== i$1.length) return null;
				try {
					return JSON.parse(e.l(i$1[1]));
				} catch (e$1) {
					return null;
				}
			}
			class A {
				constructor(e$1) {
					this.type = e$1, this.anonId = null, this.anonIdTimestamp = null, this.eventData = {}, this.queue = [], this.pendingRequest = null;
				}
				getStorageKey(t$1) {
					const i$1 = R(e.e.ACCESS_TOKEN);
					let o$1 = "";
					return o$1 = i$1 && i$1.u ? e.f(i$1.u) : e.e.ACCESS_TOKEN || "", t$1 ? `${C}.${t$1}:${o$1}` : `${C}:${o$1}`;
				}
				fetchEventData() {
					const t$1 = e.s("localStorage"), i$1 = this.getStorageKey(), o$1 = this.getStorageKey("uuid"), s$1 = this.getStorageKey("uuidTimestamp");
					if (t$1) try {
						const e$1 = localStorage.getItem(i$1);
						e$1 && (this.eventData = JSON.parse(e$1));
						const t$2 = localStorage.getItem(o$1);
						t$2 && (this.anonId = t$2);
						const r$1 = localStorage.getItem(s$1);
						r$1 && (this.anonIdTimestamp = Number(r$1));
						const n$1 = Date.now() - 864e5;
						(!this.anonIdTimestamp || this.anonIdTimestamp < n$1) && this.refreshUUID();
					} catch (t$2) {
						e.w("Unable to read from LocalStorage");
					}
				}
				refreshUUID() {
					this.anonId = e.u(), this.anonIdTimestamp = Date.now();
				}
				saveEventData() {
					const t$1 = e.s("localStorage"), i$1 = this.getStorageKey(), o$1 = this.getStorageKey("uuid"), s$1 = this.getStorageKey("uuidTimestamp"), r$1 = this.anonId, n$1 = this.anonIdTimestamp;
					if (t$1 && r$1) try {
						localStorage.setItem(o$1, r$1), Object.keys(this.eventData).length >= 1 && localStorage.setItem(i$1, JSON.stringify(this.eventData)), n$1 && localStorage.setItem(s$1, n$1.toString());
					} catch (t$2) {
						e.w("Unable to write to LocalStorage");
					}
				}
				processRequests(e$1) {}
				postEvent(t$1, i$1, o$1, s$1) {
					if (!e.e.EVENTS_URL) return;
					const r$1 = S(e.e.EVENTS_URL);
					r$1.params.push(`access_token=${s$1 || e.e.ACCESS_TOKEN || ""}`);
					const n$1 = {
						event: this.type,
						created: new Date(t$1).toISOString()
					}, a$1 = i$1 ? Object.assign(n$1, i$1) : n$1, l$1 = {
						url: I(r$1),
						headers: { "Content-Type": "text/plain" },
						body: JSON.stringify([a$1])
					};
					this.pendingRequest = e.p(l$1, ((e$1) => {
						this.pendingRequest = null, o$1(e$1), this.saveEventData(), this.processRequests(s$1);
					}));
				}
				queueRequest(e$1, t$1) {
					this.queue.push(e$1), this.processRequests(t$1);
				}
			}
			class L extends A {
				constructor(e$1) {
					super("metrics"), e$1 && (this.data = e$1);
				}
				postMetricsEvent(t$1) {
					if (!e.e.EVENTS_URL || !t$1 && !e.e.ACCESS_TOKEN) return;
					this.anonId || this.fetchEventData(), e.v(this.anonId) || this.refreshUUID();
					const i$1 = Object.assign({}, this.data, { sessionId: this.anonId });
					this.queueRequest({
						timestamp: Date.now(),
						payload: i$1
					}, t$1);
				}
				processRequests(e$1) {
					if (this.pendingRequest || 0 === this.queue.length) return;
					const { timestamp: t$1, payload: i$1 } = this.queue.shift();
					this.postEvent(t$1, i$1, (() => {}), e$1);
				}
			}
			const D = new class extends A {
				constructor(e$1) {
					super("appUserTurnstile"), this._customAccessToken = e$1;
				}
				postTurnstileEvent(t$1, i$1) {
					e.e.EVENTS_URL && e.e.ACCESS_TOKEN && Array.isArray(t$1) && t$1.some(((t$2) => e.h(t$2) || e.j(t$2))) && this.queueRequest(Date.now(), i$1);
				}
				processRequests(i$1) {
					if (this.pendingRequest || 0 === this.queue.length) return;
					this.anonId && this.anonIdTimestamp && this.eventData.lastSuccess && this.eventData.tokenU || this.fetchEventData();
					const o$1 = R(e.e.ACCESS_TOKEN), s$1 = o$1 ? o$1.u : e.e.ACCESS_TOKEN;
					let r$1 = s$1 !== this.eventData.tokenU;
					e.v(this.anonId) || (this.refreshUUID(), r$1 = !0);
					const n$1 = this.queue.shift();
					if (this.eventData.lastSuccess) {
						const e$1 = new Date(this.eventData.lastSuccess), t$1 = new Date(n$1), i$2 = (n$1 - this.eventData.lastSuccess) / 864e5;
						r$1 = r$1 || i$2 >= 1 || i$2 < -1 || e$1.getDate() !== t$1.getDate();
					} else r$1 = !0;
					r$1 ? this.postEvent(n$1, {
						sdkIdentifier: "mapbox-gl-js",
						sdkVersion: t,
						skuId: b,
						"enabled.telemetry": !1,
						userId: this.anonId
					}, ((e$1) => {
						e$1 || (this.eventData.lastSuccess = n$1, this.eventData.tokenU = s$1);
					}), i$1) : this.processRequests();
				}
			}(), P = D.postTurnstileEvent.bind(D), O = new class extends A {
				constructor() {
					super("map.load"), this.success = {}, this.skuToken = "";
				}
				postMapLoadEvent(t$1, i$1, o$1, s$1) {
					this.skuToken = i$1, this.errorCb = s$1, e.e.EVENTS_URL && (o$1 || e.e.ACCESS_TOKEN ? this.queueRequest({
						id: t$1,
						timestamp: Date.now()
					}, o$1) : this.errorCb(new Error(w)));
				}
				processRequests(i$1) {
					if (this.pendingRequest || 0 === this.queue.length) return;
					const { id: o$1, timestamp: s$1 } = this.queue.shift();
					o$1 && this.success[o$1] || (this.anonId && this.anonIdTimestamp || this.fetchEventData(), e.v(this.anonId) || this.refreshUUID(), this.postEvent(s$1, {
						sdkIdentifier: "mapbox-gl-js",
						sdkVersion: t,
						skuId: b,
						skuToken: this.skuToken,
						userId: this.anonId
					}, ((e$1) => {
						e$1 ? this.errorCb(e$1) : o$1 && (this.success[o$1] = !0);
					}), i$1));
				}
				remove() {
					this.errorCb = null;
				}
			}(), z = O.postMapLoadEvent.bind(O), M = new class extends A {
				constructor() {
					super("style.load"), this.eventIdPerMapInstanceMap = /* @__PURE__ */ new Map(), this.mapInstanceIdMap = /* @__PURE__ */ new WeakMap();
				}
				getMapInstanceId(t$1) {
					let i$1 = this.mapInstanceIdMap.get(t$1);
					return i$1 || (i$1 = e.u(), this.mapInstanceIdMap.set(t$1, i$1)), i$1;
				}
				getEventId(e$1) {
					const t$1 = this.eventIdPerMapInstanceMap.get(e$1) || 0;
					return this.eventIdPerMapInstanceMap.set(e$1, t$1 + 1), t$1;
				}
				postStyleLoadEvent(t$1, i$1) {
					const { map: o$1, style: s$1, importedStyles: r$1 } = i$1;
					if (!e.e.EVENTS_URL || !t$1 && !e.e.ACCESS_TOKEN) return;
					const n$1 = this.getMapInstanceId(o$1), a$1 = {
						mapInstanceId: n$1,
						eventId: this.getEventId(n$1),
						style: s$1
					};
					r$1.length && (a$1.importedStyles = r$1), this.queueRequest({
						timestamp: Date.now(),
						payload: a$1
					}, t$1);
				}
				processRequests(e$1) {
					if (this.pendingRequest || 0 === this.queue.length) return;
					const { timestamp: t$1, payload: i$1 } = this.queue.shift();
					this.postEvent(t$1, i$1, (() => {}), e$1);
				}
			}(), F = M.postStyleLoadEvent.bind(M), B = new L({ attributes: [{ name: "maps/js/layer-animations/style-with-appearances" }] }), k = B.postMetricsEvent.bind(B), N = new L({ attributes: [{ name: "maps/js/layer-animations/runtime-appearances" }] }), U = N.postMetricsEvent.bind(N), j = new class extends A {
				constructor() {
					super("gljs.performance");
				}
				postPerformanceEvent(t$1, i$1) {
					e.e.EVENTS_URL && (t$1 || e.e.ACCESS_TOKEN) && this.queueRequest({
						timestamp: Date.now(),
						performanceData: i$1
					}, t$1);
				}
				processRequests(o$1) {
					if (this.pendingRequest || 0 === this.queue.length) return;
					const { timestamp: r$1, performanceData: n$1 } = this.queue.shift(), a$1 = function(o$2) {
						const r$2 = performance.getEntriesByType("resource"), n$2 = performance.getEntriesByType("mark"), a$2 = function(e$1) {
							const t$1 = {};
							if (e$1) {
								for (const i$1 in e$1) if ("other" !== i$1) for (const o$3 of e$1[i$1]) {
									const e$2 = `${i$1}ResolveRangeMin`, s$1 = `${i$1}ResolveRangeMax`, r$3 = `${i$1}RequestCount`, n$3 = `${i$1}RequestCachedCount`;
									t$1[e$2] = Math.min(t$1[e$2] || Infinity, o$3.startTime), t$1[s$1] = Math.max(t$1[s$1] || -Infinity, o$3.responseEnd);
									const a$3 = (e$3) => {
										void 0 === t$1[e$3] && (t$1[e$3] = 0), ++t$1[e$3];
									};
									void 0 !== o$3.transferSize && 0 === o$3.transferSize && a$3(n$3), a$3(r$3);
								}
							}
							return t$1;
						}(function(e$1, t$1) {
							const i$1 = {};
							if (e$1) for (const o$3 of e$1) {
								const e$2 = t$1(o$3);
								void 0 === i$1[e$2] && (i$1[e$2] = []), i$1[e$2].push(o$3);
							}
							return i$1;
						}(r$2, s)), l$1 = window.devicePixelRatio, c$1 = navigator.connection || navigator.mozConnection || navigator.webkitConnection, h$1 = c$1 ? c$1.effectiveType : void 0, d$1 = {
							counters: [],
							metadata: [],
							attributes: []
						}, u$1 = (e$1, t$1, i$1) => {
							null != i$1 && e$1.push({
								name: t$1,
								value: i$1.toString()
							});
						};
						for (const e$1 in a$2) u$1(d$1.counters, e$1, a$2[e$1]);
						if (o$2.interactionRange[0] !== Infinity && o$2.interactionRange[1] !== -Infinity && (u$1(d$1.counters, "interactionRangeMin", o$2.interactionRange[0]), u$1(d$1.counters, "interactionRangeMax", o$2.interactionRange[1])), n$2) for (const e$1 of Object.values(i)) {
							const t$1 = n$2.find(((t$2) => t$2.name === e$1));
							t$1 && u$1(d$1.counters, e$1, t$1.startTime);
						}
						return u$1(d$1.counters, "visibilityHidden", o$2.visibilityHidden), u$1(d$1.attributes, "style", function(t$1) {
							if (t$1) for (const i$1 of t$1) {
								const t$2 = i$1.name.split("?")[0];
								if (e.i(t$2)) {
									const e$1 = t$2.split("/").slice(-2);
									if (2 === e$1.length) return `mapbox://styles/${e$1[0]}/${e$1[1]}`;
								}
							}
						}(r$2)), u$1(d$1.attributes, "terrainEnabled", o$2.terrainEnabled ? "true" : "false"), u$1(d$1.attributes, "fogEnabled", o$2.fogEnabled ? "true" : "false"), u$1(d$1.attributes, "projection", o$2.projection), u$1(d$1.attributes, "zoom", o$2.zoom), u$1(d$1.metadata, "devicePixelRatio", l$1), u$1(d$1.metadata, "connectionEffectiveType", h$1), u$1(d$1.metadata, "navigatorUserAgent", navigator.userAgent), u$1(d$1.metadata, "screenWidth", window.screen.width), u$1(d$1.metadata, "screenHeight", window.screen.height), u$1(d$1.metadata, "windowWidth", window.innerWidth), u$1(d$1.metadata, "windowHeight", window.innerHeight), u$1(d$1.metadata, "mapWidth", o$2.width / l$1), u$1(d$1.metadata, "mapHeight", o$2.height / l$1), u$1(d$1.metadata, "webglRenderer", o$2.renderer), u$1(d$1.metadata, "webglVendor", o$2.vendor), u$1(d$1.metadata, "sdkVersion", t), u$1(d$1.metadata, "sdkIdentifier", "mapbox-gl-js"), d$1;
					}(n$1);
					for (const e$1 of a$1.metadata);
					for (const e$1 of a$1.counters);
					for (const e$1 of a$1.attributes);
					this.postEvent(r$1, a$1, (() => {}), o$1);
				}
			}(), G = j.postPerformanceEvent.bind(j), V = new class extends A {
				constructor() {
					super("map.auth"), this.success = {}, this.skuToken = "";
				}
				getSession(t$1, i$1, o$1, s$1) {
					if (!e.e.API_URL || !e.e.SESSION_PATH) return;
					const r$1 = S(e.e.API_URL + e.e.SESSION_PATH);
					r$1.params.push(`sku=${i$1 || ""}`), r$1.params.push(`access_token=${s$1 || e.e.ACCESS_TOKEN || ""}`);
					const n$1 = {
						url: I(r$1),
						headers: { "Content-Type": "text/plain" }
					};
					this.pendingRequest = e.g(n$1, ((e$1) => {
						this.pendingRequest = null, o$1(e$1), this.saveEventData(), this.processRequests(s$1);
					}));
				}
				getSessionAPI(t$1, i$1, o$1, s$1) {
					this.skuToken = i$1, this.errorCb = s$1, e.e.SESSION_PATH && e.e.API_URL && (o$1 || e.e.ACCESS_TOKEN ? this.queueRequest({
						id: t$1,
						timestamp: Date.now()
					}, o$1) : this.errorCb(new Error(w)));
				}
				processRequests(e$1) {
					if (this.pendingRequest || 0 === this.queue.length) return;
					const { id: t$1, timestamp: i$1 } = this.queue.shift();
					t$1 && this.success[t$1] || this.getSession(i$1, this.skuToken, ((e$2) => {
						e$2 ? this.errorCb(e$2) : t$1 && (this.success[t$1] = !0);
					}), e$1);
				}
				remove() {
					this.errorCb = null;
				}
			}(), H = V.getSessionAPI.bind(V), q = /* @__PURE__ */ new Set();
			function Z(e$1, t$1) {
				t$1 ? q.add(e$1) : q.delete(e$1);
			}
			class W {
				constructor() {
					this._changed = !1, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSourceCaches = {}, this._updatedPaintProps = /* @__PURE__ */ new Set(), this._updatedImages = {};
				}
				isDirty() {
					return this._changed;
				}
				setDirty() {
					this._changed = !0;
				}
				getUpdatedSourceCaches() {
					return this._updatedSourceCaches;
				}
				updateSourceCache(e$1, t$1) {
					this._updatedSourceCaches[e$1] = t$1, this.setDirty();
				}
				discardSourceCacheUpdate(e$1) {
					delete this._updatedSourceCaches[e$1];
				}
				updateLayer(e$1) {
					const t$1 = e$1.scope;
					this._updatedLayers[t$1] = this._updatedLayers[t$1] || /* @__PURE__ */ new Set(), this._updatedLayers[t$1].add(e$1.id), this.setDirty();
				}
				removeLayer(e$1) {
					const t$1 = e$1.scope;
					this._removedLayers[t$1] = this._removedLayers[t$1] || {}, this._updatedLayers[t$1] = this._updatedLayers[t$1] || /* @__PURE__ */ new Set(), this._removedLayers[t$1][e$1.id] = e$1, this._updatedLayers[t$1].delete(e$1.id), this._updatedPaintProps.delete(e$1.fqid), this.setDirty();
				}
				getRemovedLayer(e$1) {
					return this._removedLayers[e$1.scope] ? this._removedLayers[e$1.scope][e$1.id] : null;
				}
				discardLayerRemoval(e$1) {
					this._removedLayers[e$1.scope] && delete this._removedLayers[e$1.scope][e$1.id];
				}
				getLayerUpdatesByScope() {
					const e$1 = {};
					for (const t$1 in this._updatedLayers) e$1[t$1] = e$1[t$1] || {}, e$1[t$1].updatedIds = Array.from(this._updatedLayers[t$1].values());
					for (const t$1 in this._removedLayers) e$1[t$1] = e$1[t$1] || {}, e$1[t$1].removedIds = Object.keys(this._removedLayers[t$1]);
					return e$1;
				}
				getUpdatedPaintProperties() {
					return this._updatedPaintProps;
				}
				updatePaintProperties(e$1) {
					this._updatedPaintProps.add(e$1.fqid), this.setDirty();
				}
				getUpdatedImages(e$1) {
					return this._updatedImages[e$1] ? Array.from(this._updatedImages[e$1].values()) : [];
				}
				updateImage(t$1, i$1) {
					this._updatedImages[i$1] = this._updatedImages[i$1] || /* @__PURE__ */ new Set(), this._updatedImages[i$1].add(e.I.toString(t$1)), this.setDirty();
				}
				resetUpdatedImages(e$1) {
					this._updatedImages[e$1] && this._updatedImages[e$1].clear();
				}
				reset() {
					this._changed = !1, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSourceCaches = {}, this._updatedPaintProps.clear(), this._updatedImages = {};
				}
			}
			function $(e$1) {
				const { userImage: t$1 } = e$1;
				return !!(t$1 && t$1.render && t$1.render()) && (e$1.data.replace(new Uint8Array(t$1.data.buffer)), !0);
			}
			class X extends e.E {
				constructor(t$1) {
					super(), this.imageProviders = /* @__PURE__ */ new Map(), this.images = /* @__PURE__ */ new Map(), this.updatedImages = /* @__PURE__ */ new Map(), this.callbackDispatchedThisFrame = /* @__PURE__ */ new Map(), this.loaded = /* @__PURE__ */ new Map(), this.requestors = [], this.patterns = /* @__PURE__ */ new Map(), this.patternsInFlight = /* @__PURE__ */ new Set(), this.atlasImage = /* @__PURE__ */ new Map(), this.atlasTexture = /* @__PURE__ */ new Map(), this.dirty = !0, this.spriteFormat = t$1, "raster" !== t$1 && e.r() && (this.imageRasterizerDispatcher = new e.D(e.t(), this, "Image Rasterizer Worker", 1));
				}
				addScope(t$1) {
					this.loaded.set(t$1, !1), this.imageProviders.set(t$1, /* @__PURE__ */ new Map()), this.images.set(t$1, /* @__PURE__ */ new Map()), this.updatedImages.set(t$1, /* @__PURE__ */ new Set()), this.callbackDispatchedThisFrame.set(t$1, /* @__PURE__ */ new Set()), this.patterns.set(t$1, /* @__PURE__ */ new Map()), this.atlasImage.set(t$1, new e.q({
						width: 1,
						height: 1
					}));
				}
				removeScope(e$1) {
					this.loaded.delete(e$1), this.imageProviders.delete(e$1), this.images.delete(e$1), this.updatedImages.delete(e$1), this.callbackDispatchedThisFrame.delete(e$1), this.patterns.delete(e$1), this.atlasImage.delete(e$1);
					const t$1 = this.atlasTexture.get(e$1);
					t$1 && (t$1.destroy(), this.atlasTexture.delete(e$1));
				}
				addImageProvider(e$1, t$1) {
					this.imageProviders.has(t$1) || this.imageProviders.set(t$1, /* @__PURE__ */ new Map()), this.imageProviders.get(t$1).set(e$1.id, e$1);
				}
				removeImageProvider(e$1, t$1) {
					this.imageProviders.has(t$1) && this.imageProviders.get(t$1).delete(e$1);
				}
				getPendingImageProviders() {
					const e$1 = [];
					for (const t$1 of this.imageProviders.values()) for (const i$1 of t$1.values()) i$1.hasPendingRequests() && e$1.push(i$1);
					return e$1;
				}
				get imageRasterizer() {
					return this._imageRasterizer || (this._imageRasterizer = new e.x()), this._imageRasterizer;
				}
				isLoaded() {
					for (const e$1 of this.loaded.keys()) if (!this.loaded.get(e$1)) return !1;
					return !0;
				}
				setLoaded(e$1, t$1) {
					if (this.loaded.get(t$1) !== e$1 && (this.loaded.set(t$1, e$1), e$1)) {
						for (const { ids: e$2, callback: i$1 } of this.requestors) this._notify(e$2, t$1, i$1);
						this.requestors = [];
					}
				}
				hasImage(e$1, t$1) {
					return !!this.getImage(e$1, t$1);
				}
				getImage(e$1, t$1) {
					return this.images.get(t$1).get(e$1.toString());
				}
				addImage(e$1, t$1, i$1) {
					this._validate(e$1, i$1) && this.images.get(t$1).set(e$1.toString(), i$1);
				}
				_validate(t$1, i$1) {
					let o$1 = !0;
					return this._validateStretch(i$1.stretchX, i$1.data && i$1.data.width) || (this.fire(new e.y(/* @__PURE__ */ new Error(`Image "${t$1.name}" has invalid "stretchX" value`))), o$1 = !1), this._validateStretch(i$1.stretchY, i$1.data && i$1.data.height) || (this.fire(new e.y(/* @__PURE__ */ new Error(`Image "${t$1.name}" has invalid "stretchY" value`))), o$1 = !1), this._validateContent(i$1.content, i$1) || (this.fire(new e.y(/* @__PURE__ */ new Error(`Image "${t$1.name}" has invalid "content" value`))), o$1 = !1), o$1;
				}
				_validateStretch(e$1, t$1) {
					if (!e$1) return !0;
					let i$1 = 0;
					for (const o$1 of e$1) {
						if (o$1[0] < i$1 || o$1[1] < o$1[0] || t$1 < o$1[1]) return !1;
						i$1 = o$1[1];
					}
					return !0;
				}
				_validateContent(e$1, t$1) {
					if (!e$1) return !0;
					if (4 !== e$1.length) return !1;
					if (!t$1.usvg) {
						if (e$1[0] < 0 || t$1.data.width < e$1[0]) return !1;
						if (e$1[1] < 0 || t$1.data.height < e$1[1]) return !1;
						if (e$1[2] < 0 || t$1.data.width < e$1[2]) return !1;
						if (e$1[3] < 0 || t$1.data.height < e$1[3]) return !1;
					}
					return !(e$1[2] < e$1[0] || e$1[3] < e$1[1]);
				}
				updateImage(e$1, t$1, i$1) {
					i$1.version = this.images.get(t$1).get(e$1.toString()).version + 1, this.images.get(t$1).set(e$1.toString(), i$1), this.updatedImages.get(t$1).add(e$1), this.removeFromImageRasterizerCache(e$1, t$1);
				}
				clearUpdatedImages(e$1) {
					this.updatedImages.get(e$1).clear();
				}
				removeFromImageRasterizerCache(t$1, i$1) {
					"raster" !== this.spriteFormat && (e.r() ? this.imageRasterizerDispatcher.getActor().send("removeRasterizedImages", {
						imageIds: [t$1],
						scope: i$1
					}) : this.imageRasterizer.removeImagesFromCacheByIds([t$1], i$1));
				}
				removeImage(e$1, t$1) {
					const i$1 = this.images.get(t$1), o$1 = i$1.get(e$1.toString());
					i$1.delete(e$1.toString()), this.patterns.get(t$1).delete(e$1.toString()), this.removeFromImageRasterizerCache(e$1, t$1), o$1.userImage && o$1.userImage.onRemove && o$1.userImage.onRemove();
				}
				listImages(t$1) {
					return Array.from(this.images.get(t$1).keys()).map(((t$2) => e.I.from(t$2)));
				}
				getImages(e$1, t$1, i$1) {
					const o$1 = [], s$1 = [], r$1 = this.imageProviders.get(t$1);
					for (const i$2 of e$1) {
						if (!i$2.iconsetId) {
							o$1.push(i$2);
							continue;
						}
						const e$2 = r$1.get(i$2.iconsetId);
						e$2 && (this.getImage(i$2, t$1) ? s$1.push(i$2) : e$2.addPendingRequest(i$2));
					}
					if (0 === o$1.length) return void this._notify(s$1, t$1, i$1);
					let n$1 = !0;
					const a$1 = !!this.loaded.get(t$1), l$1 = this.images.get(t$1);
					if (!a$1) for (const e$2 of o$1) l$1.has(e$2.toString()) || (n$1 = !1);
					a$1 || n$1 ? this._notify(o$1, t$1, i$1) : this.requestors.push({
						ids: o$1,
						scope: t$1,
						callback: i$1
					});
				}
				rasterizeImages(e$1, t$1) {
					const i$1 = /* @__PURE__ */ new Map(), { tasks: o$1, scope: s$1 } = e$1;
					for (const [e$2, t$2] of o$1.entries()) {
						const o$2 = this.getImage(t$2.id, s$1);
						o$2 && i$1.set(e$2, {
							image: o$2,
							imageVariant: t$2
						});
					}
					this._rasterizeImages(s$1, i$1, t$1);
				}
				_rasterizeImages(t$1, i$1, o$1) {
					if (e.r()) this.imageRasterizerDispatcher.getActor().send("rasterizeImagesWorker", {
						tasks: i$1,
						scope: t$1
					}, o$1);
					else {
						const e$1 = /* @__PURE__ */ new Map();
						for (const [o$2, { image: s$1, imageVariant: r$1 }] of i$1.entries()) e$1.set(o$2, this.imageRasterizer.rasterize(r$1, s$1, t$1, 0));
						o$1(void 0, e$1);
					}
				}
				getUpdatedImages(e$1) {
					return this.updatedImages.get(e$1) || /* @__PURE__ */ new Set();
				}
				_notify(t$1, i$1, o$1) {
					const s$1 = this.images.get(i$1), r$1 = /* @__PURE__ */ new Map();
					for (const i$2 of t$1) {
						if (!s$1.get(i$2.toString())) {
							if (i$2.iconsetId) continue;
							this.fire(new e.z("styleimagemissing", { id: i$2.name }));
						}
						const t$2 = s$1.get(i$2.toString());
						if (!t$2) {
							e.w(`Image "${i$2.name}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`);
							continue;
						}
						const o$2 = {
							data: t$2.usvg ? null : t$2.data.clone(),
							pixelRatio: t$2.pixelRatio,
							sdf: t$2.sdf,
							usvg: t$2.usvg,
							version: t$2.version,
							stretchX: t$2.stretchX,
							stretchY: t$2.stretchY,
							content: t$2.content,
							hasRenderCallback: Boolean(t$2.userImage && t$2.userImage.render)
						};
						t$2.usvg && Object.assign(o$2, {
							width: t$2.icon.usvg_tree.width,
							height: t$2.icon.usvg_tree.height
						}), r$1.set(e.I.toString(i$2), o$2);
					}
					o$1(null, r$1);
				}
				getPixelSize(e$1) {
					const { width: t$1, height: i$1 } = this.atlasImage.get(e$1);
					return {
						width: t$1,
						height: i$1
					};
				}
				getPattern(t$1, i$1, o$1) {
					const s$1 = t$1.toString(), r$1 = this.patterns.get(i$1), n$1 = r$1.get(s$1), a$1 = this.getImage(t$1, i$1);
					if (!a$1) return null;
					if (n$1) {
						if (n$1.position.version === a$1.version) return n$1.position;
						n$1.position.version = a$1.version;
					} else {
						if (a$1.usvg && !a$1.data) {
							const r$2 = this.getPatternInFlightId(s$1, i$1);
							if (this.patternsInFlight.has(r$2)) return null;
							this.patternsInFlight.add(r$2);
							const n$2 = new e.A(t$1).scaleSelf(e.o.devicePixelRatio), l$1 = new Map([[n$2.toString(), {
								image: a$1,
								imageVariant: n$2
							}]]);
							return this._rasterizeImages(i$1, l$1, ((e$1, t$2) => this.storePatternImage(n$2, i$1, a$1, o$1, t$2))), null;
						}
						this.storePattern(t$1, i$1, a$1);
					}
					return this._updatePatternAtlas(i$1, o$1), r$1.get(s$1).position;
				}
				getPatternInFlightId(t$1, i$1) {
					return e.B(t$1, i$1);
				}
				hasPatternsInFlight() {
					return 0 !== this.patternsInFlight.size;
				}
				storePatternImage(e$1, t$1, i$1, o$1, s$1) {
					const r$1 = e$1.toString(), n$1 = s$1 ? s$1.get(r$1) : void 0;
					n$1 && (i$1.data = n$1, this.storePattern(e$1.id, t$1, i$1), this._updatePatternAtlas(t$1, o$1), this.patternsInFlight.delete(this.getPatternInFlightId(e$1.id.toString(), t$1)));
				}
				storePattern(t$1, i$1, o$1) {
					const s$1 = {
						w: o$1.data.width + 2 * e.C,
						h: o$1.data.height + 2 * e.C,
						x: 0,
						y: 0
					}, r$1 = new e.F(s$1, o$1, e.C);
					this.patterns.get(i$1).set(t$1.toString(), {
						bin: s$1,
						position: r$1
					});
				}
				destroyAtlasTextures() {
					for (const e$1 of this.atlasTexture.values()) e$1 && e$1.destroy();
					this.atlasTexture.clear();
				}
				bind(t$1, i$1) {
					const o$1 = t$1.gl;
					let s$1 = this.atlasTexture.get(i$1);
					s$1 ? this.dirty && (s$1.update(this.atlasImage.get(i$1)), this.dirty = !1) : (s$1 = new e.T(t$1, this.atlasImage.get(i$1), o$1.RGBA8), this.atlasTexture.set(i$1, s$1)), s$1.bind(o$1.LINEAR, o$1.CLAMP_TO_EDGE);
				}
				_updatePatternAtlas(t$1, i$1) {
					const o$1 = this.patterns.get(t$1), s$1 = Array.from(o$1.values()).map((({ bin: e$1 }) => e$1)), { w: r$1, h: n$1 } = e.G(s$1), a$1 = this.atlasImage.get(t$1);
					a$1.resize({
						width: r$1 || 1,
						height: n$1 || 1
					});
					const l$1 = this.images.get(t$1);
					for (const [t$2, { bin: s$2, position: r$2 }] of o$1.entries()) {
						let o$2 = r$2.padding;
						const n$2 = s$2.x + o$2, c$1 = s$2.y + o$2, h$1 = l$1.get(t$2).data, d$1 = h$1.width, u$1 = h$1.height;
						o$2 = o$2 > 1 ? o$2 - 1 : o$2, e.q.copy(h$1, a$1, {
							x: 0,
							y: 0
						}, {
							x: n$2,
							y: c$1
						}, {
							width: d$1,
							height: u$1
						}, i$1), e.q.copy(h$1, a$1, {
							x: 0,
							y: u$1 - o$2
						}, {
							x: n$2,
							y: c$1 - o$2
						}, {
							width: d$1,
							height: o$2
						}, i$1), e.q.copy(h$1, a$1, {
							x: 0,
							y: 0
						}, {
							x: n$2,
							y: c$1 + u$1
						}, {
							width: d$1,
							height: o$2
						}, i$1), e.q.copy(h$1, a$1, {
							x: d$1 - o$2,
							y: 0
						}, {
							x: n$2 - o$2,
							y: c$1
						}, {
							width: o$2,
							height: u$1
						}, i$1), e.q.copy(h$1, a$1, {
							x: 0,
							y: 0
						}, {
							x: n$2 + d$1,
							y: c$1
						}, {
							width: o$2,
							height: u$1
						}, i$1), e.q.copy(h$1, a$1, {
							x: d$1 - o$2,
							y: u$1 - o$2
						}, {
							x: n$2 - o$2,
							y: c$1 - o$2
						}, {
							width: o$2,
							height: o$2
						}, i$1), e.q.copy(h$1, a$1, {
							x: 0,
							y: u$1 - o$2
						}, {
							x: n$2 + d$1,
							y: c$1 - o$2
						}, {
							width: o$2,
							height: o$2
						}, i$1), e.q.copy(h$1, a$1, {
							x: 0,
							y: 0
						}, {
							x: n$2 + d$1,
							y: c$1 + u$1
						}, {
							width: o$2,
							height: o$2
						}, i$1), e.q.copy(h$1, a$1, {
							x: d$1 - o$2,
							y: 0
						}, {
							x: n$2 - o$2,
							y: c$1 + u$1
						}, {
							width: o$2,
							height: o$2
						}, i$1);
					}
					this.dirty = !0;
				}
				beginFrame() {
					for (const e$1 of this.images.keys()) this.callbackDispatchedThisFrame.set(e$1, /* @__PURE__ */ new Set());
				}
				dispatchRenderCallbacks(e$1, t$1) {
					const i$1 = this.images.get(t$1);
					for (const o$1 of e$1) {
						if (this.callbackDispatchedThisFrame.get(t$1).has(o$1.toString())) continue;
						this.callbackDispatchedThisFrame.get(t$1).add(o$1.toString());
						const e$2 = i$1.get(o$1.toString());
						$(e$2) && this.updateImage(o$1, t$1, e$2);
					}
				}
				destroy() {
					this.imageRasterizerDispatcher && this.imageRasterizerDispatcher.remove();
				}
			}
			function Y(t$1) {
				const i$1 = t$1.value, o$1 = t$1.valueSpec, s$1 = t$1.style, r$1 = t$1.styleSpec, n$1 = t$1.key, a$1 = t$1.arrayElementValidator || ve;
				if (!Array.isArray(i$1)) return [new e.V(n$1, i$1, `array expected, ${e.K(i$1)} found`)];
				if (o$1.length && i$1.length !== o$1.length) return [new e.V(n$1, i$1, `array length ${o$1.length} expected, length ${i$1.length} found`)];
				if (o$1["min-length"] && i$1.length < o$1["min-length"]) return [new e.V(n$1, i$1, `array length at least ${o$1["min-length"]} expected, length ${i$1.length} found`)];
				let l$1 = {
					type: o$1.value,
					values: o$1.values,
					minimum: o$1.minimum,
					maximum: o$1.maximum,
					function: void 0
				};
				r$1.$version < 7 && (l$1.function = o$1.function), e.H(o$1.value) && (l$1 = o$1.value);
				let c$1 = [];
				for (let e$1 = 0; e$1 < i$1.length; e$1++) c$1 = c$1.concat(a$1({
					array: i$1,
					arrayIndex: e$1,
					value: i$1[e$1],
					valueSpec: l$1,
					style: s$1,
					styleSpec: r$1,
					key: `${n$1}[${e$1}]`
				}, !0));
				return c$1;
			}
			function K(t$1) {
				const i$1 = t$1.key, o$1 = t$1.value, s$1 = t$1.valueSpec;
				if (!e.L(o$1)) return [new e.V(i$1, o$1, `number expected, ${e.K(o$1)} found`)];
				if (o$1 != o$1) return [new e.V(i$1, o$1, "number expected, NaN found")];
				if ("minimum" in s$1) {
					let r$1 = s$1.minimum;
					if (Array.isArray(s$1.minimum) && (r$1 = s$1.minimum[t$1.arrayIndex]), o$1 < r$1) return [new e.V(i$1, o$1, `${o$1} is less than the minimum value ${r$1}`)];
				}
				if ("maximum" in s$1) {
					let r$1 = s$1.maximum;
					if (Array.isArray(s$1.maximum) && (r$1 = s$1.maximum[t$1.arrayIndex]), o$1 > r$1) return [new e.V(i$1, o$1, `${o$1} is greater than the maximum value ${r$1}`)];
				}
				return [];
			}
			function J(t$1) {
				const i$1 = t$1.key, o$1 = t$1.value;
				if (!e.H(o$1)) return [new e.V(i$1, o$1, `object expected, ${e.K(o$1)} found`)];
				const s$1 = t$1.valueSpec, r$1 = e.J(o$1.type);
				let n$1, a$1, l$1, c$1 = {};
				const h$1 = "categorical" !== r$1 && void 0 === o$1.property, d$1 = !h$1, u$1 = function(t$2) {
					const i$2 = t$2.stops;
					return Array.isArray(i$2) && Array.isArray(i$2[0]) && e.H(i$2[0][0]);
				}(o$1), _$1 = ye({
					key: t$1.key,
					value: t$1.value,
					valueSpec: t$1.styleSpec.function,
					style: t$1.style,
					styleSpec: t$1.styleSpec,
					objectElementValidators: {
						stops: function(t$2) {
							if ("identity" === r$1) return [new e.V(t$2.key, t$2.value, "identity function may not have a \"stops\" property")];
							let i$2 = [];
							const o$2 = t$2.value;
							return i$2 = i$2.concat(Y({
								key: t$2.key,
								value: o$2,
								valueSpec: t$2.valueSpec,
								style: t$2.style,
								styleSpec: t$2.styleSpec,
								arrayElementValidator: p$1
							})), Array.isArray(o$2) && 0 === o$2.length && i$2.push(new e.V(t$2.key, o$2, "array must have at least one stop")), i$2;
						},
						default: function(e$1) {
							return ve({
								key: e$1.key,
								value: e$1.value,
								valueSpec: s$1,
								style: e$1.style,
								styleSpec: e$1.styleSpec
							});
						}
					}
				});
				return "identity" === r$1 && h$1 && _$1.push(new e.V(t$1.key, t$1.value, "missing required property \"property\"")), "identity" === r$1 || o$1.stops || _$1.push(new e.V(t$1.key, t$1.value, "missing required property \"stops\"")), "exponential" === r$1 && s$1.expression && !e.M(s$1) && _$1.push(new e.V(t$1.key, t$1.value, "exponential functions not supported")), t$1.styleSpec.$version >= 8 && (d$1 && !e.N(s$1) ? _$1.push(new e.V(t$1.key, t$1.value, "property functions not supported")) : h$1 && !e.O(s$1) && _$1.push(new e.V(t$1.key, t$1.value, "zoom functions not supported"))), "categorical" !== r$1 && !u$1 || void 0 !== o$1.property || _$1.push(new e.V(t$1.key, t$1.value, "\"property\" property is required")), _$1;
				function p$1(t$2) {
					let i$2 = [];
					const o$2 = t$2.value, r$2 = t$2.key;
					if (!Array.isArray(o$2)) return [new e.V(r$2, o$2, `array expected, ${e.K(o$2)} found`)];
					if (2 !== o$2.length) return [new e.V(r$2, o$2, `array length 2 expected, length ${o$2.length} found`)];
					if (u$1) {
						if (!e.H(o$2[0])) return [new e.V(r$2, o$2, `object expected, ${e.K(o$2[0])} found`)];
						const s$2 = o$2[0];
						if (void 0 === s$2.zoom) return [new e.V(r$2, o$2, "object stop key must have zoom")];
						if (void 0 === s$2.value) return [new e.V(r$2, o$2, "object stop key must have value")];
						const n$2 = e.J(s$2.zoom);
						if ("number" != typeof n$2) return [new e.V(r$2, s$2.zoom, "stop zoom values must be numbers")];
						if (l$1 && l$1 > n$2) return [new e.V(r$2, s$2.zoom, "stop zoom values must appear in ascending order")];
						n$2 !== l$1 && (l$1 = n$2, a$1 = void 0, c$1 = {}), i$2 = i$2.concat(ye({
							key: `${r$2}[0]`,
							value: o$2[0],
							valueSpec: { zoom: {} },
							style: t$2.style,
							styleSpec: t$2.styleSpec,
							objectElementValidators: {
								zoom: K,
								value: f$1
							}
						}));
					} else i$2 = i$2.concat(f$1({
						key: `${r$2}[0]`,
						value: o$2[0],
						style: t$2.style,
						styleSpec: t$2.styleSpec
					}, o$2));
					return e.Q(e.S(o$2[1])) ? i$2.concat([new e.V(`${r$2}[1]`, o$2[1], "expressions are not allowed in function stops.")]) : i$2.concat(ve({
						key: `${r$2}[1]`,
						value: o$2[1],
						valueSpec: s$1,
						style: t$2.style,
						styleSpec: t$2.styleSpec
					}));
				}
				function f$1(t$2, i$2) {
					const o$2 = e.K(t$2.value), l$2 = e.J(t$2.value), h$2 = null !== t$2.value ? t$2.value : i$2;
					if (n$1) {
						if (o$2 !== n$1) return [new e.V(t$2.key, h$2, `${o$2} stop domain type must match previous stop domain type ${n$1}`)];
					} else n$1 = o$2;
					if ("number" !== o$2 && "string" !== o$2 && "boolean" !== o$2 && "number" != typeof l$2 && "string" != typeof l$2 && "boolean" != typeof l$2) return [new e.V(t$2.key, h$2, "stop domain value must be a number, string, or boolean")];
					if ("number" !== o$2 && "categorical" !== r$1) {
						let i$3 = `number expected, ${o$2} found`;
						return e.N(s$1) && void 0 === r$1 && (i$3 += "\nIf you intended to use a categorical function, specify `\"type\": \"categorical\"`."), [new e.V(t$2.key, h$2, i$3)];
					}
					return "categorical" !== r$1 || "number" !== o$2 || "number" == typeof l$2 && isFinite(l$2) && Math.floor(l$2) === l$2 ? "categorical" !== r$1 && "number" === o$2 && "number" == typeof l$2 && "number" == typeof a$1 && void 0 !== a$1 && l$2 < a$1 ? [new e.V(t$2.key, h$2, "stop domain values must appear in ascending order")] : (a$1 = l$2, "categorical" === r$1 && l$2 in c$1 ? [new e.V(t$2.key, h$2, "stop domain values must be unique")] : (c$1[l$2] = !0, [])) : [new e.V(t$2.key, h$2, `integer expected, found ${String(l$2)}`)];
				}
			}
			function Q(t$1) {
				const i$1 = ("property" === t$1.expressionContext ? e.W : e.U)(e.S(t$1.value), t$1.valueSpec);
				if ("error" === i$1.result) return i$1.value.map(((i$2) => new e.V(`${t$1.key}${i$2.key}`, t$1.value, i$2.message)));
				const o$1 = i$1.value.expression || i$1.value._styleExpression.expression;
				if ("property" === t$1.expressionContext && "text-font" === t$1.propertyKey && !o$1.outputDefined()) return [new e.V(t$1.key, t$1.value, `Invalid data expression for "${t$1.propertyKey}". Output values must be contained as literals within the expression.`)];
				if ("property" === t$1.expressionContext && "layout" === t$1.propertyType && !e.Z(o$1)) return [new e.V(t$1.key, t$1.value, "\"feature-state\" data expressions are not supported with layout properties.")];
				if ("filter" === t$1.expressionContext) return ee(o$1, t$1);
				if ("appearance" === t$1.expressionContext) return te(o$1, t$1);
				if (t$1.expressionContext && 0 === t$1.expressionContext.indexOf("cluster")) {
					if (!e.X(o$1, ["zoom", "feature-state"])) return [new e.V(t$1.key, t$1.value, "\"zoom\" and \"feature-state\" expressions are not supported with cluster properties.")];
					if ("cluster-initial" === t$1.expressionContext && !e.Y(o$1)) return [new e.V(t$1.key, t$1.value, "Feature data expressions are not supported with initial expression part of cluster properties.")];
				}
				return [];
			}
			function ee(t$1, i$1) {
				const o$1 = new Set([
					"zoom",
					"feature-state",
					"pitch",
					"distance-from-center"
				]);
				if (i$1.valueSpec && i$1.valueSpec.expression) for (const e$1 of i$1.valueSpec.expression.parameters) o$1.delete(e$1);
				if (0 === o$1.size) return [];
				const s$1 = [];
				return t$1 instanceof e._ && o$1.has(t$1.name) ? [new e.V(i$1.key, i$1.value, `["${t$1.name}"] expression is not supported in a filter for a ${i$1.object.type} layer with id: ${i$1.object.id}`)] : (t$1.eachChild(((e$1) => {
					s$1.push(...ee(e$1, i$1));
				})), s$1);
			}
			function te(t$1, i$1) {
				const o$1 = /* @__PURE__ */ new Set();
				if (i$1.valueSpec && i$1.valueSpec.expression) for (const e$1 of i$1.valueSpec.expression.parameters) o$1.add(e$1);
				if (0 === o$1.size) return [];
				const s$1 = [];
				return t$1 instanceof e._ && !o$1.has(t$1.name) ? [new e.V(i$1.key, i$1.value, `["${t$1.name}"] is not an allowed parameter`)] : (t$1.eachChild(((e$1) => {
					s$1.push(...te(e$1, i$1));
				})), s$1);
			}
			function ie(t$1) {
				const i$1 = t$1.key, o$1 = t$1.value, s$1 = t$1.valueSpec, r$1 = [];
				return Array.isArray(s$1.values) ? -1 === s$1.values.indexOf(e.J(o$1)) && r$1.push(new e.V(i$1, o$1, `expected one of [${s$1.values.join(", ")}], ${JSON.stringify(o$1)} found`)) : -1 === Object.keys(s$1.values).indexOf(e.J(o$1)) && r$1.push(new e.V(i$1, o$1, `expected one of [${Object.keys(s$1.values).join(", ")}], ${JSON.stringify(o$1)} found`)), r$1;
			}
			function oe(t$1) {
				return e.a2(e.S(t$1.value)) ? Q(Object.assign({}, t$1, {
					expressionContext: "filter",
					valueSpec: t$1.styleSpec[`filter_${t$1.layerType || "fill"}`]
				})) : se(t$1);
			}
			function se(t$1) {
				const i$1 = t$1.value, o$1 = t$1.key;
				if (!Array.isArray(i$1)) return [new e.V(o$1, i$1, `array expected, ${e.K(i$1)} found`)];
				if (i$1.length < 1) return [new e.V(o$1, i$1, "filter array must have at least 1 element")];
				const s$1 = t$1.styleSpec;
				let r$1 = ie({
					key: `${o$1}[0]`,
					value: i$1[0],
					valueSpec: s$1.filter_operator
				});
				const n$1 = () => {
					i$1.length >= 2 && (e.a0(i$1[1]) || r$1.push(new e.V(`${o$1}[1]`, i$1[1], `string expected, ${e.K(i$1[1])} found`)));
					for (let t$2 = 2; t$2 < i$1.length; t$2++) "$type" === e.J(i$1[1]) ? r$1 = r$1.concat(ie({
						key: `${o$1}[${t$2}]`,
						value: i$1[t$2],
						valueSpec: s$1.geometry_type
					})) : e.a0(i$1[t$2]) || e.L(i$1[t$2]) || e.$(i$1[t$2]) || r$1.push(new e.V(`${o$1}[${t$2}]`, i$1[t$2], `string, number, or boolean expected, ${e.K(i$1[t$2])} found.`));
				};
				switch (e.J(i$1[0])) {
					case "<":
					case "<=":
					case ">":
					case ">=":
						i$1.length >= 2 && "$type" === e.J(i$1[1]) && r$1.push(new e.V(o$1, i$1, `"$type" cannot be use with operator "${i$1[0]}"`)), 3 !== i$1.length && r$1.push(new e.V(o$1, i$1, `filter array for operator "${i$1[0]}" must have 3 elements`)), n$1();
						break;
					case "==":
					case "!=":
						3 !== i$1.length && r$1.push(new e.V(o$1, i$1, `filter array for operator "${i$1[0]}" must have 3 elements`)), n$1();
						break;
					case "in":
					case "!in":
						n$1();
						break;
					case "any":
					case "all":
					case "none":
						for (let e$1 = 1; e$1 < i$1.length; e$1++) r$1 = r$1.concat(se({
							key: `${o$1}[${e$1}]`,
							value: i$1[e$1],
							style: t$1.style,
							styleSpec: t$1.styleSpec
						}));
						break;
					case "has":
					case "!has": 2 !== i$1.length ? r$1.push(new e.V(o$1, i$1, `filter array for "${i$1[0]}" operator must have 2 elements`)) : e.a0(i$1[1]) || r$1.push(new e.V(`${o$1}[1]`, i$1[1], `string expected, ${e.K(i$1[1])} found`));
				}
				return r$1;
			}
			function re(t$1, i$1) {
				const o$1 = t$1.key, s$1 = t$1.style, r$1 = t$1.layer, n$1 = t$1.styleSpec, a$1 = t$1.value, l$1 = t$1.objectKey, c$1 = n$1[`${i$1}_${t$1.layerType}`];
				if (!c$1) return [];
				const h$1 = l$1.match(/^(.*)-use-theme$/);
				if (h$1 && c$1[h$1[1]]) return e.Q(e.S(a$1)) ? [].concat(ve({
					key: o$1,
					value: a$1,
					valueSpec: {
						type: "string",
						expression: {
							interpolated: !1,
							parameters: ["zoom", "feature"]
						},
						"property-type": "data-driven"
					},
					style: s$1,
					styleSpec: n$1,
					expressionContext: "property",
					propertyType: i$1,
					propertyKey: l$1
				})) : ve({
					key: o$1,
					value: a$1,
					valueSpec: { type: "string" },
					style: s$1,
					styleSpec: n$1
				});
				const d$1 = l$1.match(/^(.*)-transition$/);
				if ("paint" === i$1 && d$1 && c$1[d$1[1]] && c$1[d$1[1]].transition) return ve({
					key: o$1,
					value: a$1,
					valueSpec: n$1.transition,
					style: s$1,
					styleSpec: n$1
				});
				const u$1 = t$1.valueSpec || c$1[l$1];
				if (!u$1) return [new e.a3(o$1, a$1, `unknown property "${l$1}"`)];
				let _$1;
				if (e.a0(a$1) && e.N(u$1) && !u$1.tokens && (_$1 = /^{([^}]+)}$/.exec(a$1))) {
					const t$2 = `\`{ "type": "identity", "property": ${_$1 ? JSON.stringify(_$1[1]) : "\"_\""} }\``;
					return [new e.V(o$1, a$1, `"${l$1}" does not support interpolation syntax\nUse an identity property function instead: ${t$2}.`)];
				}
				const p$1 = [];
				if ("symbol" === t$1.layerType) "text-field" !== l$1 || !s$1 || s$1.glyphs || s$1.imports || p$1.push(new e.V(o$1, a$1, "use of \"text-field\" requires a style \"glyphs\" property")), "text-font" === l$1 && e.a4(e.S(a$1)) && "identity" === e.J(a$1.type) && p$1.push(new e.V(o$1, a$1, "\"text-font\" does not support identity functions"));
				else if ("model" === t$1.layerType && "paint" === i$1 && r$1 && r$1.layout && r$1.layout.hasOwnProperty("model-id") && e.N(u$1) && (e.a5(u$1) || e.O(u$1))) {
					const t$2 = e.W(e.S(a$1), u$1).value, i$2 = "expression" in t$2 && t$2.expression || "_styleExpression" in t$2 && t$2._styleExpression && t$2._styleExpression.expression;
					i$2 && !e.X(i$2, ["measure-light"]) && ("model-emissive-strength" === l$1 && e.Y(i$2) && e.Z(i$2) || p$1.push(new e.V(o$1, a$1, `${l$1} does not support measure-light expressions when the model layer source is vector tile or GeoJSON.`)));
				}
				return p$1.concat(ve({
					key: t$1.key,
					value: a$1,
					valueSpec: u$1,
					style: s$1,
					styleSpec: n$1,
					expressionContext: "property",
					propertyType: i$1,
					propertyKey: l$1
				}));
			}
			function ne(e$1) {
				return re(e$1, "paint");
			}
			function ae(e$1) {
				return re(e$1, "layout");
			}
			function le(t$1) {
				let i$1 = [];
				const o$1 = t$1.value, s$1 = t$1.key, r$1 = t$1.style, n$1 = t$1.styleSpec;
				if (!e.H(o$1)) return [new e.V(s$1, o$1, "object expected")];
				o$1.type || o$1.ref || i$1.push(new e.V(s$1, o$1, "either \"type\" or \"ref\" is required"));
				let a$1 = e.J(o$1.type);
				const l$1 = e.J(o$1.ref);
				if (o$1.id) {
					const n$2 = e.J(o$1.id);
					for (let a$2 = 0; a$2 < t$1.arrayIndex; a$2++) {
						const t$2 = r$1.layers[a$2];
						e.J(t$2.id) === n$2 && i$1.push(new e.V(s$1, o$1.id, `duplicate layer id "${n$2}", previously used at line ${t$2.id.__line__}`));
					}
				}
				if ("ref" in o$1) {
					let t$2;
					[
						"type",
						"source",
						"source-layer",
						"filter",
						"layout"
					].forEach(((t$3) => {
						t$3 in o$1 && i$1.push(new e.V(s$1, o$1[t$3], `"${t$3}" is prohibited for ref layers`));
					})), r$1.layers.forEach(((i$2) => {
						e.J(i$2.id) === l$1 && (t$2 = i$2);
					})), t$2 ? t$2.ref ? i$1.push(new e.V(s$1, o$1.ref, "ref cannot reference another ref layer")) : a$1 = e.J(t$2.type) : "string" == typeof l$1 && i$1.push(new e.V(s$1, o$1.ref, `ref layer "${l$1}" not found`));
				} else if ("background" !== a$1 && "sky" !== a$1 && "slot" !== a$1) if (o$1.source) if (e.a0(o$1.source)) {
					const t$2 = r$1.sources && r$1.sources[o$1.source], n$2 = t$2 && e.J(t$2.type);
					t$2 ? "vector" === n$2 && "raster" === a$1 ? i$1.push(new e.V(s$1, o$1.source, `layer "${o$1.id}" requires a raster source`)) : "raster" === n$2 && "raster" !== a$1 ? i$1.push(new e.V(s$1, o$1.source, `layer "${o$1.id}" requires a vector source`)) : "vector" !== n$2 || o$1["source-layer"] ? "raster-dem" === n$2 && "hillshade" !== a$1 ? i$1.push(new e.V(s$1, o$1.source, "raster-dem source can only be used with layer type 'hillshade'.")) : "raster-array" !== n$2 || ["raster", "raster-particle"].includes(a$1) ? "line" === a$1 && o$1.paint && (o$1.paint["line-gradient"] || o$1.paint["line-trim-offset"]) && "geojson" === n$2 && !t$2.lineMetrics ? i$1.push(new e.V(s$1, o$1, `layer "${o$1.id}" specifies a line-gradient, which requires the GeoJSON source to have \`lineMetrics\` enabled.`)) : "raster-particle" === a$1 && "raster-array" !== n$2 && i$1.push(new e.V(s$1, o$1.source, `layer "${o$1.id}" requires a 'raster-array' source.`)) : i$1.push(new e.V(s$1, o$1.source, "raster-array source can only be used with layer type 'raster'.")) : i$1.push(new e.V(s$1, o$1, `layer "${o$1.id}" must specify a "source-layer"`)) : i$1.push(new e.V(s$1, o$1.source, `source "${o$1.source}" not found`));
				} else i$1.push(new e.V(`${s$1}.source`, o$1.source, "\"source\" must be a string"));
				else i$1.push(new e.V(s$1, o$1, "missing required property \"source\""));
				return i$1 = i$1.concat(ye({
					key: s$1,
					value: o$1,
					valueSpec: n$1.layer,
					style: t$1.style,
					styleSpec: t$1.styleSpec,
					objectElementValidators: {
						"*": () => [],
						type: () => ve({
							key: `${s$1}.type`,
							value: o$1.type,
							valueSpec: n$1.layer.type,
							style: t$1.style,
							styleSpec: t$1.styleSpec,
							object: o$1,
							objectKey: "type"
						}),
						filter: (e$1) => oe(Object.assign({ layerType: a$1 }, e$1)),
						layout: (e$1) => ye({
							layer: o$1,
							key: e$1.key,
							value: e$1.value,
							valueSpec: {},
							style: e$1.style,
							styleSpec: e$1.styleSpec,
							objectElementValidators: { "*": (e$2) => ae(Object.assign({ layerType: a$1 }, e$2)) }
						}),
						paint: (e$1) => ye({
							layer: o$1,
							key: e$1.key,
							value: e$1.value,
							valueSpec: {},
							style: e$1.style,
							styleSpec: e$1.styleSpec,
							objectElementValidators: { "*": (e$2) => ne(Object.assign({
								layerType: a$1,
								layer: o$1
							}, e$2)) }
						}),
						appearances(t$2) {
							const i$2 = Y({
								key: t$2.key,
								value: t$2.value,
								valueSpec: t$2.valueSpec,
								style: t$2.style,
								styleSpec: t$2.styleSpec,
								arrayElementValidator: (t$3) => function(t$4) {
									const { key: i$3, layer: o$2, layerType: s$3 } = t$4, r$3 = e.J(t$4.value), n$2 = e.J(r$3.name), a$2 = e.J(r$3.condition), l$2 = ye({
										key: i$3,
										value: r$3,
										valueSpec: t$4.styleSpec.appearance,
										style: t$4.style,
										styleSpec: t$4.styleSpec,
										objectElementValidators: {
											condition: (t$5) => function(t$6) {
												const i$4 = [];
												return i$4.push(...Q({
													key: t$6.key,
													value: t$6.object.condition,
													valueSpec: e.a6.appearance.condition,
													expressionContext: "appearance"
												})), i$4;
											}(Object.assign({
												layer: o$2,
												layerType: s$3
											}, t$5)),
											properties: (t$5) => function(t$6) {
												const i$4 = [], { styleSpec: o$3, layer: s$4, layerType: r$4 } = t$6, n$3 = o$3[`paint_${r$4}`], a$3 = o$3[`layout_${r$4}`], l$3 = t$6.object[t$6.objectKey];
												for (const o$4 in l$3) {
													const c$1 = o$4 in n$3 ? "paint" : o$4 in a$3 ? "layout" : void 0;
													if (!c$1) {
														i$4.push(new e.V(t$6.key, o$4, `unknown property "${o$4}" for layer type "${r$4}"`));
														continue;
													}
													const h$1 = Object.assign({}, t$6, {
														key: `${t$6.key}.${o$4}`,
														object: l$3,
														objectKey: o$4,
														layer: s$4,
														layerType: r$4,
														value: l$3[o$4],
														valueSpec: "paint" === c$1 ? n$3[o$4] : a$3[o$4]
													});
													i$4.push(...re(h$1, c$1));
												}
												return i$4;
											}(Object.assign({
												layer: o$2,
												layerType: s$3
											}, t$5))
										}
									});
									return "hidden" !== n$2 && void 0 === a$2 && l$2.push(new e.V(t$4.key, "name", "Appearance with name different than \"hidden\" must have a condition")), l$2;
								}(Object.assign({
									layerType: a$1,
									layer: o$1
								}, t$3))
							}), s$2 = Array.isArray(t$2.value) ? t$2.value : [], r$2 = /* @__PURE__ */ new Set();
							return s$2.forEach(((s$3, n$2) => {
								const a$2 = e.J(s$3.name);
								if (a$2) if (r$2.has(a$2)) {
									const s$4 = e.J(o$1.id);
									i$2.push(new e.V(t$2.key, a$2, `Duplicated appearance name "${a$2}" for layer "${s$4}"`));
								} else r$2.add(a$2);
							})), i$2;
						}
					}
				})), i$1;
			}
			function ce({ key: t$1, value: i$1 }) {
				return e.a0(i$1) ? [] : [new e.V(t$1, i$1, `string expected, ${e.K(i$1)} found`)];
			}
			const he = { promoteId: function t$1({ key: i$1, value: o$1 }) {
				if (e.a0(o$1)) return ce({
					key: i$1,
					value: o$1
				});
				if (Array.isArray(o$1)) {
					const t$2 = [], s$2 = e.S(o$1), r$1 = e.U(s$2);
					return "error" === r$1.result && r$1.value.forEach(((o$2) => {
						t$2.push(new e.V(`${i$1}${o$2.key}`, null, `${o$2.message}`));
					})), e.X(r$1.value.expression, [
						"zoom",
						"heatmap-density",
						"line-progress",
						"raster-value",
						"sky-radial-progress",
						"accumulated",
						"is-supported-script",
						"pitch",
						"distance-from-center",
						"measure-light",
						"raster-particle-speed"
					]) || t$2.push(new e.V(`${i$1}`, null, "promoteId expression should be only feature dependent")), t$2;
				}
				if (!e.H(o$1)) return [new e.V(i$1, o$1, `string, expression or object expected, "${e.K(o$1)}" found`)];
				const s$1 = [];
				for (const e$1 in o$1) s$1.push(...t$1({
					key: `${i$1}.${e$1}`,
					value: o$1[e$1]
				}));
				return s$1;
			} };
			function de(t$1) {
				const i$1 = t$1.value, o$1 = t$1.key, s$1 = t$1.styleSpec, r$1 = t$1.style;
				if (!e.H(i$1)) return [new e.V(o$1, i$1, `object expected, ${e.K(i$1)} found`)];
				if (!("type" in i$1)) return [new e.V(o$1, i$1, "\"type\" is required")];
				const n$1 = e.J(i$1.type);
				let a$1 = [];
				switch ([
					"vector",
					"raster",
					"raster-dem",
					"raster-array"
				].includes(n$1) && ("url" in i$1 || "tiles" in i$1 || a$1.push(new e.a3(o$1, i$1, "Either \"url\" or \"tiles\" is required."))), n$1) {
					case "vector":
					case "raster":
					case "raster-dem":
					case "raster-array": return a$1 = a$1.concat(ye({
						key: o$1,
						value: i$1,
						valueSpec: s$1[`source_${n$1.replace("-", "_")}`],
						style: t$1.style,
						styleSpec: s$1,
						objectElementValidators: he
					})), a$1;
					case "geojson":
						if (a$1 = ye({
							key: o$1,
							value: i$1,
							valueSpec: s$1.source_geojson,
							style: r$1,
							styleSpec: s$1,
							objectElementValidators: he
						}), "cluster" in i$1 && "clusterProperties" in i$1) {
							if (!e.H(i$1.clusterProperties)) return [new e.V(`${o$1}.clusterProperties`, i$1, `object expected, ${e.K(i$1)} found`)];
							for (const t$2 in i$1.clusterProperties) {
								const s$2 = i$1.clusterProperties[t$2];
								if (!Array.isArray(s$2)) return [new e.V(`${o$1}.clusterProperties.${t$2}`, s$2, "array expected")];
								const [r$2, n$2] = s$2, l$1 = "string" == typeof r$2 ? [
									r$2,
									["accumulated"],
									["get", t$2]
								] : r$2;
								a$1.push(...Q({
									key: `${o$1}.${t$2}.map`,
									value: n$2,
									expressionContext: "cluster-map"
								})), a$1.push(...Q({
									key: `${o$1}.${t$2}.reduce`,
									value: l$1,
									expressionContext: "cluster-reduce"
								}));
							}
						}
						return a$1;
					case "video": return ye({
						key: o$1,
						value: i$1,
						valueSpec: s$1.source_video,
						style: r$1,
						styleSpec: s$1
					});
					case "image": return ye({
						key: o$1,
						value: i$1,
						valueSpec: s$1.source_image,
						style: r$1,
						styleSpec: s$1
					});
					case "canvas": return [new e.V(o$1, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
					default: return ie({
						key: `${o$1}.type`,
						value: i$1.type,
						valueSpec: { values: ue(s$1) }
					});
				}
			}
			function ue(e$1) {
				return e$1.source.reduce(((t$1, i$1) => {
					const o$1 = e$1[i$1];
					return "enum" === o$1.type.type && (t$1 = t$1.concat(Object.keys(o$1.type.values || {}))), t$1;
				}), []);
			}
			function _e(t$1) {
				const i$1 = t$1.value, o$1 = t$1.styleSpec, s$1 = o$1.light, r$1 = t$1.style;
				if (void 0 === i$1) return [];
				if (!e.H(i$1)) return [new e.V("light", i$1, `object expected, ${e.K(i$1)} found`)];
				let n$1 = [];
				for (const t$2 in i$1) {
					const a$1 = t$2.match(/^(.*)-transition$/), l$1 = t$2.match(/^(.*)-use-theme$/);
					n$1 = n$1.concat(l$1 && s$1[l$1[1]] ? ve({
						key: t$2,
						value: i$1[t$2],
						valueSpec: { type: "string" },
						style: r$1,
						styleSpec: o$1
					}) : a$1 && s$1[a$1[1]] && s$1[a$1[1]].transition ? ve({
						key: t$2,
						value: i$1[t$2],
						valueSpec: o$1.transition,
						style: r$1,
						styleSpec: o$1
					}) : s$1[t$2] ? ve({
						key: t$2,
						value: i$1[t$2],
						valueSpec: s$1[t$2],
						style: r$1,
						styleSpec: o$1
					}) : [new e.V(t$2, i$1[t$2], `unknown property "${t$2}"`)]);
				}
				return n$1;
			}
			function pe(t$1) {
				const i$1 = t$1.value;
				if (!i$1) return [];
				const o$1 = t$1.key;
				if (!e.H(i$1)) return [new e.V(o$1, i$1, `object expected, ${e.K(i$1)} found`)];
				let s$1 = [];
				const r$1 = t$1.styleSpec, n$1 = r$1["light-3d"], a$1 = t$1.style, l$1 = t$1.style.lights;
				for (const t$2 of ["type", "id"]) if (!(t$2 in i$1)) return s$1 = s$1.concat([new e.V(o$1, i$1, `missing property "${t$2}"`)]), s$1;
				if (!e.a0(i$1.type)) return s$1 = s$1.concat([new e.V(`${o$1}.type`, i$1.type, "string expected")]), s$1;
				if (l$1) for (let r$2 = 0; r$2 < t$1.arrayIndex; r$2++) {
					const t$2 = e.J(i$1.type), n$2 = l$1[r$2];
					e.J(n$2.type) === t$2 && s$1.push(new e.V(o$1, i$1.id, `duplicate light type "${i$1.type}", previously defined at line ${n$2.id.__line__}`));
				}
				const c$1 = `properties_light_${i$1.type}`;
				if (!(c$1 in r$1)) return s$1 = s$1.concat([new e.V(`${o$1}.type`, i$1, `Invalid light type ${i$1.type}`)]), s$1;
				const h$1 = r$1[c$1];
				for (const o$2 in i$1) if ("properties" === o$2) {
					const n$2 = i$1[o$2];
					if (!e.H(n$2)) return s$1 = s$1.concat([new e.V("properties", n$2, `object expected, ${e.K(n$2)} found`)]), s$1;
					for (const l$2 in n$2) {
						const c$2 = l$2.match(/^(.*)-transition$/), d$1 = l$2.match(/^(.*)-use-theme$/);
						s$1 = s$1.concat(d$1 && h$1[d$1[1]] ? ve({
							key: o$2,
							value: n$2[l$2],
							valueSpec: { type: "string" },
							style: a$1,
							styleSpec: r$1
						}) : c$2 && h$1[c$2[1]] && h$1[c$2[1]].transition ? ve({
							key: o$2,
							value: i$1[o$2],
							valueSpec: r$1.transition,
							style: a$1,
							styleSpec: r$1
						}) : h$1[l$2] ? ve({
							key: l$2,
							value: n$2[l$2],
							valueSpec: h$1[l$2],
							style: a$1,
							styleSpec: r$1
						}) : [new e.a3(t$1.key, n$2[l$2], `unknown property "${l$2}"`)]);
					}
				} else s$1 = s$1.concat(n$1[o$2] ? ve({
					key: o$2,
					value: i$1[o$2],
					valueSpec: n$1[o$2],
					style: a$1,
					styleSpec: r$1
				}) : [new e.a3(o$2, i$1[o$2], `unknown property "${o$2}"`)]);
				return s$1;
			}
			function fe(t$1) {
				const i$1 = t$1.value, o$1 = t$1.key, s$1 = t$1.style, r$1 = t$1.styleSpec, n$1 = r$1.terrain;
				if (null == i$1) return [];
				if (!e.H(i$1)) return [new e.V("terrain", i$1, `object expected, ${e.K(i$1)} found`)];
				let a$1 = [];
				for (const t$2 in i$1) {
					const o$2 = t$2.match(/^(.*)-transition$/), l$1 = t$2.match(/^(.*)-use-theme$/);
					a$1 = a$1.concat(l$1 && n$1[l$1[1]] ? ve({
						key: t$2,
						value: i$1[t$2],
						valueSpec: { type: "string" },
						style: s$1,
						styleSpec: r$1
					}) : o$2 && n$1[o$2[1]] && n$1[o$2[1]].transition ? ve({
						key: t$2,
						value: i$1[t$2],
						valueSpec: r$1.transition,
						style: s$1,
						styleSpec: r$1
					}) : n$1[t$2] ? ve({
						key: t$2,
						value: i$1[t$2],
						valueSpec: n$1[t$2],
						style: s$1,
						styleSpec: r$1
					}) : [new e.a3(t$2, i$1[t$2], `unknown property "${t$2}"`)]);
				}
				if (i$1.source) if (e.a0(i$1.source)) {
					const t$2 = s$1.sources && s$1.sources[i$1.source], r$2 = t$2 && e.J(t$2.type);
					t$2 ? "raster-dem" !== r$2 && a$1.push(new e.V(`${o$1}.source`, i$1.source, `terrain cannot be used with a source of type ${r$2}, it only be used with a "raster-dem" source type`)) : a$1.push(new e.V(`${o$1}.source`, i$1.source, `source "${i$1.source}" not found`));
				} else a$1.push(new e.V(`${o$1}.source`, i$1.source, "source must be a string"));
				else a$1.push(new e.V(o$1, i$1, "terrain is missing required property \"source\""));
				return a$1;
			}
			function me(t$1) {
				const i$1 = t$1.value, o$1 = t$1.style, s$1 = t$1.styleSpec, r$1 = s$1.fog;
				if (void 0 === i$1) return [];
				if (!e.H(i$1)) return [new e.V("fog", i$1, `object expected, ${e.K(i$1)} found`)];
				let n$1 = [];
				for (const t$2 in i$1) {
					const a$1 = t$2.match(/^(.*)-transition$/), l$1 = t$2.match(/^(.*)-use-theme$/);
					n$1 = n$1.concat(l$1 && r$1[l$1[1]] ? ve({
						key: t$2,
						value: i$1[t$2],
						valueSpec: { type: "string" },
						style: o$1,
						styleSpec: s$1
					}) : a$1 && r$1[a$1[1]] && r$1[a$1[1]].transition ? ve({
						key: t$2,
						value: i$1[t$2],
						valueSpec: s$1.transition,
						style: o$1,
						styleSpec: s$1
					}) : r$1[t$2] ? ve({
						key: t$2,
						value: i$1[t$2],
						valueSpec: r$1[t$2],
						style: o$1,
						styleSpec: s$1
					}) : [new e.a3(t$2, i$1[t$2], `unknown property "${t$2}"`)]);
				}
				return n$1;
			}
			const ge = {
				"*": () => [],
				array: Y,
				boolean: function(t$1) {
					const i$1 = t$1.value, o$1 = t$1.key;
					return e.$(i$1) ? [] : [new e.V(o$1, i$1, `boolean expected, ${e.K(i$1)} found`)];
				},
				number: K,
				color: function({ key: t$1, value: i$1 }) {
					return e.a0(i$1) ? null === e.a1.parseCSSColor(i$1) ? [new e.V(t$1, i$1, `color expected, "${i$1}" found`)] : [] : [new e.V(t$1, i$1, `color expected, ${e.K(i$1)} found`)];
				},
				enum: ie,
				filter: oe,
				function: J,
				layer: le,
				object: ye,
				source: de,
				model: e.a7,
				light: _e,
				"light-3d": pe,
				terrain: fe,
				fog: me,
				string: ce,
				formatted: function(e$1) {
					return 0 === ce(e$1).length ? [] : Q(e$1);
				},
				resolvedImage: function(e$1) {
					return 0 === ce(e$1).length ? [] : Q(e$1);
				},
				projection: function(t$1) {
					const i$1 = t$1.value, o$1 = t$1.styleSpec, s$1 = o$1.projection, r$1 = t$1.style;
					if (e.H(i$1)) {
						let e$1 = [];
						for (const t$2 in i$1) e$1 = e$1.concat(ve({
							key: t$2,
							value: i$1[t$2],
							valueSpec: s$1[t$2],
							style: r$1,
							styleSpec: o$1
						}));
						return e$1;
					}
					return e.a0(i$1) ? [] : [new e.V("projection", i$1, `object or string expected, ${e.K(i$1)} found`)];
				},
				import: function(t$1) {
					const i$1 = t$1.key, { value: o$1, styleSpec: s$1 } = t$1;
					if (!e.H(o$1)) return [new e.V(i$1, o$1, "import must be an object")];
					const { data: r$1, ...n$1 } = o$1;
					Object.defineProperty(n$1, "__line__", {
						value: o$1.__line__,
						enumerable: !1
					});
					let a$1 = ye(Object.assign({}, t$1, {
						value: n$1,
						valueSpec: s$1.import
					}));
					return "" === e.J(n$1.id) && a$1.push(new e.V(`${t$1.key}.id`, n$1, "import id can't be an empty string")), r$1 && (a$1 = a$1.concat(be(r$1, s$1, { key: `${t$1.key}.data` }))), a$1;
				},
				iconset: function(t$1) {
					const i$1 = t$1.value, o$1 = t$1.key, s$1 = t$1.styleSpec, r$1 = t$1.style;
					if (!e.H(i$1)) return [new e.V(o$1, i$1, "object expected")];
					if (!i$1.type) return [new e.V(o$1, i$1, "\"type\" is required")];
					const n$1 = e.J(i$1.type);
					let a$1 = [];
					if (a$1 = a$1.concat(ye({
						key: o$1,
						value: i$1,
						valueSpec: s$1[`iconset_${n$1}`],
						style: r$1,
						styleSpec: s$1
					})), function(e$1, t$2) {
						return !("source" !== e$1 || !t$2.source);
					}(n$1, i$1)) {
						const t$2 = r$1.sources && r$1.sources[i$1.source], s$2 = t$2 && e.J(t$2.type);
						t$2 ? "raster-array" !== s$2 && a$1.push(new e.V(o$1, i$1.source, `iconset cannot be used with a source of type ${String(s$2)}, it only be used with a "raster-array" source type`)) : a$1.push(new e.V(o$1, i$1.source, `source "${i$1.source}" not found`));
					}
					return a$1;
				}
			};
			function ve(t$1, i$1 = !1) {
				const o$1 = t$1.value, s$1 = t$1.valueSpec, r$1 = t$1.styleSpec;
				if (s$1.expression) {
					if (e.a4(e.J(o$1))) return J(t$1);
					if (e.Q(e.S(o$1))) return Q(t$1);
				}
				if (s$1.type && ge[s$1.type]) {
					const e$1 = ge[s$1.type](t$1);
					return !0 === i$1 && e$1.length > 0 && Array.isArray(t$1.value) ? Q(t$1) : e$1;
				}
				return ye(Object.assign({}, t$1, { valueSpec: s$1.type ? r$1[s$1.type] : s$1 }));
			}
			function ye(t$1) {
				const i$1 = t$1.key, o$1 = t$1.value, s$1 = t$1.valueSpec || {}, r$1 = t$1.objectElementValidators || {}, n$1 = t$1.style, a$1 = t$1.styleSpec;
				if (!e.H(o$1)) return [new e.V(i$1, o$1, `object expected, ${e.K(o$1)} found`)];
				let l$1 = [];
				for (const t$2 in o$1) {
					const c$1 = t$2.split(".")[0];
					let h$1;
					r$1[c$1] ? h$1 = r$1[c$1] : s$1[c$1] ? h$1 = ve : r$1["*"] ? h$1 = r$1["*"] : s$1["*"] && (h$1 = ve), h$1 ? l$1 = l$1.concat(h$1({
						key: (i$1 ? `${i$1}.` : i$1) + t$2,
						value: o$1[t$2],
						valueSpec: s$1[c$1] || s$1["*"],
						style: n$1,
						styleSpec: a$1,
						object: o$1,
						objectKey: t$2
					}, o$1)) : l$1.push(new e.a3(i$1, o$1[t$2], `unknown property "${t$2}"`));
				}
				for (const t$2 in s$1) {
					if (r$1[t$2]) continue;
					const n$2 = s$1[t$2];
					n$2.required && void 0 === n$2.default && void 0 === o$1[t$2] && l$1.push(new e.V(i$1, o$1, `missing required property "${t$2}"`));
				}
				return l$1;
			}
			function xe({ key: t$1, value: i$1 }) {
				const o$1 = ce({
					key: t$1,
					value: i$1
				});
				if (o$1.length) return o$1;
				const s$1 = i$1;
				return -1 === s$1.indexOf("{fontstack}") && o$1.push(new e.V(t$1, i$1, "\"glyphs\" url must include a \"{fontstack}\" token")), -1 === s$1.indexOf("{range}") && o$1.push(new e.V(t$1, i$1, "\"glyphs\" url must include a \"{range}\" token")), o$1;
			}
			function be(t$1, i$1 = e.a6, o$1 = {}) {
				return ye({
					key: o$1.key || "",
					value: t$1,
					valueSpec: Object.assign(i$1.$root, { "*": { type: "*" } }),
					styleSpec: i$1,
					style: t$1,
					objectElementValidators: { glyphs: xe }
				});
			}
			function we(t$1, i$1 = e.a6) {
				return Me(be(t$1, i$1));
			}
			const Te = (e$1) => Me(de(e$1)), Ee = (e$1) => Me(_e(e$1)), Se = (e$1) => Me(pe(e$1)), Ie = (e$1) => Me(fe(e$1)), Ce = (e$1) => Me(me(e$1)), Re = (t$1) => Me(function(t$2) {
				const i$1 = t$2.value, o$1 = t$2.style, s$1 = t$2.styleSpec, r$1 = s$1.snow;
				if (void 0 === i$1) return [];
				if (!e.H(i$1)) return [new e.V("snow", i$1, `object expected, ${e.K(i$1)} found`)];
				let n$1 = [];
				for (const t$3 in i$1) {
					const a$1 = t$3.match(/^(.*)-transition$/);
					n$1 = n$1.concat(a$1 && r$1[a$1[1]] && r$1[a$1[1]].transition ? ve({
						key: t$3,
						value: i$1[t$3],
						valueSpec: s$1.transition,
						style: o$1,
						styleSpec: s$1
					}) : r$1[t$3] ? ve({
						key: t$3,
						value: i$1[t$3],
						valueSpec: r$1[t$3],
						style: o$1,
						styleSpec: s$1
					}) : [new e.a3(t$3, i$1[t$3], `unknown property "${t$3}"`)]);
				}
				return n$1;
			}(t$1)), Ae = (t$1) => Me(function(t$2) {
				const i$1 = t$2.value, o$1 = t$2.style, s$1 = t$2.styleSpec, r$1 = s$1.rain;
				if (void 0 === i$1) return [];
				if (!e.H(i$1)) return [new e.V("rain", i$1, `object expected, ${e.K(i$1)} found`)];
				let n$1 = [];
				for (const t$3 in i$1) {
					const a$1 = t$3.match(/^(.*)-transition$/);
					n$1 = n$1.concat(a$1 && r$1[a$1[1]] && r$1[a$1[1]].transition ? ve({
						key: t$3,
						value: i$1[t$3],
						valueSpec: s$1.transition,
						style: o$1,
						styleSpec: s$1
					}) : r$1[t$3] ? ve({
						key: t$3,
						value: i$1[t$3],
						valueSpec: r$1[t$3],
						style: o$1,
						styleSpec: s$1
					}) : [new e.a3(t$3, i$1[t$3], `unknown property "${t$3}"`)]);
				}
				return n$1;
			}(t$1)), Le = (e$1) => Me(le(e$1)), De = (e$1) => Me(oe(e$1)), Pe = (e$1) => Me(ne(e$1)), Oe = (e$1) => Me(ae(e$1)), ze = (t$1) => Me(e.a7(t$1));
			function Me(e$1) {
				return e$1.slice().sort(((e$2, t$1) => e$2.line && t$1.line ? e$2.line - t$1.line : 0));
			}
			function Fe(t$1, i$1) {
				let o$1 = !1;
				if (i$1 && i$1.length) for (const s$1 of i$1) s$1 instanceof e.a3 ? e.w(s$1.message) : (t$1.fire(new e.y(new Error(s$1.message))), o$1 = !0);
				return o$1;
			}
			const Be = e.a6.light;
			let ke;
			class Ne extends e.E {
				constructor(t$1, i$1 = "flat") {
					super(), this._transitionable = new e.a8(ke || (ke = new e.a9({
						anchor: new e.aa(Be.anchor),
						position: new e.ab(Be.position),
						color: new e.aa(Be.color),
						intensity: new e.aa(Be.intensity)
					}))), this.setLight(t$1, i$1), this._transitioning = this._transitionable.untransitioned();
				}
				getLight() {
					return this._transitionable.serialize();
				}
				setLight(e$1, t$1, i$1 = {}) {
					this._validate(Ee, e$1, i$1) || (this._transitionable.setTransitionOrValue(e$1), this.id = t$1);
				}
				updateTransitions(e$1) {
					this._transitioning = this._transitionable.transitioned(e$1, this._transitioning);
				}
				hasTransition() {
					return this._transitioning.hasTransition();
				}
				recalculate(e$1) {
					this.properties = this._transitioning.possiblyEvaluate(e$1);
				}
				_validate(t$1, i$1, o$1) {
					return (!o$1 || !1 !== o$1.validate) && Fe(this, t$1.call(we, Object.assign({
						value: i$1,
						style: {
							glyphs: !0,
							sprite: !0
						},
						styleSpec: e.a6
					})));
				}
			}
			const Ue = e.a6.terrain;
			let je = class extends e.E {
				constructor(t$1, i$1, o$1, s$1, r$1) {
					super(), this.scope = o$1, this._transitionable = new e.a8(new e.a9({
						source: new e.aa(Ue.source),
						exaggeration: new e.aa(Ue.exaggeration)
					}), o$1, s$1), this._transitionable.setTransitionOrValue(t$1, s$1), this._transitioning = this._transitionable.untransitioned(), this.drapeRenderMode = i$1, this.worldview = r$1;
				}
				get() {
					return this._transitionable.serialize();
				}
				set(e$1, t$1) {
					this._transitionable.setTransitionOrValue(e$1, t$1);
				}
				updateTransitions(e$1) {
					this._transitioning = this._transitionable.transitioned(e$1, this._transitioning);
				}
				hasTransition() {
					return this._transitioning.hasTransition();
				}
				recalculate(e$1) {
					this.properties = this._transitioning.possiblyEvaluate(e$1);
				}
				getExaggeration(t$1) {
					return this._transitioning.possiblyEvaluate(new e.ac(t$1, { worldview: this.worldview })).get("exaggeration");
				}
				getAttenuationRange() {
					if (!this.isZoomDependent()) return null;
					const t$1 = this._transitionable._values.exaggeration;
					if (!t$1) return null;
					const i$1 = t$1.value.expression;
					if (!i$1) return null;
					let o$1 = -1, s$1 = -1, r$1 = 1;
					for (const t$2 of i$1.zoomStops) r$1 = i$1.evaluate(new e.ac(t$2, { worldview: this.worldview })), r$1 > .01 ? (o$1 = t$2, s$1 = -1) : s$1 = t$2;
					return r$1 < .01 && o$1 > 0 && s$1 > o$1 ? [o$1, s$1] : null;
				}
				isZoomDependent() {
					const t$1 = this._transitionable._values.exaggeration;
					return null != t$1 && null != t$1.value && null != t$1.value.expression && t$1.value.expression instanceof e.ad;
				}
			};
			const Ge = 45, Ve = 65, He = .05;
			function qe(t$1, i$1, o$1, s$1) {
				const r$1 = e.ah(Ge, Ve, o$1), [n$1, a$1] = Ze(t$1, s$1);
				let l$1 = 1 - Math.min(1, Math.exp((i$1 - n$1) / (a$1 - n$1) * -6));
				return l$1 *= l$1 * l$1, l$1 = Math.min(1, 1.00747 * l$1), l$1 * r$1 * t$1.alpha;
			}
			function Ze(e$1, t$1) {
				const i$1 = .5 / Math.tan(.5 * t$1);
				return [e$1.range[0] + i$1, e$1.range[1] + i$1];
			}
			function We(t$1, i$1, o$1, s$1, r$1) {
				const n$1 = e.af([], [
					i$1,
					o$1,
					s$1
				], r$1.mercatorFogMatrix);
				return qe(t$1, e.ag(n$1), r$1.pitch, r$1._fov);
			}
			function $e(t$1, i$1, o$1, s$1, r$1, n$1, a$1) {
				const l$1 = [
					[
						o$1,
						s$1,
						0
					],
					[
						r$1,
						s$1,
						0
					],
					[
						r$1,
						n$1,
						0
					],
					[
						o$1,
						n$1,
						0
					]
				];
				let c$1 = Number.MAX_VALUE, h$1 = -Number.MAX_VALUE;
				for (const t$2 of l$1) {
					const o$2 = e.af([], t$2, i$1), s$2 = e.ag(o$2);
					c$1 = Math.min(c$1, s$2), h$1 = Math.max(h$1, s$2);
				}
				return [qe(t$1, c$1, a$1.pitch, a$1._fov), qe(t$1, h$1, a$1.pitch, a$1._fov)];
			}
			const Xe = e.a6.fog;
			class Ye extends e.E {
				constructor(t$1, i$1, o$1, s$1) {
					super();
					const r$1 = new e.a9({
						range: new e.aa(Xe.range),
						color: new e.aa(Xe.color),
						"color-use-theme": new e.aa({
							type: "string",
							"property-type": "data-constant",
							default: "default"
						}),
						"high-color": new e.aa(Xe["high-color"]),
						"high-color-use-theme": new e.aa({
							type: "string",
							"property-type": "data-constant",
							default: "default"
						}),
						"space-color": new e.aa(Xe["space-color"]),
						"space-color-use-theme": new e.aa({
							type: "string",
							"property-type": "data-constant",
							default: "default"
						}),
						"horizon-blend": new e.aa(Xe["horizon-blend"]),
						"star-intensity": new e.aa(Xe["star-intensity"]),
						"vertical-range": new e.aa(Xe["vertical-range"])
					});
					this._transitionable = new e.a8(r$1, o$1, new Map(s$1)), this.set(t$1, s$1), this._transitioning = this._transitionable.untransitioned(), this._transform = i$1, this.properties = new e.ai(r$1), this.scope = o$1;
				}
				get state() {
					const t$1 = this._transform, i$1 = "globe" === t$1.projection.name, o$1 = e.aj(t$1.zoom), s$1 = this.properties.get("range"), r$1 = [.5, 3];
					return {
						range: i$1 ? [e.ak(r$1[0], s$1[0], o$1), e.ak(r$1[1], s$1[1], o$1)] : s$1,
						horizonBlend: this.properties.get("horizon-blend"),
						alpha: this.properties.get("color").a
					};
				}
				get() {
					return this._transitionable.serialize();
				}
				set(e$1, t$1, i$1 = {}) {
					if (this._validate(Ce, e$1, i$1)) return;
					const o$1 = Object.assign({}, e$1);
					for (const e$2 of Object.keys(Xe)) void 0 === o$1[e$2] && (o$1[e$2] = Xe[e$2].default);
					this._options = o$1, this._transitionable.setTransitionOrValue(this._options, t$1);
				}
				getOpacity(t$1) {
					if (!this._transform.projection.supportsFog) return 0;
					const i$1 = this.properties && this.properties.get("color") || 1;
					return ("globe" === this._transform.projection.name ? 1 : e.ah(Ge, Ve, t$1)) * i$1.a;
				}
				getOpacityAtLatLng(t$1, i$1) {
					return this._transform.projection.supportsFog ? function(t$2, i$2, o$1) {
						const s$1 = e.ae.fromLngLat(i$2), r$1 = o$1.elevation ? o$1.elevation.getAtPointOrZero(s$1) : 0;
						return We(t$2, s$1.x, s$1.y, r$1, o$1);
					}(this.state, t$1, i$1) : 0;
				}
				getOpacityForTile(t$1) {
					if (!this._transform.projection.supportsFog) return [1, 1];
					const i$1 = this._transform.calculateFogTileMatrix(t$1.toUnwrapped());
					return $e(this.state, i$1, 0, 0, e.al, e.al, this._transform);
				}
				getOpacityForBounds(e$1, t$1, i$1, o$1, s$1) {
					return this._transform.projection.supportsFog ? $e(this.state, e$1, t$1, i$1, o$1, s$1, this._transform) : [1, 1];
				}
				getFovAdjustedRange(e$1) {
					return this._transform.projection.supportsFog ? Ze(this.state, e$1) : [0, 1];
				}
				isVisibleOnFrustum(t$1) {
					if (!this._transform.projection.supportsFog) return !1;
					for (const o$1 of [
						4,
						5,
						6,
						7
					]) {
						const i$1 = t$1.points[o$1];
						let s$1;
						if (i$1[2] >= 0) s$1 = i$1;
						else {
							const r$1 = t$1.points[o$1 - 4];
							s$1 = e.am(r$1, i$1, r$1[2] / (r$1[2] - i$1[2]));
						}
						if (We(this.state, s$1[0], s$1[1], 0, this._transform) >= He) return !0;
					}
					return !1;
				}
				updateConfig(e$1) {
					this._transitionable.setTransitionOrValue(this._options, new Map(e$1));
				}
				updateTransitions(e$1) {
					this._transitioning = this._transitionable.transitioned(e$1, this._transitioning);
				}
				hasTransition() {
					return this._transitioning.hasTransition();
				}
				recalculate(e$1) {
					this.properties = this._transitioning.possiblyEvaluate(e$1);
				}
				_validate(t$1, i$1, o$1) {
					return (!o$1 || !1 !== o$1.validate) && Fe(this, t$1.call(we, Object.assign({
						value: i$1,
						style: {
							glyphs: !0,
							sprite: !0
						},
						styleSpec: e.a6
					})));
				}
			}
			let Ke, Je, Qe, et, tt = class extends e.E {
				constructor(t$1, i$1, o$1, s$1) {
					super();
					const r$1 = Ke || (Ke = new e.a9({
						density: new e.aa(e.a6.snow.density),
						intensity: new e.aa(e.a6.snow.intensity),
						color: new e.aa(e.a6.snow.color),
						opacity: new e.aa(e.a6.snow.opacity),
						vignette: new e.aa(e.a6.snow.vignette),
						"vignette-color": new e.aa(e.a6.snow["vignette-color"]),
						"center-thinning": new e.aa(e.a6.snow["center-thinning"]),
						direction: new e.aa(e.a6.snow.direction),
						"flake-size": new e.aa(e.a6.snow["flake-size"])
					}));
					this._transitionable = new e.a8(r$1, o$1, new Map(s$1)), this.set(t$1, s$1), this._transitioning = this._transitionable.untransitioned(), this.properties = new e.ai(r$1), this.scope = o$1;
				}
				get state() {
					const t$1 = this.properties.get("opacity"), i$1 = this.properties.get("color"), o$1 = this.properties.get("direction"), s$1 = e.an(o$1[0]), r$1 = -Math.max(e.an(o$1[1]), .01), n$1 = [
						Math.cos(s$1) * Math.cos(r$1),
						Math.sin(s$1) * Math.cos(r$1),
						Math.sin(r$1)
					], a$1 = this.properties.get("vignette"), l$1 = this.properties.get("vignette-color");
					return l$1.a = a$1, {
						density: this.properties.get("density"),
						intensity: this.properties.get("intensity"),
						color: new e.ao(i$1.r, i$1.g, i$1.b, i$1.a * t$1),
						direction: n$1,
						centerThinning: this.properties.get("center-thinning"),
						flakeSize: this.properties.get("flake-size"),
						vignetteColor: l$1
					};
				}
				get() {
					return this._transitionable.serialize();
				}
				set(t$1, i$1, o$1 = {}) {
					if (this._validate(Re, t$1, o$1)) return;
					const s$1 = Object.assign({}, t$1), r$1 = e.a6.snow;
					for (const e$1 of Object.keys(r$1)) void 0 === s$1[e$1] && (s$1[e$1] = r$1[e$1].default);
					this._options = s$1, this._transitionable.setTransitionOrValue(this._options, i$1);
				}
				updateConfig(e$1) {
					this._transitionable.setTransitionOrValue(this._options, new Map(e$1));
				}
				updateTransitions(e$1) {
					this._transitioning = this._transitionable.transitioned(e$1, this._transitioning);
				}
				hasTransition() {
					return this._transitioning.hasTransition();
				}
				recalculate(e$1) {
					this.properties = this._transitioning.possiblyEvaluate(e$1);
				}
				_validate(t$1, i$1, o$1) {
					return (!o$1 || !1 !== o$1.validate) && Fe(this, t$1.call(we, Object.assign({
						value: i$1,
						style: {
							glyphs: !0,
							sprite: !0
						},
						styleSpec: e.a6
					})));
				}
			}, it = class extends e.E {
				constructor(t$1, i$1, o$1, s$1) {
					super();
					const r$1 = Je || (Je = new e.a9({
						density: new e.aa(e.a6.rain.density),
						intensity: new e.aa(e.a6.rain.intensity),
						color: new e.aa(e.a6.rain.color),
						opacity: new e.aa(e.a6.rain.opacity),
						vignette: new e.aa(e.a6.rain.vignette),
						"vignette-color": new e.aa(e.a6.rain["vignette-color"]),
						"center-thinning": new e.aa(e.a6.rain["center-thinning"]),
						direction: new e.aa(e.a6.rain.direction),
						"droplet-size": new e.aa(e.a6.rain["droplet-size"]),
						"distortion-strength": new e.aa(e.a6.rain["distortion-strength"])
					}));
					this._transitionable = new e.a8(r$1, o$1, new Map(s$1)), this.set(t$1, s$1), this._transitioning = this._transitionable.untransitioned(), this.properties = new e.ai(r$1), this.scope = o$1;
				}
				get state() {
					const t$1 = this.properties.get("opacity"), i$1 = this.properties.get("color"), o$1 = this.properties.get("direction"), s$1 = e.an(o$1[0]), r$1 = -Math.max(e.an(o$1[1]), .01), n$1 = [
						Math.cos(s$1) * Math.cos(r$1),
						Math.sin(s$1) * Math.cos(r$1),
						Math.sin(r$1)
					], a$1 = this.properties.get("vignette-color");
					return a$1.a = this.properties.get("vignette"), {
						density: this.properties.get("density"),
						intensity: this.properties.get("intensity"),
						color: new e.ao(i$1.r, i$1.g, i$1.b, i$1.a * t$1),
						direction: n$1,
						centerThinning: this.properties.get("center-thinning"),
						dropletSize: this.properties.get("droplet-size"),
						distortionStrength: this.properties.get("distortion-strength"),
						vignetteColor: a$1
					};
				}
				get() {
					return this._transitionable.serialize();
				}
				set(t$1, i$1, o$1 = {}) {
					if (this._validate(Ae, t$1, o$1)) return;
					const s$1 = Object.assign({}, t$1), r$1 = e.a6.rain;
					for (const e$1 of Object.keys(r$1)) void 0 === s$1[e$1] && (s$1[e$1] = r$1[e$1].default);
					this._options = s$1, this._transitionable.setTransitionOrValue(this._options, i$1);
				}
				updateConfig(e$1) {
					this._transitionable.setTransitionOrValue(this._options, new Map(e$1));
				}
				updateTransitions(e$1) {
					this._transitioning = this._transitionable.transitioned(e$1, this._transitioning);
				}
				hasTransition() {
					return this._transitioning.hasTransition();
				}
				recalculate(e$1) {
					this.properties = this._transitioning.possiblyEvaluate(e$1);
				}
				_validate(t$1, i$1, o$1) {
					return (!o$1 || !1 !== o$1.validate) && Fe(this, t$1.call(we, Object.assign({
						value: i$1,
						style: {
							glyphs: !0,
							sprite: !0
						},
						styleSpec: e.a6
					})));
				}
			};
			class ot extends e.E {
				constructor(t$1, i$1, o$1, s$1) {
					super(), this.scope = o$1, this._options = t$1, this.properties = new e.ai(i$1), this._transitionable = new e.a8(i$1, o$1, new Map(s$1)), this._transitionable.setTransitionOrValue(t$1.properties), this._transitioning = this._transitionable.untransitioned();
				}
				updateConfig(e$1) {
					this._transitionable.setTransitionOrValue(this._options.properties, new Map(e$1));
				}
				updateTransitions(e$1) {
					this._transitioning = this._transitionable.transitioned(e$1, this._transitioning);
				}
				hasTransition() {
					return this._transitioning.hasTransition();
				}
				recalculate(e$1) {
					this.properties = this._transitioning.possiblyEvaluate(e$1);
				}
				get() {
					return this._options.properties = this._transitionable.serialize(), this._options;
				}
				set(e$1, t$1) {
					this._options = e$1, this._transitionable.setTransitionOrValue(e$1.properties, t$1);
				}
				shadowsEnabled() {
					return !!this.properties && !0 === this.properties.get("cast-shadows");
				}
			}
			class st {
				constructor(e$1, t$1, i$1) {
					this.screenBounds = e$1, this.cameraPoint = i$1.getCameraPoint(), this._screenRaycastCache = {}, this._cameraRaycastCache = {}, this.isAboveHorizon = t$1, this.screenGeometry = this.bufferedScreenGeometry(0), this.screenGeometryMercator = this._bufferedScreenMercator(0, i$1);
				}
				static createFromScreenPoints(t$1, i$1) {
					let o$1, s$1;
					if (t$1 instanceof e.P || "number" == typeof t$1[0]) {
						const r$1 = e.P.convert(t$1);
						o$1 = [r$1], s$1 = i$1.isPointAboveHorizon(r$1);
					} else {
						const r$1 = e.P.convert(t$1[0]), n$1 = e.P.convert(t$1[1]), a$1 = r$1.add(n$1)._div(2);
						o$1 = [r$1, n$1], s$1 = e.aq(r$1, n$1).every(((e$1) => i$1.isPointAboveHorizon(e$1))) && i$1.isPointAboveHorizon(a$1);
					}
					return new st(o$1, s$1, i$1);
				}
				isPointQuery() {
					return 1 === this.screenBounds.length;
				}
				bufferedScreenGeometry(t$1) {
					return e.aq(this.screenBounds[0], 1 === this.screenBounds.length ? this.screenBounds[0] : this.screenBounds[1], t$1);
				}
				bufferedCameraGeometry(t$1) {
					const i$1 = this.screenBounds[0], o$1 = 1 === this.screenBounds.length ? this.screenBounds[0].add(new e.P(1, 1)) : this.screenBounds[1], s$1 = e.aq(i$1, o$1, 0, !1);
					return this.cameraPoint.y > o$1.y && (this.cameraPoint.x > i$1.x && this.cameraPoint.x < o$1.x ? s$1.splice(3, 0, this.cameraPoint) : this.cameraPoint.x >= o$1.x ? s$1[2] = this.cameraPoint : this.cameraPoint.x <= i$1.x && (s$1[3] = this.cameraPoint)), e.ar(s$1, t$1);
				}
				bufferedCameraGeometryGlobe(t$1) {
					const i$1 = this.screenBounds[0], o$1 = 1 === this.screenBounds.length ? this.screenBounds[0].add(new e.P(1, 1)) : this.screenBounds[1], s$1 = e.aq(i$1, o$1, t$1), r$1 = this.cameraPoint.clone();
					switch (3 * ((r$1.y > i$1.y) + (r$1.y > o$1.y)) + ((r$1.x > i$1.x) + (r$1.x > o$1.x))) {
						case 0:
							s$1[0] = r$1, s$1[4] = r$1.clone();
							break;
						case 1:
							s$1.splice(1, 0, r$1);
							break;
						case 2:
							s$1[1] = r$1;
							break;
						case 3:
							s$1.splice(4, 0, r$1);
							break;
						case 5:
							s$1.splice(2, 0, r$1);
							break;
						case 6:
							s$1[3] = r$1;
							break;
						case 7:
							s$1.splice(3, 0, r$1);
							break;
						case 8: s$1[2] = r$1;
					}
					return s$1;
				}
				containsTile(t$1, i$1, o$1, s$1 = 0) {
					const r$1 = Math.max(t$1.queryPadding, t$1.evaluateQueryRenderedFeaturePadding()) / i$1._pixelsPerMercatorPixel + 1, n$1 = o$1 ? this._bufferedCameraMercator(r$1, i$1) : this._bufferedScreenMercator(r$1, i$1);
					let a$1 = t$1.tileID.wrap + (n$1.unwrapped ? s$1 : 0);
					const l$1 = n$1.polygon.map(((i$2) => e.as(t$1.tileTransform, i$2, a$1)));
					if (!e.at(l$1, 0, 0, e.al, e.al)) return;
					a$1 = t$1.tileID.wrap + (this.screenGeometryMercator.unwrapped ? s$1 : 0);
					const c$1 = this.screenGeometryMercator.polygon.map(((i$2) => e.au(t$1.tileTransform, i$2, a$1))), h$1 = c$1.map(((t$2) => new e.P(t$2[0], t$2[1]))), d$1 = i$1.getFreeCameraOptions().position || new e.ae(0, 0, 0), u$1 = e.au(t$1.tileTransform, d$1, a$1), _$1 = c$1.map(((t$2) => {
						const i$2 = e.av(t$2, t$2, u$1);
						return e.aw(i$2, i$2), new e.ax(u$1, i$2);
					})), p$1 = e.ay(t$1, 1, i$1.zoom) * i$1._pixelsPerMercatorPixel;
					return {
						queryGeometry: this,
						tilespaceGeometry: h$1,
						tilespaceRays: _$1,
						bufferedTilespaceGeometry: l$1,
						bufferedTilespaceBounds: (f$1 = e.az(l$1), f$1.min.x = e.aA(f$1.min.x, 0, e.al), f$1.min.y = e.aA(f$1.min.y, 0, e.al), f$1.max.x = e.aA(f$1.max.x, 0, e.al), f$1.max.y = e.aA(f$1.max.y, 0, e.al), f$1),
						tile: t$1,
						tileID: t$1.tileID,
						pixelToTileUnitsFactor: p$1
					};
					var f$1;
				}
				_bufferedScreenMercator(e$1, t$1) {
					const i$1 = at(e$1);
					if (this._screenRaycastCache[i$1]) return this._screenRaycastCache[i$1];
					{
						let o$1;
						return o$1 = "globe" === t$1.projection.name ? this._projectAndResample(this.bufferedScreenGeometry(e$1), t$1) : {
							polygon: this.bufferedScreenGeometry(e$1).map(((e$2) => t$1.pointCoordinate3D(e$2))),
							unwrapped: !0
						}, this._screenRaycastCache[i$1] = o$1, o$1;
					}
				}
				_bufferedCameraMercator(e$1, t$1) {
					const i$1 = at(e$1);
					if (this._cameraRaycastCache[i$1]) return this._cameraRaycastCache[i$1];
					{
						let o$1;
						return o$1 = "globe" === t$1.projection.name ? this._projectAndResample(this.bufferedCameraGeometryGlobe(e$1), t$1) : {
							polygon: this.bufferedCameraGeometry(e$1).map(((e$2) => t$1.pointCoordinate3D(e$2))),
							unwrapped: !0
						}, this._cameraRaycastCache[i$1] = o$1, o$1;
					}
				}
				_projectAndResample(t$1, i$1) {
					const o$1 = function(t$2, i$2) {
						const o$2 = e.aB([], i$2.pixelMatrix, i$2.globeMatrix), s$2 = [
							0,
							-e.aD,
							0,
							1
						], r$1 = [
							0,
							e.aD,
							0,
							1
						], n$1 = [
							0,
							0,
							0,
							1
						];
						e.aC(s$2, s$2, o$2), e.aC(r$1, r$1, o$2), e.aC(n$1, n$1, o$2);
						const a$1 = new e.P(s$2[0] / s$2[3], s$2[1] / s$2[3]), l$1 = new e.P(r$1[0] / r$1[3], r$1[1] / r$1[3]), c$1 = e.aE(t$2, a$1) && s$2[3] < n$1[3], h$1 = e.aE(t$2, l$1) && r$1[3] < n$1[3];
						if (!c$1 && !h$1) return null;
						const d$1 = function(e$1, t$3, i$3) {
							for (let o$3 = 1; o$3 < e$1.length; o$3++) {
								const s$3 = nt(t$3.pointCoordinate3D(e$1[o$3 - 1]).x), r$2 = nt(t$3.pointCoordinate3D(e$1[o$3]).x);
								if (i$3 < 0) {
									if (s$3 < r$2) return {
										idx: o$3,
										t: -s$3 / (r$2 - 1 - s$3)
									};
								} else if (r$2 < s$3) return {
									idx: o$3,
									t: (1 - s$3) / (r$2 + 1 - s$3)
								};
							}
							return null;
						}(t$2, i$2, c$1 ? -1 : 1);
						if (!d$1) return null;
						const { idx: u$1, t: _$1 } = d$1;
						let p$1 = u$1 > 1 ? rt(t$2.slice(0, u$1), i$2) : [], f$1 = u$1 < t$2.length ? rt(t$2.slice(u$1), i$2) : [];
						p$1 = p$1.map(((t$3) => new e.P(nt(t$3.x), t$3.y))), f$1 = f$1.map(((t$3) => new e.P(nt(t$3.x), t$3.y)));
						const m$1 = [...p$1];
						0 === m$1.length && m$1.push(f$1[f$1.length - 1]);
						const g$1 = e.ak(m$1[m$1.length - 1].y, (0 === f$1.length ? p$1[0] : f$1[0]).y, _$1);
						let v$1;
						return v$1 = c$1 ? [
							new e.P(0, g$1),
							new e.P(0, 0),
							new e.P(1, 0),
							new e.P(1, g$1)
						] : [
							new e.P(1, g$1),
							new e.P(1, 1),
							new e.P(0, 1),
							new e.P(0, g$1)
						], m$1.push(...v$1), 0 === f$1.length ? m$1.push(p$1[0]) : m$1.push(...f$1), {
							polygon: m$1.map(((t$3) => new e.ae(t$3.x, t$3.y))),
							unwrapped: !1
						};
					}(t$1, i$1);
					if (o$1) return o$1;
					const s$1 = function(t$2, i$2) {
						let o$2 = !1, s$2 = -Infinity, r$1 = 0;
						for (let e$1 = 0; e$1 < t$2.length - 1; e$1++) t$2[e$1].x > s$2 && (s$2 = t$2[e$1].x, r$1 = e$1);
						for (let e$1 = 0; e$1 < t$2.length - 1; e$1++) {
							const i$3 = (r$1 + e$1) % (t$2.length - 1), s$3 = t$2[i$3], n$2 = t$2[i$3 + 1];
							Math.abs(s$3.x - n$2.x) > .5 && (s$3.x < n$2.x ? (s$3.x += 1, 0 === i$3 && (t$2[t$2.length - 1].x += 1)) : (n$2.x += 1, i$3 + 1 === t$2.length - 1 && (t$2[0].x += 1)), o$2 = !0);
						}
						const n$1 = e.aF(i$2.center.lng);
						return o$2 && n$1 < Math.abs(n$1 - 1) && t$2.forEach(((e$1) => {
							e$1.x -= 1;
						})), {
							polygon: t$2,
							unwrapped: o$2
						};
					}(rt(t$1, i$1).map(((t$2) => new e.P(nt(t$2.x), t$2.y))), i$1);
					return {
						polygon: s$1.polygon.map(((t$2) => new e.ae(t$2.x, t$2.y))),
						unwrapped: s$1.unwrapped
					};
				}
			}
			function rt(t$1, i$1) {
				return e.aG(t$1, ((e$1) => {
					const t$2 = i$1.pointCoordinate3D(e$1);
					e$1.x = t$2.x, e$1.y = t$2.y;
				}), 1 / 256);
			}
			function nt(e$1) {
				return e$1 < 0 ? 1 + e$1 % 1 : e$1 % 1;
			}
			function at(e$1) {
				return 100 * e$1 | 0;
			}
			function lt(t$1, i$1, o$1, s$1, r$1) {
				const n$1 = function(o$2, s$2) {
					if (o$2) return r$1(o$2);
					if (s$2) {
						if (t$1.url && s$2.tiles && t$1.tiles && delete t$1.tiles, s$2.variants) {
							if (!Array.isArray(s$2.variants)) return r$1(/* @__PURE__ */ new Error("variants must be an array"));
							for (const e$1 of s$2.variants) {
								if (null == e$1 || "object" != typeof e$1 || e$1.constructor !== Object) return r$1(/* @__PURE__ */ new Error("variant must be an object"));
								if (!Array.isArray(e$1.capabilities)) return r$1(/* @__PURE__ */ new Error("capabilities must be an array"));
								if (1 === e$1.capabilities.length && "meshopt" === e$1.capabilities[0]) {
									s$2 = Object.assign(s$2, e$1);
									break;
								}
							}
						}
						const o$3 = e.aH(Object.assign({}, s$2, t$1), [
							"tilejson",
							"tiles",
							"minzoom",
							"maxzoom",
							"attribution",
							"mapbox_logo",
							"bounds",
							"extra_bounds",
							"scheme",
							"tileSize",
							"encoding",
							"vector_layers",
							"raster_layers",
							"worldview_options",
							"worldview_default",
							"worldview"
						]);
						o$3.tiles = i$1.canonicalizeTileset(o$3, t$1.url), r$1(null, o$3);
					}
				}, a$1 = function(e$1, t$2, i$2) {
					if (!e$1) return null;
					if (!t$2 && !i$2) return e$1;
					i$2 = i$2 || e$1.worldview_default;
					const o$2 = Object.values(e$1.language || {});
					if (0 === o$2.length) return null;
					const s$2 = Object.values(e$1.worldview || {});
					if (0 === s$2.length) return null;
					const r$2 = o$2.every(((e$2) => e$2 === t$2)), n$2 = s$2.every(((e$2) => e$2 === i$2));
					return r$2 && n$2 ? e$1 : t$2 in (e$1.language_options || {}) || i$2 in (e$1.worldview_options || {}) ? null : e$1.language_options && e$1.worldview_options ? e$1 : null;
				}(t$1.data, o$1, s$1);
				return a$1 ? e.o.frame((() => n$1(null, a$1))) : t$1.url ? e.m(i$1.transformRequest(i$1.normalizeSourceURL(t$1.url, null, o$1, s$1), e.R.Source), n$1) : e.o.frame((() => {
					const { data: e$1, ...i$2 } = t$1;
					n$1(null, i$2);
				}));
			}
			function ct(t$1, i$1) {
				const o$1 = Math.pow(2, i$1.z), s$1 = Math.floor(e.aF(t$1.getWest()) * o$1), r$1 = Math.floor(e.aJ(t$1.getNorth()) * o$1), n$1 = Math.ceil(e.aF(t$1.getEast()) * o$1), a$1 = Math.ceil(e.aJ(t$1.getSouth()) * o$1);
				return i$1.x >= s$1 && i$1.x < n$1 && i$1.y >= r$1 && i$1.y < a$1;
			}
			class ht {
				constructor(t$1, i$1, o$1) {
					this.bounds = t$1 ? e.aI.convert(this.validateBounds(t$1)) : null, this.minzoom = i$1 || 0, this.maxzoom = o$1 || 24;
				}
				validateBounds(e$1) {
					return Array.isArray(e$1) && 4 === e$1.length ? [
						Math.max(-180, e$1[0]),
						Math.max(-90, e$1[1]),
						Math.min(180, e$1[2]),
						Math.min(90, e$1[3])
					] : [
						-180,
						-90,
						180,
						90
					];
				}
				addExtraBounds(t$1) {
					if (t$1) {
						this.extraBounds || (this.extraBounds = []);
						for (const i$1 of t$1) this.extraBounds.push(e.aI.convert(this.validateBounds(i$1)));
					}
				}
				contains(e$1) {
					if (e$1.z > this.maxzoom || e$1.z < this.minzoom) return !1;
					if (this.bounds && !ct(this.bounds, e$1)) return !1;
					if (!this.extraBounds) return !0;
					for (const t$1 of this.extraBounds) if (ct(t$1, e$1)) return !0;
					return !1;
				}
				static fromTileJSON(e$1) {
					if (!e$1.bounds && !e$1.extra_bounds) return null;
					const t$1 = new ht(e$1.bounds, e$1.minzoom, e$1.maxzoom);
					return t$1.addExtraBounds(e$1.extra_bounds), t$1;
				}
			}
			class dt extends e.E {
				constructor(t$1, i$1, o$1, s$1) {
					if (super(), this.id = t$1, this.dispatcher = o$1, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = !0, this.isTileClipped = !0, this._loaded = !1, Object.assign(this, e.aH(i$1, [
						"url",
						"scheme",
						"tileSize",
						"promoteId"
					])), this._options = Object.assign({ type: "vector" }, i$1), this._collectResourceTiming = !!i$1.collectResourceTiming, 512 !== this.tileSize) throw new Error("vector tile sources must have a tileSize of 512");
					this.setEventedParent(s$1), this._tileWorkers = {}, this._deduped = new e.aK();
				}
				load(t$1) {
					this._loaded = !1, this.fire(new e.z("dataloading", { dataType: "source" }));
					const i$1 = Array.isArray(this.map._language) ? this.map._language.join() : this.map._language, o$1 = this.map.getWorldview();
					this._tileJSONRequest = lt(this._options, this.map._requestManager, i$1, o$1, ((s$1, r$1) => {
						if (this._tileJSONRequest = null, this._loaded = !0, s$1) i$1 && console.warn(`Ensure that your requested language string is a valid BCP-47 code or list of codes. Found: ${i$1}`), o$1 && console.warn(`Requested worldview strings must be a valid ISO alpha-2 code. Found: ${o$1}`), this.fire(new e.y(s$1));
						else if (r$1) {
							if (Object.assign(this, r$1), this.hasWorldviews = !!r$1.worldview_options, r$1.worldview_default && (this.worldviewDefault = r$1.worldview_default), r$1.vector_layers) {
								this.vectorLayers = r$1.vector_layers, this.vectorLayerIds = [], this.localizableLayerIds = /* @__PURE__ */ new Set();
								for (const e$1 of r$1.vector_layers) this.vectorLayerIds.push(e$1.id), r$1.worldview && r$1.worldview[e$1.source] && this.localizableLayerIds.add(e$1.id);
							}
							this.tileBounds = ht.fromTileJSON(r$1), P(r$1.tiles, this.map._requestManager._customAccessToken), this.fire(new e.z("data", {
								dataType: "source",
								sourceDataType: "metadata"
							})), this.fire(new e.z("data", {
								dataType: "source",
								sourceDataType: "content"
							}));
						}
						t$1 && t$1(s$1);
					}));
				}
				loaded() {
					return this._loaded;
				}
				hasTile(e$1) {
					return !this.tileBounds || this.tileBounds.contains(e$1.canonical);
				}
				onAdd(e$1) {
					this.map = e$1, this.load();
				}
				reload() {
					this.cancelTileJSONRequest();
					const t$1 = e.B(this.id, this.scope);
					this.load((() => this.map.style.clearSource(t$1)));
				}
				setTiles(e$1) {
					return this._options.tiles = e$1, this.reload(), this;
				}
				setUrl(e$1) {
					return this.url = e$1, this._options.url = e$1, this.reload(), this;
				}
				onRemove(e$1) {
					this.cancelTileJSONRequest();
				}
				serialize() {
					return Object.assign({}, this._options);
				}
				loadTile(t$1, i$1) {
					const o$1 = t$1.tileID.canonical.url(this.tiles, this.scheme), s$1 = this.map._requestManager.normalizeTileURL(o$1), r$1 = this.map._requestManager.transformRequest(s$1, e.R.Tile), n$1 = this.map.style ? this.map.style.getLut(this.scope) : null, a$1 = n$1 ? { image: n$1.image.clone() } : null, l$1 = {
						request: r$1,
						data: void 0,
						uid: t$1.uid,
						tileID: t$1.tileID,
						tileZoom: t$1.tileZoom,
						zoom: t$1.tileID.overscaledZ,
						maxZoom: this.maxzoom,
						lut: a$1,
						tileSize: this.tileSize * t$1.tileID.overscaleFactor(),
						type: this.type,
						source: this.id,
						scope: this.scope,
						pixelRatio: e.o.devicePixelRatio,
						showCollisionBoxes: this.map.showCollisionBoxes,
						promoteId: this.promoteId,
						isSymbolTile: t$1.isSymbolTile,
						brightness: this.map.style && this.map.style.getBrightness() || 0,
						extraShadowCaster: t$1.isExtraShadowCaster,
						tessellationStep: this.map._tessellationStep,
						scaleFactor: this.map.getScaleFactor(),
						worldview: this.map.getWorldview() || this.worldviewDefault,
						indoor: this.map.indoor ? this.map.indoor.getIndoorTileOptions(this.id, this.scope) : null
					};
					if (this.hasWorldviews && e.h(o$1) && (l$1.localizableLayerIds = this.localizableLayerIds), l$1.request.collectResourceTiming = this._collectResourceTiming, t$1.actor && "expired" !== t$1.state) "loading" === t$1.state ? t$1.reloadCallback = i$1 : t$1.request = t$1.actor.send("reloadTile", l$1, c$1.bind(this));
					else if (t$1.actor = this._tileWorkers[s$1] = this._tileWorkers[s$1] || this.dispatcher.getActor(), this.dispatcher.ready) t$1.request = t$1.actor.send("loadTile", l$1, c$1.bind(this), void 0, !0);
					else t$1.request = { cancel: e.aL.call({ deduped: this._deduped }, l$1, ((i$2, o$2) => {
						if (i$2 || !o$2) c$1.call(this, i$2);
						else {
							const i$3 = e.aM(o$2.responseHeaders);
							l$1.data = {
								rawData: o$2.rawData.slice(0),
								expires: i$3.expires,
								cacheControl: i$3.cacheControl
							}, t$1.actor && t$1.actor.send("loadTile", l$1, c$1.bind(this), void 0, !0);
						}
					}), !0) };
					function c$1(o$2, s$2) {
						return delete t$1.request, t$1.aborted ? i$1(null) : o$2 && o$2 instanceof e.aN && 404 !== o$2.status ? i$1(o$2) : (s$2 && s$2.resourceTiming && (t$1.resourceTiming = s$2.resourceTiming), this.map._refreshExpiredTiles && s$2 && t$1.setExpiryData(s$2), t$1.loadVectorData(s$2, this.map.painter), e.aO(this.dispatcher), i$1(null, s$2), void (t$1.reloadCallback && (this.loadTile(t$1, t$1.reloadCallback), t$1.reloadCallback = null)));
					}
				}
				abortTile(e$1) {
					e$1.request && (e$1.request.cancel(), delete e$1.request), e$1.actor && e$1.actor.send("abortTile", {
						uid: e$1.uid,
						type: this.type,
						source: this.id,
						scope: this.scope
					});
				}
				unloadTile(e$1, t$1) {
					e$1.actor && e$1.actor.send("removeTile", {
						uid: e$1.uid,
						type: this.type,
						source: this.id,
						scope: this.scope
					}), e$1.destroy();
				}
				hasTransition() {
					return !1;
				}
				afterUpdate() {
					this._tileWorkers = {};
				}
				cancelTileJSONRequest() {
					this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
				}
			}
			class ut extends e.E {
				constructor(t$1, i$1, o$1, s$1) {
					super(), this.id = t$1, this.dispatcher = o$1, this.setEventedParent(s$1), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = !0, this.scheme = "xyz", this.tileSize = 512, this._loaded = !1, this._options = Object.assign({ type: "raster" }, i$1), Object.assign(this, e.aH(i$1, [
						"url",
						"scheme",
						"tileSize"
					]));
				}
				load(t$1) {
					this._loaded = !1, this.fire(new e.z("dataloading", { dataType: "source" }));
					const i$1 = this.map.getWorldview();
					this._tileJSONRequest = lt(this._options, this.map._requestManager, null, i$1, ((i$2, o$1) => {
						this._tileJSONRequest = null, this._loaded = !0, i$2 ? this.fire(new e.y(i$2)) : o$1 && (Object.assign(this, o$1), o$1.raster_layers && (this.rasterLayers = o$1.raster_layers, this.rasterLayerIds = this.rasterLayers.map(((e$1) => e$1.id))), this.tileBounds = ht.fromTileJSON(o$1), P(o$1.tiles), this.fire(new e.z("data", {
							dataType: "source",
							sourceDataType: "metadata"
						})), this.fire(new e.z("data", {
							dataType: "source",
							sourceDataType: "content"
						}))), t$1 && t$1(i$2);
					}));
				}
				loaded() {
					return this._loaded;
				}
				onAdd(e$1) {
					this.map = e$1, this.load();
				}
				reload() {
					this.cancelTileJSONRequest();
					const t$1 = e.B(this.id, this.scope);
					this.load((() => this.map.style.clearSource(t$1)));
				}
				setTiles(e$1) {
					return this._options.tiles = e$1, this.reload(), this;
				}
				setUrl(e$1) {
					return this.url = e$1, this._options.url = e$1, this.reload(), this;
				}
				onRemove(e$1) {
					this.cancelTileJSONRequest();
				}
				serialize() {
					return Object.assign({}, this._options);
				}
				hasTile(e$1) {
					return !this.tileBounds || this.tileBounds.contains(e$1.canonical);
				}
				loadTile(t$1, i$1) {
					const o$1 = e.o.devicePixelRatio >= 2, s$1 = this.map._requestManager.normalizeTileURL(t$1.tileID.canonical.url(this.tiles, this.scheme), o$1, this.tileSize);
					t$1.request = e.n(this.map._requestManager.transformRequest(s$1, e.R.Tile), ((o$2, s$2, r$1) => {
						if (delete t$1.request, t$1.aborted) return t$1.state = "unloaded", i$1(null);
						if (o$2) return t$1.state = "errored", i$1(o$2);
						if (!s$2) return i$1(null);
						const n$1 = e.aM(r$1);
						this.map._refreshExpiredTiles && t$1.setExpiryData(n$1), t$1.setTexture(s$2, this.map.painter), t$1.state = "loaded", e.aO(this.dispatcher), i$1(null);
					}));
				}
				abortTile(e$1, t$1) {
					e$1.request && (e$1.request.cancel(), delete e$1.request), t$1 && t$1();
				}
				unloadTile(t$1, i$1) {
					t$1.texture && t$1.texture instanceof e.T ? (t$1.destroy(!1), t$1.texture && t$1.texture instanceof e.T && this.map.painter.saveTileTexture(t$1.texture)) : t$1.destroy(), i$1 && i$1();
				}
				hasTransition() {
					return !1;
				}
				cancelTileJSONRequest() {
					this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
				}
			}
			function _t([t$1, i$1], o$1, s$1, { scaled: r$1 = !0 } = {}) {
				const { tileSize: n$1, buffer: a$1 } = s$1, { x: l$1, y: c$1, z: h$1 } = o$1;
				if (!isFinite(l$1) || !isFinite(c$1) || !isFinite(h$1)) throw new Error("Invalid MRT header");
				const d$1 = 2 ** h$1, u$1 = d$1 * e.aF(t$1), _$1 = d$1 * e.aJ(i$1);
				return function([e$1, t$2], i$2, { scaled: o$2 = !0 } = {}) {
					if (!i$2) throw new Error("bandView is undefined");
					const { data: s$2, tileSize: r$2, buffer: n$2, offset: a$2, scale: l$2, dimension: c$2 } = i$2;
					if (e$1 < -n$2 || e$1 > r$2 + n$2 || t$2 < -n$2 || t$2 > r$2 + n$2) throw new Error(`Point (${e$1}, ${t$2}) out of bounds for tileSize=${r$2}, buffer=${n$2}`);
					const h$2 = (t$2 + n$2) * (r$2 + 2 * n$2) + (e$1 + n$2);
					if (4294967295 === new Uint32Array(s$2.buffer)[h$2]) return null;
					let d$2 = [];
					d$2 = o$2 ? [] : new i$2.data.constructor(c$2);
					for (let e$2 = 0; e$2 < c$2; e$2++) d$2[e$2] = Math.round(0xe8d4a51000 * (s$2[c$2 * h$2 + e$2] * l$2 + a$2)) / 0xe8d4a51000;
					return d$2;
				}([Math.min(Math.max(-a$1, Math.floor((u$1 - l$1) * n$1)), n$1 - 1 + a$1), Math.min(Math.max(-a$1, Math.floor((_$1 - c$1) * n$1)), n$1 - 1 + a$1)], s$1, { scaled: r$1 });
			}
			class pt extends ut {
				constructor(e$1, t$1, i$1, o$1) {
					super(e$1, t$1, i$1, o$1), this.type = "raster-array", this.maxzoom = 22, this.partial = !0, this._loadTilePending = {}, this._loadTileLoaded = {}, this._options = Object.assign({ type: "raster-array" }, t$1);
				}
				triggerRepaint(e$1) {
					const t$1 = this.map.painter._terrain, i$1 = this.map.style.getSourceCache(this.id);
					t$1 && t$1.enabled && i$1 && t$1._clearRenderCacheForTile(i$1.id, e$1.tileID), this.map.triggerRepaint();
				}
				loadTile(t$1, i$1) {
					const o$1 = this.map._requestManager.normalizeTileURL(t$1.tileID.canonical.url(this.tiles, this.scheme), !1, this.tileSize), s$1 = this.map._requestManager.transformRequest(o$1, e.R.Tile), r$1 = {
						request: s$1,
						uid: t$1.uid,
						tileID: t$1.tileID,
						type: this.type,
						source: this.id,
						scope: this.scope,
						partial: this.partial
					};
					t$1.source = this.id, t$1.scope = this.scope, t$1.requestParams = s$1, t$1.actor || (t$1.actor = this.dispatcher.getActor());
					const n$1 = (o$2, s$2, r$2) => {
						if (delete t$1.request, t$1.aborted) return t$1.state = "unloaded", i$1(null);
						if (o$2) {
							if ("AbortError" === o$2.name) return;
							return t$1.state = "errored", i$1(o$2);
						}
						if (this.map._refreshExpiredTiles && s$2) {
							const i$2 = e.aM(r$2);
							t$1.setExpiryData(i$2);
						}
						if (this.partial && "expired" !== t$1.state) t$1.state = "empty";
						else if (!this.partial) {
							if (!s$2) return i$1(null);
							t$1.state = "loaded", t$1._isHeaderLoaded = !0, t$1._mrt = s$2;
						}
						i$1(null);
					};
					t$1.request = this.partial ? t$1.fetchHeader(void 0, n$1.bind(this)) : t$1.actor.send("loadTile", r$1, n$1.bind(this), void 0, !0);
				}
				abortTile(e$1) {
					e$1.request && (e$1.request.cancel(), delete e$1.request), e$1.actor && e$1.actor.send("abortTile", {
						uid: e$1.uid,
						type: this.type,
						source: this.id,
						scope: this.scope
					});
				}
				unloadTile(e$1, t$1) {
					const i$1 = e$1.texturePerLayer;
					if (e$1.flushAllQueues(), i$1.size) {
						e$1.destroy(!1);
						for (const e$2 of i$1.values()) this.map.painter.saveTileTexture(e$2);
					} else e$1.destroy();
				}
				prepareTile(t$1, i$1, o$1, s$1) {
					t$1._isHeaderLoaded && ("empty" !== t$1.state && (t$1.state = "reloading"), t$1.fetchBandForRender(i$1, o$1, s$1, ((i$2, s$2) => {
						if (i$2) return t$1.state = "errored", this.fire(new e.y(i$2)), void this.triggerRepaint(t$1);
						s$2 && (t$1._isHeaderLoaded = !0, t$1.setTexturePerLayer(o$1, s$2, this.map.painter), t$1.state = "loaded", this.triggerRepaint(t$1));
					})));
				}
				getInitialBand(e$1) {
					if (!this.rasterLayers) return 0;
					const t$1 = this.rasterLayers.find((({ id: t$2 }) => t$2 === e$1)), i$1 = t$1 && t$1.fields, o$1 = i$1 && i$1.bands && i$1.bands;
					return o$1 ? o$1[0] : 0;
				}
				getTextureDescriptor(t$1, i$1, o$1) {
					if (!t$1) return;
					const s$1 = i$1.sourceLayer || this.rasterLayerIds && this.rasterLayerIds[0];
					if (!s$1) return;
					let r$1 = null;
					i$1 instanceof e.aR ? r$1 = i$1.paint.get("raster-array-band") : i$1 instanceof e.aS && (r$1 = i$1.paint.get("raster-particle-array-band"));
					const n$1 = r$1 || this.getInitialBand(s$1);
					if (null == n$1) return;
					if (!t$1.textureDescriptorPerLayer.get(i$1.id)) return void this.prepareTile(t$1, s$1, i$1.id, n$1);
					if (t$1.updateNeeded(i$1.id, n$1) && !o$1) return;
					const a$1 = t$1.textureDescriptorPerLayer.get(i$1.id);
					return Object.assign({}, a$1, { texture: t$1.texturePerLayer.get(i$1.id) });
				}
				getImages(t$1, i$1) {
					const o$1 = /* @__PURE__ */ new Map();
					for (const s$1 of t$1) for (const t$2 of i$1) {
						const [i$2, r$1] = t$2.split("/"), n$1 = s$1.getLayer(i$2);
						if (!n$1) continue;
						if (!n$1.hasBand(r$1) || !n$1.hasDataForBand(r$1)) continue;
						const { bytes: a$1, tileSize: l$1, buffer: c$1 } = n$1.getBandView(r$1), h$1 = l$1 + 2 * c$1, d$1 = {
							data: new e.q({
								width: h$1,
								height: h$1
							}, a$1),
							pixelRatio: 2,
							sdf: !1,
							usvg: !1,
							version: 0
						};
						o$1.set(t$2, d$1);
					}
					return o$1;
				}
				queryRasterArrayValueByBandId(t$1, i$1, o$1) {
					const s$1 = i$1._mrt;
					return new Promise(((r$1) => {
						const n$1 = {}, a$1 = /* @__PURE__ */ new Set();
						for (const [l$1, c$1] of Object.entries(s$1.layers)) {
							if (o$1.layerName && l$1 !== o$1.layerName) continue;
							const h$1 = {};
							n$1[l$1] = h$1;
							for (const { bands: d$1 } of c$1.dataIndex) for (const u$1 of d$1) o$1.bands && !o$1.bands.includes(u$1) || (a$1.add(e.B(l$1, u$1)), i$1.fetchBand(l$1, null, u$1, ((i$2) => {
								e.o.frame((() => {
									h$1[u$1] = i$2 ? null : _t([t$1.lng, t$1.lat], s$1, c$1.getBandView(u$1)), a$1.delete(e.B(l$1, u$1)), 0 === a$1.size && r$1(n$1);
								}));
							}), !1));
						}
						0 === a$1.size && r$1(n$1);
					}));
				}
				_loadTileForQuery(t$1, i$1) {
					if (this._loadTileLoaded[t$1.uid]) return void i$1(null, t$1._mrt);
					if (this._loadTilePending[t$1.uid]) return void this._loadTilePending[t$1.uid].push(i$1);
					this._loadTilePending[t$1.uid] = [i$1];
					const o$1 = this.map._requestManager.normalizeTileURL(t$1.tileID.canonical.url(this.tiles, this.scheme), !1, this.tileSize), s$1 = this.map._requestManager.transformRequest(o$1, e.R.Tile);
					t$1.actor.send("loadTile", {
						request: s$1,
						uid: t$1.uid,
						tileID: t$1.tileID,
						type: this.type,
						source: this.id,
						scope: this.scope,
						partial: !1
					}, ((i$2, o$2, s$2) => {
						if (i$2) return this._loadTilePending[t$1.uid].forEach(((e$1) => e$1(i$2, null))), void delete this._loadTilePending[t$1.uid];
						if (!o$2) return this._loadTilePending[t$1.uid].forEach(((e$1) => e$1(null, null))), void delete this._loadTilePending[t$1.uid];
						if (this.map._refreshExpiredTiles && o$2) {
							const i$3 = e.aM(s$2);
							t$1.setExpiryData(i$3);
						}
						t$1._mrt = o$2, t$1._isHeaderLoaded = !0, t$1.state = "loaded", this._loadTilePending[t$1.uid].forEach(((e$1) => e$1(null, o$2))), this._loadTileLoaded[t$1.uid] = !0, delete this._loadTilePending[t$1.uid];
					}), void 0, !0);
				}
				queryRasterArrayValueByAllBands(e$1, t$1, i$1) {
					return new Promise(((o$1, s$1) => {
						this._loadTileForQuery(t$1, ((r$1, n$1) => {
							r$1 ? s$1(r$1) : o$1(n$1 ? this.queryRasterArrayValueByBandId(e$1, t$1, i$1) : null);
						}));
					}));
				}
				queryRasterArrayValue(t$1, i$1) {
					const o$1 = e.aT.convert(t$1), s$1 = this.findLoadedParent(o$1);
					return s$1 && s$1._mrt ? i$1.bands || !this.partial ? this.queryRasterArrayValueByBandId(o$1, s$1, i$1) : this.queryRasterArrayValueByAllBands(o$1, s$1, i$1) : Promise.resolve(null);
				}
				findLoadedParent(t$1) {
					const i$1 = e.ae.fromLngLat(t$1, this.map.transform.tileSize), o$1 = this.maxzoom + 1, s$1 = 1 << o$1, r$1 = Math.floor(i$1.x), n$1 = Math.floor((i$1.x - r$1) * s$1), a$1 = Math.floor(i$1.y * s$1), l$1 = this.map.style.getSourceCache(this.id), c$1 = new e.aQ(o$1, r$1, o$1, n$1, a$1);
					return l$1.findLoadedParent(c$1, this.minzoom);
				}
			}
			const ft = {
				vector: dt,
				raster: ut,
				"raster-dem": class extends ut {
					constructor(e$1, t$1, i$1, o$1) {
						super(e$1, t$1, i$1, o$1), this.type = "raster-dem", this.maxzoom = 22, this._options = Object.assign({ type: "raster-dem" }, t$1), this.encoding = t$1.encoding || "mapbox";
					}
					loadTile(t$1, i$1) {
						const o$1 = this.map._requestManager.normalizeTileURL(t$1.tileID.canonical.url(this.tiles, this.scheme), !1, this.tileSize);
						function s$1(e$1, o$2) {
							e$1 && (t$1.state = "errored", i$1(e$1)), o$2 && (t$1.dem = o$2, t$1.dem.onDeserialize(), t$1.needsHillshadePrepare = !0, t$1.needsDEMTextureUpload = !0, t$1.state = "loaded", i$1(null));
						}
						t$1.request = e.n(this.map._requestManager.transformRequest(o$1, e.R.Tile), function(o$2, r$1, n$1) {
							if (delete t$1.request, t$1.aborted) t$1.state = "unloaded", i$1(null);
							else if (o$2) t$1.state = "errored", i$1(o$2);
							else if (r$1) {
								const i$2 = e.aM(n$1);
								this.map._refreshExpiredTiles && t$1.setExpiryData(i$2);
								const o$3 = ImageBitmap && r$1 instanceof ImageBitmap && e.r(), a$1 = 1 - (r$1.width - e.aP(r$1.width)) / 2;
								a$1 < 1 || t$1.neighboringTiles || (t$1.neighboringTiles = this._getNeighboringTiles(t$1.tileID));
								const l$1 = o$3 ? r$1 : e.o.getImageData(r$1, a$1), c$1 = {
									uid: t$1.uid,
									tileID: t$1.tileID,
									source: this.id,
									type: this.type,
									scope: this.scope,
									rawImageData: l$1,
									encoding: this.encoding,
									padding: a$1
								};
								t$1.actor && "expired" !== t$1.state || (t$1.actor = this.dispatcher.getActor(), t$1.actor.send("loadTile", c$1, s$1.bind(this), void 0, !0));
							}
						}.bind(this));
					}
					_getNeighboringTiles(t$1) {
						const i$1 = t$1.canonical, o$1 = Math.pow(2, i$1.z), s$1 = (i$1.x - 1 + o$1) % o$1, r$1 = 0 === i$1.x ? t$1.wrap - 1 : t$1.wrap, n$1 = (i$1.x + 1 + o$1) % o$1, a$1 = i$1.x + 1 === o$1 ? t$1.wrap + 1 : t$1.wrap, l$1 = {};
						return l$1[new e.aQ(t$1.overscaledZ, r$1, i$1.z, s$1, i$1.y).key] = { backfilled: !1 }, l$1[new e.aQ(t$1.overscaledZ, a$1, i$1.z, n$1, i$1.y).key] = { backfilled: !1 }, i$1.y > 0 && (l$1[new e.aQ(t$1.overscaledZ, r$1, i$1.z, s$1, i$1.y - 1).key] = { backfilled: !1 }, l$1[new e.aQ(t$1.overscaledZ, t$1.wrap, i$1.z, i$1.x, i$1.y - 1).key] = { backfilled: !1 }, l$1[new e.aQ(t$1.overscaledZ, a$1, i$1.z, n$1, i$1.y - 1).key] = { backfilled: !1 }), i$1.y + 1 < o$1 && (l$1[new e.aQ(t$1.overscaledZ, r$1, i$1.z, s$1, i$1.y + 1).key] = { backfilled: !1 }, l$1[new e.aQ(t$1.overscaledZ, t$1.wrap, i$1.z, i$1.x, i$1.y + 1).key] = { backfilled: !1 }, l$1[new e.aQ(t$1.overscaledZ, a$1, i$1.z, n$1, i$1.y + 1).key] = { backfilled: !1 }), l$1;
					}
				},
				"raster-array": pt,
				geojson: class extends e.E {
					constructor(t$1, i$1, o$1, s$1) {
						super(), this.id = t$1, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = !0, this.reparseOverscaled = !0, this._loaded = !1, this.actor = o$1.getActor(), this.setEventedParent(s$1), this._data = i$1.data, this._options = Object.assign({}, i$1), this._collectResourceTiming = i$1.collectResourceTiming, void 0 !== i$1.maxzoom && (this.maxzoom = i$1.maxzoom), void 0 !== i$1.minzoom && (this.minzoom = i$1.minzoom), i$1.type && (this.type = i$1.type), i$1.attribution && (this.attribution = i$1.attribution), this.promoteId = i$1.promoteId;
						const r$1 = e.al / this.tileSize;
						this.workerOptions = Object.assign({
							source: this.id,
							scope: this.scope,
							cluster: i$1.cluster || !1,
							geojsonVtOptions: {
								buffer: (void 0 !== i$1.buffer ? i$1.buffer : 128) * r$1,
								tolerance: (void 0 !== i$1.tolerance ? i$1.tolerance : .375) * r$1,
								extent: e.al,
								maxZoom: this.maxzoom,
								lineMetrics: i$1.lineMetrics || !1,
								generateId: i$1.generateId || !1
							},
							superclusterOptions: {
								maxZoom: void 0 !== i$1.clusterMaxZoom ? i$1.clusterMaxZoom : this.maxzoom - 1,
								minPoints: Math.max(2, i$1.clusterMinPoints || 2),
								extent: e.al,
								radius: (void 0 !== i$1.clusterRadius ? i$1.clusterRadius : 50) * r$1,
								log: !1,
								generateId: i$1.generateId || !1
							},
							clusterProperties: i$1.clusterProperties,
							filter: i$1.filter,
							dynamic: i$1.dynamic
						}, i$1.workerOptions);
					}
					onAdd(e$1) {
						this.map = e$1, this.setData(this._data);
					}
					setData(e$1) {
						return this._data = e$1, this._updateWorkerData(), this;
					}
					updateData(t$1) {
						if (!this._options.dynamic) return this.fire(new e.y(/* @__PURE__ */ new Error("Can't call updateData on a GeoJSON source with dynamic set to false.")));
						if ("string" != typeof t$1 && ("Feature" === t$1.type && (t$1 = {
							type: "FeatureCollection",
							features: [t$1]
						}), "FeatureCollection" !== t$1.type)) return this.fire(new e.y(/* @__PURE__ */ new Error("Data to update should be a feature or a feature collection.")));
						if (this._coalesce && "string" != typeof t$1 && "string" != typeof this._data && "FeatureCollection" === this._data.type) {
							const e$1 = /* @__PURE__ */ new Map();
							for (const t$2 of this._data.features) e$1.set(t$2.id, t$2);
							for (const i$1 of t$1.features) e$1.set(i$1.id, i$1);
							this._data.features = [...e$1.values()];
						} else this._data = t$1;
						return this._updateWorkerData(!0), this;
					}
					getClusterExpansionZoom(e$1, t$1) {
						return this.actor.send("geojson.getClusterExpansionZoom", {
							clusterId: e$1,
							source: this.id,
							scope: this.scope
						}, t$1), this;
					}
					getClusterChildren(e$1, t$1) {
						return this.actor.send("geojson.getClusterChildren", {
							clusterId: e$1,
							source: this.id,
							scope: this.scope
						}, t$1), this;
					}
					getClusterLeaves(e$1, t$1, i$1, o$1) {
						return this.actor.send("geojson.getClusterLeaves", {
							source: this.id,
							scope: this.scope,
							clusterId: e$1,
							limit: t$1,
							offset: i$1
						}, o$1), this;
					}
					_updateWorkerData(t$1 = !1) {
						if (this._pendingLoad) return void (this._coalesce = !0);
						this.fire(new e.z("dataloading", { dataType: "source" })), this._loaded = !1;
						const i$1 = Object.assign({ append: t$1 }, this.workerOptions);
						i$1.scope = this.scope;
						const o$1 = this._data;
						"string" == typeof o$1 ? (i$1.request = this.map._requestManager.transformRequest(e.o.resolveURL(o$1), e.R.Source), i$1.request.collectResourceTiming = this._collectResourceTiming) : i$1.data = JSON.stringify(o$1), this._pendingLoad = this.actor.send(`${this.type}.loadData`, i$1, ((i$2, o$2) => {
							if (this._loaded = !0, this._pendingLoad = null, i$2) this.fire(new e.y(i$2));
							else {
								const i$3 = {
									dataType: "source",
									sourceDataType: this._metadataFired ? "content" : "metadata"
								};
								this._collectResourceTiming && o$2 && o$2.resourceTiming && o$2.resourceTiming[this.id] && (i$3.resourceTiming = o$2.resourceTiming[this.id]), t$1 && (this._partialReload = !0), this.fire(new e.z("data", i$3)), this._partialReload = !1, this._metadataFired = !0;
							}
							this._coalesce && (this._updateWorkerData(t$1), this._coalesce = !1);
						}));
					}
					loaded() {
						return this._loaded;
					}
					reload() {
						const t$1 = e.B(this.id, this.scope);
						this.map.style.clearSource(t$1), this._updateWorkerData();
					}
					loadTile(t$1, i$1) {
						const o$1 = t$1.actor ? "reloadTile" : "loadTile";
						t$1.actor = this.actor;
						const s$1 = this.map.style ? this.map.style.getLut(this.scope) : null, r$1 = s$1 ? { image: s$1.image.clone() } : null, n$1 = this._partialReload, a$1 = {
							type: this.type,
							uid: t$1.uid,
							tileID: t$1.tileID,
							tileZoom: t$1.tileZoom,
							zoom: t$1.tileID.overscaledZ,
							maxZoom: this.maxzoom,
							tileSize: this.tileSize,
							source: this.id,
							lut: r$1,
							scope: this.scope,
							pixelRatio: e.o.devicePixelRatio,
							showCollisionBoxes: this.map.showCollisionBoxes,
							promoteId: this.promoteId,
							brightness: this.map.style && this.map.style.getBrightness() || 0,
							extraShadowCaster: t$1.isExtraShadowCaster,
							scaleFactor: this.map.getScaleFactor(),
							partial: n$1,
							worldview: this.map.getWorldview(),
							indoor: this.map.indoor ? this.map.indoor.getIndoorTileOptions(this.id, this.scope) : null
						};
						t$1.request = this.actor.send(o$1, a$1, ((e$1, s$2) => n$1 && !s$2 ? (t$1.state = "loaded", i$1(null)) : (delete t$1.request, t$1.destroy(!1), t$1.aborted ? i$1(null) : e$1 ? i$1(e$1) : (t$1.loadVectorData(s$2, this.map.painter, "reloadTile" === o$1), i$1(null)))), void 0, "loadTile" === o$1);
					}
					abortTile(e$1) {
						e$1.request && (e$1.request.cancel(), delete e$1.request), e$1.aborted = !0;
					}
					unloadTile(e$1, t$1) {
						this.actor.send("removeTile", {
							uid: e$1.uid,
							type: this.type,
							source: this.id,
							scope: this.scope
						}), e$1.destroy();
					}
					onRemove(e$1) {
						this._pendingLoad && this._pendingLoad.cancel();
					}
					serialize() {
						return Object.assign({}, this._options, {
							type: this.type,
							data: this._data
						});
					}
					hasTransition() {
						return !1;
					}
				},
				video: class extends e.aU {
					constructor(e$1, t$1, i$1, o$1) {
						super(e$1, t$1, i$1, o$1), this.roundZoom = !0, this.type = "video", this.options = t$1;
					}
					load() {
						this._loaded = !1;
						const t$1 = this.options;
						this.urls = [];
						for (const i$1 of t$1.urls) this.urls.push(this.map._requestManager.transformRequest(i$1, e.R.Source).url);
						e.aV(this.urls, ((t$2, i$1) => {
							this._loaded = !0, t$2 ? this.fire(new e.y(t$2)) : i$1 && (this.video = i$1, this.video.loop = !0, this.video.setAttribute("playsinline", ""), this.video.addEventListener("playing", (() => {
								this.map.triggerRepaint();
							})), this.map && this.video.play(), this._finishLoading());
						}));
					}
					pause() {
						this.video && this.video.pause();
					}
					play() {
						this.video && this.video.play();
					}
					seek(t$1) {
						if (this.video) {
							const i$1 = this.video.seekable;
							t$1 < i$1.start(0) || t$1 > i$1.end(0) ? this.fire(new e.y(new e.V(`sources.${this.id}`, null, `Playback for this video can be set only between the ${i$1.start(0)} and ${i$1.end(0)}-second mark.`))) : this.video.currentTime = t$1;
						}
					}
					getVideo() {
						return this.video;
					}
					onAdd(e$1) {
						this.map || (this.map = e$1, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));
					}
					prepare() {
						if (0 === Object.keys(this.tiles).length || this.video.readyState < 2) return;
						const t$1 = this.map.painter.context, i$1 = t$1.gl;
						this.texture ? this.video.paused || (this.texture.bind(i$1.LINEAR, i$1.CLAMP_TO_EDGE), i$1.texSubImage2D(i$1.TEXTURE_2D, 0, 0, 0, i$1.RGBA, i$1.UNSIGNED_BYTE, this.video)) : (this.texture = new e.T(t$1, this.video, i$1.RGBA8), this.texture.bind(i$1.LINEAR, i$1.CLAMP_TO_EDGE), this.width = this.video.videoWidth, this.height = this.video.videoHeight), this._prepareData(t$1);
					}
					serialize() {
						return {
							type: "video",
							urls: this.urls,
							coordinates: this.coordinates
						};
					}
					hasTransition() {
						return this.video && !this.video.paused;
					}
				},
				image: e.aU,
				model: e.aX,
				"batched-model": class extends e.E {
					constructor(e$1, t$1, i$1, o$1) {
						super(), this.type = "batched-model", this.id = e$1, this.tileSize = 512, this._options = t$1, this.tiles = this._options.tiles, this.maxzoom = t$1.maxzoom || 19, this.minzoom = t$1.minzoom || 0, this.roundZoom = !0, this.usedInConflation = !0, this.dispatcher = i$1, this.reparseOverscaled = !1, this.scheme = "xyz", this._loaded = !1, this.setEventedParent(o$1);
					}
					onAdd(e$1) {
						this.map = e$1, this.load();
					}
					reload() {
						this.cancelTileJSONRequest();
						const t$1 = e.B(this.id, this.scope);
						this.load((() => this.map.style.clearSource(t$1)));
					}
					cancelTileJSONRequest() {
						this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
					}
					load(t$1) {
						this._loaded = !1, this.fire(new e.z("dataloading", { dataType: "source" }));
						const i$1 = Array.isArray(this.map._language) ? this.map._language.join() : this.map._language, o$1 = this.map.getWorldview();
						this._tileJSONRequest = lt(this._options, this.map._requestManager, i$1, o$1, ((s$1, r$1) => {
							this._tileJSONRequest = null, this._loaded = !0, s$1 ? (i$1 && console.warn(`Ensure that your requested language string is a valid BCP-47 code or list of codes. Found: ${i$1}`), o$1 && 2 !== o$1.length && console.warn(`Requested worldview strings must be a valid ISO alpha-2 code. Found: ${o$1}`), this.fire(new e.y(s$1))) : r$1 && (Object.assign(this, r$1), r$1.bounds && (this.tileBounds = new ht(r$1.bounds, this.minzoom, this.maxzoom)), P(r$1.tiles, this.map._requestManager._customAccessToken), this.fire(new e.z("data", {
								dataType: "source",
								sourceDataType: "metadata"
							})), this.fire(new e.z("data", {
								dataType: "source",
								sourceDataType: "content"
							}))), t$1 && t$1(s$1);
						}));
					}
					hasTransition() {
						return !1;
					}
					hasTile(e$1) {
						return !this.tileBounds || this.tileBounds.contains(e$1.canonical);
					}
					loaded() {
						return this._loaded;
					}
					loadTile(t$1, i$1) {
						const o$1 = this.map._requestManager.normalizeTileURL(t$1.tileID.canonical.url(this.tiles, this.scheme)), s$1 = {
							request: this.map._requestManager.transformRequest(o$1, e.R.Tile),
							data: void 0,
							uid: t$1.uid,
							tileID: t$1.tileID,
							tileZoom: t$1.tileZoom,
							zoom: t$1.tileID.overscaledZ,
							tileSize: this.tileSize * t$1.tileID.overscaleFactor(),
							type: this.type,
							source: this.id,
							scope: this.scope,
							showCollisionBoxes: this.map.showCollisionBoxes,
							isSymbolTile: t$1.isSymbolTile,
							brightness: this.map.style && this.map.style.getBrightness() || 0,
							pixelRatio: e.o.devicePixelRatio,
							promoteId: this.promoteId
						};
						if (t$1.actor && "expired" !== t$1.state) if ("loading" === t$1.state) t$1.reloadCallback = i$1;
						else {
							if (t$1.buckets) {
								const e$1 = Object.values(t$1.buckets);
								for (const t$2 of e$1) t$2.dirty = !0;
								t$1.state = "loaded";
								return;
							}
							t$1.request = t$1.actor.send("reloadTile", s$1, r$1.bind(this));
						}
						else t$1.actor = this.dispatcher.getActor(), t$1.request = t$1.actor.send("loadTile", s$1, r$1.bind(this), void 0, !0);
						function r$1(e$1, o$2) {
							return t$1.aborted ? i$1(null) : e$1 && 404 !== e$1.status ? i$1(e$1) : (this.map._refreshExpiredTiles && o$2 && t$1.setExpiryData(o$2), t$1.loadModelData(o$2, this.map.painter), t$1.state = "loaded", void i$1(null));
						}
					}
					serialize() {
						return Object.assign({}, this._options);
					}
				},
				canvas: class extends e.aU {
					constructor(t$1, i$1, o$1, s$1) {
						super(t$1, i$1, o$1, s$1), i$1.coordinates ? Array.isArray(i$1.coordinates) && 4 === i$1.coordinates.length && !i$1.coordinates.some(((e$1) => !Array.isArray(e$1) || 2 !== e$1.length || e$1.some(((e$2) => "number" != typeof e$2)))) || this.fire(new e.y(new e.V(`sources.${t$1}`, null, "\"coordinates\" property must be an array of 4 longitude/latitude array pairs"))) : this.fire(new e.y(new e.V(`sources.${t$1}`, null, "missing required property \"coordinates\""))), i$1.animate && "boolean" != typeof i$1.animate && this.fire(new e.y(new e.V(`sources.${t$1}`, null, "optional \"animate\" property must be a boolean value"))), i$1.canvas ? "string" == typeof i$1.canvas || i$1.canvas instanceof HTMLCanvasElement || this.fire(new e.y(new e.V(`sources.${t$1}`, null, "\"canvas\" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance"))) : this.fire(new e.y(new e.V(`sources.${t$1}`, null, "missing required property \"canvas\""))), this.options = i$1, this.animate = void 0 === i$1.animate || i$1.animate;
					}
					load() {
						this._loaded = !0, this.canvas || (this.canvas = this.options.canvas instanceof HTMLCanvasElement ? this.options.canvas : document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new e.y(/* @__PURE__ */ new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
							this._playing = !0, this.map.triggerRepaint();
						}, this.pause = function() {
							this._playing && (this.prepare(), this._playing = !1);
						}, this._finishLoading());
					}
					getCanvas() {
						return this.canvas;
					}
					onAdd(e$1) {
						this.map = e$1, this.load(), this.canvas && this.animate && this.play();
					}
					onRemove(e$1) {
						this.pause();
					}
					prepare() {
						let t$1 = !1;
						if (this.canvas.width !== this.width && (this.width = this.canvas.width, t$1 = !0), this.canvas.height !== this.height && (this.height = this.canvas.height, t$1 = !0), this._hasInvalidDimensions()) return;
						if (0 === Object.keys(this.tiles).length) return;
						const i$1 = this.map.painter.context;
						this.texture ? !t$1 && !this._playing || this.texture instanceof e.aW || this.texture.update(this.canvas, { premultiply: !0 }) : this.texture = new e.T(i$1, this.canvas, i$1.gl.RGBA8, { premultiply: !0 }), this._prepareData(i$1);
					}
					serialize() {
						return {
							type: "canvas",
							coordinates: this.coordinates
						};
					}
					hasTransition() {
						return this._playing;
					}
					_hasInvalidDimensions() {
						for (const e$1 of [this.canvas.width, this.canvas.height]) if (isNaN(e$1) || e$1 <= 0) return !0;
						return !1;
					}
				},
				custom: class extends e.E {
					constructor(t$1, i$1, o$1, s$1) {
						super(), this.id = t$1, this.type = "custom", this._dataType = "raster", this._dispatcher = o$1, this._implementation = i$1, this.setEventedParent(s$1), this.scheme = "xyz", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this._loaded = !1, this.roundZoom = !0, this._implementation || this.fire(new e.y(/* @__PURE__ */ new Error(`Missing implementation for ${this.id} custom source`))), this._implementation.loadTile || this.fire(new e.y(/* @__PURE__ */ new Error(`Missing loadTile implementation for ${this.id} custom source`))), this._implementation.bounds && (this.tileBounds = new ht(this._implementation.bounds, this.minzoom, this.maxzoom)), i$1.update = this._update.bind(this), i$1.clearTiles = this._clearTiles.bind(this), i$1.coveringTiles = this._coveringTiles.bind(this), Object.assign(this, e.aH(i$1, [
							"dataType",
							"scheme",
							"minzoom",
							"maxzoom",
							"tileSize",
							"attribution",
							"minTileCacheSize",
							"maxTileCacheSize"
						]));
					}
					serialize() {
						return e.aH(this, [
							"type",
							"scheme",
							"minzoom",
							"maxzoom",
							"tileSize",
							"attribution"
						]);
					}
					load() {
						this._loaded = !0, this.fire(new e.z("data", {
							dataType: "source",
							sourceDataType: "metadata"
						})), this.fire(new e.z("data", {
							dataType: "source",
							sourceDataType: "content"
						}));
					}
					loaded() {
						return this._loaded;
					}
					onAdd(t$1) {
						this.map = t$1, this._loaded = !1, this.fire(new e.z("dataloading", { dataType: "source" })), this._implementation.onAdd && this._implementation.onAdd(t$1), this.load();
					}
					onRemove(e$1) {
						this._implementation.onRemove && this._implementation.onRemove(e$1);
					}
					hasTile(e$1) {
						if (this._implementation.hasTile) {
							const { x: t$1, y: i$1, z: o$1 } = e$1.canonical;
							return this._implementation.hasTile({
								x: t$1,
								y: i$1,
								z: o$1
							});
						}
						return !this.tileBounds || this.tileBounds.contains(e$1.canonical);
					}
					loadTile(e$1, t$1) {
						const { x: i$1, y: o$1, z: s$1 } = e$1.tileID.canonical, r$1 = new AbortController();
						e$1.request = Promise.resolve(this._implementation.loadTile({
							x: i$1,
							y: o$1,
							z: s$1
						}, { signal: r$1.signal })).then(function(i$2) {
							return delete e$1.request, e$1.aborted ? (e$1.state = "unloaded", t$1(null)) : void 0 === i$2 ? (e$1.state = "errored", t$1(null)) : null === i$2 ? (this.loadTileData(e$1, {
								width: this.tileSize,
								height: this.tileSize,
								data: null
							}), e$1.state = "loaded", t$1(null)) : function(e$2) {
								return e$2 instanceof ImageData || e$2 instanceof HTMLCanvasElement || e$2 instanceof ImageBitmap || e$2 instanceof HTMLImageElement;
							}(i$2) ? (this.loadTileData(e$1, i$2), e$1.state = "loaded", void t$1(null)) : (e$1.state = "errored", t$1(/* @__PURE__ */ new Error(`Can't infer data type for ${this.id}, only raster data supported at the moment`)));
						}.bind(this)).catch(((i$2) => {
							"AbortError" !== i$2.name && (e$1.state = "errored", t$1(i$2));
						})), e$1.request.cancel = () => r$1.abort();
					}
					loadTileData(e$1, t$1) {
						e$1.setTexture(t$1, this.map.painter);
					}
					unloadTile(t$1, i$1) {
						if (t$1.texture && t$1.texture instanceof e.T ? (t$1.destroy(!1), t$1.texture && t$1.texture instanceof e.T && this.map.painter.saveTileTexture(t$1.texture)) : t$1.destroy(), this._implementation.unloadTile) {
							const { x: e$1, y: i$2, z: o$1 } = t$1.tileID.canonical;
							this._implementation.unloadTile({
								x: e$1,
								y: i$2,
								z: o$1
							});
						}
						i$1 && i$1();
					}
					abortTile(e$1, t$1) {
						e$1.request && e$1.request.cancel && (e$1.request.cancel(), delete e$1.request), t$1 && t$1();
					}
					hasTransition() {
						return !1;
					}
					_coveringTiles() {
						return this.map.transform.coveringTiles({
							tileSize: this.tileSize,
							minzoom: this.minzoom,
							maxzoom: this.maxzoom,
							roundZoom: this.roundZoom
						}).map(((e$1) => ({
							x: e$1.canonical.x,
							y: e$1.canonical.y,
							z: e$1.canonical.z
						})));
					}
					_clearTiles() {
						const t$1 = e.B(this.id, this.scope);
						this.map.style.clearSource(t$1);
					}
					_update() {
						this.fire(new e.z("data", {
							dataType: "source",
							sourceDataType: "content"
						}));
					}
				}
			}, mt = function(t$1, i$1, o$1, s$1) {
				const r$1 = new ft[i$1.type](t$1, i$1, o$1, s$1);
				if (r$1.id !== t$1) throw new Error(`Expected Source id to be ${t$1} instead of ${r$1.id}`);
				return e.aY([
					"load",
					"abort",
					"unload",
					"serialize",
					"prepare"
				], r$1), r$1;
			};
			function gt(e$1, t$1, i$1 = "") {
				return `${i$1}:${t$1.id || ""}:${t$1.layer.id}:${function(e$2) {
					if ("layerId" in e$2) return `layer:${e$2.layerId}`;
					{
						const { featuresetId: t$2, importId: i$2 } = e$2;
						return `featureset:${t$2}${i$2 ? `:import:${i$2}` : ""}`;
					}
				}(e$1.target)}`;
			}
			function vt(e$1, t$1, i$1, o$1 = "") {
				if (e$1.uniqueFeatureID) {
					const s$1 = gt(e$1, t$1, o$1);
					if (i$1.has(s$1)) return !0;
					i$1.add(s$1);
				}
				return !1;
			}
			function yt(e$1, t$1, i$1, o$1, s$1 = !1) {
				const r$1 = t$1.sourceCache.transform, n$1 = t$1.sourceCache.tilesIn(e$1, t$1.has3DLayers, s$1);
				n$1.sort(wt);
				const a$1 = [];
				for (const e$2 of n$1) {
					const n$2 = e$2.tile.queryRenderedFeatures(t$1, e$2, i$1, o$1, r$1, s$1);
					Object.keys(n$2).length && a$1.push({
						wrappedTileID: e$2.tile.tileID.wrapped().key,
						queryResults: n$2
					});
				}
				for (const i$2 in t$1.layers) {
					const s$2 = t$1.layers[i$2];
					if (s$2.styleLayer) {
						const i$3 = s$2.styleLayer.queryRenderedFeatures(e$1, t$1.sourceCache, o$1);
						Object.keys(i$3).length && a$1.push({
							wrappedTileID: 0,
							queryResults: i$3
						});
					}
				}
				return 0 === a$1.length ? {} : function(e$2) {
					const t$2 = {}, i$2 = {};
					for (const o$2 of e$2) {
						const e$3 = o$2.queryResults, s$2 = o$2.wrappedTileID, r$2 = i$2[s$2] = i$2[s$2] || {};
						for (const i$3 in e$3) {
							const o$3 = e$3[i$3], s$3 = r$2[i$3] = r$2[i$3] || {}, n$2 = t$2[i$3] = t$2[i$3] || [];
							for (const e$4 of o$3) s$3[e$4.featureIndex] || (s$3[e$4.featureIndex] = !0, n$2.push(e$4));
						}
					}
					return t$2;
				}(a$1);
			}
			function xt(e$1, t$1, i$1, o$1, s$1, r$1) {
				const n$1 = {}, a$1 = o$1.queryRenderedSymbols(e$1), l$1 = [];
				for (const e$2 of Object.keys(a$1).map(Number)) l$1.push(s$1[e$2]);
				l$1.sort(wt);
				for (const e$2 of l$1) {
					const o$2 = e$2.featureIndex.lookupSymbolFeatures(a$1[e$2.bucketInstanceId], e$2.bucketIndex, e$2.sourceLayerIndex, t$1, i$1, r$1);
					for (const t$2 in o$2) {
						const i$2 = n$1[t$2] = n$1[t$2] || [], s$2 = o$2[t$2];
						s$2.sort(((t$3, i$3) => {
							const o$3 = e$2.featureSortOrder;
							if (o$3) {
								const e$3 = o$3.indexOf(t$3.featureIndex);
								return o$3.indexOf(i$3.featureIndex) - e$3;
							}
							return i$3.featureIndex - t$3.featureIndex;
						}));
						for (const e$3 of s$2) i$2.push(e$3);
					}
				}
				return n$1;
			}
			function bt(e$1, t$1) {
				const i$1 = e$1.getRenderableIds().map(((t$2) => e$1.getTileByID(t$2))), o$1 = [], s$1 = {};
				for (let e$2 = 0; e$2 < i$1.length; e$2++) {
					const r$1 = i$1[e$2], n$1 = r$1.tileID.canonical.key;
					s$1[n$1] || (s$1[n$1] = !0, r$1.querySourceFeatures(o$1, t$1));
				}
				return o$1;
			}
			function wt(e$1, t$1) {
				const i$1 = e$1.tileID, o$1 = t$1.tileID;
				return i$1.overscaledZ - o$1.overscaledZ || i$1.canonical.y - o$1.canonical.y || i$1.wrap - o$1.wrap || i$1.canonical.x - o$1.canonical.x;
			}
			function Tt(e$1, t$1) {
				const i$1 = {};
				if (!t$1) return i$1;
				for (const o$1 of e$1) {
					const e$2 = o$1.layerIds.map(((e$3) => t$1.getLayer(e$3))).filter(Boolean);
					if (0 !== e$2.length) {
						o$1.layers = e$2, o$1.stateDependentLayerIds && (o$1.stateDependentLayers = o$1.stateDependentLayerIds.map(((t$2) => e$2.filter(((e$3) => e$3.id === t$2))[0])));
						for (const t$2 of e$2) i$1[t$2.fqid] = o$1;
					}
				}
				return i$1;
			}
			const Et = 32, St = 33, It = new Uint16Array(8184);
			for (let e$1 = 0; e$1 < 2046; e$1++) {
				let t$1 = e$1 + 2, i$1 = 0, o$1 = 0, s$1 = 0, r$1 = 0, n$1 = 0, a$1 = 0;
				for (1 & t$1 ? s$1 = r$1 = n$1 = Et : i$1 = o$1 = a$1 = Et; (t$1 >>= 1) > 1;) {
					const e$2 = i$1 + s$1 >> 1, l$2 = o$1 + r$1 >> 1;
					1 & t$1 ? (s$1 = i$1, r$1 = o$1, i$1 = n$1, o$1 = a$1) : (i$1 = s$1, o$1 = r$1, s$1 = n$1, r$1 = a$1), n$1 = e$2, a$1 = l$2;
				}
				const l$1 = 4 * e$1;
				It[l$1 + 0] = i$1, It[l$1 + 1] = o$1, It[l$1 + 2] = s$1, It[l$1 + 3] = r$1;
			}
			const Ct = new Uint16Array(2178), Rt = new Uint8Array(1089), At = new Uint16Array(1089);
			function Lt(e$1) {
				return 0 === e$1 ? -.03125 : 32 === e$1 ? .03125 : 0;
			}
			const Dt = (() => ({
				type: 2,
				extent: e.al,
				loadGeometry: () => [[
					new e.P(0, 0),
					new e.P(e.al + 1, 0),
					new e.P(e.al + 1, e.al + 1),
					new e.P(0, e.al + 1),
					new e.P(0, 0)
				]]
			}))();
			class Pt {
				constructor(t$1, i$1, o$1, s$1, r$1, n$1) {
					this.tileID = t$1, this.uid = e.b2(), this.uses = 0, this.tileSize = i$1, this.tileZoom = o$1, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = !1, this.hasRTLText = !1, this.dependencies = {}, this.isRaster = r$1, s$1 && s$1.style && (this._lastUpdatedBrightness = s$1.style.getBrightness()), this.expiredRequestCount = 0, this.state = "loading", s$1 && s$1.transform && (this.projection = s$1.transform.projection), this.worldview = n$1, this._hasAppearances = null;
				}
				registerFadeDuration(t$1) {
					const i$1 = t$1 + this.timeAdded;
					i$1 < e.o.now() || this.fadeEndTime && i$1 < this.fadeEndTime || (this.fadeEndTime = i$1);
				}
				wasRequested() {
					return "errored" === this.state || "loaded" === this.state || "reloading" === this.state;
				}
				get tileTransform() {
					return this._tileTransform || (this._tileTransform = e.aZ(this.tileID.canonical, this.projection)), this._tileTransform;
				}
				loadVectorData(t$1, i$1, o$1) {
					if (this.unloadVectorData(), this.state = "loaded", t$1) {
						t$1.featureIndex && (this.latestFeatureIndex = t$1.featureIndex, t$1.rawTileData ? (this.latestRawTileData = t$1.rawTileData, this.latestFeatureIndex.rawTileData = t$1.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = t$1.collisionBoxArray, this.buckets = Tt(t$1.buckets, i$1.style), this.hasSymbolBuckets = !1;
						for (const t$2 in this.buckets) {
							const i$2 = this.buckets[t$2];
							if (i$2 instanceof e.b4) {
								if (this.hasSymbolBuckets = !0, !o$1) break;
								i$2.justReloaded = !0;
							}
						}
						if (this.hasRTLText = !1, this.hasSymbolBuckets) for (const t$2 in this.buckets) {
							const i$2 = this.buckets[t$2];
							if (i$2 instanceof e.b4 && i$2.hasRTLText) {
								this.hasRTLText = !0, e.b5();
								break;
							}
						}
						this.queryPadding = 0;
						for (const e$1 in this.buckets) {
							const t$2 = this.buckets[e$1], o$2 = i$1.style.getOwnLayer(e$1);
							if (!o$2) continue;
							const s$1 = o$2.queryRadius(t$2);
							this.queryPadding = Math.max(this.queryPadding, s$1);
						}
						t$1.imageAtlas && (this.imageAtlas = t$1.imageAtlas), t$1.glyphAtlasImage && (this.glyphAtlasImage = t$1.glyphAtlasImage), t$1.lineAtlas && (this.lineAtlas = t$1.lineAtlas), this._lastUpdatedBrightness = t$1.brightness;
					} else this.collisionBoxArray = new e.b3();
				}
				unloadVectorData() {
					if (this.hasData()) {
						for (const e$1 in this.buckets) this.buckets[e$1].destroy();
						this.buckets = {}, this.imageAtlas && (this.imageAtlas = null), this.lineAtlas && (this.lineAtlas = null), this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.lineAtlasTexture && this.lineAtlasTexture.destroy(), this._tileBoundsBuffer && (this._tileBoundsBuffer.destroy(), this._tileBoundsIndexBuffer.destroy(), this._tileBoundsSegments.destroy(), this._tileBoundsBuffer = null), this._tileDebugBuffer && (this._tileDebugBuffer.destroy(), this._tileDebugSegments.destroy(), this._tileDebugBuffer = null), this._tileDebugIndexBuffer && (this._tileDebugIndexBuffer.destroy(), this._tileDebugIndexBuffer = null), this._globeTileDebugBorderBuffer && (this._globeTileDebugBorderBuffer.destroy(), this._globeTileDebugBorderBuffer = null), this._tileDebugTextBuffer && (this._tileDebugTextBuffer.destroy(), this._tileDebugTextSegments.destroy(), this._tileDebugTextIndexBuffer.destroy(), this._tileDebugTextBuffer = null), this._globeTileDebugTextBuffer && (this._globeTileDebugTextBuffer.destroy(), this._globeTileDebugTextBuffer = null), this.latestFeatureIndex = null, this.state = "unloaded";
					}
				}
				loadModelData(e$1, t$1, i$1) {
					e$1 && (e$1.resourceTiming && (this.resourceTiming = e$1.resourceTiming), this.buckets = Object.assign({}, this.buckets, Tt(e$1.buckets, t$1.style)), e$1.featureIndex && (this.latestFeatureIndex = e$1.featureIndex));
				}
				getBucket(e$1) {
					return this.buckets[e$1.fqid];
				}
				upload(t$1, i$1) {
					for (const e$1 in this.buckets) {
						const o$2 = this.buckets[e$1];
						if (o$2.uploadPending()) {
							let e$2 = {}, s$2 = [], r$1 = {
								zoom: 0,
								pitch: 0,
								brightness: 0,
								worldview: ""
							};
							if (i$1) {
								if (i$1.style) {
									s$2 = i$1.style.listImages();
									const t$2 = o$2.layers[0], r$2 = t$2.sourceLayer || "_geojsonTileLayer", n$1 = i$1.style.getLayerSourceCache(t$2);
									n$1 && (e$2 = n$1._state.getState(r$2, void 0));
								}
								r$1 = {
									zoom: i$1.transform.zoom || 0,
									pitch: i$1.transform.pitch || 0,
									brightness: i$1.style.getBrightness() || 0,
									worldview: i$1.worldview || ""
								};
							}
							o$2.upload(t$1, this.tileID.canonical, e$2, s$2, r$1);
						}
					}
					const o$1 = t$1.gl, s$1 = this.imageAtlas;
					s$1 && !s$1.uploaded && (this.imageAtlasTexture = new e.T(t$1, s$1.image, o$1.RGBA8, { useMipmap: !!s$1.patternPositions.size }), this.imageAtlas.uploaded = !0), this.glyphAtlasImage && (this.glyphAtlasTexture = new e.T(t$1, this.glyphAtlasImage, o$1.R8), this.glyphAtlasImage = null), this.lineAtlas && !this.lineAtlas.uploaded && (this.lineAtlasTexture = new e.T(t$1, this.lineAtlas.image, o$1.R8), this.lineAtlas.uploaded = !0);
				}
				prepare(e$1, t$1, i$1) {
					if (this.imageAtlas && this.imageAtlasTexture && this.imageAtlas.patchUpdatedImages(e$1, this.imageAtlasTexture, i$1), !t$1 || !this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData) return;
					const o$1 = t$1.style.getBrightness();
					null === this._hasAppearances && (this._hasAppearances = this.hasAppearances(t$1)), (this._lastUpdatedBrightness || o$1 || this._hasAppearances) && (!this._hasAppearances && this._lastUpdatedBrightness && o$1 && Math.abs(this._lastUpdatedBrightness - o$1) < .001 || (this.updateBuckets(t$1, this._lastUpdatedBrightness !== o$1), this._lastUpdatedBrightness = o$1));
				}
				evaluateQueryRenderedFeaturePadding() {
					let e$1 = 0;
					for (const t$1 in this.buckets) {
						const i$1 = this.buckets[t$1];
						i$1.evaluateQueryRenderedFeaturePadding && (e$1 = Math.max(e$1, i$1.evaluateQueryRenderedFeaturePadding()));
					}
					return e$1;
				}
				queryRenderedFeatures(t$1, i$1, o$1, s$1, r$1, n$1) {
					if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData && !this.latestFeatureIndex.is3DTile) return {};
					const a$1 = this.evaluateQueryRenderedFeaturePadding(), l$1 = function(t$2, i$2) {
						const o$2 = e.bq([], [
							.5 * t$2.width,
							.5 * -t$2.height,
							1
						]);
						return e.br(o$2, o$2, [
							1,
							-1,
							0
						]), e.aB(o$2, o$2, t$2.calculateProjMatrix(i$2.toUnwrapped())), Float32Array.from(o$2);
					}(r$1, this.tileID);
					return this.latestFeatureIndex.query(t$1, {
						tilespaceGeometry: i$1,
						pixelPosMatrix: l$1,
						transform: s$1,
						availableImages: o$1,
						tileTransform: this.tileTransform,
						worldview: this.worldview,
						queryRadius: a$1
					});
				}
				querySourceFeatures(t$1, i$1) {
					const o$1 = this.latestFeatureIndex;
					if (!o$1 || !o$1.rawTileData) return;
					const s$1 = o$1.loadVTLayers(), r$1 = i$1 ? i$1.sourceLayer : "", n$1 = s$1._geojsonTileLayer || s$1[r$1];
					if (!n$1) return;
					const a$1 = e.b6(i$1 && i$1.filter), { z: l$1, x: c$1, y: h$1 } = this.tileID.canonical, d$1 = {
						z: l$1,
						x: c$1,
						y: h$1
					};
					for (let i$2 = 0; i$2 < n$1.length; i$2++) {
						const s$2 = n$1.feature(i$2);
						if (a$1.needGeometry) {
							const t$2 = e.b7(s$2, !0);
							if (!a$1.filter(new e.ac(this.tileID.overscaledZ, { worldview: this.worldview }), t$2, this.tileID.canonical)) continue;
						} else if (!a$1.filter(new e.ac(this.tileID.overscaledZ, { worldview: this.worldview }), s$2)) continue;
						const u$1 = o$1.getId(s$2, r$1), _$1 = new e.b8(s$2, l$1, c$1, h$1, u$1);
						_$1.tile = d$1, t$1.push(_$1);
					}
				}
				loaded() {
					return "loaded" === this.state || "errored" === this.state;
				}
				hasData() {
					return "loaded" === this.state || "reloading" === this.state || "expired" === this.state;
				}
				patternsLoaded() {
					return !!this.imageAtlas && !!this.imageAtlas.patternPositions.size;
				}
				setExpiryData(t$1) {
					const i$1 = this.expirationTime;
					if (t$1.cacheControl) {
						const i$2 = e.b9(t$1.cacheControl);
						i$2["max-age"] && (this.expirationTime = Date.now() + 1e3 * i$2["max-age"]);
					} else t$1.expires && (this.expirationTime = new Date(t$1.expires).getTime());
					if (this.expirationTime) {
						const e$1 = Date.now();
						let t$2 = !1;
						if (this.expirationTime > e$1) t$2 = !1;
						else if (i$1) if (this.expirationTime < i$1) t$2 = !0;
						else {
							const o$1 = this.expirationTime - i$1;
							o$1 ? this.expirationTime = e$1 + Math.max(o$1, 3e4) : t$2 = !0;
						}
						else t$2 = !0;
						t$2 ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0;
					}
				}
				getExpiryTimeout() {
					if (this.expirationTime) return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - (/* @__PURE__ */ new Date()).getTime(), Math.pow(2, 31) - 1);
				}
				refreshFeatureState(e$1) {
					this.latestFeatureIndex && (this.latestFeatureIndex.rawTileData || this.latestFeatureIndex.is3DTile) && e$1 && this.updateBuckets(e$1);
				}
				hasAppearances(e$1) {
					for (const t$1 in this.buckets) if (e$1.style.hasLayer(t$1) && this.buckets[t$1].layers.some(((e$2) => e$2.appearances && e$2.appearances.length > 0))) return !0;
					return !1;
				}
				updateBuckets(t$1, i$1) {
					if (!this.latestFeatureIndex) return;
					if (!t$1.style) return;
					const o$1 = t$1.style.listImages(), s$1 = t$1.style.getBrightness();
					for (const r$1 in this.buckets) {
						if (!t$1.style.hasLayer(r$1)) continue;
						const n$1 = this.buckets[r$1], a$1 = n$1.layers[0], l$1 = a$1.sourceLayer || "_geojsonTileLayer", c$1 = t$1.style.getLayerSourceCache(a$1);
						let h$1 = {};
						c$1 && (h$1 = c$1._state.getState(l$1, void 0));
						const d$1 = this.imageAtlas ? Object.fromEntries(this.imageAtlas.patternPositions) : {}, u$1 = Object.keys(h$1).length > 0 && !i$1;
						n$1.hasAppearances = n$1.layers.some(((e$1) => e$1.appearances && e$1.appearances.length > 0));
						const _$1 = u$1 ? n$1.stateDependentLayers : n$1.layers;
						if (u$1 && 0 !== n$1.stateDependentLayers.length || i$1) {
							const e$1 = this.latestFeatureIndex.loadVTLayers();
							n$1.update(h$1, e$1[l$1], o$1, d$1, _$1, i$1, s$1);
						}
						if (u$1 && 0 !== n$1.stateDependentLayers.length || i$1 || n$1.hasAppearances) {
							const e$1 = {
								zoom: t$1.transform.zoom,
								pitch: t$1.transform.pitch,
								brightness: t$1.style.getBrightness() || 0,
								worldview: t$1.worldview
							};
							n$1.updateAppearances(this.tileID.canonical, h$1, o$1, e$1);
						}
						(n$1 instanceof e.ba || n$1 instanceof e.bb) && t$1._terrain && t$1._terrain.enabled && c$1 && n$1.uploadPending() && t$1._terrain._clearRenderCacheForTile(c$1.id, this.tileID);
						const p$1 = t$1 && t$1.style && t$1.style.getOwnLayer(r$1);
						p$1 && (this.queryPadding = Math.max(this.queryPadding, p$1.queryRadius(n$1)));
					}
				}
				holdingForFade() {
					return void 0 !== this.symbolFadeHoldUntil;
				}
				symbolFadeFinished() {
					return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < e.o.now();
				}
				clearFadeHold() {
					this.symbolFadeHoldUntil = void 0;
				}
				setHoldDuration(t$1) {
					this.symbolFadeHoldUntil = e.o.now() + t$1;
				}
				setTexture(t$1, i$1) {
					const o$1 = i$1.context, s$1 = o$1.gl;
					this.texture = this.texture || i$1.getTileTexture(t$1.width), this.texture && this.texture instanceof e.T ? this.texture.update(t$1) : (this.texture = new e.T(o$1, t$1, s$1.RGBA8, { useMipmap: !0 }), this.texture.bind(s$1.LINEAR, s$1.CLAMP_TO_EDGE));
				}
				setDependencies(e$1, t$1) {
					const i$1 = {};
					for (const e$2 of t$1) i$1[e$2] = !0;
					this.dependencies[e$1] = i$1;
				}
				hasDependency(e$1, t$1) {
					for (const i$1 of e$1) {
						const e$2 = this.dependencies[i$1];
						if (e$2) {
							for (const i$2 of t$1) if (e$2[i$2]) return !0;
						}
					}
					return !1;
				}
				clearQueryDebugViz() {}
				_makeDebugTileBoundsBuffers(t$1, i$1) {
					if (!i$1 || "mercator" === i$1.name || this._tileDebugBuffer) return;
					const o$1 = e.bc(Dt, this.tileID.canonical, this.tileTransform)[0], s$1 = new e.bd(), r$1 = new e.be();
					for (let e$1 = 0; e$1 < o$1.length; e$1++) {
						const { x: t$2, y: i$2 } = o$1[e$1];
						s$1.emplaceBack(t$2, i$2), r$1.emplaceBack(e$1);
					}
					r$1.emplaceBack(0), this._tileDebugIndexBuffer = t$1.createIndexBuffer(r$1), this._tileDebugBuffer = t$1.createVertexBuffer(s$1, e.bf.members), this._tileDebugSegments = e.bg.simpleSegment(0, 0, s$1.length, r$1.length);
				}
				_makeTileBoundsBuffers(t$1, i$1) {
					if (this._tileBoundsBuffer || !i$1 || "mercator" === i$1.name) return;
					const o$1 = e.bc(Dt, this.tileID.canonical, this.tileTransform)[0];
					let s$1, r$1;
					if (this.isRaster) {
						const t$2 = function(t$3, i$2) {
							const o$2 = e.aZ(t$3, i$2), s$2 = Math.pow(2, t$3.z);
							for (let r$3 = 0; r$3 < St; r$3++) for (let n$2 = 0; n$2 < St; n$2++) {
								const a$2 = e.a_((t$3.x + (n$2 + Lt(n$2)) / Et) / s$2), l$2 = e.a$((t$3.y + (r$3 + Lt(r$3)) / Et) / s$2), c$2 = i$2.project(a$2, l$2), h$1 = r$3 * St + n$2;
								Ct[2 * h$1 + 0] = Math.round((c$2.x * o$2.scale - o$2.x) * e.al), Ct[2 * h$1 + 1] = Math.round((c$2.y * o$2.scale - o$2.y) * e.al);
							}
							Rt.fill(0), At.fill(0);
							for (let e$1 = 2045; e$1 >= 0; e$1--) {
								const t$4 = 4 * e$1, i$3 = It[t$4 + 0], o$3 = It[t$4 + 1], s$3 = It[t$4 + 2], r$3 = It[t$4 + 3], n$2 = i$3 + s$3 >> 1, a$2 = o$3 + r$3 >> 1, l$2 = n$2 + a$2 - o$3, c$2 = a$2 + i$3 - n$2, h$1 = o$3 * St + i$3, d$1 = r$3 * St + s$3, u$1 = a$2 * St + n$2, _$1 = Math.hypot((Ct[2 * h$1 + 0] + Ct[2 * d$1 + 0]) / 2 - Ct[2 * u$1 + 0], (Ct[2 * h$1 + 1] + Ct[2 * d$1 + 1]) / 2 - Ct[2 * u$1 + 1]) >= 16;
								Rt[u$1] = Rt[u$1] || (_$1 ? 1 : 0), e$1 < 1022 && (Rt[u$1] = Rt[u$1] || Rt[(o$3 + c$2 >> 1) * St + (i$3 + l$2 >> 1)] || Rt[(r$3 + c$2 >> 1) * St + (s$3 + l$2 >> 1)]);
							}
							const r$2 = new e.b1(), n$1 = new e.b0();
							let a$1 = 0;
							function l$1(t$4, i$3) {
								const o$3 = i$3 * St + t$4;
								return 0 === At[o$3] && (r$2.emplaceBack(Ct[2 * o$3 + 0], Ct[2 * o$3 + 1], t$4 * e.al / Et, i$3 * e.al / Et), At[o$3] = ++a$1), At[o$3] - 1;
							}
							function c$1(e$1, t$4, i$3, o$3, s$3, r$3) {
								const a$2 = e$1 + i$3 >> 1, h$1 = t$4 + o$3 >> 1;
								if (Math.abs(e$1 - s$3) + Math.abs(t$4 - r$3) > 1 && Rt[h$1 * St + a$2]) c$1(s$3, r$3, e$1, t$4, a$2, h$1), c$1(i$3, o$3, s$3, r$3, a$2, h$1);
								else {
									const a$3 = l$1(e$1, t$4), c$2 = l$1(i$3, o$3), h$2 = l$1(s$3, r$3);
									n$1.emplaceBack(a$3, c$2, h$2);
								}
							}
							return c$1(0, 0, Et, Et, Et, 0), c$1(Et, Et, 0, 0, 0, Et), {
								vertices: r$2,
								indices: n$1
							};
						}(this.tileID.canonical, i$1);
						s$1 = t$2.vertices, r$1 = t$2.indices;
					} else {
						s$1 = new e.b1(), r$1 = new e.b0();
						for (const { x: e$1, y: t$3 } of o$1) s$1.emplaceBack(e$1, t$3, 0, 0);
						const t$2 = e.bh(s$1.int16.subarray(0, 4 * s$1.length), void 0, 4);
						for (let e$1 = 0; e$1 < t$2.length; e$1 += 3) r$1.emplaceBack(t$2[e$1], t$2[e$1 + 1], t$2[e$1 + 2]);
					}
					this._tileBoundsBuffer = t$1.createVertexBuffer(s$1, e.bi.members), this._tileBoundsIndexBuffer = t$1.createIndexBuffer(r$1), this._tileBoundsSegments = e.bg.simpleSegment(0, 0, s$1.length, r$1.length);
				}
				_makeGlobeTileDebugBuffers(t$1, i$1) {
					const o$1 = i$1.projection;
					if (!o$1 || "globe" !== o$1.name || i$1.freezeTileCoverage) return;
					const s$1 = this.tileID.canonical, r$1 = e.bj(s$1, i$1), n$1 = e.bk(r$1), a$1 = e.aj(i$1.zoom);
					let l$1;
					a$1 > 0 && (l$1 = e.bl(new Float64Array(16), i$1.globeMatrix)), this._makeGlobeTileDebugBorderBuffer(t$1, s$1, i$1, n$1, l$1, a$1), this._makeGlobeTileDebugTextBuffer(t$1, s$1, i$1, n$1, l$1, a$1);
				}
				_globePoint(t$1, i$1, o$1, s$1, r$1, n$1, a$1) {
					let l$1 = e.bm(t$1, i$1, o$1);
					if (n$1) {
						const r$2 = 1 << o$1.z, c$1 = e.aF(s$1.center.lng), h$1 = e.aJ(s$1.center.lat), d$1 = (o$1.x + .5) / r$2 - c$1;
						let u$1 = 0;
						d$1 > .5 ? u$1 = -1 : d$1 < -.5 && (u$1 = 1);
						let _$1 = (t$1 / e.al + o$1.x) / r$2 + u$1, p$1 = (i$1 / e.al + o$1.y) / r$2;
						_$1 = (_$1 - c$1) * s$1._pixelsPerMercatorPixel + c$1, p$1 = (p$1 - h$1) * s$1._pixelsPerMercatorPixel + h$1;
						const f$1 = [
							_$1 * s$1.worldSize,
							p$1 * s$1.worldSize,
							0
						];
						e.af(f$1, f$1, n$1), l$1 = e.bn(l$1, f$1, a$1);
					}
					return e.af(l$1, l$1, r$1);
				}
				_makeGlobeTileDebugBorderBuffer(t$1, i$1, o$1, s$1, r$1, n$1) {
					const a$1 = new e.bd(), l$1 = new e.be(), c$1 = new e.bo(), h$1 = (e$1, t$2, h$2, d$2, u$1) => {
						const _$1 = (h$2 - e$1) / (u$1 - 1), p$1 = (d$2 - t$2) / (u$1 - 1), f$1 = a$1.length;
						for (let h$3 = 0; h$3 < u$1; h$3++) {
							const d$3 = e$1 + h$3 * _$1, u$2 = t$2 + h$3 * p$1;
							a$1.emplaceBack(d$3, u$2);
							const m$1 = this._globePoint(d$3, u$2, i$1, o$1, s$1, r$1, n$1);
							c$1.emplaceBack(m$1[0], m$1[1], m$1[2]), l$1.emplaceBack(f$1 + h$3);
						}
					}, d$1 = e.al;
					h$1(0, 0, d$1, 0, 16), h$1(d$1, 0, d$1, d$1, 16), h$1(d$1, d$1, 0, d$1, 16), h$1(0, d$1, 0, 0, 16), this._tileDebugIndexBuffer = t$1.createIndexBuffer(l$1), this._tileDebugBuffer = t$1.createVertexBuffer(a$1, e.bf.members), this._globeTileDebugBorderBuffer = t$1.createVertexBuffer(c$1, e.bp.members), this._tileDebugSegments = e.bg.simpleSegment(0, 0, a$1.length, l$1.length);
				}
				_makeGlobeTileDebugTextBuffer(t$1, i$1, o$1, s$1, r$1, n$1) {
					const a$1 = e.al / 4, l$1 = new e.bd(), c$1 = new e.b0(), h$1 = new e.bo(), d$1 = 25;
					c$1.reserve(32), l$1.reserve(d$1), h$1.reserve(d$1);
					const u$1 = (e$1, t$2) => d$1 * e$1 + t$2;
					for (let e$1 = 0; e$1 < d$1; e$1++) {
						const t$2 = e$1 * a$1;
						for (let e$2 = 0; e$2 < d$1; e$2++) {
							const c$2 = e$2 * a$1;
							l$1.emplaceBack(c$2, t$2);
							const d$2 = this._globePoint(c$2, t$2, i$1, o$1, s$1, r$1, n$1);
							h$1.emplaceBack(d$2[0], d$2[1], d$2[2]);
						}
					}
					for (let e$1 = 0; e$1 < 4; e$1++) for (let t$2 = 0; t$2 < 4; t$2++) {
						const i$2 = u$1(e$1, t$2), o$2 = u$1(e$1, t$2 + 1), s$2 = u$1(e$1 + 1, t$2), r$2 = u$1(e$1 + 1, t$2 + 1);
						c$1.emplaceBack(i$2, o$2, s$2), c$1.emplaceBack(s$2, o$2, r$2);
					}
					this._tileDebugTextIndexBuffer = t$1.createIndexBuffer(c$1), this._tileDebugTextBuffer = t$1.createVertexBuffer(l$1, e.bf.members), this._globeTileDebugTextBuffer = t$1.createVertexBuffer(h$1, e.bp.members), this._tileDebugTextSegments = e.bg.simpleSegment(0, 0, d$1, 32);
				}
				destroy(t$1 = !0) {
					for (const e$1 in this.buckets) this.buckets[e$1].destroy(t$1);
					this.buckets = {}, this.imageAtlas && (this.imageAtlas = null), this.lineAtlas && (this.lineAtlas = null), this.imageAtlasTexture && (this.imageAtlasTexture.destroy(), delete this.imageAtlasTexture), this.glyphAtlasTexture && (this.glyphAtlasTexture.destroy(), delete this.glyphAtlasTexture), this.lineAtlasTexture && (this.lineAtlasTexture.destroy(), delete this.lineAtlasTexture), this._tileBoundsBuffer && (this._tileBoundsBuffer.destroy(), this._tileBoundsIndexBuffer.destroy(), this._tileBoundsSegments.destroy(), this._tileBoundsBuffer = null), this._tileDebugBuffer && (this._tileDebugBuffer.destroy(), this._tileDebugSegments.destroy(), this._tileDebugBuffer = null), this._tileDebugIndexBuffer && (this._tileDebugIndexBuffer.destroy(), this._tileDebugIndexBuffer = null), this._globeTileDebugBorderBuffer && (this._globeTileDebugBorderBuffer.destroy(), this._globeTileDebugBorderBuffer = null), this._tileDebugTextBuffer && (this._tileDebugTextBuffer.destroy(), this._tileDebugTextSegments.destroy(), this._tileDebugTextIndexBuffer.destroy(), this._tileDebugTextBuffer = null), this._globeTileDebugTextBuffer && (this._globeTileDebugTextBuffer.destroy(), this._globeTileDebugTextBuffer = null), t$1 && this.texture && this.texture instanceof e.T && (this.texture.destroy(), delete this.texture), this.emissiveTexture && this.emissiveTexture instanceof e.T && (this.emissiveTexture.destroy(), delete this.emissiveTexture), this.hillshadeFBO && (this.hillshadeFBO.destroy(), delete this.hillshadeFBO), this.dem && delete this.dem, this.neighboringTiles && delete this.neighboringTiles, this.demTexture && (this.demTexture.destroy(), delete this.demTexture), this.rasterParticleState && (this.rasterParticleState.destroy(), delete this.rasterParticleState), this.latestFeatureIndex = null, this.state = "unloaded";
				}
			}
			e.bs.setPbf(e.bt);
			class Ot extends Pt {
				constructor(e$1, t$1, i$1, o$1, s$1) {
					super(e$1, t$1, i$1, o$1, s$1), this._workQueuePerLayer = /* @__PURE__ */ new Map(), this._fetchQueuePerLayer = /* @__PURE__ */ new Map(), this._taskQueue = /* @__PURE__ */ new Map(), this._isHeaderLoaded = !1, this.textureDescriptorPerLayer = /* @__PURE__ */ new Map(), this.texturePerLayer = /* @__PURE__ */ new Map();
				}
				getLayers() {
					return this._mrt ? Object.values(this._mrt.layers) : [];
				}
				getLayer(e$1) {
					return this._mrt && this._mrt.getLayer(e$1);
				}
				setTexturePerLayer(t$1, i$1, o$1) {
					const s$1 = o$1.context, r$1 = s$1.gl;
					let n$1 = this.texturePerLayer.get(t$1) || o$1.getTileTexture(i$1.width);
					n$1 && n$1 instanceof e.T ? n$1.update(i$1, { premultiply: !1 }) : n$1 = new e.T(s$1, i$1, r$1.RGBA8, { premultiply: !1 }), this.texturePerLayer.has(t$1) || this.texturePerLayer.set(t$1, n$1);
				}
				flushQueues(e$1) {
					const t$1 = this._workQueuePerLayer.get(e$1) || [], i$1 = this._fetchQueuePerLayer.get(e$1) || [];
					for (; t$1.length;) t$1.pop()();
					for (; i$1.length;) i$1.pop()();
				}
				flushAllQueues() {
					for (const e$1 of this._workQueuePerLayer.keys()) {
						const t$1 = this._workQueuePerLayer.get(e$1) || [];
						for (; t$1.length;) t$1.pop()();
					}
					for (const e$1 of this._fetchQueuePerLayer.keys()) {
						const t$1 = this._fetchQueuePerLayer.get(e$1) || [];
						for (; t$1.length;) t$1.pop()();
					}
				}
				fetchHeader(t$1 = 16384, i$1) {
					const o$1 = this._mrt = new e.bs(30), s$1 = Object.assign({}, this.requestParams, { headers: { Range: "bytes=0-" + (t$1 - 1) } });
					return this.entireBuffer = null, this.request = e.bu(s$1, ((e$1, s$2, r$1) => {
						if (e$1) i$1(e$1);
						else try {
							const e$2 = o$1.getHeaderLength(s$2);
							if (e$2 > t$1) return void (this.request = this.fetchHeader(e$2, i$1));
							o$1.parseHeader(s$2), this._isHeaderLoaded = !0;
							let n$1 = 0;
							for (const e$3 of Object.values(o$1.layers)) n$1 = Math.max(n$1, e$3.dataIndex[e$3.dataIndex.length - 1].lastByte);
							s$2.byteLength >= n$1 && (this.entireBuffer = s$2), i$1(null, this.entireBuffer || s$2, r$1);
						} catch (e$2) {
							i$1(e$2);
						}
					})), this.request;
				}
				fetchBandForRender(e$1, t$1, i$1, o$1) {
					this.fetchBand(e$1, t$1, i$1, ((s$1) => {
						if (s$1) return void o$1(s$1);
						this.updateTextureDescriptor(e$1, t$1, i$1);
						const r$1 = this.textureDescriptorPerLayer.get(t$1);
						o$1(null, r$1 ? r$1.img : null);
					}));
				}
				fetchBand(t$1, i$1, o$1, s$1, r$1 = !0) {
					const n$1 = this._mrt;
					if (!this._isHeaderLoaded || !n$1) return void s$1(/* @__PURE__ */ new Error("Tile header is not ready"));
					const a$1 = this.actor;
					if (!a$1) return void s$1(/* @__PURE__ */ new Error("Can't fetch tile band without an actor"));
					let l$1;
					const c$1 = e.B(String(o$1), e.B(this.tileID.key, t$1));
					let h$1 = this._taskQueue.get(c$1);
					h$1 ? h$1.add(s$1) : (h$1 = /* @__PURE__ */ new Set(), h$1.add(s$1), this._taskQueue.set(c$1, h$1));
					const d$1 = (e$1, t$2) => {
						l$1.complete(e$1, t$2), e$1 ? s$1(e$1) : (h$1.forEach(((e$2) => e$2(null, t$2))), this._taskQueue.delete(c$1));
					}, u$1 = (e$1, t$2) => {
						if (e$1) return s$1(e$1);
						const o$2 = a$1.send("decodeRasterArray", {
							type: "raster-array",
							source: this.source,
							scope: this.scope,
							tileID: this.tileID,
							uid: this.uid,
							buffer: t$2,
							task: l$1
						}, d$1, void 0, !0);
						if (null !== i$1) {
							const e$2 = this._workQueuePerLayer.get(i$1) || [];
							e$2.push((() => {
								o$2 && o$2.cancel(), l$1.cancel();
							})), this._workQueuePerLayer.has(i$1) || this._workQueuePerLayer.set(i$1, e$2);
						}
					};
					let _$1;
					try {
						_$1 = n$1.getLayer(t$1);
					} catch (e$1) {
						if ("reloading" === this.state) return;
						throw e$1;
					}
					if (!_$1) return void s$1(/* @__PURE__ */ new Error(`Unknown sourceLayer "${t$1}"`));
					if (_$1.hasDataForBand(o$1)) return h$1.forEach(((e$1) => e$1(null, null))), void this._taskQueue.delete(c$1);
					const p$1 = _$1.getDataRange([o$1]);
					if (l$1 = n$1.createDecodingTask(p$1), !l$1 || l$1.tasks.length) if (null !== i$1 && this.flushQueues(i$1), this.entireBuffer) u$1(null, this.entireBuffer.slice(p$1.firstByte, p$1.lastByte + 1));
					else {
						const t$2 = Object.assign({}, this.requestParams, { headers: { Range: `bytes=${p$1.firstByte}-${p$1.lastByte}` } }), o$2 = e.bu(t$2, u$1);
						if (null !== i$1) {
							const e$1 = this._fetchQueuePerLayer.get(i$1) || [];
							e$1.push((() => {
								o$2.cancel(), l$1.cancel();
							})), this._fetchQueuePerLayer.has(i$1) || this._fetchQueuePerLayer.set(i$1, e$1);
						}
					}
				}
				updateNeeded(e$1, t$1) {
					return (!this.textureDescriptorPerLayer.get(e$1) || this.textureDescriptorPerLayer.get(e$1).band !== t$1 || this.refreshedUponExpiration) && "errored" !== this.state;
				}
				updateTextureDescriptor(t$1, i$1, o$1) {
					if (!this._mrt) return;
					const s$1 = this._mrt.getLayer(t$1);
					if (!s$1 || !s$1.hasBand(o$1) || !s$1.hasDataForBand(o$1)) return;
					const { bytes: r$1, tileSize: n$1, buffer: a$1, offset: l$1, scale: c$1 } = s$1.getBandView(o$1), h$1 = n$1 + 2 * a$1, d$1 = new e.q({
						width: h$1,
						height: h$1
					}, r$1), u$1 = this.texturePerLayer.get(i$1);
					u$1 && u$1 instanceof e.T && u$1.update(d$1, { premultiply: !1 }), this.textureDescriptorPerLayer.set(i$1, {
						layer: t$1,
						band: o$1,
						img: d$1,
						buffer: a$1,
						offset: l$1,
						tileSize: n$1,
						format: s$1.pixelFormat,
						mix: [
							c$1,
							256 * c$1,
							65536 * c$1,
							16777216 * c$1
						]
					});
				}
				destroy(t$1 = !1) {
					if (super.destroy(t$1), delete this._mrt, !t$1) for (const t$2 of this.texturePerLayer.values()) t$2 && t$2 instanceof e.T && t$2.destroy();
					this.texturePerLayer.clear(), this.textureDescriptorPerLayer.clear(), this.fbo && (this.fbo.destroy(), delete this.fbo), delete this.request, delete this.requestParams, this._isHeaderLoaded = !1;
				}
			}
			class zt {
				constructor(e$1, t$1) {
					this.max = e$1, this.onRemove = t$1, this.reset();
				}
				reset() {
					for (const e$1 in this.data) for (const t$1 of this.data[e$1]) t$1.timeout && clearTimeout(t$1.timeout), this.onRemove(t$1.value);
					return this.data = {}, this.order = [], this;
				}
				add(e$1, t$1, i$1) {
					const o$1 = e$1.wrapped().key;
					void 0 === this.data[o$1] && (this.data[o$1] = []);
					const s$1 = {
						value: t$1,
						timeout: void 0
					};
					if (void 0 !== i$1 && (s$1.timeout = setTimeout((() => {
						this.remove(e$1, s$1);
					}), i$1)), this.data[o$1].push(s$1), this.order.push(o$1), this.order.length > this.max) {
						const e$2 = this._getAndRemoveByKey(this.order[0]);
						e$2 && this.onRemove(e$2);
					}
					return this;
				}
				has(e$1) {
					return e$1.wrapped().key in this.data;
				}
				getAndRemove(e$1) {
					return this.has(e$1) ? this._getAndRemoveByKey(e$1.wrapped().key) : null;
				}
				_getAndRemoveByKey(e$1) {
					const t$1 = this.data[e$1].shift();
					return t$1.timeout && clearTimeout(t$1.timeout), 0 === this.data[e$1].length && delete this.data[e$1], this.order.splice(this.order.indexOf(e$1), 1), t$1.value;
				}
				getByKey(e$1) {
					const t$1 = this.data[e$1];
					return t$1 ? t$1[0].value : null;
				}
				get(e$1) {
					return this.has(e$1) ? this.data[e$1.wrapped().key][0].value : null;
				}
				remove(e$1, t$1) {
					if (!this.has(e$1)) return this;
					const i$1 = e$1.wrapped().key, o$1 = void 0 === t$1 ? 0 : this.data[i$1].indexOf(t$1), s$1 = this.data[i$1][o$1];
					return this.data[i$1].splice(o$1, 1), s$1.timeout && clearTimeout(s$1.timeout), 0 === this.data[i$1].length && delete this.data[i$1], this.onRemove(s$1.value), this.order.splice(this.order.indexOf(i$1), 1), this;
				}
				setMaxSize(e$1) {
					for (this.max = e$1; this.order.length > this.max;) {
						const e$2 = this._getAndRemoveByKey(this.order[0]);
						e$2 && this.onRemove(e$2);
					}
					return this;
				}
				filter(e$1) {
					const t$1 = [];
					for (const i$1 in this.data) for (const o$1 of this.data[i$1]) e$1(o$1.value) || t$1.push(o$1);
					for (const e$2 of t$1) this.remove(e$2.value.tileID, e$2);
				}
			}
			class Mt {
				constructor() {
					this.state = {}, this.stateChanges = {}, this.deletedStates = {};
				}
				updateState(e$1, t$1, i$1) {
					const o$1 = String(t$1);
					if (this.stateChanges[e$1] = this.stateChanges[e$1] || {}, this.stateChanges[e$1][o$1] = this.stateChanges[e$1][o$1] || {}, Object.assign(this.stateChanges[e$1][o$1], i$1), null === this.deletedStates[e$1]) {
						this.deletedStates[e$1] = {};
						for (const t$2 in this.state[e$1]) t$2 !== o$1 && (this.deletedStates[e$1][t$2] = null);
					} else if (this.deletedStates[e$1] && null === this.deletedStates[e$1][o$1]) {
						this.deletedStates[e$1][o$1] = {};
						for (const t$2 in this.state[e$1][o$1]) i$1[t$2] || (this.deletedStates[e$1][o$1][t$2] = null);
					} else for (const t$2 in i$1) this.deletedStates[e$1] && this.deletedStates[e$1][o$1] && null === this.deletedStates[e$1][o$1][t$2] && delete this.deletedStates[e$1][o$1][t$2];
				}
				removeFeatureState(e$1, t$1, i$1) {
					if (null === this.deletedStates[e$1]) return;
					const o$1 = String(t$1);
					if (this.deletedStates[e$1] = this.deletedStates[e$1] || {}, i$1 && void 0 !== t$1) null !== this.deletedStates[e$1][o$1] && (this.deletedStates[e$1][o$1] = this.deletedStates[e$1][o$1] || {}, this.deletedStates[e$1][o$1][i$1] = null);
					else if (void 0 !== t$1) if (this.stateChanges[e$1] && this.stateChanges[e$1][o$1]) for (i$1 in this.deletedStates[e$1][o$1] = {}, this.stateChanges[e$1][o$1]) this.deletedStates[e$1][o$1][i$1] = null;
					else this.deletedStates[e$1][o$1] = null;
					else this.deletedStates[e$1] = null;
				}
				getState(e$1, t$1) {
					const i$1 = this.state[e$1] || {}, o$1 = this.stateChanges[e$1] || {}, s$1 = this.deletedStates[e$1];
					if (null === s$1) return {};
					if (void 0 !== t$1) {
						const e$2 = String(t$1), r$2 = Object.assign({}, i$1[e$2], o$1[e$2]);
						if (s$1) {
							const e$3 = s$1[t$1];
							if (null === e$3) return {};
							for (const t$2 in e$3) delete r$2[t$2];
						}
						return r$2;
					}
					const r$1 = Object.assign({}, i$1, o$1);
					if (s$1) for (const e$2 in s$1) delete r$1[e$2];
					return r$1;
				}
				initializeTileState(e$1, t$1) {
					e$1.refreshFeatureState(t$1);
				}
				coalesceChanges(e$1, t$1) {
					const i$1 = {};
					for (const e$2 in this.stateChanges) {
						this.state[e$2] = this.state[e$2] || {};
						const t$2 = {};
						for (const i$2 in this.stateChanges[e$2]) this.state[e$2][i$2] || (this.state[e$2][i$2] = {}), Object.assign(this.state[e$2][i$2], this.stateChanges[e$2][i$2]), t$2[i$2] = this.state[e$2][i$2];
						i$1[e$2] = t$2;
					}
					for (const e$2 in this.deletedStates) {
						this.state[e$2] = this.state[e$2] || {};
						const t$2 = {};
						if (null === this.deletedStates[e$2]) for (const i$2 in this.state[e$2]) t$2[i$2] = {}, this.state[e$2][i$2] = {};
						else for (const i$2 in this.deletedStates[e$2]) {
							if (null === this.deletedStates[e$2][i$2]) this.state[e$2][i$2] = {};
							else if (this.state[e$2][i$2]) for (const t$3 of Object.keys(this.deletedStates[e$2][i$2])) delete this.state[e$2][i$2][t$3];
							t$2[i$2] = this.state[e$2][i$2];
						}
						i$1[e$2] = i$1[e$2] || {}, Object.assign(i$1[e$2], t$2);
					}
					if (this.stateChanges = {}, this.deletedStates = {}, 0 !== Object.keys(i$1).length) for (const i$2 in e$1) e$1[i$2].refreshFeatureState(t$1);
				}
			}
			class Ft extends e.E {
				constructor(e$1, t$1, i$1) {
					super(), this.id = e$1, this._onlySymbols = i$1, t$1.on("data", ((e$2) => {
						"source" === e$2.dataType && "metadata" === e$2.sourceDataType && (this._sourceLoaded = !0), this._sourceLoaded && !this._paused && "source" === e$2.dataType && "content" === e$2.sourceDataType && (this.reload(), this.transform && this.update(this.transform));
					})), t$1.on("error", (() => {
						this._sourceErrored = !0;
					})), this._source = t$1, this._tiles = {}, this._cache = new zt(0, this._unloadTile.bind(this)), this._timers = {}, this._cacheTimers = {}, this._minTileCacheSize = t$1.minTileCacheSize, this._maxTileCacheSize = t$1.maxTileCacheSize, this._loadedParentTiles = {}, this.castsShadows = !1, this.tileCoverLift = 0, this._coveredTiles = {}, this._shadowCasterTiles = {}, this._state = new Mt(), this._isRaster = "raster" === this._source.type || "raster-dem" === this._source.type || "raster-array" === this._source.type || "custom" === this._source.type && "raster" === this._source._dataType;
				}
				onAdd(e$1) {
					this.map = e$1, this._minTileCacheSize = void 0 === this._minTileCacheSize && e$1 ? e$1._minTileCacheSize : this._minTileCacheSize, this._maxTileCacheSize = void 0 === this._maxTileCacheSize && e$1 ? e$1._maxTileCacheSize : this._maxTileCacheSize;
				}
				loaded() {
					if (this._sourceErrored) return !0;
					if (!this._sourceLoaded) return !1;
					if (!this._source.loaded()) return !1;
					for (const e$1 in this._tiles) if (!this._tiles[e$1].loaded()) return !1;
					return !0;
				}
				getSource() {
					return this._source;
				}
				pause() {
					this._paused = !0;
				}
				resume() {
					if (!this._paused) return;
					const e$1 = this._shouldReloadOnResume;
					this._paused = !1, this._shouldReloadOnResume = !1, e$1 && this.reload(), this.transform && this.update(this.transform);
				}
				_loadTile(e$1, t$1) {
					return e$1.isSymbolTile = this._onlySymbols, e$1.isExtraShadowCaster = this._shadowCasterTiles[e$1.tileID.key], this._source.loadTile(e$1, t$1);
				}
				_unloadTile(e$1) {
					if (this._source.unloadTile) return this._source.unloadTile(e$1);
				}
				_abortTile(e$1) {
					if (this._source.abortTile) return this._source.abortTile(e$1);
				}
				serialize() {
					return this._source.serialize();
				}
				prepare(e$1) {
					this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
					for (const t$1 in this._tiles) {
						const i$1 = this._tiles[t$1];
						i$1.upload(e$1, this.map ? this.map.painter : void 0), i$1.prepare(this.map.style.imageManager, this.map ? this.map.painter : null, this._source.scope);
					}
				}
				getIds() {
					return Object.values(this._tiles).map(((e$1) => e$1.tileID)).sort(Bt).map(((e$1) => e$1.key));
				}
				getRenderableIds(t$1, i$1) {
					const o$1 = [];
					for (const e$1 in this._tiles) this._isIdRenderable(+e$1, t$1, i$1) && o$1.push(this._tiles[e$1]);
					return t$1 ? o$1.sort(((t$2, i$2) => {
						const o$2 = t$2.tileID, s$1 = i$2.tileID, r$1 = new e.P(o$2.canonical.x, o$2.canonical.y)._rotate(this.transform.angle), n$1 = new e.P(s$1.canonical.x, s$1.canonical.y)._rotate(this.transform.angle);
						return o$2.overscaledZ - s$1.overscaledZ || n$1.y - r$1.y || n$1.x - r$1.x;
					})).map(((e$1) => e$1.tileID.key)) : o$1.map(((e$1) => e$1.tileID)).sort(Bt).map(((e$1) => e$1.key));
				}
				hasRenderableParent(e$1) {
					const t$1 = this.findLoadedParent(e$1, 0);
					return !!t$1 && this._isIdRenderable(t$1.tileID.key);
				}
				_isIdRenderable(e$1, t$1, i$1) {
					return this._tiles[e$1] && this._tiles[e$1].hasData() && !this._coveredTiles[e$1] && (t$1 || !this._tiles[e$1].holdingForFade()) && (i$1 || !this._shadowCasterTiles[e$1]);
				}
				reload() {
					if (this._paused) this._shouldReloadOnResume = !0;
					else {
						this._cache.reset();
						for (const e$1 in this._tiles) "errored" !== this._tiles[e$1].state && this._reloadTile(+e$1, "reloading");
					}
				}
				_reloadTile(e$1, t$1) {
					const i$1 = this._tiles[e$1];
					i$1 && ("loading" !== i$1.state && (i$1.state = t$1), this._loadTile(i$1, this._tileLoaded.bind(this, i$1, e$1, t$1)));
				}
				_tileLoaded(t$1, i$1, o$1, s$1, r$1) {
					if (s$1) {
						if (t$1.state = "errored", 404 !== s$1.status) this._source.fire(new e.y(s$1, { tile: t$1 }));
						else {
							if (this._source.fire(new e.z("data", {
								dataType: "source",
								sourceDataType: "error",
								sourceId: this._source.id,
								tile: t$1
							})), !(t$1.tileID.key in this._loadedParentTiles)) return;
							if ("raster-dem" === this._source.type && this.usedForTerrain && this.map.painter.terrain) {
								const e$1 = this.map.painter.terrain;
								this.update(this.transform, e$1.getScaledDemTileSize(), !0), e$1.resetTileLookupCache(this.id);
							} else this.update(this.transform);
						}
						return;
					}
					t$1.timeAdded = e.o.now(), "expired" === o$1 && (t$1.refreshedUponExpiration = !0), this._setTileReloadTimer(i$1, t$1), "raster-dem" === this._source.type && t$1.dem && this._backfillDEM(t$1), this._state.initializeTileState(t$1, this.map ? this.map.painter : null);
					let n$1 = /* @__PURE__ */ new Map();
					r$1 && r$1.responseHeaders && (n$1 = r$1.responseHeaders), this._source.fire(new e.z("data", {
						dataType: "source",
						tile: t$1,
						coord: t$1.tileID,
						sourceCacheId: this.id,
						responseHeaders: n$1
					}));
				}
				_backfillDEM(e$1) {
					const t$1 = this.getRenderableIds();
					for (let o$1 = 0; o$1 < t$1.length; o$1++) {
						const s$1 = t$1[o$1];
						if (e$1.neighboringTiles && e$1.neighboringTiles[s$1]) {
							const t$2 = this.getTileByID(s$1);
							i$1(e$1, t$2), i$1(t$2, e$1);
						}
					}
					function i$1(e$2, t$2) {
						if (!e$2.dem || e$2.dem.borderReady) return;
						e$2.needsHillshadePrepare = !0, e$2.needsDEMTextureUpload = !0;
						let i$2 = t$2.tileID.canonical.x - e$2.tileID.canonical.x;
						const o$1 = t$2.tileID.canonical.y - e$2.tileID.canonical.y, s$1 = Math.pow(2, e$2.tileID.canonical.z), r$1 = t$2.tileID.key;
						0 === i$2 && 0 === o$1 || Math.abs(o$1) > 1 || (Math.abs(i$2) > 1 && (1 === Math.abs(i$2 + s$1) ? i$2 += s$1 : 1 === Math.abs(i$2 - s$1) && (i$2 -= s$1)), t$2.dem && e$2.dem && (e$2.dem.backfillBorder(t$2.dem, i$2, o$1), e$2.neighboringTiles && e$2.neighboringTiles[r$1] && (e$2.neighboringTiles[r$1].backfilled = !0)));
					}
				}
				getTile(e$1) {
					return this.getTileByID(e$1.key);
				}
				getTileByID(e$1) {
					return this._tiles[e$1];
				}
				_retainLoadedChildren(e$1, t$1, i$1, o$1) {
					for (const s$1 in this._tiles) {
						let r$1 = this._tiles[s$1];
						if (o$1[s$1] || !r$1.hasData() || r$1.tileID.overscaledZ <= t$1 || r$1.tileID.overscaledZ > i$1) continue;
						let n$1 = r$1.tileID;
						for (; r$1 && r$1.tileID.overscaledZ > t$1 + 1;) {
							const e$2 = r$1.tileID.scaledTo(r$1.tileID.overscaledZ - 1);
							r$1 = this._tiles[e$2.key], r$1 && r$1.hasData() && (n$1 = e$2);
						}
						let a$1 = n$1;
						for (; a$1.overscaledZ > t$1;) if (a$1 = a$1.scaledTo(a$1.overscaledZ - 1), e$1[a$1.key]) {
							o$1[n$1.key] = n$1;
							break;
						}
					}
				}
				findLoadedParent(e$1, t$1) {
					if (e$1.key in this._loadedParentTiles) {
						const i$1 = this._loadedParentTiles[e$1.key];
						return i$1 && i$1.tileID.overscaledZ >= t$1 ? i$1 : null;
					}
					for (let i$1 = e$1.overscaledZ - 1; i$1 >= t$1; i$1--) {
						const t$2 = e$1.scaledTo(i$1), o$1 = this._getLoadedTile(t$2);
						if (o$1) return o$1;
					}
				}
				_getLoadedTile(e$1) {
					const t$1 = this._tiles[e$1.key];
					return t$1 && t$1.hasData() ? t$1 : this._cache.getByKey(this._source.reparseOverscaled ? e$1.wrapped().key : e$1.canonical.key);
				}
				updateCacheSize(e$1, t$1) {
					t$1 = t$1 || this._source.tileSize;
					const i$1 = Math.ceil(e$1.width / t$1) + 1, o$1 = Math.ceil(e$1.height / t$1) + 1, s$1 = Math.floor(i$1 * o$1 * 5), r$1 = "number" == typeof this._minTileCacheSize ? Math.max(this._minTileCacheSize, s$1) : s$1, n$1 = "number" == typeof this._maxTileCacheSize ? Math.min(this._maxTileCacheSize, r$1) : r$1;
					this._cache.setMaxSize(n$1);
				}
				handleWrapJump(e$1) {
					const t$1 = Math.round((e$1 - (void 0 === this._prevLng ? e$1 : this._prevLng)) / 360);
					if (this._prevLng = e$1, t$1) {
						const e$2 = {};
						for (const i$1 in this._tiles) {
							const o$1 = this._tiles[i$1];
							o$1.tileID = o$1.tileID.unwrapTo(o$1.tileID.wrap + t$1), e$2[o$1.tileID.key] = o$1;
						}
						this._tiles = e$2;
						for (const e$3 in this._timers) clearTimeout(this._timers[e$3]), delete this._timers[e$3];
						for (const e$3 in this._tiles) this._setTileReloadTimer(+e$3, this._tiles[e$3]);
					}
				}
				update(t$1, i$1, o$1, s$1, r$1) {
					if (this.transform = t$1, !this._sourceLoaded || this._paused || this.transform.freezeTileCoverage) return;
					if (this.usedForTerrain && !o$1) return;
					this.updateCacheSize(t$1, i$1), "globe" !== this.transform.projection.name && this.handleWrapJump(this.transform.center.lng), this._shadowCasterTiles = {}, this._coveredTiles = {};
					const n$1 = "batched-model" === this._source.type;
					let a$1, l$1 = this._source.maxzoom;
					const c$1 = this.map && this.map.painter ? this.map.painter._terrain : null;
					if (c$1 && c$1.sourceCache === this && c$1.attenuationRange()) {
						const e$1 = c$1.attenuationRange()[0], t$2 = Math.floor(e$1) - Math.log2(c$1.getDemUpscale());
						l$1 > t$2 && (l$1 = t$2);
					}
					if (this.used || this.usedForTerrain) {
						if (this._source.tileID) a$1 = t$1.getVisibleUnwrappedCoordinates(this._source.tileID).map(((t$2) => new e.aQ(t$2.canonical.z, t$2.wrap, t$2.canonical.z, t$2.canonical.x, t$2.canonical.y)));
						else if (0 !== this.tileCoverLift) {
							const s$2 = t$1.clone();
							s$2.tileCoverLift = this.tileCoverLift, a$1 = s$2.coveringTiles({
								tileSize: i$1 || this._source.tileSize,
								minzoom: this._source.minzoom,
								maxzoom: l$1,
								roundZoom: this._source.roundZoom && !o$1,
								reparseOverscaled: this._source.reparseOverscaled,
								isTerrainDEM: this.usedForTerrain,
								calculateQuadrantVisibility: n$1
							}), this._source.minzoom <= 1 && "globe" === t$1.projection.name && (a$1.push(new e.aQ(1, 0, 1, 0, 0)), a$1.push(new e.aQ(1, 0, 1, 1, 0)), a$1.push(new e.aQ(1, 0, 1, 0, 1)), a$1.push(new e.aQ(1, 0, 1, 1, 1)));
						} else if (a$1 = t$1.coveringTiles({
							tileSize: i$1 || this._source.tileSize,
							minzoom: this._source.minzoom,
							maxzoom: l$1,
							roundZoom: this._source.roundZoom && !o$1,
							reparseOverscaled: this._source.reparseOverscaled,
							isTerrainDEM: this.usedForTerrain,
							calculateQuadrantVisibility: n$1
						}), this._source.hasTile) {
							const e$1 = this._source.hasTile.bind(this._source);
							a$1 = a$1.filter(((t$2) => e$1(t$2)));
						}
					} else a$1 = [];
					if (a$1.length > 0 && "globe" !== this.transform.projection.name && !this.usedForTerrain && !kt(this._source.type)) {
						const e$1 = t$1.coveringZoomLevel({
							tileSize: i$1 || this._source.tileSize,
							roundZoom: this._source.roundZoom && !o$1
						}), l$2 = Math.min(e$1, this._source.maxzoom);
						if (n$1) {
							const e$2 = t$1.extendTileCover(a$1, l$2);
							for (const t$2 of e$2) a$1.push(t$2);
						} else if (r$1) {
							const e$2 = t$1.extendTileCoverToNearPlane(a$1, this.transform.getFrustum(l$2), l$2);
							for (const t$2 of e$2) a$1.push(t$2);
						} else if (this.castsShadows && s$1) {
							const e$2 = t$1.extendTileCover(a$1, l$2, s$1, 16);
							for (const t$2 of e$2) this._shadowCasterTiles[t$2.key] = !0, a$1.push(t$2);
						}
					}
					const h$1 = this._updateRetainedTiles(a$1);
					if (kt(this._source.type) && 0 !== a$1.length) {
						const t$2 = {}, i$2 = {}, o$2 = Object.keys(h$1);
						for (const s$3 of o$2) {
							const o$3 = h$1[s$3], r$2 = this._tiles[s$3];
							if (!r$2 || r$2.fadeEndTime && r$2.fadeEndTime <= e.o.now()) continue;
							const n$2 = this.findLoadedParent(o$3, Math.max(o$3.overscaledZ - Ft.maxOverzooming, this._source.minzoom));
							n$2 && (this._addTile(n$2.tileID), t$2[n$2.tileID.key] = n$2.tileID), i$2[s$3] = o$3;
						}
						const s$2 = a$1[a$1.length - 1].overscaledZ;
						for (const e$1 in this._tiles) {
							const t$3 = this._tiles[e$1];
							if (h$1[e$1] || !t$3.hasData()) continue;
							let o$3 = t$3.tileID;
							for (; o$3.overscaledZ > s$2;) {
								o$3 = o$3.scaledTo(o$3.overscaledZ - 1);
								const s$3 = this._tiles[o$3.key];
								if (s$3 && s$3.hasData() && i$2[o$3.key]) {
									h$1[e$1] = t$3.tileID;
									break;
								}
							}
						}
						for (const e$1 in t$2) h$1[e$1] || (this._coveredTiles[e$1] = !0, h$1[e$1] = t$2[e$1]);
					}
					for (const e$1 in h$1) this._tiles[e$1].clearFadeHold();
					const d$1 = e.bv(this._tiles, h$1);
					for (const e$1 of d$1) {
						const t$2 = this._tiles[e$1];
						t$2.hasSymbolBuckets && !t$2.holdingForFade() ? t$2.setHoldDuration(this.map._fadeDuration) : t$2.hasSymbolBuckets && !t$2.symbolFadeFinished() || this._removeTile(+e$1);
					}
					this._updateLoadedParentTileCache(), this._onlySymbols && this._source.afterUpdate && this._source.afterUpdate();
				}
				releaseSymbolFadeTiles() {
					for (const e$1 in this._tiles) this._tiles[e$1].holdingForFade() && this._removeTile(+e$1);
				}
				_updateRetainedTiles(e$1) {
					const t$1 = {};
					if (0 === e$1.length) return t$1;
					const i$1 = {}, o$1 = e$1.reduce(((e$2, t$2) => Math.min(e$2, t$2.overscaledZ)), Infinity), s$1 = e$1[0].overscaledZ, r$1 = Math.max(s$1 - Ft.maxOverzooming, this._source.minzoom), n$1 = Math.max(s$1 + Ft.maxUnderzooming, this._source.minzoom), a$1 = {};
					for (const i$2 of e$1) {
						const e$2 = this._addTile(i$2);
						t$1[i$2.key] = i$2, e$2.hasData() || o$1 < this._source.maxzoom && (a$1[i$2.key] = i$2);
					}
					this._retainLoadedChildren(a$1, o$1, n$1, t$1);
					for (const o$2 of e$1) {
						let e$2 = this._tiles[o$2.key];
						if (e$2.hasData()) continue;
						if (o$2.canonical.z >= this._source.maxzoom) {
							const e$3 = o$2.children(this._source.maxzoom)[0], i$2 = this.getTile(e$3);
							if (i$2 && i$2.hasData()) {
								t$1[e$3.key] = e$3;
								continue;
							}
						} else {
							const e$3 = o$2.children(this._source.maxzoom);
							if (t$1[e$3[0].key] && t$1[e$3[1].key] && t$1[e$3[2].key] && t$1[e$3[3].key]) continue;
						}
						let s$2 = e$2.wasRequested();
						for (let n$2 = o$2.overscaledZ - 1; n$2 >= r$1; --n$2) {
							const r$2 = o$2.scaledTo(n$2);
							if (i$1[r$2.key]) break;
							if (i$1[r$2.key] = !0, e$2 = this.getTile(r$2), !e$2 && s$2 && (e$2 = this._addTile(r$2)), e$2 && (t$1[r$2.key] = r$2, s$2 = e$2.wasRequested(), e$2.hasData())) break;
						}
					}
					return t$1;
				}
				_updateLoadedParentTileCache() {
					this._loadedParentTiles = {};
					for (const e$1 in this._tiles) {
						const t$1 = [];
						let i$1, o$1 = this._tiles[e$1].tileID;
						for (; o$1.overscaledZ > 0;) {
							if (o$1.key in this._loadedParentTiles) {
								i$1 = this._loadedParentTiles[o$1.key];
								break;
							}
							t$1.push(o$1.key);
							const e$2 = o$1.scaledTo(o$1.overscaledZ - 1);
							if (i$1 = this._getLoadedTile(e$2), i$1) break;
							o$1 = e$2;
						}
						for (const e$2 of t$1) this._loadedParentTiles[e$2] = i$1;
					}
				}
				_addTile(t$1) {
					let i$1 = this._tiles[t$1.key];
					if (i$1) return !0 !== i$1.isExtraShadowCaster || this._shadowCasterTiles[t$1.key] || this._reloadTile(t$1.key, "reloading"), i$1;
					i$1 = this._cache.getAndRemove(t$1), i$1 && (this._setTileReloadTimer(t$1.key, i$1), i$1.tileID = t$1, this._state.initializeTileState(i$1, this.map ? this.map.painter : null), this._cacheTimers[t$1.key] && (clearTimeout(this._cacheTimers[t$1.key]), delete this._cacheTimers[t$1.key], this._setTileReloadTimer(t$1.key, i$1)));
					const o$1 = Boolean(i$1);
					if (!o$1) {
						const e$1 = this.map ? this.map.painter : null, o$2 = this._source.tileSize * t$1.overscaleFactor();
						i$1 = "raster-array" === this._source.type ? new Ot(t$1, o$2, this.transform.tileZoom, e$1, this._isRaster) : new Pt(t$1, o$2, this.transform.tileZoom, e$1, this._isRaster, this._source.worldview), this._loadTile(i$1, this._tileLoaded.bind(this, i$1, t$1.key, i$1.state));
					}
					return i$1.uses++, this._tiles[t$1.key] = i$1, o$1 || this._source.fire(new e.z("dataloading", {
						tile: i$1,
						coord: i$1.tileID,
						dataType: "source"
					})), i$1;
				}
				_setTileReloadTimer(e$1, t$1) {
					e$1 in this._timers && (clearTimeout(this._timers[e$1]), delete this._timers[e$1]);
					const i$1 = t$1.getExpiryTimeout();
					i$1 && (this._timers[e$1] = setTimeout((() => {
						this._reloadTile(e$1, "expired"), delete this._timers[e$1];
					}), i$1));
				}
				_removeTile(e$1) {
					const t$1 = this._tiles[e$1];
					t$1 && (t$1.uses--, delete this._tiles[e$1], this._timers[e$1] && (clearTimeout(this._timers[e$1]), delete this._timers[e$1]), t$1.uses > 0 || (t$1.hasData() && "reloading" !== t$1.state || "empty" === t$1.state ? this._cache.add(t$1.tileID, t$1, t$1.getExpiryTimeout()) : (t$1.aborted = !0, this._abortTile(t$1), this._unloadTile(t$1))));
				}
				clearTiles() {
					this._shouldReloadOnResume = !1, this._paused = !1;
					for (const e$1 in this._tiles) this._removeTile(+e$1);
					this._source._clear && this._source._clear(), this._cache.reset(), this.map && this.usedForTerrain && this.map.painter.terrain && this.map.painter.terrain.resetTileLookupCache(this.id);
				}
				tilesIn(t$1, i$1, o$1) {
					const s$1 = [], r$1 = this.transform;
					if (!r$1) return s$1;
					const n$1 = "globe" === r$1.projection.name, a$1 = e.aF(r$1.center.lng);
					for (const l$1 in this._tiles) {
						const c$1 = this._tiles[l$1];
						if (o$1 && c$1.clearQueryDebugViz(), c$1.holdingForFade()) continue;
						let h$1;
						if (n$1) {
							const t$2 = c$1.tileID.canonical;
							if (0 === t$2.z) {
								const i$2 = [Math.abs(e.aA(a$1, ...Nt(t$2, -1)) - a$1), Math.abs(e.aA(a$1, ...Nt(t$2, 1)) - a$1)];
								h$1 = [0, 2 * i$2.indexOf(Math.min(...i$2)) - 1];
							} else {
								const i$2 = [
									Math.abs(e.aA(a$1, ...Nt(t$2, -1)) - a$1),
									Math.abs(e.aA(a$1, ...Nt(t$2, 0)) - a$1),
									Math.abs(e.aA(a$1, ...Nt(t$2, 1)) - a$1)
								];
								h$1 = [i$2.indexOf(Math.min(...i$2)) - 1];
							}
						} else h$1 = [0];
						for (const e$1 of h$1) {
							const o$2 = t$1.containsTile(c$1, r$1, i$1, e$1);
							o$2 && s$1.push(o$2);
						}
					}
					return s$1;
				}
				getShadowCasterCoordinates() {
					return this._getRenderableCoordinates(!1, !0);
				}
				getVisibleCoordinates(e$1) {
					return this._getRenderableCoordinates(e$1);
				}
				_getRenderableCoordinates(e$1, t$1) {
					const i$1 = this.getRenderableIds(e$1, t$1).map(((e$2) => this._tiles[e$2].tileID)), o$1 = "globe" === this.transform.projection.name;
					for (const e$2 of i$1) e$2.projMatrix = this.transform.calculateProjMatrix(e$2.toUnwrapped()), e$2.expandedProjMatrix = o$1 ? this.transform.calculateProjMatrix(e$2.toUnwrapped(), !1, !0) : e$2.projMatrix;
					return i$1;
				}
				sortCoordinatesByDistance(e$1) {
					const t$1 = e$1.slice(), i$1 = this.transform._camera.position, o$1 = this.transform._camera.forward(), s$1 = {};
					for (const e$2 of t$1) {
						const t$2 = 1 / (1 << e$2.canonical.z);
						s$1[e$2.key] = ((e$2.canonical.x + .5) * t$2 + e$2.wrap - i$1[0]) * o$1[0] + ((e$2.canonical.y + .5) * t$2 - i$1[1]) * o$1[1] - i$1[2] * o$1[2];
					}
					return t$1.sort(((e$2, t$2) => s$1[e$2.key] - s$1[t$2.key])), t$1;
				}
				hasTransition() {
					if (this._source.hasTransition()) return !0;
					if (kt(this._source.type)) for (const t$1 in this._tiles) {
						const i$1 = this._tiles[t$1];
						if (void 0 !== i$1.fadeEndTime && i$1.fadeEndTime >= e.o.now()) return !0;
					}
					return !1;
				}
				setFeatureState(e$1, t$1, i$1) {
					this._state.updateState(e$1 = e$1 || "_geojsonTileLayer", t$1, i$1);
				}
				removeFeatureState(e$1, t$1, i$1) {
					this._state.removeFeatureState(e$1 = e$1 || "_geojsonTileLayer", t$1, i$1);
				}
				getFeatureState(e$1, t$1) {
					return this._state.getState(e$1 = e$1 || "_geojsonTileLayer", t$1);
				}
				setDependencies(e$1, t$1, i$1) {
					const o$1 = this._tiles[e$1];
					o$1 && o$1.setDependencies(t$1, i$1);
				}
				reloadTilesForDependencies(e$1, t$1) {
					for (const i$1 in this._tiles) this._tiles[i$1].hasDependency(e$1, t$1) && this._reloadTile(+i$1, "reloading");
					this._cache.filter(((i$1) => !i$1.hasDependency(e$1, t$1)));
				}
				_preloadTiles(t$1, i$1) {
					if (!this._sourceLoaded) {
						const e$1 = () => {
							this._sourceLoaded && (this._source.off("data", e$1), this._preloadTiles(t$1, i$1));
						};
						this._source.on("data", e$1);
						return;
					}
					const o$1 = /* @__PURE__ */ new Map(), s$1 = Array.isArray(t$1) ? t$1 : [t$1], r$1 = this.map.painter.terrain, n$1 = this.usedForTerrain && r$1 ? r$1.getScaledDemTileSize() : this._source.tileSize;
					for (const e$1 of s$1) {
						const t$2 = e$1.coveringTiles({
							tileSize: n$1,
							minzoom: this._source.minzoom,
							maxzoom: this._source.maxzoom,
							roundZoom: this._source.roundZoom && !this.usedForTerrain,
							reparseOverscaled: this._source.reparseOverscaled,
							isTerrainDEM: this.usedForTerrain
						});
						for (const e$2 of t$2) o$1.set(e$2.key, e$2);
						this.usedForTerrain && e$1.updateElevation(!1);
					}
					const a$1 = Array.from(o$1.values());
					e.bw(a$1, ((e$1, t$2) => {
						const i$2 = new Pt(e$1, this._source.tileSize * e$1.overscaleFactor(), this.transform.tileZoom, this.map.painter, this._isRaster, this._source.worldview);
						this._loadTile(i$2, ((e$2) => {
							"raster-dem" === this._source.type && i$2.dem && this._backfillDEM(i$2), t$2(e$2, i$2);
						}));
					}), i$1);
				}
			}
			function Bt(e$1, t$1) {
				const i$1 = Math.abs(2 * e$1.wrap) - +(e$1.wrap < 0), o$1 = Math.abs(2 * t$1.wrap) - +(t$1.wrap < 0);
				return e$1.overscaledZ - t$1.overscaledZ || o$1 - i$1 || t$1.canonical.y - e$1.canonical.y || t$1.canonical.x - e$1.canonical.x;
			}
			function kt(e$1) {
				return "raster" === e$1 || "image" === e$1 || "video" === e$1 || "custom" === e$1;
			}
			function Nt(e$1, t$1) {
				const i$1 = 1 << e$1.z;
				return [e$1.x / i$1 + t$1, (e$1.x + 1) / i$1 + t$1];
			}
			Ft.maxOverzooming = 10, Ft.maxUnderzooming = 3;
			class Ut {
				constructor(e$1) {
					this.style = e$1, this.layersGotHidden = !1, this.layers = [];
				}
				processLayersChanged() {
					this.layers = [];
					const e$1 = !1, t$1 = !1;
					for (const i$1 in this.style._mergedLayers) {
						const o$1 = this.style._mergedLayers[i$1];
						if ("fill-extrusion" === o$1.type || "building" === o$1.type) this.layers.push({
							layer: o$1,
							visible: e$1,
							visibilityChanged: t$1
						});
						else if ("model" === o$1.type) {
							const i$2 = this.style.getLayerSource(o$1);
							i$2 && "batched-model" === i$2.type && this.layers.push({
								layer: o$1,
								visible: e$1,
								visibilityChanged: t$1
							});
						}
					}
				}
				onNewFrame(e$1) {
					this.layersGotHidden = !1;
					for (const t$1 of this.layers) {
						const i$1 = t$1.layer;
						let o$1 = !1;
						"fill-extrusion" === i$1.type ? o$1 = !i$1.isHidden(e$1) && i$1.paint.get("fill-extrusion-opacity") > 0 : "building" === i$1.type ? o$1 = !i$1.isHidden(e$1) && i$1.paint.get("building-opacity") > 0 : "model" === i$1.type && (o$1 = !i$1.isHidden(e$1) && i$1.paint.get("model-opacity").constantOr(1) > 0), this.layersGotHidden = this.layersGotHidden || !o$1 && t$1.visible, t$1.visible = o$1;
					}
				}
				updateZOffset(e$1, t$1) {
					this.currentBuildingBuckets = [];
					for (const e$2 of this.layers) {
						const i$2 = e$2.layer, o$1 = this.style.getLayerSourceCache(i$2);
						let s$1 = 1;
						"fill-extrusion" === i$2.type ? s$1 = e$2.visible ? i$2.paint.get("fill-extrusion-vertical-scale") : 0 : "building" === i$2.type && (s$1 = e$2.visible ? i$2.paint.get("building-vertical-scale") : 0);
						let r$1 = o$1 ? o$1.getTile(t$1) : null;
						if (!r$1 && o$1) for (const e$3 in o$1._tiles) {
							const i$3 = o$1._tiles[e$3];
							if (t$1.canonical.isChildOf(i$3.tileID.canonical)) {
								r$1 = i$3;
								break;
							}
						}
						this.currentBuildingBuckets.push({
							bucket: r$1 ? r$1.getBucket(i$2) : null,
							tileID: r$1 ? r$1.tileID : t$1,
							verticalScale: s$1
						});
					}
					e$1.hasAnyZOffset = !1;
					let i$1 = !1;
					for (let o$1 = 0; o$1 < e$1.symbolInstances.length; o$1++) {
						const s$1 = e$1.symbolInstances.get(o$1), r$1 = s$1.zOffset, n$1 = this._getHeightAtTileOffset(t$1, s$1.tileAnchorX, s$1.tileAnchorY);
						s$1.zOffset = n$1 !== Number.NEGATIVE_INFINITY ? n$1 : r$1, i$1 || r$1 === s$1.zOffset || (i$1 = !0), e$1.hasAnyZOffset || 0 === s$1.zOffset || (e$1.hasAnyZOffset = !0);
					}
					i$1 && (e$1.zOffsetBuffersNeedUpload = !0, e$1.zOffsetSortDirty = !0);
				}
				_mapCoordToOverlappingTile(t$1, i$1, o$1, s$1) {
					let r$1 = i$1, n$1 = o$1;
					if (t$1.canonical.z !== s$1.canonical.z) {
						const a$1 = s$1.canonical, l$1 = 1 / (1 << t$1.canonical.z - a$1.z);
						r$1 = (i$1 + t$1.canonical.x * e.al) * l$1 - a$1.x * e.al | 0, n$1 = (o$1 + t$1.canonical.y * e.al) * l$1 - a$1.y * e.al | 0;
					}
					return {
						tileX: r$1,
						tileY: n$1
					};
				}
				_getHeightAtTileOffset(e$1, t$1, i$1) {
					let o$1, s$1;
					for (let r$1 = 0; r$1 < this.layers.length; ++r$1) {
						const n$1 = this.layers[r$1].layer;
						if ("fill-extrusion" !== n$1.type && "building" !== n$1.type) continue;
						const { bucket: a$1, tileID: l$1, verticalScale: c$1 } = this.currentBuildingBuckets[r$1];
						if (!a$1) continue;
						const { tileX: h$1, tileY: d$1 } = this._mapCoordToOverlappingTile(e$1, t$1, i$1, l$1), u$1 = a$1.getHeightAtTileCoord(h$1, d$1);
						u$1 && void 0 !== u$1.height && (u$1.hidden ? o$1 = u$1.height : s$1 = Math.max(u$1.height * c$1, s$1 || 0));
					}
					if (void 0 !== s$1) return s$1;
					for (let s$2 = 0; s$2 < this.layers.length; ++s$2) {
						const r$1 = this.layers[s$2];
						if ("model" !== r$1.layer.type || !r$1.visible) continue;
						const { bucket: n$1, tileID: a$1 } = this.currentBuildingBuckets[s$2];
						if (!n$1) continue;
						const { tileX: l$1, tileY: c$1 } = this._mapCoordToOverlappingTile(e$1, t$1, i$1, a$1), h$1 = n$1.getHeightAtTileCoord(l$1, c$1);
						if (h$1 && !h$1.hidden) return void 0 === h$1.height && void 0 !== o$1 ? Math.min(h$1.maxHeight, o$1) * h$1.verticalScale : h$1.height ? h$1.height * h$1.verticalScale : Number.NEGATIVE_INFINITY;
					}
					return this.layersGotHidden ? 0 : Number.NEGATIVE_INFINITY;
				}
			}
			function jt(t$1, i$1) {
				const o$1 = {};
				for (const e$1 in t$1) "ref" !== e$1 && (o$1[e$1] = t$1[e$1]);
				return e.bx.forEach(((e$1) => {
					e$1 in i$1 && (o$1[e$1] = i$1[e$1]);
				})), o$1;
			}
			function Gt(e$1) {
				e$1 = e$1.slice();
				const t$1 = Object.create(null);
				for (let i$1 = 0; i$1 < e$1.length; i$1++) t$1[e$1[i$1].id] = e$1[i$1];
				for (let i$1 = 0; i$1 < e$1.length; i$1++) "ref" in e$1[i$1] && (e$1[i$1] = jt(e$1[i$1], t$1[e$1[i$1].ref]));
				return e$1;
			}
			const Vt = {
				setStyle: "setStyle",
				addLayer: "addLayer",
				removeLayer: "removeLayer",
				setPaintProperty: "setPaintProperty",
				setLayoutProperty: "setLayoutProperty",
				setSlot: "setSlot",
				setFilter: "setFilter",
				addSource: "addSource",
				removeSource: "removeSource",
				setGeoJSONSourceData: "setGeoJSONSourceData",
				setLayerZoomRange: "setLayerZoomRange",
				setLayerProperty: "setLayerProperty",
				setCenter: "setCenter",
				setZoom: "setZoom",
				setBearing: "setBearing",
				setPitch: "setPitch",
				setSprite: "setSprite",
				setGlyphs: "setGlyphs",
				setTransition: "setTransition",
				setLight: "setLight",
				setTerrain: "setTerrain",
				setFog: "setFog",
				setSnow: "setSnow",
				setRain: "setRain",
				setCamera: "setCamera",
				setLights: "setLights",
				setProjection: "setProjection",
				addImport: "addImport",
				removeImport: "removeImport",
				updateImport: "updateImport",
				addIconset: "addIconset",
				removeIconset: "removeIconset"
			};
			function Ht(e$1, t$1, i$1) {
				i$1.push({
					command: Vt.addSource,
					args: [e$1, t$1[e$1]]
				});
			}
			function qt(e$1, t$1, i$1) {
				t$1.push({
					command: Vt.removeSource,
					args: [e$1]
				}), i$1[e$1] = !0;
			}
			function Zt(e$1, t$1, i$1, o$1) {
				qt(e$1, i$1, o$1), Ht(e$1, t$1, i$1);
			}
			function Wt(t$1, i$1, o$1) {
				let s$1;
				for (s$1 in t$1[o$1]) if (t$1[o$1].hasOwnProperty(s$1) && "data" !== s$1 && !e.by(t$1[o$1][s$1], i$1[o$1][s$1])) return !1;
				for (s$1 in i$1[o$1]) if (i$1[o$1].hasOwnProperty(s$1) && "data" !== s$1 && !e.by(t$1[o$1][s$1], i$1[o$1][s$1])) return !1;
				return !0;
			}
			function $t(t$1, i$1, o$1, s$1, r$1, n$1) {
				let a$1;
				for (a$1 in i$1 = i$1 || {}, t$1 = t$1 || {}) t$1.hasOwnProperty(a$1) && (e.by(t$1[a$1], i$1[a$1]) || o$1.push({
					command: n$1,
					args: [
						s$1,
						a$1,
						i$1[a$1],
						r$1
					]
				}));
				for (a$1 in i$1) i$1.hasOwnProperty(a$1) && !t$1.hasOwnProperty(a$1) && (e.by(t$1[a$1], i$1[a$1]) || o$1.push({
					command: n$1,
					args: [
						s$1,
						a$1,
						i$1[a$1],
						r$1
					]
				}));
			}
			function Xt(e$1) {
				return e$1.id;
			}
			function Yt(e$1, t$1) {
				return e$1[t$1.id] = t$1, e$1;
			}
			function Kt(t$1, i$1, o$1) {
				const s$1 = i$1.createTileMatrix(t$1, t$1.worldSize, o$1.toUnwrapped());
				return e.aB(new Float32Array(16), t$1.projMatrix, s$1);
			}
			function Jt(e$1, t$1, i$1) {
				if (t$1.projection.name === i$1.projection.name) return e$1.projMatrix;
				const o$1 = i$1.clone();
				return o$1.setProjection(t$1.projection), Kt(o$1, t$1.getProjection(), e$1);
			}
			function Qt(e$1, t$1, i$1) {
				return t$1.name === i$1.projection.name ? e$1.projMatrix : Kt(i$1, t$1, e$1);
			}
			class ei {
				constructor(e$1, t$1) {
					this.reset(e$1, t$1);
				}
				reset(e$1, t$1) {
					this.points = e$1 || [], this._distances = [0];
					for (let e$2 = 1; e$2 < this.points.length; e$2++) this._distances[e$2] = this._distances[e$2 - 1] + this.points[e$2].dist(this.points[e$2 - 1]);
					this.length = this._distances[this._distances.length - 1], this.padding = Math.min(t$1 || 0, .5 * this.length), this.paddedLength = this.length - 2 * this.padding;
				}
				lerp(t$1) {
					if (1 === this.points.length) return this.points[0];
					t$1 = e.aA(t$1, 0, 1);
					let i$1 = 1, o$1 = this._distances[i$1];
					const s$1 = t$1 * this.paddedLength + this.padding;
					for (; o$1 < s$1 && i$1 < this._distances.length;) o$1 = this._distances[++i$1];
					const r$1 = i$1 - 1, n$1 = this._distances[r$1], a$1 = o$1 - n$1, l$1 = a$1 > 0 ? (s$1 - n$1) / a$1 : 0;
					return this.points[r$1].mult(1 - l$1).add(this.points[i$1].mult(l$1));
				}
			}
			class ti {
				constructor(e$1, t$1, i$1) {
					const o$1 = this.boxCells = [], s$1 = this.circleCells = [];
					this.xCellCount = Math.ceil(e$1 / i$1), this.yCellCount = Math.ceil(t$1 / i$1);
					for (let e$2 = 0; e$2 < this.xCellCount * this.yCellCount; e$2++) o$1.push([]), s$1.push([]);
					this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = e$1, this.height = t$1, this.xScale = this.xCellCount / e$1, this.yScale = this.yCellCount / t$1, this.boxUid = 0, this.circleUid = 0;
				}
				keysLength() {
					return this.boxKeys.length + this.circleKeys.length;
				}
				insert(e$1, t$1, i$1, o$1, s$1) {
					this._forEachCell(t$1, i$1, o$1, s$1, this._insertBoxCell, this.boxUid++), this.boxKeys.push(e$1), this.bboxes.push(t$1), this.bboxes.push(i$1), this.bboxes.push(o$1), this.bboxes.push(s$1);
				}
				insertCircle(e$1, t$1, i$1, o$1) {
					this._forEachCell(t$1 - o$1, i$1 - o$1, t$1 + o$1, i$1 + o$1, this._insertCircleCell, this.circleUid++), this.circleKeys.push(e$1), this.circles.push(t$1), this.circles.push(i$1), this.circles.push(o$1);
				}
				_insertBoxCell(e$1, t$1, i$1, o$1, s$1, r$1) {
					this.boxCells[s$1].push(r$1);
				}
				_insertCircleCell(e$1, t$1, i$1, o$1, s$1, r$1) {
					this.circleCells[s$1].push(r$1);
				}
				_query(e$1, t$1, i$1, o$1, s$1, r$1) {
					if (i$1 < 0 || e$1 > this.width || o$1 < 0 || t$1 > this.height) return !s$1 && [];
					const n$1 = [];
					if (e$1 <= 0 && t$1 <= 0 && this.width <= i$1 && this.height <= o$1) {
						if (s$1) return !0;
						for (let e$2 = 0; e$2 < this.boxKeys.length; e$2++) n$1.push({
							key: this.boxKeys[e$2],
							x1: this.bboxes[4 * e$2],
							y1: this.bboxes[4 * e$2 + 1],
							x2: this.bboxes[4 * e$2 + 2],
							y2: this.bboxes[4 * e$2 + 3]
						});
						for (let e$2 = 0; e$2 < this.circleKeys.length; e$2++) {
							const t$2 = this.circles[3 * e$2], i$2 = this.circles[3 * e$2 + 1], o$2 = this.circles[3 * e$2 + 2];
							n$1.push({
								key: this.circleKeys[e$2],
								x1: t$2 - o$2,
								y1: i$2 - o$2,
								x2: t$2 + o$2,
								y2: i$2 + o$2
							});
						}
						return r$1 ? n$1.filter(r$1) : n$1;
					}
					return this._forEachCell(e$1, t$1, i$1, o$1, this._queryCell, n$1, {
						hitTest: s$1,
						seenUids: {
							box: {},
							circle: {}
						}
					}, r$1), s$1 ? n$1.length > 0 : n$1;
				}
				_queryCircle(e$1, t$1, i$1, o$1, s$1) {
					const r$1 = e$1 - i$1, n$1 = e$1 + i$1, a$1 = t$1 - i$1, l$1 = t$1 + i$1;
					if (n$1 < 0 || r$1 > this.width || l$1 < 0 || a$1 > this.height) return !o$1 && [];
					const c$1 = [];
					return this._forEachCell(r$1, a$1, n$1, l$1, this._queryCellCircle, c$1, {
						hitTest: o$1,
						circle: {
							x: e$1,
							y: t$1,
							radius: i$1
						},
						seenUids: {
							box: {},
							circle: {}
						}
					}, s$1), o$1 ? c$1.length > 0 : c$1;
				}
				query(e$1, t$1, i$1, o$1, s$1) {
					return this._query(e$1, t$1, i$1, o$1, !1, s$1);
				}
				hitTest(e$1, t$1, i$1, o$1, s$1) {
					return this._query(e$1, t$1, i$1, o$1, !0, s$1);
				}
				hitTestCircle(e$1, t$1, i$1, o$1) {
					return this._queryCircle(e$1, t$1, i$1, !0, o$1);
				}
				_queryCell(e$1, t$1, i$1, o$1, s$1, r$1, n$1, a$1) {
					const l$1 = n$1.seenUids, c$1 = this.boxCells[s$1];
					if (null !== c$1) {
						const s$2 = this.bboxes;
						for (const h$2 of c$1) if (!l$1.box[h$2]) {
							l$1.box[h$2] = !0;
							const c$2 = 4 * h$2;
							if (e$1 <= s$2[c$2 + 2] && t$1 <= s$2[c$2 + 3] && i$1 >= s$2[c$2 + 0] && o$1 >= s$2[c$2 + 1] && (!a$1 || a$1(this.boxKeys[h$2]))) {
								if (n$1.hitTest) return r$1.push(!0), !0;
								r$1.push({
									key: this.boxKeys[h$2],
									x1: s$2[c$2],
									y1: s$2[c$2 + 1],
									x2: s$2[c$2 + 2],
									y2: s$2[c$2 + 3]
								});
							}
						}
					}
					const h$1 = this.circleCells[s$1];
					if (null !== h$1) {
						const s$2 = this.circles;
						for (const c$2 of h$1) if (!l$1.circle[c$2]) {
							l$1.circle[c$2] = !0;
							const h$2 = 3 * c$2;
							if (this._circleAndRectCollide(s$2[h$2], s$2[h$2 + 1], s$2[h$2 + 2], e$1, t$1, i$1, o$1) && (!a$1 || a$1(this.circleKeys[c$2]))) {
								if (n$1.hitTest) return r$1.push(!0), !0;
								{
									const e$2 = s$2[h$2], t$2 = s$2[h$2 + 1], i$2 = s$2[h$2 + 2];
									r$1.push({
										key: this.circleKeys[c$2],
										x1: e$2 - i$2,
										y1: t$2 - i$2,
										x2: e$2 + i$2,
										y2: t$2 + i$2
									});
								}
							}
						}
					}
				}
				_queryCellCircle(e$1, t$1, i$1, o$1, s$1, r$1, n$1, a$1) {
					const l$1 = n$1.circle, c$1 = n$1.seenUids, h$1 = this.boxCells[s$1];
					if (null !== h$1) {
						const e$2 = this.bboxes;
						for (const t$2 of h$1) if (!c$1.box[t$2]) {
							c$1.box[t$2] = !0;
							const i$2 = 4 * t$2;
							if (this._circleAndRectCollide(l$1.x, l$1.y, l$1.radius, e$2[i$2 + 0], e$2[i$2 + 1], e$2[i$2 + 2], e$2[i$2 + 3]) && (!a$1 || a$1(this.boxKeys[t$2]))) return r$1.push(!0), !0;
						}
					}
					const d$1 = this.circleCells[s$1];
					if (null !== d$1) {
						const e$2 = this.circles;
						for (const t$2 of d$1) if (!c$1.circle[t$2]) {
							c$1.circle[t$2] = !0;
							const i$2 = 3 * t$2;
							if (this._circlesCollide(e$2[i$2], e$2[i$2 + 1], e$2[i$2 + 2], l$1.x, l$1.y, l$1.radius) && (!a$1 || a$1(this.circleKeys[t$2]))) return r$1.push(!0), !0;
						}
					}
				}
				_forEachCell(e$1, t$1, i$1, o$1, s$1, r$1, n$1, a$1) {
					const l$1 = this._convertToXCellCoord(e$1), c$1 = this._convertToYCellCoord(t$1), h$1 = this._convertToXCellCoord(i$1), d$1 = this._convertToYCellCoord(o$1);
					for (let u$1 = l$1; u$1 <= h$1; u$1++) for (let l$2 = c$1; l$2 <= d$1; l$2++) if (s$1.call(this, e$1, t$1, i$1, o$1, this.xCellCount * l$2 + u$1, r$1, n$1, a$1)) return;
				}
				_convertToXCellCoord(e$1) {
					return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(e$1 * this.xScale)));
				}
				_convertToYCellCoord(e$1) {
					return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(e$1 * this.yScale)));
				}
				_circlesCollide(e$1, t$1, i$1, o$1, s$1, r$1) {
					const n$1 = o$1 - e$1, a$1 = s$1 - t$1, l$1 = i$1 + r$1;
					return l$1 * l$1 > n$1 * n$1 + a$1 * a$1;
				}
				_circleAndRectCollide(e$1, t$1, i$1, o$1, s$1, r$1, n$1) {
					const a$1 = (r$1 - o$1) / 2, l$1 = Math.abs(e$1 - (o$1 + a$1));
					if (l$1 > a$1 + i$1) return !1;
					const c$1 = (n$1 - s$1) / 2, h$1 = Math.abs(t$1 - (s$1 + c$1));
					if (h$1 > c$1 + i$1) return !1;
					if (l$1 <= a$1 || h$1 <= c$1) return !0;
					const d$1 = l$1 - a$1, u$1 = h$1 - c$1;
					return d$1 * d$1 + u$1 * u$1 <= i$1 * i$1;
				}
			}
			const ii = {
				unknown: 0,
				flipRequired: 1,
				flipNotRequired: 2
			}, oi = Math.tan(85 * Math.PI / 180);
			function si(t$1, i$1, o$1, s$1, r$1, n$1, a$1) {
				const l$1 = e.bC();
				if (o$1) if ("globe" === n$1.name) {
					const t$2 = e.bD(r$1, i$1);
					e.aB(l$1, l$1, t$2);
				} else {
					const t$2 = e.bE([], a$1);
					l$1[0] = t$2[0], l$1[1] = t$2[1], l$1[4] = t$2[2], l$1[5] = t$2[3], s$1 || e.bB(l$1, l$1, r$1.angle);
				}
				else e.aB(l$1, r$1.labelPlaneMatrix, t$1);
				return l$1;
			}
			function ri(e$1, t$1, i$1, o$1, s$1, r$1, n$1) {
				const a$1 = si(e$1, t$1, i$1, o$1, s$1, r$1, n$1);
				return "globe" === r$1.name && i$1 || (a$1[2] = a$1[6] = a$1[10] = a$1[14] = 0), a$1;
			}
			function ni(t$1, i$1, o$1, s$1, r$1, n$1, a$1) {
				if (o$1) {
					if ("globe" === n$1.name) {
						const l$1 = si(t$1, i$1, o$1, s$1, r$1, n$1, a$1);
						return e.bl(l$1, l$1), e.aB(l$1, t$1, l$1), l$1;
					}
					{
						const i$2 = e.bz(t$1), o$2 = e.bA([]);
						return o$2[0] = a$1[0], o$2[1] = a$1[1], o$2[4] = a$1[2], o$2[5] = a$1[3], e.aB(i$2, i$2, o$2), s$1 || e.bB(i$2, i$2, -r$1.angle), i$2;
					}
				}
				return r$1.glCoordMatrix;
			}
			function ai(t$1, i$1, o$1, s$1) {
				const r$1 = [
					t$1,
					i$1,
					o$1,
					1
				];
				o$1 ? e.aC(r$1, r$1, s$1) : vi(r$1, r$1, s$1);
				const n$1 = r$1[3];
				return r$1[0] /= n$1, r$1[1] /= n$1, r$1[2] /= n$1, r$1;
			}
			function li(e$1, t$1) {
				return Math.min(.5 + e$1 / t$1 * .5, 1.5);
			}
			function ci(e$1, t$1) {
				const i$1 = e$1[0] / e$1[3], o$1 = e$1[1] / e$1[3];
				return i$1 >= -t$1[0] && i$1 <= t$1[0] && o$1 >= -t$1[1] && o$1 <= t$1[1];
			}
			function hi(t$1, i$1, o$1, s$1, r$1, n$1, a$1, l$1, c$1, h$1, d$1 = 1) {
				const u$1 = o$1.transform, _$1 = s$1 ? t$1.textSizeData : t$1.iconSizeData, p$1 = e.bK(_$1, o$1.transform.zoom, d$1), f$1 = "globe" === u$1.projection.name, m$1 = [256 / o$1.width * 2 + 1, 256 / o$1.height * 2 + 1], g$1 = s$1 ? t$1.text.dynamicLayoutVertexArray : t$1.icon.dynamicLayoutVertexArray;
				g$1.clear();
				let v$1 = null;
				f$1 && (v$1 = s$1 ? t$1.text.globeExtVertexArray : t$1.icon.globeExtVertexArray);
				const y$1 = t$1.lineVertexArray, x$1 = s$1 ? t$1.text.placedSymbolArray : t$1.icon.placedSymbolArray, b$1 = o$1.transform.width / o$1.transform.height;
				let w$1, T$1 = !1;
				for (let s$2 = 0; s$2 < x$1.length; s$2++) {
					const d$2 = x$1.get(s$2), { numGlyphs: f$2, writingMode: E$1 } = d$2;
					if (E$1 !== e.bL.vertical || T$1 || w$1 === e.bL.horizontal || (T$1 = !0), w$1 = E$1, (d$2.hidden || E$1 === e.bL.vertical) && !T$1) {
						gi(f$2, g$1);
						continue;
					}
					T$1 = !1;
					const S$1 = new e.P(d$2.tileAnchorX, d$2.tileAnchorY), I$1 = "road" === t$1.elevationType, C$1 = !!u$1.elevation || I$1;
					let { x: R$1, y: A$1, z: L$1 } = u$1.projection.projectTilePoint(S$1.x, S$1.y, h$1.canonical), D$1 = null;
					if (C$1) {
						const e$1 = I$1 ? t$1.getElevationFeatureForText(s$2) : null;
						D$1 = {
							getElevation: c$1,
							elevation: u$1.elevation,
							elevationFeature: e$1
						};
						const [i$2, o$2, r$2] = c$1(S$1, u$1.elevation, e$1);
						R$1 += i$2, A$1 += o$2, L$1 += r$2;
					}
					const P$1 = [
						R$1,
						A$1,
						L$1,
						1
					];
					if (e.aC(P$1, P$1, i$1), !ci(P$1, m$1)) {
						gi(f$2, g$1);
						continue;
					}
					const O$1 = P$1[3], z$1 = li(o$1.transform.getCameraToCenterDistance(u$1.projection), O$1), M$1 = e.bM(_$1, p$1, d$2), F$1 = a$1 ? M$1 / z$1 : M$1 * z$1, B$1 = ai(R$1, A$1, L$1, r$1);
					if (B$1[3] <= 0) {
						gi(f$2, g$1);
						continue;
					}
					let k$1 = {};
					const N$1 = e.an(t$1.layers[0].layout.get("text-max-angle")), U$1 = Math.cos(N$1), j$1 = a$1 ? null : D$1, G$1 = _i(d$2, F$1, !1, l$1, i$1, r$1, n$1, t$1.glyphOffsetArray, y$1, g$1, v$1, B$1, S$1, k$1, b$1, j$1, u$1.projection, h$1, a$1, U$1);
					T$1 = G$1.useVertical, j$1 && G$1.needsFlipping && (k$1 = {}), (G$1.notEnoughRoom || T$1 || G$1.needsFlipping && _i(d$2, F$1, !0, l$1, i$1, r$1, n$1, t$1.glyphOffsetArray, y$1, g$1, v$1, B$1, S$1, k$1, b$1, j$1, u$1.projection, h$1, a$1, U$1).notEnoughRoom) && gi(f$2, g$1);
				}
				s$1 ? (t$1.text.dynamicLayoutVertexBuffer.updateData(g$1), v$1 && t$1.text.globeExtVertexBuffer && t$1.text.globeExtVertexBuffer.updateData(v$1)) : (t$1.icon.dynamicLayoutVertexBuffer.updateData(g$1), v$1 && t$1.icon.globeExtVertexBuffer && t$1.icon.globeExtVertexBuffer.updateData(v$1));
			}
			function di(e$1, t$1, i$1, o$1, s$1, r$1, n$1, a$1, l$1, c$1, h$1, d$1, u$1, _$1, p$1, f$1, m$1) {
				const { lineStartIndex: g$1, glyphStartIndex: v$1, segment: y$1 } = a$1, x$1 = v$1 + a$1.numGlyphs, b$1 = g$1 + a$1.lineLength, w$1 = t$1.getoffsetX(v$1), T$1 = t$1.getoffsetX(x$1 - 1), E$1 = mi(e$1 * w$1, i$1, o$1, s$1, r$1, n$1, y$1, g$1, b$1, l$1, c$1, h$1, d$1, u$1, !0, _$1, p$1, f$1, m$1);
				if (!E$1) return null;
				const S$1 = mi(e$1 * T$1, i$1, o$1, s$1, r$1, n$1, y$1, g$1, b$1, l$1, c$1, h$1, d$1, u$1, !0, _$1, p$1, f$1, m$1);
				return S$1 ? {
					first: E$1,
					last: S$1
				} : null;
			}
			function ui(t$1, i$1, o$1, s$1) {
				return t$1 === e.bL.horizontal && Math.abs(s$1) > Math.abs(o$1) ? { useVertical: !0 } : t$1 === e.bL.vertical ? s$1 > 0 ? { needsFlipping: !0 } : null : i$1 !== ii.unknown && function(e$1, t$2) {
					return 0 === e$1 || Math.abs(t$2 / e$1) > oi;
				}(o$1, s$1) ? i$1 === ii.flipRequired ? { needsFlipping: !0 } : null : o$1 < 0 ? { needsFlipping: !0 } : null;
			}
			function _i(t$1, i$1, o$1, s$1, r$1, n$1, a$1, l$1, c$1, h$1, d$1, u$1, _$1, p$1, f$1, m$1, g$1, v$1, y$1, x$1) {
				const b$1 = i$1 / 24, w$1 = t$1.lineOffsetX * b$1, T$1 = t$1.lineOffsetY * b$1, { lineStartIndex: E$1, glyphStartIndex: S$1, numGlyphs: I$1, segment: C$1, writingMode: R$1, flipState: A$1 } = t$1, L$1 = E$1 + t$1.lineLength, D$1 = (t$2) => {
					if (d$1) {
						const [i$3, o$3, s$3] = t$2.up, r$2 = h$1.length;
						e.bN(d$1, r$2 + 0, i$3, o$3, s$3), e.bN(d$1, r$2 + 1, i$3, o$3, s$3), e.bN(d$1, r$2 + 2, i$3, o$3, s$3), e.bN(d$1, r$2 + 3, i$3, o$3, s$3);
					}
					const [i$2, o$2, s$2] = t$2.point;
					e.bO(h$1, i$2, o$2, s$2, t$2.angle);
				};
				if (I$1 > 1) {
					const e$1 = di(b$1, l$1, w$1, T$1, o$1, u$1, _$1, t$1, c$1, n$1, p$1, m$1, !1, g$1, v$1, y$1, x$1);
					if (!e$1) return { notEnoughRoom: !0 };
					if (s$1 && !o$1) {
						let [i$2, o$2, s$2] = e$1.first.point, [r$2, n$2, l$2] = e$1.last.point;
						[i$2, o$2] = ai(i$2, o$2, s$2, a$1), [r$2, n$2] = ai(r$2, n$2, l$2, a$1);
						const c$2 = ui(R$1, A$1, (r$2 - i$2) * f$1, n$2 - o$2);
						if (t$1.flipState = c$2 && c$2.needsFlipping ? ii.flipRequired : ii.flipNotRequired, c$2) return c$2;
					}
					D$1(e$1.first);
					for (let e$2 = S$1 + 1; e$2 < S$1 + I$1 - 1; e$2++) {
						const t$2 = mi(b$1 * l$1.getoffsetX(e$2), w$1, T$1, o$1, u$1, _$1, C$1, E$1, L$1, c$1, n$1, p$1, m$1, !1, !1, g$1, v$1, y$1, x$1);
						if (!t$2) return h$1.length -= 4 * (e$2 - S$1), { notEnoughRoom: !0 };
						D$1(t$2);
					}
					D$1(e$1.last);
				} else {
					if (s$1 && !o$1) {
						const i$3 = ai(_$1.x, _$1.y, 0, r$1), o$2 = E$1 + C$1 + 1, s$2 = new e.P(c$1.getx(o$2), c$1.gety(o$2)), n$2 = ai(s$2.x, s$2.y, 0, r$1), a$2 = n$2[3] > 0 ? n$2 : fi(_$1, s$2, i$3, 1, r$1, void 0, g$1, v$1.canonical), l$2 = ui(R$1, A$1, (a$2[0] - i$3[0]) * f$1, a$2[1] - i$3[1]);
						if (t$1.flipState = l$2 && l$2.needsFlipping ? ii.flipRequired : ii.flipNotRequired, l$2) return l$2;
					}
					const i$2 = mi(b$1 * l$1.getoffsetX(S$1), w$1, T$1, o$1, u$1, _$1, C$1, E$1, L$1, c$1, n$1, p$1, m$1, !1, !1, g$1, v$1, y$1, x$1);
					if (!i$2) return { notEnoughRoom: !0 };
					D$1(i$2);
				}
				return {};
			}
			function pi(e$1, t$1, i$1, o$1, s$1) {
				const { x: r$1, y: n$1, z: a$1 } = o$1.projectTilePoint(e$1.x, e$1.y, t$1);
				if (!s$1) return ai(r$1, n$1, a$1, i$1);
				const [l$1, c$1, h$1] = s$1.getElevation(e$1, s$1.elevation, s$1.elevationFeature);
				return ai(r$1 + l$1, n$1 + c$1, a$1 + h$1, i$1);
			}
			function fi(t$1, i$1, o$1, s$1, r$1, n$1, a$1, l$1) {
				const c$1 = pi(t$1.sub(i$1)._unit()._add(t$1), l$1, r$1, a$1, n$1);
				return e.av(c$1, o$1, c$1), e.aw(c$1, c$1), e.bH(c$1, o$1, c$1, s$1);
			}
			function mi(t$1, i$1, o$1, s$1, r$1, n$1, a$1, l$1, c$1, h$1, d$1, u$1, _$1, p$1, f$1, m$1, g$1, v$1, y$1) {
				const x$1 = s$1 ? t$1 - i$1 : t$1 + i$1;
				let b$1 = x$1 > 0 ? 1 : -1, w$1 = 0;
				s$1 && (b$1 *= -1, w$1 = Math.PI), b$1 < 0 && (w$1 += Math.PI);
				let T$1 = l$1 + a$1 + (b$1 > 0 ? 0 : 1) | 0, E$1 = r$1, S$1 = r$1, I$1 = 0, C$1 = 0;
				const R$1 = Math.abs(x$1), A$1 = [], L$1 = [];
				let D$1 = n$1, P$1 = D$1, O$1 = e.bF([]);
				const z$1 = () => fi(P$1, D$1, S$1, R$1 - I$1 + 1, d$1, _$1, m$1, g$1.canonical);
				for (; I$1 + C$1 <= R$1;) {
					if (T$1 += b$1, T$1 < l$1 || T$1 >= c$1) return null;
					if (S$1 = E$1, P$1 = D$1, A$1.push(S$1), p$1 && L$1.push(P$1), D$1 = new e.P(h$1.getx(T$1), h$1.gety(T$1)), E$1 = u$1[T$1], !E$1) {
						const e$1 = pi(D$1, g$1.canonical, d$1, m$1, _$1);
						E$1 = e$1[3] > 0 ? u$1[T$1] = e$1 : z$1();
					}
					I$1 += C$1;
					const t$2 = e.av([], E$1, S$1), i$2 = e.bG(S$1, E$1);
					if (o$1 && i$2 > 0 && C$1 > 0 && e.bJ(O$1, t$2) / (C$1 * i$2) < y$1) return null;
					C$1 = i$2, O$1 = t$2;
				}
				f$1 && _$1 && (u$1[T$1] && (E$1 = z$1(), C$1 = e.bG(S$1, E$1), O$1 = e.av([], E$1, S$1)), u$1[T$1] = E$1);
				const M$1 = (R$1 - I$1) / C$1, F$1 = D$1.sub(P$1)._mult(M$1)._add(P$1), B$1 = e.bH([], S$1, O$1, M$1);
				let k$1 = [
					0,
					0,
					1
				], N$1 = O$1[0], U$1 = O$1[1];
				if (v$1 && (k$1 = m$1.upVector(g$1.canonical, F$1.x, F$1.y), 0 !== k$1[0] || 0 !== k$1[1] || 1 !== k$1[2])) {
					const t$2 = [
						k$1[2],
						0,
						-k$1[0]
					], i$2 = e.bI([], k$1, t$2);
					e.aw(t$2, t$2), e.aw(i$2, i$2), N$1 = e.bJ(O$1, t$2), U$1 = e.bJ(O$1, i$2);
				}
				if (o$1) {
					const t$2 = e.bI([], k$1, O$1);
					e.aw(t$2, t$2), e.bH(B$1, B$1, t$2, o$1 * b$1);
				}
				const j$1 = w$1 + Math.atan2(U$1, N$1);
				return A$1.push(B$1), p$1 && L$1.push(F$1), {
					point: B$1,
					angle: j$1,
					path: A$1,
					tilePath: L$1,
					up: k$1
				};
			}
			function gi(e$1, t$1) {
				const i$1 = t$1.length, o$1 = i$1 + 4 * e$1;
				t$1.resize(o$1), t$1.float32.fill(-Infinity, 4 * i$1, 4 * o$1);
			}
			function vi(e$1, t$1, i$1) {
				const o$1 = t$1[0], s$1 = t$1[1];
				return e$1[0] = i$1[0] * o$1 + i$1[4] * s$1 + i$1[12], e$1[1] = i$1[1] * o$1 + i$1[5] * s$1 + i$1[13], e$1[3] = i$1[3] * o$1 + i$1[7] * s$1 + i$1[15], e$1;
			}
			const yi = 100;
			class xi {
				constructor(e$1, t$1, i$1 = new ti(e$1.width + 200, e$1.height + 200, 25), o$1 = new ti(e$1.width + 200, e$1.height + 200, 25)) {
					this.transform = e$1, this.grid = i$1, this.ignoredGrid = o$1, this.pitchfactor = Math.cos(e$1._pitch) * e$1.cameraToCenterDistance, this.screenRightBoundary = e$1.width + yi, this.screenBottomBoundary = e$1.height + yi, this.gridRightBoundary = e$1.width + 200, this.gridBottomBoundary = e$1.height + 200, this.fogState = t$1;
				}
				placeCollisionBox(t$1, i$1, o$1, s$1, r$1, n$1, a$1, l$1, c$1, h$1, d$1) {
					let u$1 = o$1.projectedAnchorX, _$1 = o$1.projectedAnchorY, p$1 = o$1.projectedAnchorZ;
					const f$1 = o$1.tileAnchorX, m$1 = o$1.tileAnchorY, g$1 = o$1.elevation, v$1 = o$1.tileID, y$1 = t$1.getProjection();
					if (g$1 && v$1) {
						const [e$1, t$2, i$2] = y$1.upVector(v$1.canonical, o$1.tileAnchorX, o$1.tileAnchorY), s$2 = y$1.upVectorScale(v$1.canonical, this.transform.center.lat, this.transform.worldSize).metersToTile;
						u$1 += e$1 * g$1 * s$2, _$1 += t$2 * g$1 * s$2, p$1 += i$2 * g$1 * s$2;
					}
					const x$1 = "globe" === t$1.projection.name, b$1 = "globe" === t$1.projection.name ? e.aj(this.transform.zoom) : 0;
					if (v$1 && x$1 && b$1 < 1 && !n$1) {
						const t$2 = 1 << v$1.canonical.z, i$2 = e.bP(f$1, m$1);
						e.bQ(i$2, i$2, 1 / e.al), e.bR(i$2, i$2, e.bP(v$1.canonical.x, v$1.canonical.y)), e.bQ(i$2, i$2, 1 / t$2), e.bS(i$2, i$2, e.bP(s$1[0], s$1[1])), i$2[0] = e.bT(i$2[0], -.5, .5), e.bQ(i$2, i$2, e.al);
						const o$2 = e.bU(i$2[0], i$2[1], e.al / (2 * Math.PI), 1);
						e.aC(o$2, o$2, r$1), u$1 = e.ak(u$1, o$2[0], b$1), _$1 = e.ak(_$1, o$2[1], b$1), p$1 = e.ak(p$1, o$2[2], b$1);
					}
					const w$1 = this.projectAndGetPerspectiveRatio(h$1, u$1, _$1, p$1, o$1.tileID, "globe" === y$1.name || !!g$1 || this.transform.pitch > 0, y$1), T$1 = c$1 * w$1.perspectiveRatio, E$1 = (o$1.x1 * i$1 + a$1.x - o$1.padding) * T$1 + w$1.point.x, S$1 = (o$1.y1 * i$1 + a$1.y - o$1.padding) * T$1 + w$1.point.y, I$1 = (o$1.x2 * i$1 + a$1.x + o$1.padding) * T$1 + w$1.point.x, C$1 = (o$1.y2 * i$1 + a$1.y + o$1.padding) * T$1 + w$1.point.y, R$1 = w$1.perspectiveRatio <= .55 || w$1.occluded;
					return !this.isInsideGrid(E$1, S$1, I$1, C$1) || !l$1 && this.grid.hitTest(E$1, S$1, I$1, C$1, d$1) || R$1 ? {
						box: [],
						offscreen: !1,
						occluded: w$1.occluded
					} : {
						box: [
							E$1,
							S$1,
							I$1,
							C$1
						],
						offscreen: this.isOffscreen(E$1, S$1, I$1, C$1),
						occluded: !1
					};
				}
				placeCollisionCircles(t$1, i$1, o$1, s$1, r$1, n$1, a$1, l$1, c$1, h$1, d$1, u$1, _$1, p$1, f$1, m$1) {
					const g$1 = [], v$1 = this.transform.elevation, y$1 = t$1.getProjection(), x$1 = "road" === t$1.elevationType, b$1 = !!v$1 || x$1, w$1 = e.bV.getAtTileOffsetFunc(m$1, this.transform.center.lat, this.transform.worldSize, y$1), T$1 = new e.P(o$1.tileAnchorX, o$1.tileAnchorY), E$1 = new e.P(o$1.tileAnchorX, o$1.tileAnchorY);
					let { x: S$1, y: I$1, z: C$1 } = y$1.projectTilePoint(E$1.x, E$1.y, m$1.canonical), R$1 = null;
					if (b$1) {
						const e$1 = x$1 ? t$1.getElevationFeatureForText(s$1) : null;
						R$1 = {
							getElevation: w$1,
							elevation: v$1,
							elevationFeature: e$1
						};
						const [i$2, o$2, r$2] = w$1(T$1, v$1, e$1);
						S$1 += i$2, I$1 += o$2, C$1 += r$2;
					}
					const A$1 = "globe" === y$1.name, L$1 = this.projectAndGetPerspectiveRatio(l$1, S$1, I$1, C$1, m$1, A$1 || !!v$1 || this.transform.pitch > 0, y$1), { perspectiveRatio: D$1 } = L$1, P$1 = (u$1 ? a$1 / D$1 : a$1 * D$1) / e.bY, O$1 = ai(S$1, I$1, C$1, c$1), z$1 = o$1.lineOffsetX * P$1, M$1 = o$1.lineOffsetY * P$1, F$1 = e.an(t$1.layers[0].layout.get("text-max-angle")), B$1 = Math.cos(F$1), k$1 = L$1.signedDistanceFromCamera > 0 ? di(P$1, n$1, z$1, M$1, x$1 && 1 === o$1.flipState, O$1, E$1, o$1, r$1, c$1, {}, b$1 && !u$1 ? R$1 : null, u$1 && b$1, y$1, m$1, u$1, B$1) : null;
					let N$1 = !1, U$1 = !1, j$1 = !0;
					if (k$1 && !L$1.occluded) {
						const t$2 = .5 * p$1 * D$1 + f$1, o$2 = new e.P(-100, -100), s$2 = new e.P(this.screenRightBoundary, this.screenBottomBoundary), r$2 = new ei(), { first: n$2, last: a$2 } = k$1, l$2 = n$2.path.length;
						let c$2 = [];
						for (let e$1 = l$2 - 1; e$1 >= 1; e$1--) c$2.push(n$2.path[e$1]);
						for (let e$1 = 1; e$1 < a$2.path.length; e$1++) c$2.push(a$2.path[e$1]);
						const u$2 = 2.5 * t$2;
						h$1 && (c$2 = c$2.map((([e$1, t$3, i$2], o$3) => (b$1 && !A$1 && (i$2 = w$1(o$3 < l$2 - 1 ? n$2.tilePath[l$2 - 1 - o$3] : a$2.tilePath[o$3 - l$2 + 2], v$1, R$1.elevationFeature)[2]), ai(e$1, t$3, i$2, h$1)))), c$2.some(((e$1) => e$1[3] <= 0)) && (c$2 = []));
						let m$2 = [];
						if (c$2.length > 0) {
							let t$3 = Infinity, i$2 = -Infinity, r$3 = Infinity, n$3 = -Infinity;
							for (const e$1 of c$2) t$3 = Math.min(t$3, e$1[0]), r$3 = Math.min(r$3, e$1[1]), i$2 = Math.max(i$2, e$1[0]), n$3 = Math.max(n$3, e$1[1]);
							i$2 >= o$2.x && t$3 <= s$2.x && n$3 >= o$2.y && r$3 <= s$2.y && (m$2 = [c$2.map(((t$4) => new e.P(t$4[0], t$4[1])))], (t$3 < o$2.x || i$2 > s$2.x || r$3 < o$2.y || n$3 > s$2.y) && (m$2 = e.bW(m$2, o$2.x, o$2.y, s$2.x, s$2.y)));
						}
						for (const e$1 of m$2) {
							r$2.reset(e$1, .25 * t$2);
							let o$3 = 0;
							o$3 = r$2.length <= .5 * t$2 ? 1 : Math.ceil(r$2.paddedLength / u$2) + 1;
							for (let e$2 = 0; e$2 < o$3; e$2++) {
								const s$3 = e$2 / Math.max(o$3 - 1, 1), n$3 = r$2.lerp(s$3), a$3 = n$3.x + yi, l$3 = n$3.y + yi;
								g$1.push(a$3, l$3, t$2, 0);
								const c$3 = a$3 - t$2, h$2 = l$3 - t$2, u$3 = a$3 + t$2, p$2 = l$3 + t$2;
								if (j$1 = j$1 && this.isOffscreen(c$3, h$2, u$3, p$2), U$1 = U$1 || this.isInsideGrid(c$3, h$2, u$3, p$2), !i$1 && this.grid.hitTestCircle(a$3, l$3, t$2, _$1) && (N$1 = !0, !d$1)) return {
									circles: [],
									offscreen: !1,
									collisionDetected: N$1,
									occluded: !1
								};
							}
						}
					}
					return {
						circles: !d$1 && N$1 || !U$1 ? [] : g$1,
						offscreen: j$1,
						collisionDetected: N$1,
						occluded: L$1.occluded
					};
				}
				queryRenderedSymbols(t$1) {
					if (0 === t$1.length || 0 === this.grid.keysLength() && 0 === this.ignoredGrid.keysLength()) return {};
					const i$1 = [];
					let o$1 = Infinity, s$1 = Infinity, r$1 = -Infinity, n$1 = -Infinity;
					for (const a$2 of t$1) {
						const t$2 = new e.P(a$2.x + yi, a$2.y + yi);
						o$1 = Math.min(o$1, t$2.x), s$1 = Math.min(s$1, t$2.y), r$1 = Math.max(r$1, t$2.x), n$1 = Math.max(n$1, t$2.y), i$1.push(t$2);
					}
					const a$1 = this.grid.query(o$1, s$1, r$1, n$1).concat(this.ignoredGrid.query(o$1, s$1, r$1, n$1)), l$1 = {}, c$1 = {};
					for (const t$2 of a$1) {
						const o$2 = t$2.key;
						if (void 0 === l$1[o$2.bucketInstanceId] && (l$1[o$2.bucketInstanceId] = {}), l$1[o$2.bucketInstanceId][o$2.featureIndex]) continue;
						const s$2 = [
							new e.P(t$2.x1, t$2.y1),
							new e.P(t$2.x2, t$2.y1),
							new e.P(t$2.x2, t$2.y2),
							new e.P(t$2.x1, t$2.y2)
						];
						e.bX(i$1, s$2) && (l$1[o$2.bucketInstanceId][o$2.featureIndex] = !0, void 0 === c$1[o$2.bucketInstanceId] && (c$1[o$2.bucketInstanceId] = []), c$1[o$2.bucketInstanceId].push(o$2.featureIndex));
					}
					return c$1;
				}
				insertCollisionBox(e$1, t$1, i$1, o$1, s$1) {
					(t$1 ? this.ignoredGrid : this.grid).insert({
						bucketInstanceId: i$1,
						featureIndex: o$1,
						collisionGroupID: s$1
					}, e$1[0], e$1[1], e$1[2], e$1[3]);
				}
				insertCollisionCircles(e$1, t$1, i$1, o$1, s$1) {
					const r$1 = t$1 ? this.ignoredGrid : this.grid, n$1 = {
						bucketInstanceId: i$1,
						featureIndex: o$1,
						collisionGroupID: s$1
					};
					for (let t$2 = 0; t$2 < e$1.length; t$2 += 4) r$1.insertCircle(n$1, e$1[t$2], e$1[t$2 + 1], e$1[t$2 + 2]);
				}
				projectAndGetPerspectiveRatio(t$1, i$1, o$1, s$1, r$1, n$1, a$1) {
					const l$1 = [
						i$1,
						o$1,
						s$1,
						1
					];
					let c$1 = !1;
					if (s$1 || this.transform.pitch > 0) {
						if (e.aC(l$1, l$1, t$1), this.fogState && r$1 && "globe" !== a$1.name) c$1 = function(t$2, i$2, o$2, s$2, r$2, n$2) {
							const a$2 = n$2.calculateFogTileMatrix(r$2), l$2 = [
								i$2,
								o$2,
								s$2
							];
							return e.af(l$2, l$2, a$2), qe(t$2, e.ag(l$2), n$2.pitch, n$2._fov);
						}(this.fogState, i$1, o$1, s$1, r$1.toUnwrapped(), this.transform) > .9;
					} else vi(l$1, l$1, t$1);
					const h$1 = l$1[3];
					return {
						point: new e.P((l$1[0] / h$1 + 1) / 2 * this.transform.width + yi, (-l$1[1] / h$1 + 1) / 2 * this.transform.height + yi),
						perspectiveRatio: Math.min(.5 + this.transform.getCameraToCenterDistance(a$1) / h$1 * .5, 1.5),
						signedDistanceFromCamera: h$1,
						occluded: n$1 && l$1[2] > h$1 || c$1
					};
				}
				isOffscreen(e$1, t$1, i$1, o$1) {
					return i$1 < yi || e$1 >= this.screenRightBoundary || o$1 < yi || t$1 > this.screenBottomBoundary;
				}
				isInsideGrid(e$1, t$1, i$1, o$1) {
					return i$1 >= 0 && e$1 < this.gridRightBoundary && o$1 >= 0 && t$1 < this.gridBottomBoundary;
				}
				getViewportMatrix() {
					const t$1 = e.bA([]);
					return e.br(t$1, t$1, [
						-100,
						-100,
						0
					]), t$1;
				}
			}
			class bi {
				constructor(e$1, t$1, i$1, o$1) {
					this.opacity = e$1 ? Math.max(0, Math.min(1, e$1.opacity + (e$1.placed ? t$1 : -t$1))) : o$1 && i$1 ? 1 : 0, this.placed = i$1;
				}
				isHidden() {
					return 0 === this.opacity && !this.placed;
				}
			}
			class wi {
				constructor(e$1, t$1, i$1, o$1, s$1, r$1 = !1) {
					this.text = new bi(e$1 ? e$1.text : null, t$1, i$1, s$1), this.icon = new bi(e$1 ? e$1.icon : null, t$1, o$1, s$1), this.clipped = r$1;
				}
				isHidden() {
					return this.text.isHidden() && this.icon.isHidden();
				}
			}
			class Ti {
				constructor(e$1, t$1, i$1, o$1 = !1) {
					this.text = e$1, this.icon = t$1, this.skipFade = i$1, this.clipped = o$1;
				}
			}
			class Ei {
				constructor() {
					this.invProjMatrix = e.bC(), this.viewportMatrix = e.bC(), this.circles = [];
				}
			}
			class Si {
				constructor(e$1, t$1, i$1, o$1, s$1) {
					this.bucketInstanceId = e$1, this.featureIndex = t$1, this.sourceLayerIndex = i$1, this.bucketIndex = o$1, this.tileID = s$1;
				}
			}
			class Ii {
				constructor(e$1) {
					this.crossSourceCollisions = e$1, this.maxGroupID = 0, this.collisionGroups = {};
				}
				get(e$1) {
					if (this.crossSourceCollisions) return {
						ID: 0,
						predicate: null
					};
					if (!this.collisionGroups[e$1]) {
						const t$1 = ++this.maxGroupID;
						this.collisionGroups[e$1] = {
							ID: t$1,
							predicate: (e$2) => e$2.collisionGroupID === t$1
						};
					}
					return this.collisionGroups[e$1];
				}
			}
			function Ci(t$1, i$1, o$1, s$1, r$1) {
				const { horizontalAlign: n$1, verticalAlign: a$1 } = e.c1(t$1), l$1 = -(n$1 - .5) * i$1, c$1 = -(a$1 - .5) * o$1, h$1 = e.c2(t$1, s$1);
				return new e.P(l$1 + h$1[0] * r$1, c$1 + h$1[1] * r$1);
			}
			function Ri(t$1, i$1, o$1, s$1, r$1) {
				const n$1 = new e.P(t$1, i$1);
				return o$1 && n$1._rotate(s$1 ? r$1 : -r$1), n$1;
			}
			class Ai {
				constructor(e$1, t$1, i$1, o$1, s$1, r$1) {
					this.transform = e$1.clone(), this.projection = e$1.projection.name, this.collisionIndex = new xi(this.transform, s$1), this.buildingIndex = r$1, this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = !1, this.commitTime = 0, this.fadeDuration = t$1, this.retainedQueryData = {}, this.collisionGroups = new Ii(i$1), this.collisionCircleArrays = {}, this.prevPlacement = o$1, o$1 && (o$1.prevPlacement = void 0), this.placedOrientations = {}, this.lastReplacementSourceUpdateTime = 0;
				}
				getBucketParts(t$1, i$1, o$1, s$1, r$1 = 1) {
					const n$1 = o$1.getBucket(i$1), a$1 = o$1.latestFeatureIndex;
					if (!n$1 || !a$1 || i$1.fqid !== n$1.layerIds[0]) return;
					const l$1 = n$1.layers[0].layout, c$1 = n$1.layers[0].paint, h$1 = o$1.collisionBoxArray, d$1 = Math.pow(2, this.transform.zoom - o$1.tileID.overscaledZ), u$1 = o$1.tileSize / e.al, _$1 = o$1.tileID.toUnwrapped();
					this.transform.setProjection(n$1.projection);
					const p$1 = (f$1 = o$1.tileID, m$1 = n$1.getProjection(), g$1 = this.transform, m$1.name === this.projection ? g$1.calculateProjMatrix(f$1.toUnwrapped()) : Kt(g$1, m$1, f$1));
					var f$1, m$1, g$1;
					const v$1 = "map" === l$1.get("text-pitch-alignment"), y$1 = "map" === l$1.get("text-rotation-alignment");
					i$1.compileFilter(i$1.options);
					const x$1 = i$1.dynamicFilter(), b$1 = i$1.dynamicFilterNeedsFeature(), w$1 = this.transform.calculatePixelsToTileUnitsMatrix(o$1), T$1 = ri(p$1, o$1.tileID.canonical, v$1, y$1, this.transform, n$1.getProjection(), w$1);
					let E$1 = null;
					const S$1 = n$1.getProjection().createInversionMatrix(this.transform, o$1.tileID.canonical);
					if (v$1) {
						const t$2 = ni(p$1, o$1.tileID.canonical, v$1, y$1, this.transform, n$1.getProjection(), w$1);
						E$1 = e.aB([], this.transform.labelPlaneMatrix, t$2);
					}
					let I$1 = null;
					x$1 && o$1.latestFeatureIndex && (I$1 = {
						unwrappedTileID: _$1,
						dynamicFilter: x$1,
						dynamicFilterNeedsFeature: b$1
					}), this.retainedQueryData[n$1.bucketInstanceId] = new Si(n$1.bucketInstanceId, a$1, n$1.sourceLayerIndex, n$1.index, o$1.tileID);
					const [C$1, R$1] = n$1.layers[0].layout.get("text-size-scale-range"), A$1 = e.aA(r$1, C$1, R$1), [L$1, D$1] = l$1.get("icon-size-scale-range"), P$1 = e.aA(r$1, L$1, D$1), O$1 = {
						bucket: n$1,
						layout: l$1,
						paint: c$1,
						posMatrix: p$1,
						invMatrix: S$1,
						mercatorCenter: [e.aF(this.transform.center.lng), e.aJ(this.transform.center.lat)],
						textLabelPlaneMatrix: T$1,
						labelToScreenMatrix: E$1,
						clippingData: I$1,
						scale: d$1,
						textPixelRatio: u$1,
						holdingForFade: o$1.holdingForFade(),
						collisionBoxArray: h$1,
						partiallyEvaluatedTextSize: e.bK(n$1.textSizeData, this.transform.zoom, A$1),
						partiallyEvaluatedIconSize: e.bK(n$1.iconSizeData, this.transform.zoom, P$1),
						collisionGroup: this.collisionGroups.get(n$1.sourceID),
						latestFeatureIndex: o$1.latestFeatureIndex
					};
					if (s$1) for (const e$1 of n$1.sortKeyRanges) {
						const { sortKey: i$2, symbolInstanceStart: o$2, symbolInstanceEnd: s$2 } = e$1;
						t$1.push({
							sortKey: i$2,
							symbolInstanceStart: o$2,
							symbolInstanceEnd: s$2,
							parameters: O$1
						});
					}
					else t$1.push({
						symbolInstanceStart: 0,
						symbolInstanceEnd: n$1.symbolInstances.length,
						parameters: O$1
					});
				}
				attemptAnchorPlacement(e$1, t$1, i$1, o$1, s$1, r$1, n$1, a$1, l$1, c$1, h$1, d$1, u$1, _$1, p$1, f$1, m$1, g$1, v$1, y$1, x$1) {
					const { textOffset0: b$1, textOffset1: w$1, crossTileID: T$1 } = p$1, E$1 = [b$1, w$1], S$1 = Ci(e$1, r$1, n$1, E$1, a$1), I$1 = this.collisionIndex.placeCollisionBox(m$1, a$1, t$1, i$1, o$1, s$1, Ri(S$1.x, S$1.y, l$1, c$1, this.transform.angle), _$1, h$1, d$1, u$1.predicate);
					if (v$1) {
						const e$2 = m$1.getSymbolInstanceIconSize(x$1, this.transform.zoom, p$1.placedIconSymbolIndex);
						if (0 === this.collisionIndex.placeCollisionBox(m$1, e$2, v$1, i$1, o$1, s$1, Ri(S$1.x, S$1.y, l$1, c$1, this.transform.angle), _$1, h$1, d$1, u$1.predicate).box.length) return;
					}
					if (I$1.box.length > 0) {
						let t$2;
						return this.prevPlacement && this.prevPlacement.variableOffsets[T$1] && this.prevPlacement.placements[T$1] && this.prevPlacement.placements[T$1].text && (t$2 = this.prevPlacement.variableOffsets[T$1].anchor), this.variableOffsets[T$1] = {
							textOffset: E$1,
							width: r$1,
							height: n$1,
							anchor: e$1,
							textScale: a$1,
							prevAnchor: t$2
						}, this.markUsedJustification(m$1, e$1, p$1, g$1), m$1.allowVerticalPlacement && (this.markUsedOrientation(m$1, g$1, p$1), this.placedOrientations[T$1] = g$1), {
							shift: S$1,
							placedGlyphBoxes: I$1
						};
					}
				}
				placeLayerBucketPart(t$1, i$1, o$1, s$1, r$1 = 1) {
					const { bucket: n$1, layout: a$1, paint: l$1, posMatrix: c$1, textLabelPlaneMatrix: h$1, labelToScreenMatrix: d$1, clippingData: u$1, textPixelRatio: _$1, mercatorCenter: p$1, invMatrix: f$1, holdingForFade: m$1, collisionBoxArray: g$1, partiallyEvaluatedTextSize: v$1, partiallyEvaluatedIconSize: y$1, collisionGroup: x$1, latestFeatureIndex: b$1 } = t$1.parameters, w$1 = a$1.get("text-optional"), T$1 = a$1.get("icon-optional"), E$1 = a$1.get("text-allow-overlap"), S$1 = a$1.get("icon-allow-overlap"), I$1 = "map" === a$1.get("text-rotation-alignment"), C$1 = "map" === a$1.get("icon-rotation-alignment"), R$1 = "map" === a$1.get("text-pitch-alignment"), A$1 = l$1.get("symbol-z-offset"), L$1 = "sea" === a$1.get("symbol-elevation-reference"), D$1 = a$1.get("symbol-placement"), [P$1, O$1] = a$1.get("text-size-scale-range"), [z$1, M$1] = a$1.get("icon-size-scale-range"), F$1 = e.aA(r$1, P$1, O$1), B$1 = e.aA(r$1, z$1, M$1), k$1 = a$1.get("text-variable-anchor"), N$1 = I$1 && "point" !== D$1, U$1 = C$1 && "point" !== D$1, j$1 = k$1 && n$1.hasTextData(), G$1 = n$1.hasIconTextFit() && j$1 && n$1.hasIconData();
					this.transform.setProjection(n$1.projection);
					const V$1 = j$1 || N$1, H$1 = U$1 || G$1;
					let q$1 = E$1 && (S$1 || !n$1.hasIconData() || T$1), Z$1 = S$1 && (E$1 || !n$1.hasTextData() || w$1);
					const W$1 = !A$1.isConstant();
					!n$1.collisionArrays && g$1 && n$1.deserializeCollisionBoxes(g$1), o$1 && s$1 && n$1.updateCollisionDebugBuffers(this.transform.zoom, g$1, F$1, B$1);
					const $$1 = (t$2, s$2, r$2) => {
						const { crossTileID: l$2, numVerticalGlyphVertices: g$2 } = t$2;
						let C$2 = null;
						if (u$1 && u$1.dynamicFilterNeedsFeature || W$1) {
							const e$1 = this.retainedQueryData[n$1.bucketInstanceId];
							C$2 = b$1.loadFeature({
								featureIndex: t$2.featureIndex,
								bucketIndex: e$1.bucketIndex,
								sourceLayerIndex: e$1.sourceLayerIndex,
								layoutVertexArrayOffset: 0
							});
							const i$2 = C$2.properties ? C$2.properties.worldview : null;
							if (n$1.localizable && n$1.worldview && "string" == typeof i$2) if ("all" === i$2) C$2.properties.$localized = !0;
							else {
								if (!i$2.split(",").includes(n$1.worldview)) return;
								C$2.properties.$localized = !0, C$2.properties.worldview = n$1.worldview;
							}
						}
						if (u$1 && !(0, u$1.dynamicFilter)({
							zoom: this.transform.zoom,
							pitch: this.transform.pitch,
							worldview: n$1.worldview
						}, C$2, this.retainedQueryData[n$1.bucketInstanceId].tileID.canonical, new e.P(t$2.tileAnchorX, t$2.tileAnchorY), this.transform.calculateDistanceTileData(u$1.unwrappedTileID))) return this.placements[l$2] = new Ti(!1, !1, !1, !0), void i$1.add(l$2);
						const D$2 = A$1.evaluate(C$2, {});
						if (i$1.has(l$2)) return;
						if (m$1) return void (this.placements[l$2] = new Ti(!1, !1, !1));
						let P$2 = !1, O$2 = !1, z$2 = !0, M$2 = !1, F$2 = !1, B$2 = null, N$2 = {
							box: null,
							offscreen: null,
							occluded: null
						}, U$2 = { box: null }, j$2 = null, G$2 = null, $$2 = null, X$2 = 0, Y$1 = 0, K$1 = 0;
						r$2.textFeatureIndex ? X$2 = r$2.textFeatureIndex : t$2.useRuntimeCollisionCircles && (X$2 = t$2.featureIndex), r$2.verticalTextFeatureIndex && (Y$1 = r$2.verticalTextFeatureIndex);
						const J$1 = n$1.elevationFeatures ? n$1.elevationFeatures[t$2.elevationFeatureIndex] : void 0, Q$1 = (i$2) => {
							i$2.tileID = this.retainedQueryData[n$1.bucketInstanceId].tileID;
							const o$2 = this.transform.elevation;
							i$2.elevation = L$1 ? D$2 : D$2 + e.bV.getAtTileOffset(i$2.tileID, new e.P(i$2.tileAnchorX, i$2.tileAnchorY), o$2, J$1), i$2.elevation += t$2.zOffset;
						}, ee$1 = r$2.textBox;
						if (ee$1) {
							Q$1(ee$1);
							const i$2 = (i$3) => {
								let o$3 = e.bL.horizontal;
								if (n$1.allowVerticalPlacement && !i$3 && this.prevPlacement) {
									const e$1 = this.prevPlacement.placedOrientations[l$2];
									e$1 && (this.placedOrientations[l$2] = e$1, o$3 = e$1, this.markUsedOrientation(n$1, o$3, t$2));
								}
								return o$3;
							}, o$2 = (t$3, i$3) => {
								if (n$1.allowVerticalPlacement && g$2 > 0 && r$2.verticalTextBox) {
									for (const o$3 of n$1.writingModes) if (o$3 === e.bL.vertical ? (N$2 = i$3(), U$2 = N$2) : N$2 = t$3(), N$2 && N$2.box && N$2.box.length) break;
								} else N$2 = t$3();
							};
							if (k$1) {
								let a$2 = k$1;
								if (this.prevPlacement && this.prevPlacement.variableOffsets[l$2]) {
									const e$1 = this.prevPlacement.variableOffsets[l$2];
									a$2.indexOf(e$1.anchor) > 0 && (a$2 = a$2.filter(((t$3) => t$3 !== e$1.anchor)), a$2.unshift(e$1.anchor));
								}
								const h$2 = (e$1, i$3, o$3) => {
									const r$3 = n$1.getSymbolInstanceTextSize(v$1, t$2, this.transform.zoom, s$2), l$3 = (e$1.x2 - e$1.x1) * r$3 + 2 * e$1.padding, h$3 = (e$1.y2 - e$1.y1) * r$3 + 2 * e$1.padding, d$3 = t$2.hasIconTextFit && !S$1 ? i$3 : null;
									d$3 && Q$1(d$3);
									let u$2 = {
										box: [],
										offscreen: !1,
										occluded: !1
									};
									const m$2 = E$1 ? 2 * a$2.length : a$2.length;
									for (let i$4 = 0; i$4 < m$2; ++i$4) {
										const m$3 = this.attemptAnchorPlacement(a$2[i$4 % a$2.length], e$1, p$1, f$1, V$1, l$3, h$3, r$3, I$1, R$1, _$1, c$1, x$1, i$4 >= a$2.length, t$2, s$2, n$1, o$3, d$3, v$1, y$1);
										if (m$3 && (u$2 = m$3.placedGlyphBoxes, u$2 && u$2.box && u$2.box.length)) {
											P$2 = !0, B$2 = m$3.shift;
											break;
										}
									}
									return u$2;
								};
								o$2((() => h$2(ee$1, r$2.iconBox, e.bL.horizontal)), (() => {
									const t$3 = r$2.verticalTextBox;
									return t$3 && Q$1(t$3), n$1.allowVerticalPlacement && !(N$2 && N$2.box && N$2.box.length) && g$2 > 0 && t$3 ? h$2(t$3, r$2.verticalIconBox, e.bL.vertical) : {
										box: null,
										offscreen: null,
										occluded: null
									};
								})), N$2 && (P$2 = N$2.box, z$2 = N$2.offscreen, M$2 = N$2.occluded);
								const d$2 = i$2(!(!N$2 || !N$2.box));
								if (!P$2 && this.prevPlacement) {
									const e$1 = this.prevPlacement.variableOffsets[l$2];
									e$1 && (this.variableOffsets[l$2] = e$1, this.markUsedJustification(n$1, e$1.anchor, t$2, d$2));
								}
							} else {
								const a$2 = (i$3, o$3) => {
									const r$3 = n$1.getSymbolInstanceTextSize(v$1, t$2, this.transform.zoom, s$2), a$3 = this.collisionIndex.placeCollisionBox(n$1, r$3, i$3, p$1, f$1, V$1, new e.P(0, 0), E$1, _$1, c$1, x$1.predicate);
									return a$3 && a$3.box && a$3.box.length && (this.markUsedOrientation(n$1, o$3, t$2), this.placedOrientations[l$2] = o$3), a$3;
								};
								o$2((() => a$2(ee$1, e.bL.horizontal)), (() => {
									const t$3 = r$2.verticalTextBox;
									return n$1.allowVerticalPlacement && g$2 > 0 && t$3 ? (Q$1(t$3), a$2(t$3, e.bL.vertical)) : {
										box: null,
										offscreen: null,
										occluded: null
									};
								})), i$2(!!(N$2 && N$2.box && N$2.box.length));
							}
						}
						if (j$2 = N$2, P$2 = j$2 && j$2.box && j$2.box.length > 0, z$2 = j$2 && j$2.offscreen, M$2 = j$2 && j$2.occluded, t$2.useRuntimeCollisionCircles) {
							const i$2 = t$2.centerJustifiedTextSymbolIndex >= 0 ? t$2.centerJustifiedTextSymbolIndex : t$2.verticalPlacedTextSymbolIndex, s$3 = n$1.text.placedSymbolArray.get(i$2), r$3 = e.bM(n$1.textSizeData, v$1, s$3), l$3 = a$1.get("text-padding");
							G$2 = this.collisionIndex.placeCollisionCircles(n$1, E$1, s$3, i$2, n$1.lineVertexArray, n$1.glyphOffsetArray, r$3, c$1, h$1, d$1, o$1, R$1, x$1.predicate, t$2.collisionCircleDiameter * r$3 / e.bY, l$3, this.retainedQueryData[n$1.bucketInstanceId].tileID), P$2 = E$1 || G$2.circles.length > 0 && !G$2.collisionDetected, z$2 = z$2 && G$2.offscreen, M$2 = G$2.occluded;
						}
						if (r$2.iconFeatureIndex && (K$1 = r$2.iconFeatureIndex), r$2.iconBox) {
							const i$2 = (i$3) => {
								Q$1(i$3);
								const o$2 = t$2.hasIconTextFit && B$2 ? Ri(B$2.x, B$2.y, I$1, R$1, this.transform.angle) : new e.P(0, 0), s$3 = n$1.getSymbolInstanceIconSize(y$1, this.transform.zoom, t$2.placedIconSymbolIndex);
								return this.collisionIndex.placeCollisionBox(n$1, s$3, i$3, p$1, f$1, H$1, o$2, S$1, _$1, c$1, x$1.predicate);
							};
							U$2 && U$2.box && U$2.box.length && r$2.verticalIconBox ? ($$2 = i$2(r$2.verticalIconBox), O$2 = $$2.box.length > 0) : ($$2 = i$2(r$2.iconBox), O$2 = $$2.box.length > 0), z$2 = z$2 && $$2.offscreen, F$2 = $$2.occluded;
						}
						const te$1 = w$1 || 0 === t$2.numHorizontalGlyphVertices && 0 === g$2, ie$1 = T$1 || 0 === t$2.numIconVertices;
						if (te$1 || ie$1 ? ie$1 ? te$1 || (O$2 = O$2 && P$2) : P$2 = O$2 && P$2 : O$2 = P$2 = O$2 && P$2, P$2 && j$2 && j$2.box && this.collisionIndex.insertCollisionBox(j$2.box, a$1.get("text-ignore-placement"), n$1.bucketInstanceId, U$2 && U$2.box && Y$1 ? Y$1 : X$2, x$1.ID), O$2 && $$2 && this.collisionIndex.insertCollisionBox($$2.box, a$1.get("icon-ignore-placement"), n$1.bucketInstanceId, K$1, x$1.ID), G$2 && (P$2 && this.collisionIndex.insertCollisionCircles(G$2.circles, a$1.get("text-ignore-placement"), n$1.bucketInstanceId, X$2, x$1.ID), o$1)) {
							const e$1 = n$1.bucketInstanceId;
							let t$3 = this.collisionCircleArrays[e$1];
							void 0 === t$3 && (t$3 = this.collisionCircleArrays[e$1] = new Ei());
							for (let e$2 = 0; e$2 < G$2.circles.length; e$2 += 4) t$3.circles.push(G$2.circles[e$2 + 0]), t$3.circles.push(G$2.circles[e$2 + 1]), t$3.circles.push(G$2.circles[e$2 + 2]), t$3.circles.push(G$2.collisionDetected ? 1 : 0);
						}
						const oe$1 = "globe" !== n$1.projection.name;
						q$1 = q$1 && (oe$1 || !M$2), Z$1 = Z$1 && (oe$1 || !F$2), this.placements[l$2] = new Ti(P$2 || q$1, O$2 || Z$1, z$2 || n$1.justReloaded), i$1.add(l$2);
					}, X$1 = this.retainedQueryData[n$1.bucketInstanceId].tileID;
					if ("offset" === n$1.elevationType && this.buildingIndex && this.buildingIndex.updateZOffset(n$1, X$1), "road" === n$1.elevationType && n$1.updateRoadElevation(X$1.canonical), n$1.updateZOffset(), n$1.sortFeaturesByY) {
						const t$2 = n$1.getSortedSymbolIndexes(this.transform.angle);
						for (let e$1 = t$2.length - 1; e$1 >= 0; --e$1) {
							const i$2 = t$2[e$1];
							$$1(n$1.symbolInstances.get(i$2), i$2, n$1.collisionArrays[i$2]);
						}
						n$1.hasAnyZOffset && e.w(`${n$1.layerIds[0]} layer symbol-z-elevate: symbols are not sorted by elevation if symbol-z-order is evaluated to viewport-y`);
					} else if (n$1.hasAnyZOffset) {
						const e$1 = n$1.getSortedIndexesByZOffset();
						for (let t$2 = 0; t$2 < e$1.length; ++t$2) {
							const i$2 = e$1[t$2];
							$$1(n$1.symbolInstances.get(i$2), i$2, n$1.collisionArrays[i$2]);
						}
					} else for (let e$1 = t$1.symbolInstanceStart; e$1 < t$1.symbolInstanceEnd; e$1++) $$1(n$1.symbolInstances.get(e$1), e$1, n$1.collisionArrays[e$1]);
					if (o$1 && n$1.bucketInstanceId in this.collisionCircleArrays) {
						const t$2 = this.collisionCircleArrays[n$1.bucketInstanceId];
						e.bl(t$2.invProjMatrix, c$1), t$2.viewportMatrix = this.collisionIndex.getViewportMatrix();
					}
					n$1.justReloaded = !1;
				}
				markUsedJustification(t$1, i$1, o$1, s$1) {
					const { leftJustifiedTextSymbolIndex: r$1, centerJustifiedTextSymbolIndex: n$1, rightJustifiedTextSymbolIndex: a$1, verticalPlacedTextSymbolIndex: l$1, crossTileID: c$1 } = o$1, h$1 = e.c3(i$1), d$1 = s$1 === e.bL.vertical ? l$1 : "left" === h$1 ? r$1 : "center" === h$1 ? n$1 : "right" === h$1 ? a$1 : -1;
					r$1 >= 0 && (t$1.text.placedSymbolArray.get(r$1).crossTileID = d$1 >= 0 && r$1 !== d$1 ? 0 : c$1), n$1 >= 0 && (t$1.text.placedSymbolArray.get(n$1).crossTileID = d$1 >= 0 && n$1 !== d$1 ? 0 : c$1), a$1 >= 0 && (t$1.text.placedSymbolArray.get(a$1).crossTileID = d$1 >= 0 && a$1 !== d$1 ? 0 : c$1), l$1 >= 0 && (t$1.text.placedSymbolArray.get(l$1).crossTileID = d$1 >= 0 && l$1 !== d$1 ? 0 : c$1);
				}
				markUsedOrientation(t$1, i$1, o$1) {
					const s$1 = i$1 === e.bL.horizontal || i$1 === e.bL.horizontalOnly ? i$1 : 0, r$1 = i$1 === e.bL.vertical ? i$1 : 0, { leftJustifiedTextSymbolIndex: n$1, centerJustifiedTextSymbolIndex: a$1, rightJustifiedTextSymbolIndex: l$1, verticalPlacedTextSymbolIndex: c$1 } = o$1, h$1 = t$1.text.placedSymbolArray;
					n$1 >= 0 && (h$1.get(n$1).placedOrientation = s$1), a$1 >= 0 && (h$1.get(a$1).placedOrientation = s$1), l$1 >= 0 && (h$1.get(l$1).placedOrientation = s$1), c$1 >= 0 && (h$1.get(c$1).placedOrientation = r$1);
				}
				commit(e$1) {
					this.commitTime = e$1, this.zoomAtLastRecencyCheck = this.transform.zoom;
					const t$1 = this.prevPlacement;
					let i$1 = !1;
					this.prevZoomAdjustment = t$1 ? t$1.zoomAdjustment(this.transform.zoom) : 0;
					const o$1 = t$1 ? t$1.symbolFadeChange(e$1) : 1, s$1 = t$1 ? t$1.opacities : {}, r$1 = t$1 ? t$1.variableOffsets : {}, n$1 = t$1 ? t$1.placedOrientations : {};
					for (const e$2 in this.placements) {
						const t$2 = this.placements[e$2], r$2 = s$1[e$2];
						r$2 ? (this.opacities[e$2] = new wi(r$2, o$1, t$2.text, t$2.icon, null, t$2.clipped), i$1 = i$1 || t$2.text !== r$2.text.placed || t$2.icon !== r$2.icon.placed) : (this.opacities[e$2] = new wi(null, o$1, t$2.text, t$2.icon, t$2.skipFade, t$2.clipped), i$1 = i$1 || t$2.text || t$2.icon);
					}
					for (const e$2 in s$1) {
						const t$2 = s$1[e$2];
						if (!this.opacities[e$2]) {
							const s$2 = new wi(t$2, o$1, !1, !1);
							s$2.isHidden() || (this.opacities[e$2] = s$2, i$1 = i$1 || t$2.text.placed || t$2.icon.placed);
						}
					}
					for (const e$2 in r$1) this.variableOffsets[e$2] || !this.opacities[e$2] || this.opacities[e$2].isHidden() || (this.variableOffsets[e$2] = r$1[e$2]);
					for (const e$2 in n$1) this.placedOrientations[e$2] || !this.opacities[e$2] || this.opacities[e$2].isHidden() || (this.placedOrientations[e$2] = n$1[e$2]);
					i$1 ? this.lastPlacementChangeTime = e$1 : "number" != typeof this.lastPlacementChangeTime && (this.lastPlacementChangeTime = t$1 ? t$1.lastPlacementChangeTime : e$1);
				}
				updateLayerOpacities(e$1, t$1, i$1, o$1) {
					o$1 && (this.lastReplacementSourceUpdateTime = o$1.updateTime);
					const s$1 = /* @__PURE__ */ new Set();
					for (const r$1 of t$1) {
						const t$2 = r$1.getBucket(e$1);
						t$2 && r$1.latestFeatureIndex && e$1.fqid === t$2.layerIds[0] && (this.updateBucketOpacities(t$2, s$1, r$1, r$1.collisionBoxArray, i$1, o$1, r$1.tileID, e$1.scope), "offset" === t$2.elevationType && this.buildingIndex && this.buildingIndex.updateZOffset(t$2, r$1.tileID), "road" === t$2.elevationType && t$2.updateRoadElevation(r$1.tileID.canonical), t$2.updateZOffset());
					}
				}
				updateBucketOpacities(t$1, i$1, o$1, s$1, r$1, n$1, a$1, l$1) {
					t$1.hasTextData() && t$1.text.opacityVertexArray.clear(), t$1.hasIconData() && t$1.icon.opacityVertexArray.clear(), t$1.hasIconCollisionBoxData() && t$1.iconCollisionBox.collisionVertexArray.clear(), t$1.hasTextCollisionBoxData() && t$1.textCollisionBox.collisionVertexArray.clear();
					const c$1 = t$1.layers[0].layout, h$1 = t$1.layers[0].paint, d$1 = !!t$1.layers[0].dynamicFilter(), u$1 = new wi(null, 0, !1, !1, !0), _$1 = c$1.get("text-allow-overlap"), p$1 = c$1.get("icon-allow-overlap"), f$1 = c$1.get("text-variable-anchor"), m$1 = "map" === c$1.get("text-rotation-alignment"), g$1 = "map" === c$1.get("text-pitch-alignment"), v$1 = h$1.get("symbol-z-offset"), y$1 = "sea" === c$1.get("symbol-elevation-reference"), x$1 = !v$1.isConstant(), b$1 = new wi(null, 0, _$1 && (p$1 || !t$1.hasIconData() || c$1.get("icon-optional")), p$1 && (_$1 || !t$1.hasTextData() || c$1.get("text-optional")), !0);
					!t$1.collisionArrays && s$1 && (t$1.hasIconCollisionBoxData() || t$1.hasTextCollisionBoxData()) && t$1.deserializeCollisionBoxes(s$1);
					const w$1 = (e$1, t$2, i$2) => {
						for (let o$2 = 0; o$2 < t$2 / 4; o$2++) e$1.opacityVertexArray.emplaceBack(i$2);
					};
					let T$1 = 0;
					n$1 && t$1.updateReplacement(a$1, n$1);
					for (let s$2 = 0; s$2 < t$1.symbolInstances.length; s$2++) {
						const c$2 = t$1.symbolInstances.get(s$2), { numHorizontalGlyphVertices: h$2, numVerticalGlyphVertices: _$2, crossTileID: p$2, numIconVertices: E$1, tileAnchorX: S$1, tileAnchorY: I$1 } = c$2;
						let C$1 = null;
						const R$1 = this.retainedQueryData[t$1.bucketInstanceId];
						x$1 && c$2 && R$1 && (C$1 = o$1.latestFeatureIndex.loadFeature({
							featureIndex: c$2.featureIndex,
							bucketIndex: R$1.bucketIndex,
							sourceLayerIndex: R$1.sourceLayerIndex,
							layoutVertexArrayOffset: 0
						}));
						const A$1 = v$1.evaluate(C$1, {}), L$1 = i$1.has(p$2);
						let D$1 = this.opacities[p$2];
						L$1 ? D$1 = u$1 : D$1 || (D$1 = b$1, this.opacities[p$2] = D$1), i$1.add(p$2);
						const P$1 = h$2 > 0 || _$2 > 0, O$1 = E$1 > 0, z$1 = this.placedOrientations[p$2], M$1 = z$1 === e.bL.vertical, F$1 = z$1 === e.bL.horizontal || z$1 === e.bL.horizontalOnly;
						!P$1 && !O$1 || D$1.isHidden() || T$1++;
						let B$1 = !1;
						if ((P$1 || O$1) && n$1) for (const i$2 of t$1.activeReplacements) {
							if (e.bZ(i$2, r$1, e.b_.Symbol, l$1)) continue;
							if (i$2.min.x > S$1 || S$1 > i$2.max.x || i$2.min.y > I$1 || I$1 > i$2.max.y) continue;
							const t$2 = e.b$(S$1, I$1, a$1.canonical, i$2.footprintTileId.canonical);
							if (B$1 = e.c0(t$2, i$2.footprint), B$1) break;
						}
						if (P$1) {
							const e$1 = B$1 ? Ni : ki(D$1.text);
							w$1(t$1.text, h$2, M$1 ? Ni : e$1), w$1(t$1.text, _$2, F$1 ? Ni : e$1);
							const i$2 = D$1.text.isHidden(), { leftJustifiedTextSymbolIndex: o$2, centerJustifiedTextSymbolIndex: s$3, rightJustifiedTextSymbolIndex: r$2, verticalPlacedTextSymbolIndex: n$2 } = c$2, a$2 = t$1.text.placedSymbolArray, l$2 = i$2 || M$1 ? 1 : 0;
							o$2 >= 0 && (a$2.get(o$2).hidden = l$2), s$3 >= 0 && (a$2.get(s$3).hidden = l$2), r$2 >= 0 && (a$2.get(r$2).hidden = l$2), n$2 >= 0 && (a$2.get(n$2).hidden = i$2 || F$1 ? 1 : 0);
							const d$2 = this.variableOffsets[p$2];
							d$2 && this.markUsedJustification(t$1, d$2.anchor, c$2, z$1);
							const u$2 = this.placedOrientations[p$2];
							u$2 && (this.markUsedJustification(t$1, "left", c$2, u$2), this.markUsedOrientation(t$1, u$2, c$2));
						}
						if (O$1) {
							const e$1 = B$1 ? Ni : ki(D$1.icon), { placedIconSymbolIndex: i$2, verticalPlacedIconSymbolIndex: o$2 } = c$2, s$3 = t$1.icon.placedSymbolArray, r$2 = D$1.icon.isHidden() ? 1 : 0;
							i$2 >= 0 && (w$1(t$1.icon, E$1, M$1 ? Ni : e$1), s$3.get(i$2).hidden = r$2), o$2 >= 0 && (w$1(t$1.icon, c$2.numVerticalIconVertices, F$1 ? Ni : e$1), s$3.get(o$2).hidden = r$2);
						}
						if (t$1.hasIconCollisionBoxData() || t$1.hasTextCollisionBoxData()) {
							const i$2 = t$1.collisionArrays[s$2];
							if (i$2) {
								let o$2 = new e.P(0, 0), s$3 = !0;
								if (i$2.textBox || i$2.verticalTextBox) {
									if (f$1) {
										const e$1 = this.variableOffsets[p$2];
										e$1 ? (o$2 = Ci(e$1.anchor, e$1.width, e$1.height, e$1.textOffset, e$1.textScale), m$1 && o$2._rotate(g$1 ? this.transform.angle : -this.transform.angle)) : s$3 = !1;
									}
									d$1 && (s$3 = !D$1.clipped), i$2.textBox && Li(t$1.textCollisionBox.collisionVertexArray, D$1.text.placed, !s$3 || M$1, A$1, y$1, o$2.x, o$2.y), i$2.verticalTextBox && Li(t$1.textCollisionBox.collisionVertexArray, D$1.text.placed, !s$3 || F$1, A$1, y$1, o$2.x, o$2.y);
								}
								const r$2 = s$3 && Boolean(!F$1 && i$2.verticalIconBox);
								i$2.iconBox && Li(t$1.iconCollisionBox.collisionVertexArray, D$1.icon.placed, r$2, A$1, y$1, c$2.hasIconTextFit ? o$2.x : 0, c$2.hasIconTextFit ? o$2.y : 0), i$2.verticalIconBox && Li(t$1.iconCollisionBox.collisionVertexArray, D$1.icon.placed, !r$2, A$1, y$1, c$2.hasIconTextFit ? o$2.x : 0, c$2.hasIconTextFit ? o$2.y : 0);
							}
						}
					}
					if (t$1.fullyClipped = 0 === T$1, t$1.sortFeatures(this.transform.angle), this.retainedQueryData[t$1.bucketInstanceId] && (this.retainedQueryData[t$1.bucketInstanceId].featureSortOrder = t$1.featureSortOrder), t$1.hasTextData() && t$1.text.opacityVertexBuffer && t$1.text.opacityVertexBuffer.updateData(t$1.text.opacityVertexArray), t$1.hasIconData() && t$1.icon.opacityVertexBuffer && t$1.icon.opacityVertexBuffer.updateData(t$1.icon.opacityVertexArray), t$1.hasIconCollisionBoxData() && t$1.iconCollisionBox.collisionVertexBuffer && t$1.iconCollisionBox.collisionVertexBuffer.updateData(t$1.iconCollisionBox.collisionVertexArray), t$1.hasTextCollisionBoxData() && t$1.textCollisionBox.collisionVertexBuffer && t$1.textCollisionBox.collisionVertexBuffer.updateData(t$1.textCollisionBox.collisionVertexArray), t$1.bucketInstanceId in this.collisionCircleArrays) {
						const e$1 = this.collisionCircleArrays[t$1.bucketInstanceId];
						t$1.placementInvProjMatrix = e$1.invProjMatrix, t$1.placementViewportMatrix = e$1.viewportMatrix, t$1.collisionCircleArray = e$1.circles, delete this.collisionCircleArrays[t$1.bucketInstanceId];
					}
				}
				symbolFadeChange(e$1) {
					return 0 === this.fadeDuration ? 1 : (e$1 - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;
				}
				zoomAdjustment(e$1) {
					return Math.max(0, (this.transform.zoom - e$1) / 1.5);
				}
				hasTransitions(e$1) {
					return this.stale || e$1 - this.lastPlacementChangeTime < this.fadeDuration;
				}
				stillRecent(e$1, t$1) {
					const i$1 = this.zoomAtLastRecencyCheck === t$1 ? 1 - this.zoomAdjustment(t$1) : 1;
					return this.zoomAtLastRecencyCheck = t$1, this.commitTime + this.fadeDuration * i$1 > e$1;
				}
				isStale() {
					return this.stale;
				}
				setStale() {
					this.stale = !0;
				}
			}
			function Li(e$1, t$1, i$1, o$1, s$1, r$1, n$1) {
				e$1.emplaceBack(t$1 ? 1 : 0, i$1 ? 1 : 0, r$1 || 0, n$1 || 0, o$1, s$1 ? 1 : 0), e$1.emplaceBack(t$1 ? 1 : 0, i$1 ? 1 : 0, r$1 || 0, n$1 || 0, o$1, s$1 ? 1 : 0), e$1.emplaceBack(t$1 ? 1 : 0, i$1 ? 1 : 0, r$1 || 0, n$1 || 0, o$1, s$1 ? 1 : 0), e$1.emplaceBack(t$1 ? 1 : 0, i$1 ? 1 : 0, r$1 || 0, n$1 || 0, o$1, s$1 ? 1 : 0);
			}
			const Di = Math.pow(2, 25), Pi = Math.pow(2, 24), Oi = Math.pow(2, 17), zi = Math.pow(2, 16), Mi = Math.pow(2, 9), Fi = Math.pow(2, 8), Bi = Math.pow(2, 1);
			function ki(e$1) {
				if (0 === e$1.opacity && !e$1.placed) return 0;
				if (1 === e$1.opacity && e$1.placed) return 4294967295;
				const t$1 = e$1.placed ? 1 : 0, i$1 = Math.floor(127 * e$1.opacity);
				return i$1 * Di + t$1 * Pi + i$1 * Oi + t$1 * zi + i$1 * Mi + t$1 * Fi + i$1 * Bi + t$1;
			}
			const Ni = 0;
			class Ui {
				constructor(e$1) {
					this._sortAcrossTiles = "viewport-y" !== e$1.layout.get("symbol-z-order") && void 0 !== e$1.layout.get("symbol-sort-key").constantOr(1), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = /* @__PURE__ */ new Set(), this._bucketParts = [];
				}
				continuePlacement(e$1, t$1, i$1, o$1, s$1, r$1) {
					const n$1 = this._bucketParts;
					for (; this._currentTileIndex < e$1.length;) if (t$1.getBucketParts(n$1, o$1, e$1[this._currentTileIndex], this._sortAcrossTiles, r$1), this._currentTileIndex++, s$1()) return !0;
					for (this._sortAcrossTiles && (this._sortAcrossTiles = !1, n$1.sort(((e$2, t$2) => e$2.sortKey - t$2.sortKey))); this._currentPartIndex < n$1.length;) {
						const e$2 = n$1[this._currentPartIndex];
						if (t$1.placeLayerBucketPart(e$2, this._seenCrossTileIDs, i$1, 0 === e$2.symbolInstanceStart, r$1), this._currentPartIndex++, s$1()) return !0;
					}
					return !1;
				}
			}
			class ji {
				constructor(e$1, t$1, i$1, o$1, s$1, r$1, n$1, a$1, l$1) {
					this.placement = new Ai(e$1, s$1, r$1, n$1, a$1, l$1), this._currentPlacementIndex = t$1.length - 1, this._forceFullPlacement = i$1, this._showCollisionBoxes = o$1, this._done = !1;
				}
				isDone() {
					return this._done;
				}
				continuePlacement(t$1, i$1, o$1, s$1, r$1) {
					const n$1 = e.o.now(), a$1 = () => {
						const t$2 = e.o.now() - n$1;
						return !this._forceFullPlacement && t$2 > 2;
					};
					for (; this._currentPlacementIndex >= 0;) {
						const n$2 = i$1[t$1[this._currentPlacementIndex]], l$1 = this.placement.collisionIndex.transform.zoom;
						if ("symbol" === n$2.type && "none" !== n$2.visibility && (!n$2.minzoom || n$2.minzoom <= l$1) && (!n$2.maxzoom || n$2.maxzoom > l$1)) {
							const t$2 = n$2, i$2 = t$2.layout.get("symbol-z-elevate"), l$2 = void 0 !== t$2.layout.get("symbol-sort-key").constantOr(1), c$1 = t$2.layout.get("symbol-z-order"), h$1 = "viewport-y" === c$1 || "auto" === c$1 && !("viewport-y" !== c$1 && l$2), d$1 = t$2.layout.get("text-allow-overlap") || t$2.layout.get("icon-allow-overlap") || t$2.layout.get("text-ignore-placement") || t$2.layout.get("icon-ignore-placement"), u$1 = h$1 && d$1, _$1 = this._inProgressLayer = this._inProgressLayer || new Ui(t$2), p$1 = e.B(n$2.source, n$2.scope);
							if (_$1.continuePlacement(i$2 || u$1 ? s$1[p$1] : o$1[p$1], this.placement, this._showCollisionBoxes, n$2, a$1, r$1)) return;
							delete this._inProgressLayer;
						}
						this._currentPlacementIndex--;
					}
					this._done = !0;
				}
				commit(e$1) {
					return this.placement.commit(e$1), this.placement;
				}
			}
			const Gi = 512 / e.al / 2;
			class Vi {
				constructor(t$1, i$1, o$1) {
					this.tileID = t$1, this.bucketInstanceId = o$1, this.index = new e.c4(i$1.length, 16, Int32Array), this.keys = [], this.crossTileIDs = [];
					const s$1 = t$1.canonical.x * e.al, r$1 = t$1.canonical.y * e.al;
					for (let e$1 = 0; e$1 < i$1.length; e$1++) {
						const { key: t$2, crossTileID: o$2, tileAnchorX: n$1, tileAnchorY: a$1 } = i$1.get(e$1), l$1 = Math.floor((s$1 + n$1) * Gi), c$1 = Math.floor((r$1 + a$1) * Gi);
						this.index.add(l$1, c$1), this.keys.push(t$2), this.crossTileIDs.push(o$2);
					}
					this.index.finish();
				}
				findMatches(t$1, i$1, o$1) {
					const s$1 = this.tileID.canonical.z < i$1.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - i$1.canonical.z), r$1 = Gi / Math.pow(2, i$1.canonical.z - this.tileID.canonical.z), n$1 = i$1.canonical.x * e.al, a$1 = i$1.canonical.y * e.al;
					for (let e$1 = 0; e$1 < t$1.length; e$1++) {
						const i$2 = t$1.get(e$1);
						if (i$2.crossTileID) continue;
						const { key: l$1, tileAnchorX: c$1, tileAnchorY: h$1 } = i$2, d$1 = Math.floor((n$1 + c$1) * r$1), u$1 = Math.floor((a$1 + h$1) * r$1), _$1 = this.index.range(d$1 - s$1, u$1 - s$1, d$1 + s$1, u$1 + s$1).sort(((e$2, t$2) => e$2 - t$2));
						for (const e$2 of _$1) {
							const t$2 = this.crossTileIDs[e$2];
							if (this.keys[e$2] === l$1 && !o$1.has(t$2)) {
								o$1.add(t$2), i$2.crossTileID = t$2;
								break;
							}
						}
					}
				}
			}
			class Hi {
				constructor() {
					this.maxCrossTileID = 0;
				}
				generate() {
					return ++this.maxCrossTileID;
				}
			}
			class qi {
				constructor() {
					this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;
				}
				handleWrapJump(e$1) {
					const t$1 = Math.round((e$1 - this.lng) / 360);
					if (0 !== t$1) for (const e$2 in this.indexes) {
						const i$1 = this.indexes[e$2], o$1 = {};
						for (const e$3 in i$1) {
							const s$1 = i$1[e$3];
							s$1.tileID = s$1.tileID.unwrapTo(s$1.tileID.wrap + t$1), o$1[s$1.tileID.key] = s$1;
						}
						this.indexes[e$2] = o$1;
					}
					this.lng = e$1;
				}
				addBucket(e$1, t$1, i$1) {
					if (this.indexes[e$1.overscaledZ] && this.indexes[e$1.overscaledZ][e$1.key]) {
						if (this.indexes[e$1.overscaledZ][e$1.key].bucketInstanceId === t$1.bucketInstanceId) return !1;
						this.removeBucketCrossTileIDs(e$1.overscaledZ, this.indexes[e$1.overscaledZ][e$1.key]);
					}
					for (let e$2 = 0; e$2 < t$1.symbolInstances.length; e$2++) t$1.symbolInstances.get(e$2).crossTileID = 0;
					this.usedCrossTileIDs[e$1.overscaledZ] || (this.usedCrossTileIDs[e$1.overscaledZ] = /* @__PURE__ */ new Set());
					const o$1 = this.usedCrossTileIDs[e$1.overscaledZ];
					for (const i$2 in this.indexes) {
						const s$1 = this.indexes[i$2];
						if (Number(i$2) > e$1.overscaledZ) for (const i$3 in s$1) {
							const r$1 = s$1[i$3];
							r$1.tileID.isChildOf(e$1) && r$1.findMatches(t$1.symbolInstances, e$1, o$1);
						}
						else {
							const r$1 = s$1[e$1.scaledTo(Number(i$2)).key];
							r$1 && r$1.findMatches(t$1.symbolInstances, e$1, o$1);
						}
					}
					for (let e$2 = 0; e$2 < t$1.symbolInstances.length; e$2++) {
						const s$1 = t$1.symbolInstances.get(e$2);
						s$1.crossTileID || (s$1.crossTileID = i$1.generate(), o$1.add(s$1.crossTileID));
					}
					return void 0 === this.indexes[e$1.overscaledZ] && (this.indexes[e$1.overscaledZ] = {}), this.indexes[e$1.overscaledZ][e$1.key] = new Vi(e$1, t$1.symbolInstances, t$1.bucketInstanceId), !0;
				}
				removeBucketCrossTileIDs(e$1, t$1) {
					for (const i$1 of t$1.crossTileIDs) this.usedCrossTileIDs[e$1].delete(i$1);
				}
				removeStaleBuckets(e$1) {
					let t$1 = !1;
					for (const i$1 in this.indexes) {
						const o$1 = this.indexes[i$1];
						for (const s$1 in o$1) e$1[o$1[s$1].bucketInstanceId] || (this.removeBucketCrossTileIDs(i$1, o$1[s$1]), delete o$1[s$1], t$1 = !0);
					}
					return t$1;
				}
			}
			class Zi {
				constructor() {
					this.layerIndexes = {}, this.crossTileIDs = new Hi(), this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};
				}
				addLayer(e$1, t$1, i$1, o$1) {
					let s$1 = this.layerIndexes[e$1.fqid];
					void 0 === s$1 && (s$1 = this.layerIndexes[e$1.fqid] = new qi());
					let r$1 = !1;
					const n$1 = {};
					"globe" !== o$1.name && s$1.handleWrapJump(i$1);
					for (const i$2 of t$1) {
						const t$2 = i$2.getBucket(e$1);
						t$2 && e$1.fqid === t$2.layerIds[0] && (t$2.bucketInstanceId || (t$2.bucketInstanceId = ++this.maxBucketInstanceId), s$1.addBucket(i$2.tileID, t$2, this.crossTileIDs) && (r$1 = !0), n$1[t$2.bucketInstanceId] = !0);
					}
					return s$1.removeStaleBuckets(n$1) && (r$1 = !0), r$1;
				}
				pruneUnusedLayers(e$1) {
					const t$1 = {};
					e$1.forEach(((e$2) => {
						t$1[e$2] = !0;
					}));
					for (const e$2 in this.layerIndexes) t$1[e$2] || delete this.layerIndexes[e$2];
				}
			}
			const Wi = 771;
			class $i {
				constructor(e$1, t$1, i$1, o$1) {
					this.blendFunction = e$1, this.blendColor = t$1.toNonPremultipliedRenderColor(null), this.mask = i$1, this.blendEquation = o$1;
				}
			}
			$i.Replace = [
				1,
				0,
				1,
				0
			], $i.disabled = new $i($i.Replace, e.ao.transparent, [
				!1,
				!1,
				!1,
				!1
			]), $i.unblended = new $i($i.Replace, e.ao.transparent, [
				!0,
				!0,
				!0,
				!0
			]), $i.alphaBlended = new $i([
				1,
				Wi,
				1,
				Wi
			], e.ao.transparent, [
				!0,
				!0,
				!0,
				!0
			]), $i.alphaBlendedNonPremultiplied = new $i([
				770,
				Wi,
				770,
				Wi
			], e.ao.transparent, [
				!0,
				!0,
				!0,
				!0
			]), $i.multiply = new $i([
				774,
				0,
				774,
				0
			], e.ao.transparent, [
				!0,
				!0,
				!0,
				!0
			]), $i.additive = new $i([
				1,
				1,
				1,
				1
			], e.ao.transparent, [
				!0,
				!0,
				!0,
				!0
			]);
			class Xi {
				constructor(e$1, t$1, i$1) {
					this.func = e$1, this.mask = t$1, this.range = i$1;
				}
			}
			Xi.ReadOnly = !1, Xi.ReadWrite = !0, Xi.disabled = new Xi(519, Xi.ReadOnly, [0, 1]);
			const Yi = 7680;
			class Ki {
				constructor(e$1, t$1, i$1, o$1, s$1, r$1) {
					this.test = e$1, this.ref = t$1, this.mask = i$1, this.fail = o$1, this.depthFail = s$1, this.pass = r$1;
				}
			}
			Ki.disabled = new Ki({
				func: 519,
				mask: 0
			}, 0, 0, Yi, Yi, Yi);
			const Ji = 1029, Qi = 2305;
			class eo {
				constructor(e$1, t$1, i$1) {
					this.enable = e$1, this.mode = t$1, this.frontFace = i$1;
				}
			}
			function to(t$1, i$1) {
				const o$1 = e.ca(t$1, 3);
				e.cc(t$1, i$1), e.cg(t$1, 3, o$1);
			}
			function io(t$1, i$1) {
				const o$1 = e.c7([]);
				return e.c8(o$1, o$1, -i$1), e.c9(o$1, o$1, -t$1), o$1;
			}
			function oo(t$1, i$1) {
				const o$1 = [
					t$1[0],
					t$1[1],
					0
				], s$1 = [
					i$1[0],
					i$1[1],
					0
				];
				if (e.ag(o$1) >= 1e-15) {
					const t$2 = e.aw([], o$1);
					e.c5(s$1, t$2, e.bJ(s$1, t$2)), i$1[0] = s$1[0], i$1[1] = s$1[1];
				}
				const r$1 = e.bI([], i$1, t$1);
				if (e.c6(r$1) < 1e-15) return null;
				const n$1 = Math.atan2(-r$1[1], r$1[0]);
				return io(Math.atan2(Math.sqrt(t$1[0] * t$1[0] + t$1[1] * t$1[1]), -t$1[2]), n$1);
			}
			eo.disabled = new eo(!1, Ji, Qi), eo.backCCW = new eo(!0, Ji, Qi), eo.backCW = new eo(!0, Ji, 2304), eo.frontCW = new eo(!0, 1028, 2304), eo.frontCCW = new eo(!0, 1028, Qi);
			class so {
				constructor(e$1, t$1) {
					this.position = e$1, this.orientation = t$1;
				}
				get position() {
					return this._position;
				}
				set position(t$1) {
					if (t$1) {
						const i$1 = t$1 instanceof e.ae ? t$1 : new e.ae(t$1[0], t$1[1], t$1[2]);
						this._renderWorldCopies && (i$1.x = e.bT(i$1.x, 0, 1)), this._position = i$1;
					} else this._position = null;
				}
				lookAtPoint(t$1, i$1, o$1) {
					if (this.orientation = null, !this.position) return;
					const s$1 = this.position, r$1 = o$1 || (this._elevation ? this._elevation.getAtPointOrZero(e.ae.fromLngLat(t$1)) : 0), n$1 = e.ae.fromLngLat(t$1, r$1), a$1 = [
						n$1.x - s$1.x,
						n$1.y - s$1.y,
						n$1.z - s$1.z
					];
					i$1 || (i$1 = [
						0,
						0,
						1
					]), i$1[2] = Math.abs(i$1[2]), this.orientation = oo(a$1, i$1);
				}
				setPitchBearing(t$1, i$1) {
					this.orientation = io(e.an(t$1), e.an(-i$1));
				}
			}
			class ro {
				constructor(t$1, i$1) {
					this._transform = e.bA([]), this.orientation = i$1, this.position = t$1;
				}
				get mercatorPosition() {
					const t$1 = this.position;
					return new e.ae(t$1[0], t$1[1], t$1[2]);
				}
				get position() {
					const t$1 = e.ca(this._transform, 3);
					return [
						t$1[0],
						t$1[1],
						t$1[2]
					];
				}
				set position(t$1) {
					var i$1;
					t$1 && e.cg(this._transform, 3, [
						(i$1 = t$1)[0],
						i$1[1],
						i$1[2],
						1
					]);
				}
				get orientation() {
					return this._orientation;
				}
				set orientation(t$1) {
					this._orientation = t$1 || e.c7([]), t$1 && to(this._transform, this._orientation);
				}
				getPitchBearing() {
					const e$1 = this.forward(), t$1 = this.right();
					return {
						bearing: Math.atan2(-t$1[1], t$1[0]),
						pitch: Math.atan2(Math.sqrt(e$1[0] * e$1[0] + e$1[1] * e$1[1]), -e$1[2])
					};
				}
				setPitchBearing(e$1, t$1) {
					this._orientation = io(e$1, t$1), to(this._transform, this._orientation);
				}
				forward() {
					const t$1 = e.ca(this._transform, 2);
					return [
						-t$1[0],
						-t$1[1],
						-t$1[2]
					];
				}
				up() {
					const t$1 = e.ca(this._transform, 1);
					return [
						-t$1[0],
						-t$1[1],
						-t$1[2]
					];
				}
				right() {
					const t$1 = e.ca(this._transform, 0);
					return [
						t$1[0],
						t$1[1],
						t$1[2]
					];
				}
				getCameraToWorld(t$1, i$1) {
					const o$1 = new Float64Array(16);
					return e.bl(o$1, this.getWorldToCamera(t$1, i$1)), o$1;
				}
				getCameraToWorldMercator() {
					return this._transform;
				}
				getWorldToCameraPosition(t$1, i$1, o$1) {
					const s$1 = this.position;
					e.c5(s$1, s$1, -t$1);
					const r$1 = new Float64Array(16);
					return e.bq(r$1, [
						o$1,
						o$1,
						o$1
					]), e.br(r$1, r$1, s$1), r$1[10] *= i$1, r$1;
				}
				getWorldToCamera(t$1, i$1) {
					const o$1 = new Float64Array(16), s$1 = new Float64Array(4), r$1 = this.position;
					return e.cb(s$1, this._orientation), e.c5(r$1, r$1, -t$1), e.cc(o$1, s$1), e.br(o$1, o$1, r$1), o$1[1] *= -1, o$1[5] *= -1, o$1[9] *= -1, o$1[13] *= -1, o$1[8] *= i$1, o$1[9] *= i$1, o$1[10] *= i$1, o$1[11] *= i$1, o$1;
				}
				getCameraToClipPerspective(t$1, i$1, o$1, s$1) {
					const r$1 = new Float64Array(16);
					return e.cd(r$1, t$1, i$1, o$1, s$1), r$1;
				}
				getCameraToClipOrthographic(t$1, i$1, o$1, s$1, r$1, n$1) {
					const a$1 = new Float64Array(16);
					return e.ce(a$1, t$1, i$1, o$1, s$1, r$1, n$1), a$1;
				}
				getDistanceToElevation(t$1, i$1 = !1) {
					const o$1 = 0 === t$1 ? 0 : e.cf(t$1, i$1 ? e.a$(this.position[1]) : this.position[1]), s$1 = this.forward();
					return (o$1 - this.position[2]) / s$1[2];
				}
				clone() {
					return new ro([...this.position], [...this.orientation]);
				}
			}
			const no = {
				BaseColor: 5,
				MetallicRoughness: 6,
				Normal: 7,
				Occlusion: 8,
				Emission: 9,
				LUT: 10,
				ShadowMap0: 11
			};
			class ao {
				constructor(e$1 = 0, t$1 = 0, i$1 = 0, o$1 = 0) {
					if (isNaN(e$1) || e$1 < 0 || isNaN(t$1) || t$1 < 0 || isNaN(i$1) || i$1 < 0 || isNaN(o$1) || o$1 < 0) throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
					this.top = e$1, this.bottom = t$1, this.left = i$1, this.right = o$1;
				}
				interpolate(t$1, i$1, o$1) {
					return null != i$1.top && null != t$1.top && (this.top = e.ak(t$1.top, i$1.top, o$1)), null != i$1.bottom && null != t$1.bottom && (this.bottom = e.ak(t$1.bottom, i$1.bottom, o$1)), null != i$1.left && null != t$1.left && (this.left = e.ak(t$1.left, i$1.left, o$1)), null != i$1.right && null != t$1.right && (this.right = e.ak(t$1.right, i$1.right, o$1)), this;
				}
				getCenter(t$1, i$1) {
					const o$1 = e.aA((this.left + t$1 - this.right) / 2, 0, t$1), s$1 = e.aA((this.top + i$1 - this.bottom) / 2, 0, i$1);
					return new e.P(o$1, s$1);
				}
				equals(e$1) {
					return this.top === e$1.top && this.bottom === e$1.bottom && this.left === e$1.left && this.right === e$1.right;
				}
				clone() {
					return new ao(this.top, this.bottom, this.left, this.right);
				}
				toJSON() {
					return {
						top: this.top,
						bottom: this.bottom,
						left: this.left,
						right: this.right
					};
				}
			}
			const lo = 15;
			class co {
				constructor(t$1, i$1, o$1, s$1, r$1, n$1, a$1) {
					this.tileSize = 512, this._renderWorldCopies = void 0 === r$1 || r$1, this._minZoom = t$1 || 0, this._maxZoom = i$1 || 22, this._minPitch = o$1 ?? 0, this._maxPitch = s$1 ?? 60, this.setProjection(n$1), this.setMaxBounds(a$1), this.width = 0, this.height = 0, this._center = new e.aT(0, 0), this.zoom = 0, this.angle = 0, this._fov = .6435011087932844, this._pitch = 0, this._nearZ = 0, this._farZ = 0, this._unmodified = !0, this._edgeInsets = new ao(), this._projMatrixCache = {}, this._alignedProjMatrixCache = {}, this._fogTileMatrixCache = {}, this._expandedProjMatrixCache = {}, this._distanceTileDataCache = {}, this._camera = new ro(), this._centerAltitude = 0, this._averageElevation = 0, this.cameraElevationReference = "ground", this._pixelsPerMercatorPixel = 1, this.globeRadius = 0, this.globeCenterInViewSpace = [
						0,
						0,
						0
					], this._tileCoverLift = 0, this.freezeTileCoverage = !1, this._horizonShift = .1, this._orthographicProjectionAtLowPitch = !1, this._allowWorldUnderZoom = !1;
				}
				clone() {
					const e$1 = new co(this._minZoom, this._maxZoom, this._minPitch, this.maxPitch, this._renderWorldCopies, this.getProjection(), this.maxBounds);
					return e$1._elevation = this._elevation, e$1._centerAltitude = this._centerAltitude, e$1._centerAltitudeValidForExaggeration = this._centerAltitudeValidForExaggeration, e$1.tileSize = this.tileSize, e$1.mercatorFromTransition = this.mercatorFromTransition, e$1.width = this.width, e$1.height = this.height, e$1.cameraElevationReference = this.cameraElevationReference, e$1._center = this._center, e$1._setZoom(this.zoom), e$1._seaLevelZoom = this._seaLevelZoom, e$1.angle = this.angle, e$1._fov = this._fov, e$1._pitch = this._pitch, e$1._nearZ = this._nearZ, e$1._farZ = this._farZ, e$1._averageElevation = this._averageElevation, e$1._orthographicProjectionAtLowPitch = this._orthographicProjectionAtLowPitch, e$1._unmodified = this._unmodified, e$1._edgeInsets = this._edgeInsets.clone(), e$1._camera = this._camera.clone(), e$1._calcMatrices(), e$1.freezeTileCoverage = this.freezeTileCoverage, e$1.frustumCorners = this.frustumCorners, e$1._allowWorldUnderZoom = this._allowWorldUnderZoom, e$1;
				}
				get isOrthographic() {
					return "globe" !== this.projection.name && this._orthographicProjectionAtLowPitch && this.pitch < lo;
				}
				get elevation() {
					return this._elevation;
				}
				set elevation(e$1) {
					this._elevation !== e$1 && (this._elevation = e$1, this._updateCameraOnTerrain(), this._calcMatrices());
				}
				get depthOcclusionForSymbolsAndCircles() {
					return "globe" !== this.projection.name && !this.isOrthographic;
				}
				updateElevation(e$1, t$1 = !1) {
					const i$1 = this._elevation && this._elevation.exaggeration() !== this._centerAltitudeValidForExaggeration;
					(null == this._seaLevelZoom || i$1) && this._updateCameraOnTerrain(), (e$1 || i$1) && this._constrainCamera(t$1), this._calcMatrices();
				}
				getProjection() {
					return e.aH(this.projection, [
						"name",
						"center",
						"parallels"
					]);
				}
				setProjection(t$1) {
					this.projectionOptions = t$1 || { name: "mercator" };
					const i$1 = this.projection ? this.getProjection() : void 0;
					this.projection = e.cm(this.projectionOptions);
					const o$1 = this.getProjection(), s$1 = !e.by(i$1, o$1);
					return s$1 && this._calcMatrices(), this.mercatorFromTransition = !1, s$1;
				}
				setOrthographicProjectionAtLowPitch(e$1) {
					return this._orthographicProjectionAtLowPitch !== e$1 && (this._orthographicProjectionAtLowPitch = e$1, this._calcMatrices(), !0);
				}
				setMercatorFromTransition() {
					const t$1 = this.projection.name;
					this.mercatorFromTransition = !0, this.projectionOptions = { name: "mercator" }, this.projection = e.cm({ name: "mercator" });
					const i$1 = t$1 !== this.projection.name;
					return i$1 && this._calcMatrices(), i$1;
				}
				get minZoom() {
					return this._minZoom;
				}
				set minZoom(e$1) {
					this._minZoom !== e$1 && (this._minZoom = e$1, this.zoom = Math.max(this.zoom, e$1));
				}
				get maxZoom() {
					return this._maxZoom;
				}
				set maxZoom(e$1) {
					this._maxZoom !== e$1 && (this._maxZoom = e$1, this.zoom = Math.min(this.zoom, e$1));
				}
				get minPitch() {
					return this._minPitch;
				}
				set minPitch(e$1) {
					this._minPitch !== e$1 && (this._minPitch = e$1, this.pitch = Math.max(this.pitch, e$1));
				}
				get maxPitch() {
					return this._maxPitch;
				}
				set maxPitch(e$1) {
					this._maxPitch !== e$1 && (this._maxPitch = e$1, this.pitch = Math.min(this.pitch, e$1));
				}
				get renderWorldCopies() {
					return this._renderWorldCopies && !0 === this.projection.supportsWorldCopies;
				}
				set renderWorldCopies(e$1) {
					void 0 === e$1 ? e$1 = !0 : null === e$1 && (e$1 = !1), this._renderWorldCopies = e$1;
				}
				get worldSize() {
					return this.tileSize * this.scale;
				}
				get cameraWorldSizeForFog() {
					const e$1 = Math.max(this._camera.getDistanceToElevation(this._averageElevation), Number.EPSILON);
					return this._worldSizeFromZoom(this._zoomFromMercatorZ(e$1));
				}
				get cameraWorldSize() {
					const e$1 = Math.max(this._camera.getDistanceToElevation(this._averageElevation, !0), Number.EPSILON);
					return this._worldSizeFromZoom(this._zoomFromMercatorZ(e$1));
				}
				get pixelsPerMeter() {
					return this.projection.pixelsPerMeter(this.center.lat, this.worldSize);
				}
				get cameraPixelsPerMeter() {
					return e.cf(1, this.center.lat) * this.cameraWorldSizeForFog;
				}
				get centerOffset() {
					return this.centerPoint._sub(this.size._div(2));
				}
				get size() {
					return new e.P(this.width, this.height);
				}
				get bearing() {
					return e.bT(this.rotation, -180, 180);
				}
				set bearing(e$1) {
					this.rotation = e$1;
				}
				get rotation() {
					return -this.angle / Math.PI * 180;
				}
				set rotation(t$1) {
					const i$1 = -t$1 * Math.PI / 180;
					this.angle !== i$1 && (this._unmodified = !1, this.angle = i$1, this._calcMatrices(), this.rotationMatrix = e.cn(), e.co(this.rotationMatrix, this.rotationMatrix, this.angle));
				}
				get pitch() {
					return this._pitch / Math.PI * 180;
				}
				set pitch(t$1) {
					const i$1 = e.aA(t$1, this.minPitch, this.maxPitch) / 180 * Math.PI;
					this._pitch !== i$1 && (this._unmodified = !1, this._pitch = i$1, this._calcMatrices());
				}
				get aspect() {
					return this.width / this.height;
				}
				get fov() {
					return this._fov / Math.PI * 180;
				}
				set fov(t$1) {
					t$1 = Math.max(.01, Math.min(60, t$1)), this._fov !== t$1 && (this._unmodified = !1, this._fov = e.an(t$1), this._calcMatrices());
				}
				get fovX() {
					return this._fov;
				}
				get fovY() {
					const e$1 = 1 / Math.tan(.5 * this.fovX);
					return 2 * Math.atan(1 / this.aspect / e$1);
				}
				get averageElevation() {
					return this._averageElevation;
				}
				set averageElevation(e$1) {
					this._averageElevation = e$1, this._calcFogMatrices(), this._distanceTileDataCache = {};
				}
				get zoom() {
					return this._zoom;
				}
				set zoom(e$1) {
					const t$1 = Math.min(Math.max(e$1, this.minZoom), this.maxZoom);
					this._zoom !== t$1 && (this._unmodified = !1, this._setZoom(t$1), this._updateSeaLevelZoom(), this._constrain(), this._calcMatrices());
				}
				_setZoom(e$1) {
					this._zoom = e$1, this.scale = this.zoomScale(e$1), this.tileZoom = Math.floor(e$1), this.zoomFraction = e$1 - this.tileZoom;
				}
				get tileCoverLift() {
					return this._tileCoverLift;
				}
				set tileCoverLift(e$1) {
					this._tileCoverLift !== e$1 && (this._tileCoverLift = e$1);
				}
				_updateCameraOnTerrain() {
					const e$1 = this.elevation ? this.elevation.getAtPoint(this.locationCoordinate(this.center), Number.NEGATIVE_INFINITY) : Number.NEGATIVE_INFINITY, t$1 = this.elevation && e$1 === Number.NEGATIVE_INFINITY && this.elevation.visibleDemTiles.length > 0 && this.elevation.exaggeration() > 0 && this._centerAltitudeValidForExaggeration;
					if (!this._elevation || e$1 === Number.NEGATIVE_INFINITY && (!t$1 || !this._centerAltitude)) return this._centerAltitude = 0, this._seaLevelZoom = null, void (this._centerAltitudeValidForExaggeration = void 0);
					const i$1 = this._elevation;
					t$1 || this._centerAltitude && this._centerAltitudeValidForExaggeration && i$1.exaggeration() && this._centerAltitudeValidForExaggeration !== i$1.exaggeration() ? (this._centerAltitude = this._centerAltitude / this._centerAltitudeValidForExaggeration * i$1.exaggeration(), this._centerAltitudeValidForExaggeration = i$1.exaggeration()) : (this._centerAltitude = e$1 || 0, this._centerAltitudeValidForExaggeration = i$1.exaggeration()), this._updateSeaLevelZoom();
				}
				_updateSeaLevelZoom() {
					if (void 0 === this._centerAltitudeValidForExaggeration) return;
					const e$1 = Math.max(0, (this.pixelsPerMeter * this._centerAltitude + this.cameraToCenterDistance) / this.worldSize);
					this._seaLevelZoom = this._zoomFromMercatorZ(e$1);
				}
				sampleAverageElevation() {
					if (!this._elevation) return 0;
					const t$1 = this._elevation, i$1 = [
						[.5, .2],
						[.3, .5],
						[.5, .5],
						[.7, .5],
						[.5, .8]
					], o$1 = this.horizonLineFromTop();
					let s$1 = 0, r$1 = 0;
					for (let n$1 = 0; n$1 < i$1.length; n$1++) {
						const a$1 = new e.P(i$1[n$1][0] * this.width, o$1 + i$1[n$1][1] * (this.height - o$1)), l$1 = t$1.pointCoordinate(a$1);
						if (!l$1) continue;
						const c$1 = 1 / Math.hypot(l$1[0] - this._camera.position[0], l$1[1] - this._camera.position[1]);
						s$1 += l$1[3] * c$1, r$1 += c$1;
					}
					return 0 === r$1 ? NaN : s$1 / r$1;
				}
				get center() {
					return this._center;
				}
				set center(e$1) {
					e$1.lat === this._center.lat && e$1.lng === this._center.lng || (this._unmodified = !1, this._center = e$1, this._terrainEnabled() && ("ground" === this.cameraElevationReference ? this._updateCameraOnTerrain() : this._updateZoomFromElevation()), this._constrain(), this._calcMatrices());
				}
				_updateZoomFromElevation() {
					if (null == this._seaLevelZoom || !this._elevation) return;
					const e$1 = this._seaLevelZoom, t$1 = this._elevation.getAtPointOrZero(this.locationCoordinate(this.center)), i$1 = this.pixelsPerMeter / this.worldSize * t$1, o$1 = this._mercatorZfromZoom(e$1), s$1 = this._mercatorZfromZoom(this._maxZoom), r$1 = Math.max(o$1 - i$1, s$1);
					this._setZoom(this._zoomFromMercatorZ(r$1));
				}
				get padding() {
					return this._edgeInsets.toJSON();
				}
				set padding(e$1) {
					this._edgeInsets.equals(e$1) || (this._unmodified = !1, this._edgeInsets.interpolate(this._edgeInsets, e$1, 1), this._calcMatrices());
				}
				equals(e$1) {
					const t$1 = this.elevation, i$1 = e$1.elevation, o$1 = null != t$1 != (null != i$1) || t$1 && i$1 && t$1.exaggeration() !== i$1.exaggeration();
					return this.width === e$1.width && this.height === e$1.height && this.center.lng === e$1.center.lng && this.center.lat === e$1.center.lat && this.zoom === e$1.zoom && this.bearing === e$1.bearing && this.pitch === e$1.pitch && this.fov === e$1.fov && this.projection.name === e$1.projection.name && this._edgeInsets.equals(e$1.padding) && !o$1;
				}
				computeZoomRelativeTo(t$1) {
					const i$1 = this.rayIntersectionCoordinate(this.pointRayIntersection(this.centerPoint, t$1.toAltitude()));
					let o$1;
					o$1 = t$1.z < this._camera.position[2] ? [
						i$1.x,
						i$1.y,
						i$1.z
					] : [
						t$1.x,
						t$1.y,
						t$1.z
					];
					const s$1 = e.ag(e.av([], this._camera.position, o$1));
					return e.aA(this._zoomFromMercatorZ(s$1), this._minZoom, this._maxZoom);
				}
				setFreeCameraOptions(t$1) {
					if (!this.height) return;
					if (!t$1.position && !t$1.orientation) return;
					this._updateCameraState();
					let i$1 = !1;
					if (t$1.orientation && !e.cp(t$1.orientation, this._camera.orientation) && (i$1 = this._setCameraOrientation(t$1.orientation)), t$1.position) {
						const o$1 = [
							t$1.position.x,
							t$1.position.y,
							t$1.position.z
						];
						e.cq(o$1, this._camera.position) || (this._setCameraPosition(o$1), i$1 = !0);
					}
					i$1 && (this._updateStateFromCamera(), this.recenterOnTerrain());
				}
				getFreeCameraOptions() {
					this._updateCameraState();
					const t$1 = this._camera.position, i$1 = new so();
					return i$1.position = new e.ae(t$1[0], t$1[1], t$1[2]), i$1.orientation = this._camera.orientation, i$1._elevation = this.elevation, i$1._renderWorldCopies = this.renderWorldCopies, i$1;
				}
				_setCameraOrientation(t$1) {
					if (!e.cr(t$1)) return !1;
					e.cs(t$1, t$1);
					const i$1 = e.ct([], [
						0,
						0,
						-1
					], t$1), o$1 = e.ct([], [
						0,
						-1,
						0
					], t$1);
					if (o$1[2] < 0) return !1;
					const s$1 = oo(i$1, o$1);
					return !!s$1 && (this._camera.orientation = s$1, !0);
				}
				_setCameraPosition(t$1) {
					const i$1 = this.zoomScale(this.minZoom) * this.tileSize, o$1 = this.zoomScale(this.maxZoom) * this.tileSize, s$1 = this.cameraToCenterDistance;
					t$1[2] = e.aA(t$1[2], s$1 / o$1, s$1 / i$1), this._camera.position = t$1;
				}
				get centerPoint() {
					return this._edgeInsets.getCenter(this.width, this.height);
				}
				get fovAboveCenter() {
					return this._fov * (.5 + this.centerOffset.y / this.height);
				}
				isPaddingEqual(e$1) {
					return this._edgeInsets.equals(e$1);
				}
				interpolatePadding(e$1, t$1, i$1) {
					this._unmodified = !1, this._edgeInsets.interpolate(e$1, t$1, i$1), this._constrain(), this._calcMatrices();
				}
				coveringZoomLevel(e$1) {
					const t$1 = (e$1.roundZoom ? Math.round : Math.floor)(this.zoom + this.scaleZoom(this.tileSize / e$1.tileSize));
					return Math.max(0, t$1);
				}
				getVisibleUnwrappedCoordinates(t$1) {
					const i$1 = [new e.cu(0, t$1)];
					if (this.renderWorldCopies) {
						const o$1 = this.pointCoordinate(new e.P(0, 0)), s$1 = this.pointCoordinate(new e.P(this.width, 0)), r$1 = this.pointCoordinate(new e.P(this.width, this.height)), n$1 = this.pointCoordinate(new e.P(0, this.height)), a$1 = Math.floor(Math.min(o$1.x, s$1.x, r$1.x, n$1.x)), l$1 = Math.floor(Math.max(o$1.x, s$1.x, r$1.x, n$1.x)), c$1 = 1;
						for (let o$2 = a$1 - c$1; o$2 <= l$1 + c$1; o$2++) 0 !== o$2 && i$1.push(new e.cu(o$2, t$1));
					}
					return i$1;
				}
				isLODDisabled(e$1) {
					return (!e$1 || this.pitch <= 60) && this._edgeInsets.top <= this._edgeInsets.bottom && !this._elevation && !this.projection.isReprojectedInTileSpace;
				}
				extendTileCover(t$1, i$1, o$1, s$1) {
					let r$1 = [];
					const n$1 = null != o$1, a$1 = !n$1;
					if (a$1 && this.zoom < i$1) return r$1;
					if (n$1 && 0 === o$1[0] && 0 === o$1[1]) return r$1;
					const l$1 = /* @__PURE__ */ new Set(), c$1 = (t$2, i$2, o$2, s$2, n$2) => {
						const a$2 = e.cY(i$2, t$2, o$2, s$2, n$2);
						l$1.has(a$2) || (r$1.push(new e.aQ(t$2, i$2, o$2, s$2, n$2)), l$1.add(a$2));
					};
					for (let e$1 = 0; e$1 < t$1.length; e$1++) {
						const r$2 = t$1[e$1];
						if (a$1 && r$2.canonical.z !== i$1) continue;
						if (n$1 && void 0 !== s$1 && s$1 > r$2.canonical.z) continue;
						const l$2 = r$2.canonical, h$2 = r$2.overscaledZ, d$1 = r$2.wrap, u$1 = 1 << l$2.z, _$1 = l$2.x + 1 < u$1, p$1 = l$2.x > 0, f$1 = l$2.y + 1 < u$1, m$1 = l$2.y > 0, g$1 = r$2.wrap - (p$1 ? 0 : 1), v$1 = r$2.wrap + (_$1 ? 0 : 1), y$1 = p$1 ? l$2.x - 1 : u$1 - 1, x$1 = _$1 ? l$2.x + 1 : 0;
						if (n$1) o$1[0] < 0 ? (c$1(h$2, v$1, l$2.z, x$1, l$2.y), o$1[1] < 0 && f$1 && (c$1(h$2, d$1, l$2.z, l$2.x, l$2.y + 1), c$1(h$2, v$1, l$2.z, x$1, l$2.y + 1)), o$1[1] > 0 && m$1 && (c$1(h$2, d$1, l$2.z, l$2.x, l$2.y - 1), c$1(h$2, v$1, l$2.z, x$1, l$2.y - 1))) : o$1[0] > 0 ? (c$1(h$2, g$1, l$2.z, y$1, l$2.y), o$1[1] < 0 && f$1 && (c$1(h$2, d$1, l$2.z, l$2.x, l$2.y + 1), c$1(h$2, g$1, l$2.z, y$1, l$2.y + 1)), o$1[1] > 0 && m$1 && (c$1(h$2, d$1, l$2.z, l$2.x, l$2.y - 1), c$1(h$2, g$1, l$2.z, y$1, l$2.y - 1))) : o$1[1] < 0 && f$1 ? c$1(h$2, d$1, l$2.z, l$2.x, l$2.y + 1) : m$1 && c$1(h$2, d$1, l$2.z, l$2.x, l$2.y - 1);
						else {
							const e$2 = r$2.visibleQuadrants;
							1 & e$2 && (c$1(h$2, g$1, l$2.z, y$1, l$2.y), m$1 && (c$1(h$2, d$1, l$2.z, l$2.x, l$2.y - 1), c$1(h$2, g$1, l$2.z, y$1, l$2.y - 1))), 2 & e$2 && (c$1(h$2, v$1, l$2.z, x$1, l$2.y), m$1 && (c$1(h$2, d$1, l$2.z, l$2.x, l$2.y - 1), c$1(h$2, v$1, l$2.z, x$1, l$2.y - 1))), 4 & e$2 && (c$1(h$2, g$1, l$2.z, y$1, l$2.y), f$1 && (c$1(h$2, d$1, l$2.z, l$2.x, l$2.y + 1), c$1(h$2, g$1, l$2.z, y$1, l$2.y + 1))), 8 & e$2 && (c$1(h$2, v$1, l$2.z, x$1, l$2.y), f$1 && (c$1(h$2, d$1, l$2.z, l$2.x, l$2.y + 1), c$1(h$2, v$1, l$2.z, x$1, l$2.y + 1)));
						}
					}
					const h$1 = [];
					for (const e$1 of r$1) r$1.some(((t$2) => e$1.isChildOf(t$2))) || h$1.push(e$1);
					if (r$1 = h$1.filter(((e$1) => !t$1.some(((t$2) => !!(e$1.overscaledZ < i$1 && t$2.isChildOf(e$1)) || e$1.equals(t$2) || e$1.isChildOf(t$2))))), a$1) {
						const e$1 = 1 << i$1, t$2 = "globe" === this.projection.name ? this._camera.mercatorPosition : this.pointCoordinate(this.getCameraPoint()), o$2 = [e$1 * t$2.x, e$1 * t$2.y], s$2 = 4, n$2 = s$2 * s$2;
						r$1 = r$1.filter(((e$2) => {
							const t$3 = e$2.canonical.x + .5 - o$2[0], i$2 = e$2.canonical.y + .5 - o$2[1];
							return t$3 * t$3 + i$2 * i$2 < n$2;
						}));
					}
					return r$1;
				}
				extendTileCoverToNearPlane(t$1, i$1, o$1) {
					const s$1 = [], r$1 = /* @__PURE__ */ new Set();
					for (const e$1 of t$1) r$1.add(e$1.key);
					const n$1 = (t$2, i$2, o$2, n$2, a$2) => {
						const l$2 = e.cY(i$2, t$2, o$2, n$2, a$2);
						r$1.has(l$2) || (s$1.push(new e.aQ(t$2, i$2, o$2, n$2, a$2)), r$1.add(l$2));
					}, a$1 = t$1.reduce(((e$1, t$2) => Math.max(e$1, t$2.overscaledZ)), o$1), l$1 = 1 << o$1, c$1 = [
						new e.P(0, 0),
						new e.P(e.al, 0),
						new e.P(e.al, e.al),
						new e.P(0, e.al)
					], h$1 = new e.P(0, 0), d$1 = new e.P(0, 0), u$1 = (t$2, i$2) => {
						const s$2 = Math.floor(t$2[0]), r$2 = Math.floor(t$2[1]), u$2 = (t$2[0] - s$2) * e.al, _$2 = (t$2[1] - r$2) * e.al, p$2 = Math.floor(i$2[0]), f$2 = Math.floor(i$2[1]), m$2 = (i$2[0] - p$2) * e.al, g$2 = (i$2[1] - f$2) * e.al;
						for (let t$3 = -1; t$3 <= 1; t$3++) {
							const i$3 = s$2 + t$3;
							if (!(i$3 < 0 || i$3 >= l$1)) {
								h$1.x = u$2 - t$3 * e.al, d$1.x = m$2 - (i$3 - p$2) * e.al;
								for (let t$4 = -1; t$4 <= 1; t$4++) {
									const s$3 = r$2 + t$4;
									h$1.y = _$2 - t$4 * e.al, d$1.y = g$2 - (s$3 - f$2) * e.al, e.cZ(h$1, d$1, c$1) && n$1(a$1, 0, o$1, i$3, s$3);
								}
							}
						}
					}, _$1 = i$1.points, p$1 = _$1[e.cv], f$1 = _$1[e.cw], m$1 = this._projectToGround(p$1, _$1[e.cx]), g$1 = this._projectToGround(f$1, _$1[e.cy]);
					return u$1(p$1, m$1), u$1(f$1, g$1), s$1;
				}
				_projectToGround(t$1, i$1) {
					return e.cz(e.cA(), t$1, i$1, t$1[2] / (t$1[2] - i$1[2]));
				}
				coveringTiles(t$1) {
					let i$1 = this.coveringZoomLevel(t$1);
					const o$1 = i$1, s$1 = this.elevation && this.elevation.exaggeration(), r$1 = s$1 && !t$1.isTerrainDEM, n$1 = "mercator" === this.projection.name;
					if (void 0 !== t$1.minzoom && i$1 < t$1.minzoom) return [];
					void 0 !== t$1.maxzoom && i$1 > t$1.maxzoom && (i$1 = t$1.maxzoom);
					const a$1 = this.locationCoordinate(this.center), l$1 = this.center.lat, c$1 = 1 << i$1, h$1 = [
						c$1 * a$1.x,
						c$1 * a$1.y,
						0
					], d$1 = "globe" === this.projection.name, u$1 = !d$1, _$1 = e.cB.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, i$1, u$1), p$1 = d$1 ? this._camera.mercatorPosition : this.pointCoordinate(this.getCameraPoint()), f$1 = c$1 * e.cf(1, this.center.lat), m$1 = this._camera.position[2] / e.cf(1, this.center.lat), g$1 = [
						c$1 * p$1.x,
						c$1 * p$1.y,
						m$1 * (u$1 ? 1 : f$1)
					], v$1 = d$1 || s$1, y$1 = this.cameraToCenterDistance / t$1.tileSize * (t$1.roundZoom ? 1 : .502), x$1 = this.isLODDisabled(!0) ? i$1 : 0;
					let b$1;
					if (this._elevation && t$1.isTerrainDEM) b$1 = 1e4 * this._elevation.exaggeration();
					else if (this._elevation) {
						const e$1 = this._elevation.getMinMaxForVisibleTiles();
						b$1 = e$1 ? e$1.max : this._centerAltitude;
					} else b$1 = this._centerAltitude;
					const w$1 = t$1.isTerrainDEM ? -b$1 : this._elevation ? this._elevation.getMinElevationBelowMSL() : 0, T$1 = this.projection.isReprojectedInTileSpace ? e.cC(this) : 1, E$1 = (t$2) => {
						const i$2 = 1 / 4e4, o$2 = new e.ae(t$2.x + i$2, t$2.y, t$2.z), s$2 = new e.ae(t$2.x, t$2.y + i$2, t$2.z), r$2 = t$2.toLngLat(), n$2 = o$2.toLngLat(), a$2 = s$2.toLngLat(), l$2 = this.locationCoordinate(r$2), c$2 = this.locationCoordinate(n$2), h$2 = this.locationCoordinate(a$2), d$2 = Math.hypot(c$2.x - l$2.x, c$2.y - l$2.y), u$2 = Math.hypot(h$2.x - l$2.x, h$2.y - l$2.y);
						return Math.sqrt(d$2 * u$2) * T$1 / i$2;
					}, S$1 = (t$2) => {
						const i$2 = b$1, o$2 = w$1;
						return {
							aabb: e.cF(this, c$1, 0, 0, 0, t$2, o$2, i$2, this.projection),
							zoom: 0,
							x: 0,
							y: 0,
							minZ: o$2,
							maxZ: i$2,
							wrap: t$2,
							fullyVisible: !1
						};
					}, I$1 = [];
					let C$1 = [];
					const R$1 = i$1, A$1 = t$1.reparseOverscaled ? o$1 : i$1, L$1 = (m$1 - this._centerAltitude) * f$1, D$1 = (e$1) => {
						if (!this._elevation || !e$1.tileID || !n$1) return;
						const t$2 = this._elevation.getMinMaxForTile(e$1.tileID), i$2 = e$1.aabb;
						t$2 ? (i$2.min[2] = t$2.min, i$2.max[2] = t$2.max, i$2.center[2] = (i$2.min[2] + i$2.max[2]) / 2) : (e$1.shouldSplit = O$1(e$1), e$1.shouldSplit || (i$2.min[2] = i$2.max[2] = i$2.center[2] = this._centerAltitude));
					}, P$1 = (e$1, t$2) => {
						if (.707 * t$2 < e$1) return 1;
						const i$2 = t$2 / e$1;
						return i$2 / (1.4144271570014144 + (Math.pow(1.1, i$2 - 1.4144271570014144 + 1) - 1) / .10000000000000009 - 1);
					}, O$1 = (t$2) => {
						if (t$2.zoom < x$1) return !0;
						if (t$2.zoom === R$1) return !1;
						if (null != t$2.shouldSplit) return t$2.shouldSplit;
						const i$2 = t$2.aabb.distanceX(g$1), s$2 = t$2.aabb.distanceY(g$1);
						let a$2 = L$1, c$2 = 1;
						if (d$1) {
							a$2 = t$2.aabb.distanceZ(g$1);
							const i$3 = Math.pow(2, t$2.zoom), o$2 = e.a$((t$2.y + 1) / i$3), s$3 = e.a$(t$2.y / i$3), r$2 = Math.min(Math.max(l$1, o$2), s$3), n$2 = e.d1(r$2) / e.d1(l$1);
							if (c$2 = r$2 === l$1 ? 1 / Math.max(1, this._mercatorScaleRatio - .3) : Math.min(1, n$2 / this._mercatorScaleRatio), this.zoom <= e.c_ && t$2.zoom === R$1 - 1 && n$2 >= .9) return !0;
						} else if (r$1 && (a$2 = t$2.aabb.distanceZ(g$1) * f$1), this.projection.isReprojectedInTileSpace && o$1 <= 5) {
							const i$3 = Math.pow(2, t$2.zoom), o$2 = E$1(new e.ae((t$2.x + .5) / i$3, (t$2.y + .5) / i$3));
							c$2 = o$2 > .85 ? 1 : o$2;
						}
						if (!n$1 && !d$1) {
							const e$1 = Math.sqrt(i$2 * i$2 + s$2 * s$2 + a$2 * a$2);
							let o$2 = (1 << R$1 - t$2.zoom) * y$1 * c$2;
							return o$2 *= P$1(Math.max(a$2, L$1), e$1), e$1 < o$2;
						}
						let u$2 = Number.MAX_VALUE, _$2 = 0;
						const p$2 = t$2.aabb.getCorners(), m$2 = [];
						for (const t$3 of p$2) {
							e.av(m$2, t$3, g$1), d$1 || (r$1 ? m$2[2] *= f$1 : m$2[2] = L$1);
							const i$3 = e.bJ(m$2, this._camera.forward());
							i$3 < u$2 && (u$2 = i$3, _$2 = Math.abs(m$2[2]));
						}
						let v$2 = (1 << R$1 - t$2.zoom) * y$1 * c$2;
						if (v$2 *= P$1(Math.max(_$2, L$1), u$2), u$2 < v$2) return !0;
						const b$2 = t$2.aabb.closestPoint(h$1);
						return b$2[0] === h$1[0] && b$2[1] === h$1[1];
					};
					if (this.renderWorldCopies) for (let e$1 = 1; e$1 <= 3; e$1++) I$1.push(S$1(-e$1)), I$1.push(S$1(e$1));
					for (I$1.push(S$1(0)); I$1.length > 0;) {
						const o$2 = I$1.pop(), s$2 = o$2.x, a$2 = o$2.y;
						let l$2 = o$2.fullyVisible;
						const u$2 = () => "globe" === this.projection.name && (0 === o$2.y || o$2.y === (1 << o$2.zoom) - 1);
						if (!l$2) {
							let t$2 = v$1 ? o$2.aabb.intersects(_$1) : o$2.aabb.intersectsFlat(_$1);
							if (0 === t$2 && u$2()) {
								const i$2 = new e.cD(o$2.zoom, s$2, a$2);
								t$2 = e.cE(this, c$1, i$2, !0).intersects(_$1);
							}
							if (0 === t$2) continue;
							l$2 = 2 === t$2;
						}
						if (o$2.zoom !== R$1 && O$1(o$2)) for (let t$2 = 0; t$2 < 4; t$2++) {
							const i$2 = (s$2 << 1) + t$2 % 2, h$2 = (a$2 << 1) + (t$2 >> 1), u$3 = {
								aabb: n$1 ? o$2.aabb.quadrant(t$2) : e.cF(this, c$1, o$2.zoom + 1, i$2, h$2, o$2.wrap, o$2.minZ, o$2.maxZ, this.projection),
								zoom: o$2.zoom + 1,
								x: i$2,
								y: h$2,
								wrap: o$2.wrap,
								fullyVisible: l$2,
								tileID: void 0,
								shouldSplit: void 0,
								minZ: o$2.minZ,
								maxZ: o$2.maxZ
							};
							r$1 && !d$1 && (u$3.tileID = new e.aQ(o$2.zoom + 1 === R$1 ? A$1 : o$2.zoom + 1, o$2.wrap, o$2.zoom + 1, i$2, h$2), D$1(u$3)), I$1.push(u$3);
						}
						else {
							const r$2 = o$2.zoom === R$1 ? A$1 : o$2.zoom;
							if (t$1.minzoom && t$1.minzoom > r$2) continue;
							let n$2 = 0;
							if (!l$2) {
								let i$2 = v$1 ? o$2.aabb.intersectsPrecise(_$1) : o$2.aabb.intersectsPreciseFlat(_$1);
								if (0 === i$2 && u$2()) {
									const t$2 = new e.cD(o$2.zoom, s$2, a$2);
									i$2 = e.cE(this, c$1, t$2, !0).intersectsPrecise(_$1);
								}
								if (0 === i$2) continue;
								if (t$1.calculateQuadrantVisibility) if (_$1.containsPoint(o$2.aabb.center)) n$2 = 15;
								else for (let e$1 = 0; e$1 < 4; e$1++) 0 !== o$2.aabb.quadrant(e$1).intersects(_$1) && (n$2 |= 1 << e$1);
							}
							const d$2 = h$1[0] - (.5 + s$2 + (o$2.wrap << o$2.zoom)) * (1 << i$1 - o$2.zoom), p$2 = h$1[1] - .5 - a$2, f$2 = o$2.tileID ? o$2.tileID : new e.aQ(r$2, o$2.wrap, o$2.zoom, s$2, a$2);
							t$1.calculateQuadrantVisibility && (f$2.visibleQuadrants = n$2), C$1.push({
								tileID: f$2,
								distanceSq: d$2 * d$2 + p$2 * p$2
							});
						}
					}
					if (this.fogCullDistSq) {
						const i$2 = this.fogCullDistSq, o$2 = this.horizonLineFromTop();
						C$1 = C$1.filter(((s$2) => {
							const r$2 = [
								0,
								0,
								0,
								1
							], n$2 = [
								e.al,
								e.al,
								0,
								1
							], a$2 = this.calculateFogTileMatrix(s$2.tileID.toUnwrapped());
							e.aC(r$2, r$2, a$2), e.aC(n$2, n$2, a$2);
							const l$2 = e.cG([], r$2, n$2), c$2 = e.cH([], r$2, n$2), h$2 = e.c$(l$2, c$2);
							if (0 === h$2) return !0;
							let d$2 = !1;
							const u$2 = this._elevation;
							if (u$2 && h$2 > i$2 && 0 !== o$2) {
								const i$3 = this.calculateProjMatrix(s$2.tileID.toUnwrapped());
								let r$3;
								t$1.isTerrainDEM || (r$3 = u$2.getMinMaxForTile(s$2.tileID)), r$3 || (r$3 = {
									min: w$1,
									max: b$1
								});
								const n$3 = e.cI(this.rotation), a$3 = [
									n$3[0] * e.al,
									n$3[1] * e.al,
									r$3.max
								];
								e.af(a$3, a$3, i$3), d$2 = (1 - a$3[1]) * this.height * .5 < o$2;
							}
							return h$2 < i$2 || d$2;
						}));
					}
					return C$1.sort(((e$1, t$2) => e$1.distanceSq - t$2.distanceSq)).map(((e$1) => e$1.tileID));
				}
				resize(e$1, t$1) {
					this.width = e$1, this.height = t$1, this.pixelsToGLUnits = [2 / e$1, -2 / t$1], this._constrain(), this._calcMatrices();
				}
				get unmodified() {
					return this._unmodified;
				}
				zoomScale(e$1) {
					return Math.pow(2, e$1);
				}
				scaleZoom(e$1) {
					return Math.log2(e$1);
				}
				project(t$1) {
					const i$1 = e.aA(t$1.lat, -e.cJ, e.cJ), o$1 = this.projection.project(t$1.lng, i$1);
					return new e.P(o$1.x * this.worldSize, o$1.y * this.worldSize);
				}
				unproject(e$1) {
					return this.projection.unproject(e$1.x / this.worldSize, e$1.y / this.worldSize);
				}
				get point() {
					return this.project(this.center);
				}
				get pointMerc() {
					return this.point._div(this.worldSize);
				}
				get pixelsPerMeterRatio() {
					return this.pixelsPerMeter / e.cf(1, this.center.lat) / this.worldSize;
				}
				setLocationAtPoint(t$1, i$1) {
					let o$1, s$1;
					const r$1 = this.centerPoint;
					if ("globe" === this.projection.name) {
						const e$1 = this.worldSize;
						o$1 = (i$1.x - r$1.x) / e$1, s$1 = (i$1.y - r$1.y) / e$1;
					} else {
						const e$1 = this.pointCoordinate(i$1), t$2 = this.pointCoordinate(r$1);
						o$1 = e$1.x - t$2.x, s$1 = e$1.y - t$2.y;
					}
					const n$1 = this.locationCoordinate(t$1);
					this.setLocation(new e.ae(n$1.x - o$1, n$1.y - s$1));
				}
				setLocation(e$1) {
					this.center = this.coordinateLocation(e$1), this.projection.wrap && (this.center = this.center.wrap());
				}
				locationPoint(e$1, t$1) {
					return this.projection.locationPoint(this, e$1, t$1);
				}
				locationPoint3D(e$1, t$1) {
					return this.projection.locationPoint(this, e$1, t$1, !0);
				}
				pointLocation(e$1) {
					return this.coordinateLocation(this.pointCoordinate(e$1));
				}
				pointLocation3D(e$1, t$1) {
					return this.coordinateLocation(this.pointCoordinate3D(e$1, t$1));
				}
				locationCoordinate(t$1, i$1) {
					const o$1 = i$1 ? e.cf(i$1, t$1.lat) : void 0, s$1 = this.projection.project(t$1.lng, t$1.lat);
					return new e.ae(s$1.x, s$1.y, o$1);
				}
				coordinateLocation(e$1) {
					return this.projection.unproject(e$1.x, e$1.y);
				}
				pointRayIntersection(t$1, i$1) {
					const o$1 = null != i$1 ? i$1 : this._centerAltitude, s$1 = [
						t$1.x,
						t$1.y,
						0,
						1
					], r$1 = [
						t$1.x,
						t$1.y,
						1,
						1
					];
					e.aC(s$1, s$1, this.pixelMatrixInverse), e.aC(r$1, r$1, this.pixelMatrixInverse);
					const n$1 = r$1[3];
					e.cK(s$1, s$1, 1 / s$1[3]), e.cK(r$1, r$1, 1 / n$1);
					const a$1 = s$1[2], l$1 = r$1[2];
					return {
						p0: s$1,
						p1: r$1,
						t: a$1 === l$1 ? 0 : (o$1 - a$1) / (l$1 - a$1)
					};
				}
				screenPointToMercatorRay(t$1) {
					const i$1 = [
						t$1.x,
						t$1.y,
						0,
						1
					], o$1 = [
						t$1.x,
						t$1.y,
						1,
						1
					];
					return e.aC(i$1, i$1, this.pixelMatrixInverse), e.aC(o$1, o$1, this.pixelMatrixInverse), e.cK(i$1, i$1, 1 / i$1[3]), e.cK(o$1, o$1, 1 / o$1[3]), i$1[2] = e.cf(i$1[2], this._center.lat) * this.worldSize, o$1[2] = e.cf(o$1[2], this._center.lat) * this.worldSize, e.cK(i$1, i$1, 1 / this.worldSize), e.cK(o$1, o$1, 1 / this.worldSize), new e.ax([
						i$1[0],
						i$1[1],
						i$1[2]
					], e.aw([], e.av([], o$1, i$1)));
				}
				rayIntersectionCoordinate(t$1) {
					const { p0: i$1, p1: o$1, t: s$1 } = t$1, r$1 = e.cf(i$1[2], this._center.lat), n$1 = e.cf(o$1[2], this._center.lat);
					return new e.ae(e.ak(i$1[0], o$1[0], s$1) / this.worldSize, e.ak(i$1[1], o$1[1], s$1) / this.worldSize, e.ak(r$1, n$1, s$1));
				}
				pointCoordinate(e$1, t$1 = this._centerAltitude) {
					return this.projection.pointCoordinate(this, e$1.x, e$1.y, t$1);
				}
				pointCoordinate3D(t$1, i$1) {
					if (!this.elevation) return this.pointCoordinate(t$1, i$1);
					let o$1 = this.projection.pointCoordinate3D(this, t$1.x, t$1.y);
					if (o$1) return new e.ae(o$1[0], o$1[1], o$1[2]);
					let s$1 = 0, r$1 = this.horizonLineFromTop();
					if (t$1.y > r$1) return this.pointCoordinate(t$1, i$1);
					const n$1 = .02 * r$1, a$1 = t$1.clone();
					for (let t$2 = 0; t$2 < 10 && r$1 - s$1 > n$1; t$2++) {
						a$1.y = e.ak(s$1, r$1, .66);
						const t$3 = this.projection.pointCoordinate3D(this, a$1.x, a$1.y);
						t$3 ? (r$1 = a$1.y, o$1 = t$3) : s$1 = a$1.y;
					}
					return o$1 ? new e.ae(o$1[0], o$1[1], o$1[2]) : this.pointCoordinate(t$1);
				}
				isPointAboveHorizon(e$1) {
					return this.projection.isPointAboveHorizon(this, e$1);
				}
				isPointOnSurface(t$1) {
					if (t$1.y < 0 || t$1.y > this.height || t$1.x < 0 || t$1.x > this.width) return !1;
					if (this.elevation || this.zoom >= e.cL) return !this.isPointAboveHorizon(t$1);
					const i$1 = this.pointCoordinate(t$1);
					return i$1.y >= 0 && i$1.y <= 1;
				}
				_coordinatePoint(t$1, i$1) {
					const o$1 = i$1 && this.elevation ? this.elevation.getAtPointOrZero(t$1, this._centerAltitude) : this._centerAltitude, s$1 = [
						t$1.x * this.worldSize,
						t$1.y * this.worldSize,
						o$1 + t$1.toAltitude(),
						1
					];
					return e.aC(s$1, s$1, this.pixelMatrix), s$1[3] > 0 ? new e.P(s$1[0] / s$1[3], s$1[1] / s$1[3]) : new e.P(Number.MAX_VALUE, Number.MAX_VALUE);
				}
				_getBoundsNonRectangular() {
					const { top: t$1, left: i$1 } = this._edgeInsets, o$1 = this.height - this._edgeInsets.bottom, s$1 = this.width - this._edgeInsets.right, r$1 = this.pointLocation3D(new e.P(i$1, t$1)), n$1 = this.pointLocation3D(new e.P(s$1, t$1)), a$1 = this.pointLocation3D(new e.P(s$1, o$1)), l$1 = this.pointLocation3D(new e.P(i$1, o$1));
					let c$1 = Math.min(r$1.lng, n$1.lng, a$1.lng, l$1.lng), h$1 = Math.max(r$1.lng, n$1.lng, a$1.lng, l$1.lng), d$1 = Math.min(r$1.lat, n$1.lat, a$1.lat, l$1.lat), u$1 = Math.max(r$1.lat, n$1.lat, a$1.lat, l$1.lat);
					const _$1 = Math.pow(2, -this.zoom) / 16 * 270, p$1 = "globe" === this.projection.name ? 1 : 4, f$1 = (t$2, i$2, o$2, s$2, r$2) => {
						const n$2 = (t$2 + o$2) / 2, a$2 = (i$2 + s$2) / 2, l$2 = new e.P(n$2, a$2), { lng: m$1, lat: g$1 } = this.pointLocation3D(l$2), v$1 = Math.max(0, c$1 - m$1, d$1 - g$1, m$1 - h$1, g$1 - u$1);
						c$1 = Math.min(c$1, m$1), h$1 = Math.max(h$1, m$1), d$1 = Math.min(d$1, g$1), u$1 = Math.max(u$1, g$1), (r$2 < p$1 || v$1 > _$1) && (f$1(t$2, i$2, n$2, a$2, r$2 + 1), f$1(n$2, a$2, o$2, s$2, r$2 + 1));
					};
					if (f$1(i$1, t$1, s$1, t$1, 1), f$1(s$1, t$1, s$1, o$1, 1), f$1(s$1, o$1, i$1, o$1, 1), f$1(i$1, o$1, i$1, t$1, 1), "globe" === this.projection.name) {
						const [t$2, i$2] = e.cM(this);
						t$2 ? (u$1 = 90, h$1 = 180, c$1 = -180) : i$2 && (d$1 = -90, h$1 = 180, c$1 = -180);
					}
					return new e.aI(new e.aT(c$1, d$1), new e.aT(h$1, u$1));
				}
				_getBoundsRectangular(t$1, i$1) {
					const { top: o$1, left: s$1 } = this._edgeInsets, r$1 = this.height - this._edgeInsets.bottom, n$1 = this.width - this._edgeInsets.right, a$1 = new e.P(s$1, o$1), l$1 = new e.P(n$1, o$1), c$1 = new e.P(n$1, r$1), h$1 = new e.P(s$1, r$1);
					let d$1 = this.pointCoordinate(a$1, t$1), u$1 = this.pointCoordinate(l$1, t$1);
					const _$1 = this.pointCoordinate(c$1, i$1), p$1 = this.pointCoordinate(h$1, i$1), f$1 = (e$1, t$2) => (t$2.y - e$1.y) / (t$2.x - e$1.x);
					return d$1.y > 1 && u$1.y >= 0 ? d$1 = new e.ae((1 - p$1.y) / f$1(p$1, d$1) + p$1.x, 1) : d$1.y < 0 && u$1.y <= 1 && (d$1 = new e.ae(-p$1.y / f$1(p$1, d$1) + p$1.x, 0)), u$1.y > 1 && d$1.y >= 0 ? u$1 = new e.ae((1 - _$1.y) / f$1(_$1, u$1) + _$1.x, 1) : u$1.y < 0 && d$1.y <= 1 && (u$1 = new e.ae(-_$1.y / f$1(_$1, u$1) + _$1.x, 0)), new e.aI().extend(this.coordinateLocation(d$1)).extend(this.coordinateLocation(u$1)).extend(this.coordinateLocation(p$1)).extend(this.coordinateLocation(_$1));
				}
				_getBoundsRectangularTerrain() {
					const e$1 = this.elevation;
					if (!e$1.visibleDemTiles.length || e$1.isUsingMockSource()) return this._getBoundsRectangular(0, 0);
					const t$1 = e$1.visibleDemTiles.reduce(((e$2, t$2) => {
						if (t$2.dem) {
							const i$1 = t$2.dem.tree;
							e$2.min = Math.min(e$2.min, i$1.minimums[0]), e$2.max = Math.max(e$2.max, i$1.maximums[0]);
						}
						return e$2;
					}), {
						min: Number.MAX_VALUE,
						max: 0
					});
					return this._getBoundsRectangular(t$1.min * e$1.exaggeration(), t$1.max * e$1.exaggeration());
				}
				getBounds() {
					return "mercator" === this.projection.name || "equirectangular" === this.projection.name ? this._terrainEnabled() ? this._getBoundsRectangularTerrain() : this._getBoundsRectangular(0, 0) : this._getBoundsNonRectangular();
				}
				horizonLineFromTop(e$1 = !0) {
					const t$1 = this.height / 2 / Math.tan(this._fov / 2) / Math.tan(Math.max(this._pitch, .1)) - this.centerOffset.y, i$1 = this.height / 2 - t$1 * (1 - this._horizonShift);
					return e$1 ? Math.max(0, i$1) : i$1;
				}
				getMaxBounds() {
					return this.maxBounds;
				}
				setMaxBounds(t$1) {
					this.maxBounds = t$1, this.minLat = -e.cJ, this.maxLat = e.cJ, this.minLng = -180, this.maxLng = 180, t$1 && (this.minLat = t$1.getSouth(), this.maxLat = t$1.getNorth(), this.minLng = t$1.getWest(), this.maxLng = t$1.getEast(), this.maxLng < this.minLng && (this.maxLng += 360)), this.worldMinX = e.aF(this.minLng) * this.tileSize, this.worldMaxX = e.aF(this.maxLng) * this.tileSize, this.worldMinY = e.aJ(this.maxLat) * this.tileSize, this.worldMaxY = e.aJ(this.minLat) * this.tileSize, this._constrain();
				}
				calculatePosMatrix(e$1, t$1) {
					return this.projection.createTileMatrix(this, t$1, e$1);
				}
				calculateDistanceTileData(t$1) {
					const i$1 = t$1.key, o$1 = this._distanceTileDataCache;
					if (o$1[i$1]) return o$1[i$1];
					const s$1 = t$1.canonical, r$1 = 1 / this.height, n$1 = this.cameraWorldSize, a$1 = n$1 / this.zoomScale(s$1.z), l$1 = (s$1.x + Math.pow(2, s$1.z) * t$1.wrap) * a$1, c$1 = s$1.y * a$1, h$1 = this.point;
					h$1.x *= n$1 / this.worldSize, h$1.y *= n$1 / this.worldSize;
					const d$1 = this.angle;
					return o$1[i$1] = {
						bearing: [Math.sin(-d$1), -Math.cos(-d$1)],
						center: [(h$1.x - l$1) * r$1, (h$1.y - c$1) * r$1],
						scale: a$1 / e.al * r$1
					}, o$1[i$1];
				}
				calculateFogTileMatrix(t$1) {
					const i$1 = t$1.key, o$1 = this._fogTileMatrixCache;
					if (o$1[i$1]) return o$1[i$1];
					const s$1 = this.projection.createTileMatrix(this, this.cameraWorldSizeForFog, t$1);
					return e.aB(s$1, this.worldToFogMatrix, s$1), o$1[i$1] = new Float32Array(s$1), o$1[i$1];
				}
				calculateProjMatrix(t$1, i$1 = !1, o$1 = !1) {
					const s$1 = t$1.key;
					let r$1;
					if (r$1 = o$1 ? this._expandedProjMatrixCache : i$1 ? this._alignedProjMatrixCache : this._projMatrixCache, r$1[s$1]) return r$1[s$1];
					const n$1 = this.calculatePosMatrix(t$1, this.worldSize);
					let a$1;
					return a$1 = this.projection.isReprojectedInTileSpace ? this.mercatorMatrix : o$1 ? this.expandedFarZProjMatrix : i$1 ? this.alignedProjMatrix : this.projMatrix, e.aB(n$1, a$1, n$1), r$1[s$1] = new Float32Array(n$1), r$1[s$1];
				}
				calculatePixelsToTileUnitsMatrix(t$1) {
					const i$1 = t$1.tileID.key, o$1 = this._pixelsToTileUnitsCache;
					if (o$1[i$1]) return o$1[i$1];
					return o$1[i$1] = e.cN(t$1, this), o$1[i$1];
				}
				customLayerMatrix() {
					return this.mercatorMatrix.slice();
				}
				globeToMercatorMatrix() {
					if ("globe" === this.projection.name) {
						const t$1 = 1 / this.worldSize, i$1 = e.bq([], [
							t$1,
							t$1,
							t$1
						]);
						return e.aB(i$1, i$1, this.globeMatrix), i$1;
					}
				}
				recenterOnTerrain() {
					if (!this._elevation || "globe" === this.projection.name) return;
					const t$1 = this._elevation;
					this._updateCameraState();
					const i$1 = e.cf(1, this._center.lat) * this.worldSize, o$1 = this._computeCameraPosition(i$1), s$1 = this._camera.forward(), r$1 = e.cf(1, this._center.lat);
					o$1[2] /= r$1, s$1[2] /= r$1, e.aw(s$1, s$1);
					const n$1 = t$1.raycast(o$1, s$1, t$1.exaggeration());
					if (n$1) {
						const t$2 = e.bH([], o$1, s$1, n$1), i$2 = new e.ae(t$2[0], t$2[1], e.cf(t$2[2], e.a$(t$2[1]))), a$1 = (i$2.z + e.ag([
							i$2.x - o$1[0],
							i$2.y - o$1[1],
							i$2.z - o$1[2] * r$1
						])) * this._pixelsPerMercatorPixel;
						this._seaLevelZoom = this._zoomFromMercatorZ(a$1), this._centerAltitude = i$2.toAltitude(), this._center = this.coordinateLocation(i$2), this._updateZoomFromElevation(), this._constrain(), this._calcMatrices();
					}
				}
				_constrainCamera(t$1 = !1) {
					if (!this._elevation) return;
					const i$1 = this._elevation, o$1 = e.cf(1, this._center.lat) * this.worldSize, s$1 = this._computeCameraPosition(o$1), r$1 = i$1.getAtPointOrZero(new e.ae(...s$1)), n$1 = this.pixelsPerMeter / this.worldSize * r$1, a$1 = this._minimumHeightOverTerrain(), l$1 = s$1[2] - n$1;
					if (l$1 <= a$1) if (l$1 < 0 || t$1) {
						const t$2 = this.locationCoordinate(this._center, this._centerAltitude), i$2 = [
							s$1[0],
							s$1[1],
							t$2.z - s$1[2]
						], o$2 = e.ag(i$2);
						i$2[2] -= (a$1 - l$1) / this._pixelsPerMercatorPixel;
						const r$2 = e.ag(i$2);
						if (0 === r$2) return;
						e.c5(i$2, i$2, o$2 / r$2 * this._pixelsPerMercatorPixel), this._camera.position = [
							s$1[0],
							s$1[1],
							t$2.z * this._pixelsPerMercatorPixel - i$2[2]
						], this._updateStateFromCamera();
					} else this._isCameraConstrained = !0;
				}
				_constrain() {
					if (!this.center || !this.width || !this.height || this._constraining) return;
					this._constraining = !0;
					const t$1 = "globe" === this.projection.name || this.mercatorFromTransition;
					if (this.projection.isReprojectedInTileSpace || t$1) {
						const i$2 = this.center;
						i$2.lat = e.aA(i$2.lat, this.minLat, this.maxLat), (this.maxBounds || !this.renderWorldCopies && !t$1) && (i$2.lng = e.aA(i$2.lng, this.minLng, this.maxLng)), this.center = i$2, this._constraining = !1;
						return;
					}
					const i$1 = this._unmodified, { x: o$1, y: s$1 } = this.point;
					let r$1 = 0, n$1 = o$1, a$1 = s$1;
					const l$1 = this.width / 2, c$1 = this.height / 2, h$1 = this.worldMinY * this.scale, d$1 = this.worldMaxY * this.scale;
					if (s$1 - c$1 < h$1 && (a$1 = h$1 + c$1), s$1 + c$1 > d$1 && (a$1 = d$1 - c$1), d$1 - h$1 < this.height && (r$1 = Math.max(r$1, this.height / (d$1 - h$1)), a$1 = (d$1 + h$1) / 2), this.maxBounds || !this._renderWorldCopies || !this.projection.wrap) {
						const e$1 = this.worldMinX * this.scale, t$2 = this.worldMaxX * this.scale, i$2 = this.worldSize / 2 - (e$1 + t$2) / 2;
						n$1 = (o$1 + i$2 + this.worldSize) % this.worldSize - i$2, n$1 - l$1 < e$1 && (n$1 = e$1 + l$1), n$1 + l$1 > t$2 && (n$1 = t$2 - l$1), t$2 - e$1 < this.width && (r$1 = Math.max(r$1, this.width / (t$2 - e$1)), n$1 = (t$2 + e$1) / 2);
					}
					n$1 === o$1 && a$1 === s$1 || this._allowWorldUnderZoom || (this.center = this.unproject(new e.P(n$1, a$1))), r$1 && !this._allowWorldUnderZoom && (this.zoom += this.scaleZoom(r$1)), this._constrainCamera(), this._unmodified = i$1, this._constraining = !1;
				}
				_minZoomForBounds() {
					let e$1 = Math.max(0, this.scaleZoom(Math.max(0, this.height) / (this.worldMaxY - this.worldMinY)));
					return this.maxBounds && (e$1 = Math.max(e$1, this.scaleZoom(this.width / (this.worldMaxX - this.worldMinX)))), e$1;
				}
				_maxCameraBoundsDistance() {
					return this._mercatorZfromZoom(this._minZoomForBounds());
				}
				_calcMatrices() {
					if (!this.height) return;
					const t$1 = this.centerOffset, i$1 = "globe" === this.projection.name, o$1 = this.pixelsPerMeter;
					"globe" === this.projection.name && (this._mercatorScaleRatio = e.cf(1, this.center.lat) / e.cf(1, e.d2));
					const s$1 = e.cO(this.projection, this.zoom, this.width, this.height, 1024);
					this._pixelsPerMercatorPixel = this.projection.pixelSpaceConversion(this.center.lat, this.worldSize, s$1), this.cameraToCenterDistance = .5 / Math.tan(.5 * this._fov) * this.height * this._pixelsPerMercatorPixel, this._updateCameraState(), this._farZ = this.projection.farthestPixelDistance(this), this._nearZ = this.height / 50;
					const r$1 = "meters" === this.projection.zAxisUnit ? o$1 : 1, n$1 = this._camera.getWorldToCamera(this.worldSize, r$1);
					let a$1;
					const l$1 = this._camera.getCameraToClipPerspective(this._fov, this.width / this.height, this._nearZ, this._farZ);
					if (l$1[8] = 2 * -t$1.x / this.width, l$1[9] = 2 * t$1.y / this.height, this.isOrthographic) {
						let i$2 = .5 * this.height / Math.tan(this._fov / 2) * 1 * Math.tan(.5 * this._fov), o$2 = i$2 * this.aspect, s$2 = -o$2, r$2 = -i$2;
						o$2 -= t$1.x, s$2 -= t$1.x, i$2 += t$1.y, r$2 += t$1.y, a$1 = this._camera.getCameraToClipOrthographic(s$2, o$2, r$2, i$2, this._nearZ, this._farZ), ((t$2, i$3, o$3, s$3) => {
							for (let r$3 = 0; r$3 < 16; r$3++) t$2[r$3] = e.ak(i$3[r$3], o$3[r$3], s$3);
						})(a$1, a$1, l$1, e.d0(this.pitch >= lo ? 1 : this.pitch / lo));
					} else a$1 = l$1;
					const c$1 = e.cP([], l$1, n$1);
					let h$1 = e.cP([], a$1, n$1);
					if (this.projection.isReprojectedInTileSpace) {
						const t$2 = this.locationCoordinate(this.center), i$2 = e.bA([]);
						e.br(i$2, i$2, [
							t$2.x * this.worldSize,
							t$2.y * this.worldSize,
							0
						]), e.aB(i$2, i$2, e.cQ(this)), e.br(i$2, i$2, [
							-t$2.x * this.worldSize,
							-t$2.y * this.worldSize,
							0
						]), e.aB(h$1, h$1, i$2), e.aB(c$1, c$1, i$2), this.inverseAdjustmentMatrix = e.cR(this);
					} else this.inverseAdjustmentMatrix = [
						1,
						0,
						0,
						1
					];
					if (this.mercatorMatrix = e.cS([], h$1, [
						this.worldSize,
						this.worldSize,
						this.worldSize / r$1,
						1
					]), this.projMatrix = h$1, this.invProjMatrix = e.bl(new Float64Array(16), this.projMatrix), i$1) {
						const i$2 = this._camera.getCameraToClipPerspective(this._fov, this.width / this.height, this._nearZ, Infinity);
						i$2[8] = 2 * -t$1.x / this.width, i$2[9] = 2 * t$1.y / this.height, this.expandedFarZProjMatrix = e.cP([], i$2, n$1);
					} else this.expandedFarZProjMatrix = this.projMatrix;
					const d$1 = e.bl([], a$1);
					this.frustumCorners = e.cT.fromInvProjectionMatrix(d$1, this.horizonLineFromTop(), this.height), this.cameraFrustum = e.cB.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, 0, !i$1);
					const u$1 = new Float32Array(16);
					e.bA(u$1), e.cS(u$1, u$1, [
						1,
						-1,
						1
					]), e.cU(u$1, u$1, this._pitch), e.bB(u$1, u$1, this.angle);
					const _$1 = e.cd(new Float32Array(16), this._fov, this.width / this.height, this._nearZ, this._farZ);
					this.starsProjMatrix = e.bz(_$1);
					const p$1 = (Math.PI / 2 - this._pitch) * (this.height / this._fov) * this._horizonShift;
					_$1[8] = 2 * -t$1.x / this.width, _$1[9] = 2 * (t$1.y + p$1) / this.height, this.skyboxMatrix = e.aB(u$1, _$1, u$1);
					const f$1 = this.point, m$1 = f$1.x, g$1 = f$1.y, v$1 = this.width % 2 / 2, y$1 = this.height % 2 / 2, x$1 = Math.cos(this.angle), b$1 = Math.sin(this.angle), w$1 = m$1 - Math.round(m$1) + x$1 * v$1 + b$1 * y$1, T$1 = g$1 - Math.round(g$1) + x$1 * y$1 + b$1 * v$1, E$1 = new Float64Array(h$1);
					if (e.br(E$1, E$1, [
						w$1 > .5 ? w$1 - 1 : w$1,
						T$1 > .5 ? T$1 - 1 : T$1,
						0
					]), this.alignedProjMatrix = E$1, h$1 = e.bC(), e.cS(h$1, h$1, [
						this.width / 2,
						-this.height / 2,
						1
					]), e.br(h$1, h$1, [
						1,
						-1,
						0
					]), this.labelPlaneMatrix = h$1, h$1 = e.bC(), e.cS(h$1, h$1, [
						1,
						-1,
						1
					]), e.br(h$1, h$1, [
						-1,
						-1,
						0
					]), e.cS(h$1, h$1, [
						2 / this.width,
						2 / this.height,
						1
					]), this.glCoordMatrix = h$1, this.pixelMatrix = e.aB(new Float64Array(16), this.labelPlaneMatrix, c$1), this._calcFogMatrices(), this._distanceTileDataCache = {}, h$1 = e.bl(new Float64Array(16), this.pixelMatrix), !h$1) throw new Error("failed to invert matrix");
					if (this.pixelMatrixInverse = h$1, "globe" === this.projection.name || this.mercatorFromTransition) {
						this.globeMatrix = e.cV(this);
						const t$2 = [
							this.globeMatrix[12],
							this.globeMatrix[13],
							this.globeMatrix[14]
						];
						this.globeCenterInViewSpace = e.af(t$2, t$2, n$1), this.globeRadius = this.worldSize / 2 / Math.PI - 1;
					} else this.globeMatrix = h$1;
					this._projMatrixCache = {}, this._alignedProjMatrixCache = {}, this._pixelsToTileUnitsCache = {}, this._expandedProjMatrixCache = {};
				}
				_calcFogMatrices() {
					this._fogTileMatrixCache = {};
					const t$1 = this.cameraWorldSizeForFog, i$1 = this.cameraPixelsPerMeter, o$1 = this._camera.position, s$1 = 1 / this.height / this._pixelsPerMercatorPixel, r$1 = [
						t$1,
						t$1,
						i$1
					];
					e.c5(r$1, r$1, s$1), e.c5(o$1, o$1, -1), e.cW(o$1, o$1, r$1);
					const n$1 = e.bC();
					e.br(n$1, n$1, o$1), e.cS(n$1, n$1, r$1), this.mercatorFogMatrix = n$1, this.worldToFogMatrix = this._camera.getWorldToCameraPosition(t$1, i$1, s$1);
				}
				_computeCameraPosition(e$1) {
					const t$1 = (e$1 = e$1 || this.pixelsPerMeter) / this.pixelsPerMeter, i$1 = this._camera.forward(), o$1 = this.point, s$1 = this._mercatorZfromZoom(this._seaLevelZoom ? this._seaLevelZoom : this._zoom) * t$1 - e$1 / this.worldSize * this._centerAltitude;
					return [
						o$1.x / this.worldSize - i$1[0] * s$1,
						o$1.y / this.worldSize - i$1[1] * s$1,
						e$1 / this.worldSize * this._centerAltitude - i$1[2] * s$1
					];
				}
				_updateCameraState() {
					this.height && (this._camera.setPitchBearing(this._pitch, this.angle), this._camera.position = this._computeCameraPosition());
				}
				_translateCameraConstrained(t$1) {
					const i$1 = this._maxCameraBoundsDistance() * Math.cos(this._pitch), o$1 = this._camera.position[2], s$1 = t$1[2];
					let r$1 = 1;
					this.projection.wrap && (this.center = this.center.wrap()), s$1 > 0 && (r$1 = Math.min((i$1 - o$1) / s$1, 1)), this._camera.position = e.bH([], this._camera.position, t$1, r$1), this._updateStateFromCamera();
				}
				_updateStateFromCamera() {
					const t$1 = this._camera.position, i$1 = this._camera.forward(), { pitch: o$1, bearing: s$1 } = this._camera.getPitchBearing(), r$1 = e.cf(this._centerAltitude, this.center.lat) * this._pixelsPerMercatorPixel, n$1 = this._mercatorZfromZoom(this._maxZoom) * Math.cos(e.an(this._maxPitch)), a$1 = Math.max((t$1[2] - r$1) / Math.cos(o$1), n$1), l$1 = this._zoomFromMercatorZ(a$1);
					e.bH(t$1, t$1, i$1, a$1), this._pitch = e.aA(o$1, e.an(this.minPitch), e.an(this.maxPitch)), this.angle = e.bT(s$1, -Math.PI, Math.PI), this._setZoom(e.aA(l$1, this._minZoom, this._maxZoom)), this._updateSeaLevelZoom(), this._center = this.coordinateLocation(new e.ae(t$1[0], t$1[1], t$1[2])), this._unmodified = !1, this._constrain(), this._calcMatrices();
				}
				_worldSizeFromZoom(e$1) {
					return Math.pow(2, e$1) * this.tileSize;
				}
				_mercatorZfromZoom(e$1) {
					return this.cameraToCenterDistance / this._worldSizeFromZoom(e$1);
				}
				_minimumHeightOverTerrain() {
					const e$1 = Math.min(null != this._seaLevelZoom ? this._seaLevelZoom : this._zoom, this._maxZoom) + 4;
					return this._mercatorZfromZoom(e$1);
				}
				_zoomFromMercatorZ(e$1) {
					return this.scaleZoom(this.cameraToCenterDistance / (Math.max(0, e$1) * this.tileSize));
				}
				zoomFromMercatorZAdjusted(t$1) {
					let i$1 = 0, o$1 = e.cL, s$1 = 0, r$1 = Infinity;
					for (; o$1 - i$1 > 1e-6 && o$1 > i$1;) {
						const e$1 = i$1 + .5 * (o$1 - i$1), n$1 = this.tileSize * Math.pow(2, e$1), a$1 = this.getCameraToCenterDistance(this.projection, e$1, n$1), l$1 = this.scaleZoom(a$1 / (Math.max(0, t$1) * this.tileSize)), c$1 = Math.abs(e$1 - l$1);
						c$1 < r$1 && (r$1 = c$1, s$1 = e$1), e$1 < l$1 ? i$1 = e$1 : o$1 = e$1;
					}
					return s$1;
				}
				_terrainEnabled() {
					return !(!this._elevation || !this.projection.supportsTerrain && (e.w("Terrain is not yet supported with alternate projections. Use mercator or globe to enable terrain."), 1));
				}
				anyCornerOffEdge(t$1, i$1) {
					const o$1 = Math.min(t$1.x, i$1.x), s$1 = Math.max(t$1.x, i$1.x), r$1 = Math.min(t$1.y, i$1.y), n$1 = Math.max(t$1.y, i$1.y);
					if (r$1 < this.horizonLineFromTop(!1)) return !0;
					if ("mercator" !== this.projection.name) return !1;
					const a$1 = [
						new e.P(o$1, r$1),
						new e.P(s$1, n$1),
						new e.P(o$1, n$1),
						new e.P(s$1, r$1)
					], l$1 = this.renderWorldCopies ? -3 : 0, c$1 = this.renderWorldCopies ? 4 : 1;
					for (const e$1 of a$1) {
						const t$2 = this.pointRayIntersection(e$1);
						if (t$2.t < 0) return !0;
						const i$2 = this.rayIntersectionCoordinate(t$2);
						if (i$2.x < l$1 || i$2.y < 0 || i$2.x > c$1 || i$2.y > 1) return !0;
					}
					return !1;
				}
				isHorizonVisible() {
					return this.pitch + e.cX(this.fovAboveCenter) > 88 || this.anyCornerOffEdge(new e.P(0, 0), new e.P(this.width, this.height));
				}
				zoomDeltaToMovement(t$1, i$1) {
					const o$1 = e.ag(e.av([], this._camera.position, t$1)), s$1 = this._zoomFromMercatorZ(o$1) + i$1;
					return o$1 - this._mercatorZfromZoom(s$1);
				}
				getCameraPoint() {
					if ("globe" === this.projection.name) {
						const t$1 = function([t$2, i$1, o$1], s$1) {
							const r$1 = [
								t$2,
								i$1,
								o$1,
								1
							];
							e.aC(r$1, r$1, s$1);
							const n$1 = r$1[3] = Math.max(r$1[3], 1e-6);
							return r$1[0] /= n$1, r$1[1] /= n$1, r$1[2] /= n$1, r$1;
						}([
							this.globeMatrix[12],
							this.globeMatrix[13],
							this.globeMatrix[14]
						], this.pixelMatrix);
						return new e.P(t$1[0], t$1[1]);
					}
					{
						const t$1 = Math.tan(this._pitch) * (this.cameraToCenterDistance || 1);
						return this.centerPoint.add(new e.P(0, t$1));
					}
				}
				getCameraToCenterDistance(t$1, i$1 = this.zoom, o$1 = this.worldSize) {
					const s$1 = e.cO(t$1, i$1, this.width, this.height, 1024), r$1 = t$1.pixelSpaceConversion(this.center.lat, o$1, s$1);
					let n$1 = .5 / Math.tan(.5 * this._fov) * this.height * r$1;
					return this.isOrthographic && (n$1 = e.ak(1, n$1, e.d0(this.pitch >= lo ? 1 : this.pitch / lo))), n$1;
				}
				getWorldToCameraMatrix() {
					const t$1 = this._camera.getWorldToCamera(this.worldSize, "meters" === this.projection.zAxisUnit ? this.pixelsPerMeter : 1);
					return "globe" === this.projection.name && e.aB(t$1, t$1, this.globeMatrix), t$1;
				}
				getFrustum(t$1) {
					return e.cB.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, t$1, "meters" === this.projection.zAxisUnit);
				}
			}
			const ho = (t$1, i$1) => {
				if (i$1 > 0 && t$1.terrain && e.w("Cutoff is currently disabled on terrain"), i$1 <= 0 || t$1.terrain) return {
					shouldRenderCutoff: !1,
					uniformValues: { u_cutoff_params: [
						0,
						0,
						0,
						1
					] }
				};
				const o$1 = t$1.transform, s$1 = Math.max(Math.abs(o$1._zoom - (t$1.minCutoffZoom - 1)), 1), r$1 = o$1.isLODDisabled(!1) ? e.ah(60, 45, o$1.pitch) : e.ah(30, 15, o$1.pitch), n$1 = o$1._farZ - o$1._nearZ, a$1 = i$1 * o$1.height, l$1 = ((1 - (c$1 = r$1)) * o$1.cameraToCenterDistance + c$1 * (o$1._farZ + a$1)) * s$1;
				var c$1;
				return {
					shouldRenderCutoff: r$1 < 1,
					uniformValues: { u_cutoff_params: [
						o$1._nearZ,
						o$1._farZ,
						(l$1 - o$1._nearZ) / n$1,
						(l$1 - a$1 - o$1._nearZ) / n$1
					] }
				};
			}, uo = 2048;
			class _o {
				constructor(e$1, t$1) {
					this.aabb = e$1, this.lastCascade = t$1;
				}
			}
			class po {
				add(e$1, t$1) {
					const i$1 = this.receivers[e$1.key];
					void 0 !== i$1 ? (i$1.aabb.min[0] = Math.min(i$1.aabb.min[0], t$1.min[0]), i$1.aabb.min[1] = Math.min(i$1.aabb.min[1], t$1.min[1]), i$1.aabb.min[2] = Math.min(i$1.aabb.min[2], t$1.min[2]), i$1.aabb.max[0] = Math.max(i$1.aabb.max[0], t$1.max[0]), i$1.aabb.max[1] = Math.max(i$1.aabb.max[1], t$1.max[1]), i$1.aabb.max[2] = Math.max(i$1.aabb.max[2], t$1.max[2])) : this.receivers[e$1.key] = new _o(t$1, null);
				}
				clear() {
					this.receivers = {};
				}
				get(e$1) {
					return this.receivers[e$1.key];
				}
				computeRequiredCascades(t$1, i$1, o$1) {
					const s$1 = e.d9.fromPoints(t$1.points);
					let r$1 = 0;
					for (const t$2 in this.receivers) {
						const n$1 = this.receivers[t$2];
						if (!n$1) continue;
						if (!s$1.intersectsAabb(n$1.aabb)) continue;
						n$1.aabb.min = s$1.closestPoint(n$1.aabb.min), n$1.aabb.max = s$1.closestPoint(n$1.aabb.max);
						const a$1 = n$1.aabb.getCorners();
						for (let t$3 = 0; t$3 < o$1.length; t$3++) {
							let s$2 = !0;
							for (const r$2 of a$1) {
								const n$2 = [
									r$2[0] * i$1,
									r$2[1] * i$1,
									r$2[2]
								];
								if (e.af(n$2, n$2, o$1[t$3].matrix), n$2[0] < -1 || n$2[0] > 1 || n$2[1] < -1 || n$2[1] > 1) {
									s$2 = !1;
									break;
								}
							}
							if (n$1.lastCascade = t$3, r$1 = Math.max(r$1, t$3), s$2) break;
						}
					}
					return r$1 + 1;
				}
			}
			class fo {
				constructor(e$1) {
					this.painter = e$1, this._enabled = !1, this._shadowLayerCount = 0, this._numCascadesToRender = 0, this._cascades = [], this._groundShadowTiles = [], this._receivers = new po(), this._depthMode = new Xi(e$1.context.gl.LEQUAL, Xi.ReadWrite, [0, 1]), this._uniformValues = {
						u_light_matrix_0: new Float32Array(16),
						u_light_matrix_1: new Float32Array(16),
						u_shadow_intensity: 0,
						u_fade_range: [0, 0],
						u_shadow_normal_offset: [
							1,
							1,
							1
						],
						u_shadow_texel_size: 1,
						u_shadow_map_resolution: 1,
						u_shadow_direction: [
							0,
							0,
							1
						],
						u_shadow_bias: [
							36e-5,
							.0012,
							.012
						],
						u_shadowmap_0: 0,
						u_shadowmap_1: 0
					}, this._forceDisable = !1, this.useNormalOffset = !1;
				}
				destroy() {
					for (const e$1 of this._cascades) e$1.texture.destroy(), e$1.framebuffer.destroy();
					this._cascades = [];
				}
				updateShadowParameters(t$1, i$1) {
					const o$1 = this.painter;
					if (this._enabled = !1, this._shadowLayerCount = 0, this._receivers.clear(), !i$1 || !i$1.properties) return;
					const s$1 = i$1.properties.get("shadow-intensity");
					if (!i$1.shadowsEnabled() || s$1 <= 0) return;
					if (this._shadowLayerCount = o$1.style.order.reduce(((e$1, i$2) => {
						const s$2 = o$1.style._mergedLayers[i$2];
						return e$1 + (s$2.hasShadowPass() && !s$2.isHidden(t$1.zoom) ? 1 : 0);
					}), 0), this._enabled = this._shadowLayerCount > 0, !this.enabled) return;
					const r$1 = o$1.context, n$1 = uo, a$1 = uo;
					if (0 === this._cascades.length || uo !== this._cascades[0].texture.size[0]) {
						this._cascades = [];
						for (let t$2 = 0; t$2 < 2; ++t$2) {
							const t$3 = o$1._shadowMapDebug, i$2 = r$1.gl, s$2 = r$1.createFramebuffer(n$1, a$1, t$3 ? 1 : 0, "texture"), l$2 = new e.T(r$1, {
								width: n$1,
								height: a$1,
								data: null
							}, i$2.DEPTH_COMPONENT16);
							if (s$2.depthAttachment.set(l$2.texture), t$3) {
								const t$4 = new e.T(r$1, {
									width: n$1,
									height: a$1,
									data: null
								}, i$2.RGBA8);
								s$2.colorAttachment0.set(t$4.texture);
							}
							this._cascades.push({
								framebuffer: s$2,
								texture: l$2,
								matrix: [],
								far: 0,
								boundingSphereRadius: 0,
								frustum: new e.cB(),
								scale: 0
							});
						}
					}
					this.shadowDirection = go(i$1);
					let l$1 = 0;
					if (t$1.elevation) {
						const e$1 = t$1.elevation, i$2 = [1e4, -1e4];
						e$1.visibleDemTiles.filter(((e$2) => e$2.dem)).forEach(((e$2) => {
							const t$2 = e$2.dem.tree;
							i$2[0] = Math.min(i$2[0], t$2.minimums[0]), i$2[1] = Math.max(i$2[1], t$2.maximums[0]);
						})), 1e4 !== i$2[0] && (l$1 = (i$2[1] - i$2[0]) * e$1.exaggeration());
					}
					const c$1 = 1.5 * t$1.cameraToCenterDistance, h$1 = 3 * c$1, d$1 = new Float64Array(16);
					for (let i$2 = 0; i$2 < this._cascades.length; ++i$2) {
						const o$2 = this._cascades[i$2];
						let s$2 = t$1.height / 50, r$2 = 1;
						0 === i$2 ? r$2 = c$1 : (s$2 = c$1, r$2 = h$1);
						const [n$2, a$2] = yo(t$1, this.shadowDirection, s$2, r$2, uo, l$1);
						o$2.scale = t$1.scale, o$2.matrix = n$2, o$2.boundingSphereRadius = a$2, e.bl(d$1, o$2.matrix), o$2.frustum = e.cB.fromInvProjectionMatrix(d$1, 1, 0, !0), o$2.far = r$2;
					}
					const u$1 = this._cascades.length - 1;
					this._uniformValues.u_fade_range = [.75 * this._cascades[u$1].far, this._cascades[u$1].far], this._uniformValues.u_shadow_intensity = s$1, this._uniformValues.u_shadow_direction = [
						this.shadowDirection[0],
						this.shadowDirection[1],
						this.shadowDirection[2]
					], this._uniformValues.u_shadow_texel_size = .00048828125, this._uniformValues.u_shadow_map_resolution = uo, this._uniformValues.u_shadowmap_0 = no.ShadowMap0, this._uniformValues.u_shadowmap_1 = no.ShadowMap0 + 1, this._groundShadowTiles = o$1.transform.coveringTiles({
						tileSize: 512,
						renderWorldCopies: !0
					});
					const _$1 = o$1.transform.elevation;
					for (const e$1 of this._groundShadowTiles) {
						let t$2 = {
							min: 0,
							max: 0
						};
						if (_$1) {
							const i$2 = _$1.getMinMaxForTile(e$1);
							i$2 && (t$2 = i$2);
						}
						this.addShadowReceiver(e$1.toUnwrapped(), t$2.min, t$2.max);
					}
				}
				get enabled() {
					return this._enabled && !this._forceDisable;
				}
				set enabled(e$1) {
					this._enabled = e$1;
				}
				drawShadowPass(t$1, i$1) {
					if (!this.enabled) return;
					const o$1 = this.painter, s$1 = o$1.context;
					this._numCascadesToRender = this._receivers.computeRequiredCascades(o$1.transform.getFrustum(0), o$1.transform.worldSize, this._cascades), s$1.viewport.set([
						0,
						0,
						uo,
						uo
					]);
					for (let r$1 = 0; r$1 < this._numCascadesToRender; ++r$1) {
						o$1.currentShadowCascade = r$1, s$1.bindFramebuffer.set(this._cascades[r$1].framebuffer.framebuffer), s$1.clear({
							color: e.ao.white,
							depth: 1
						});
						for (const e$1 of t$1.order) {
							const s$2 = t$1._mergedLayers[e$1];
							if (!s$2.hasShadowPass() || s$2.isHidden(o$1.transform.zoom)) continue;
							const r$2 = t$1.getLayerSourceCache(s$2), n$1 = r$2 ? i$1[r$2.id] : void 0;
							("model" === s$2.type || n$1 && n$1.length) && o$1.renderLayer(o$1, r$2, s$2, n$1);
						}
					}
					o$1.currentShadowCascade = 0;
				}
				drawGroundShadows() {
					if (!this.enabled) return;
					const e$1 = this.painter, t$1 = e$1.style, i$1 = e$1.context, o$1 = i$1.gl, s$1 = t$1.directionalLight, r$1 = t$1.ambientLight;
					if (!s$1 || !r$1) return;
					const n$1 = [], a$1 = ho(e$1, e$1.longestCutoffRange);
					a$1.shouldRenderCutoff && n$1.push("RENDER_CUTOFF"), n$1.push("RENDER_SHADOWS", "DEPTH_TEXTURE"), this.useNormalOffset && n$1.push("NORMAL_OFFSET");
					const l$1 = vo(t$1, s$1, r$1), c$1 = new Xi(o$1.LEQUAL, Xi.ReadOnly, e$1.depthRangeFor3D), h$1 = new Ki({
						func: o$1.EQUAL,
						mask: 255
					}, 0, 255, o$1.KEEP, o$1.KEEP, o$1.KEEP);
					for (const t$2 of this._groundShadowTiles) {
						const s$2 = t$2.toUnwrapped(), r$2 = e$1.isTileAffectedByFog(t$2), d$1 = e$1.getOrCreateProgram("groundShadow", {
							defines: n$1,
							overrideFog: r$2
						});
						this.setupShadows(s$2, d$1), e$1.uploadCommonUniforms(i$1, d$1, s$2, null, a$1);
						const u$1 = {
							u_matrix: e$1.transform.calculateProjMatrix(s$2),
							u_ground_shadow_factor: l$1
						};
						d$1.draw(e$1, o$1.TRIANGLES, c$1, h$1, $i.multiply, eo.disabled, u$1, "ground_shadow", e$1.tileExtentBuffer, e$1.quadTriangleIndexBuffer, e$1.tileExtentSegments, null, e$1.transform.zoom, null, null);
					}
				}
				getShadowPassColorMode() {
					return this.painter._shadowMapDebug ? $i.unblended : $i.disabled;
				}
				getShadowPassDepthMode() {
					return this._depthMode;
				}
				getShadowCastingLayerCount() {
					return this._shadowLayerCount;
				}
				calculateShadowPassMatrixFromTile(t$1) {
					const i$1 = this.painter.transform, o$1 = i$1.calculatePosMatrix(t$1, i$1.worldSize);
					return e.aB(o$1, this._cascades[this.painter.currentShadowCascade].matrix, o$1), Float32Array.from(o$1);
				}
				calculateShadowPassMatrixFromMatrix(t$1) {
					const i$1 = e.bz(t$1);
					return e.aB(i$1, this._cascades[this.painter.currentShadowCascade].matrix, t$1), i$1;
				}
				setupShadows(t$1, i$1, o$1) {
					if (!this.enabled) return;
					const s$1 = this.painter.transform, r$1 = this.painter.context, n$1 = r$1.gl, a$1 = this._uniformValues, l$1 = new Float64Array(16), c$1 = s$1.calculatePosMatrix(t$1, s$1.worldSize);
					for (let t$2 = 0; t$2 < this._cascades.length; t$2++) e.aB(l$1, this._cascades[t$2].matrix, c$1), a$1[0 === t$2 ? "u_light_matrix_0" : "u_light_matrix_1"] = Float32Array.from(l$1), r$1.activeTexture.set(n$1.TEXTURE0 + no.ShadowMap0 + t$2), this._cascades[t$2].texture.bindExtraParam(n$1.LINEAR, n$1.LINEAR, n$1.CLAMP_TO_EDGE, n$1.CLAMP_TO_EDGE, n$1.GREATER);
					if (this.useNormalOffset = !!o$1, this.useNormalOffset) {
						const i$2 = e.d7(t$1.canonical), r$2 = 2 / s$1.tileSize * e.al / uo, n$2 = r$2 * this._cascades[0].boundingSphereRadius, l$2 = r$2 * this._cascades[this._cascades.length - 1].boundingSphereRadius, c$2 = ("vector-tile" === o$1 ? 1 : 3) * function(t$2, i$3, o$2, s$2, r$3) {
							const n$3 = e.aA((t$2 - 22) / -22, 0, 1);
							return .125 * (1 - n$3) + 4 * n$3;
						}(s$1.zoom);
						a$1.u_shadow_normal_offset = [
							i$2,
							n$2 * c$2,
							l$2 * c$2
						], a$1.u_shadow_bias = [
							1e-4,
							.0012,
							.012
						];
					} else a$1.u_shadow_bias = [
						36e-5,
						.0012,
						.012
					];
					i$1.setShadowUniformValues(r$1, a$1);
				}
				setupShadowsFromMatrix(t$1, i$1, o$1 = !1) {
					if (!this.enabled) return;
					const s$1 = this.painter.context, r$1 = s$1.gl, n$1 = this._uniformValues, a$1 = new Float64Array(16);
					for (let i$2 = 0; i$2 < 2; i$2++) e.aB(a$1, this._cascades[i$2].matrix, t$1), n$1[0 === i$2 ? "u_light_matrix_0" : "u_light_matrix_1"] = Float32Array.from(a$1), s$1.activeTexture.set(r$1.TEXTURE0 + no.ShadowMap0 + i$2), this._cascades[i$2].texture.bindExtraParam(r$1.LINEAR, r$1.LINEAR, r$1.CLAMP_TO_EDGE, r$1.CLAMP_TO_EDGE, r$1.GREATER);
					this.useNormalOffset = o$1, o$1 ? (n$1.u_shadow_normal_offset = [
						1,
						3,
						3
					], n$1.u_shadow_bias = [
						6e-5,
						.0012,
						.012
					]) : n$1.u_shadow_bias = [
						36e-5,
						.0012,
						.012
					], i$1.setShadowUniformValues(s$1, n$1);
				}
				getShadowUniformValues() {
					return this._uniformValues;
				}
				getCurrentCascadeFrustum() {
					return this._cascades[this.painter.currentShadowCascade].frustum;
				}
				computeSimplifiedTileShadowVolume(t$1, i$1, o$1, s$1) {
					if (s$1[2] >= 0) return {};
					const r$1 = function(t$2, i$2, o$2) {
						const s$2 = o$2 / (1 << t$2.canonical.z);
						return new e.d9([
							t$2.canonical.x * s$2 + t$2.wrap * o$2,
							t$2.canonical.y * s$2 + t$2.wrap * o$2,
							0
						], [
							(t$2.canonical.x + 1) * s$2 + t$2.wrap * o$2,
							(t$2.canonical.y + 1) * s$2 + t$2.wrap * o$2,
							i$2
						]);
					}(t$1, i$1, o$1).getCorners(), n$1 = i$1 / -s$1[2];
					s$1[0] < 0 ? (e.d8(r$1[0], r$1[0], [
						s$1[0] * n$1,
						0,
						0
					]), e.d8(r$1[3], r$1[3], [
						s$1[0] * n$1,
						0,
						0
					])) : s$1[0] > 0 && (e.d8(r$1[1], r$1[1], [
						s$1[0] * n$1,
						0,
						0
					]), e.d8(r$1[2], r$1[2], [
						s$1[0] * n$1,
						0,
						0
					])), s$1[1] < 0 ? (e.d8(r$1[0], r$1[0], [
						0,
						s$1[1] * n$1,
						0
					]), e.d8(r$1[1], r$1[1], [
						0,
						s$1[1] * n$1,
						0
					])) : s$1[1] > 0 && (e.d8(r$1[2], r$1[2], [
						0,
						s$1[1] * n$1,
						0
					]), e.d8(r$1[3], r$1[3], [
						0,
						s$1[1] * n$1,
						0
					]));
					const a$1 = {};
					return a$1.vertices = r$1, a$1.planes = [
						mo(r$1[1], r$1[0], r$1[4]),
						mo(r$1[2], r$1[1], r$1[5]),
						mo(r$1[3], r$1[2], r$1[6]),
						mo(r$1[0], r$1[3], r$1[7])
					], a$1;
				}
				addShadowReceiver(t$1, i$1, o$1) {
					this._receivers.add(t$1, e.d9.fromTileIdAndHeight(t$1, i$1, o$1));
				}
				getMaxCascadeForTile(e$1) {
					const t$1 = this._receivers.get(e$1);
					return t$1 && t$1.lastCascade ? t$1.lastCascade : 0;
				}
			}
			function mo(t$1, i$1, o$1) {
				const s$1 = e.av([], o$1, i$1), r$1 = e.av([], t$1, i$1), n$1 = e.bI([], s$1, r$1), a$1 = e.ag(n$1);
				return 0 === a$1 ? [
					0,
					0,
					1,
					0
				] : (e.c5(n$1, n$1, 1 / a$1), [
					n$1[0],
					n$1[1],
					n$1[2],
					-e.bJ(n$1, i$1)
				]);
			}
			function go(t$1) {
				const i$1 = t$1.properties.get("direction"), o$1 = e.d4(i$1.x, i$1.y, i$1.z);
				o$1[2] = e.aA(o$1[2], 0, 75);
				const s$1 = e.d6([
					o$1[0],
					o$1[1],
					o$1[2]
				]);
				return e.d5(s$1.x, s$1.y, s$1.z);
			}
			function vo(t$1, i$1, o$1) {
				const s$1 = "none" === i$1.properties.get("color-use-theme"), r$1 = i$1.properties.get("color"), n$1 = i$1.properties.get("intensity"), a$1 = i$1.properties.get("direction"), l$1 = [
					a$1.x,
					a$1.y,
					a$1.z
				], c$1 = "none" === o$1.properties.get("color-use-theme"), h$1 = o$1.properties.get("color"), d$1 = o$1.properties.get("intensity"), u$1 = Math.max(e.bJ([
					0,
					0,
					1
				], l$1), 0), _$1 = [
					0,
					0,
					0
				];
				e.c5(_$1, h$1.toPremultipliedRenderColor(c$1 ? null : t$1.getLut(i$1.scope)).toArray01Linear().slice(0, 3), d$1);
				const p$1 = [
					0,
					0,
					0
				];
				return e.c5(p$1, r$1.toPremultipliedRenderColor(s$1 ? null : t$1.getLut(o$1.scope)).toArray01Linear().slice(0, 3), u$1 * n$1), e.db([
					_$1[0] > 0 ? _$1[0] / (_$1[0] + p$1[0]) : 0,
					_$1[1] > 0 ? _$1[1] / (_$1[1] + p$1[1]) : 0,
					_$1[2] > 0 ? _$1[2] / (_$1[2] + p$1[2]) : 0
				]);
			}
			function yo(t$1, i$1, o$1, s$1, r$1, n$1) {
				const a$1 = t$1.zoom, l$1 = t$1.scale, c$1 = t$1.worldSize, h$1 = 1 / c$1, d$1 = t$1.aspect, u$1 = Math.sqrt(1 + d$1 * d$1) * Math.tan(.5 * t$1.fovX), _$1 = u$1 * u$1, p$1 = s$1 - o$1, f$1 = s$1 + o$1;
				let m$1, g$1;
				_$1 > p$1 / f$1 ? (m$1 = s$1, g$1 = s$1 * u$1) : (m$1 = .5 * f$1 * (1 + _$1), g$1 = .5 * Math.sqrt(p$1 * p$1 + 2 * (s$1 * s$1 + o$1 * o$1) * _$1 + f$1 * f$1 * _$1 * _$1));
				const v$1 = t$1.projection.pixelsPerMeter(t$1.center.lat, c$1), y$1 = t$1._camera.getCameraToWorldMercator(), x$1 = [
					0,
					0,
					-m$1 * h$1
				];
				e.af(x$1, x$1, y$1);
				let b$1 = g$1 * h$1;
				const w$1 = t$1._edgeInsets;
				if (!(0 === w$1.left && 0 === w$1.top && 0 === w$1.right && 0 === w$1.bottom || w$1.left === w$1.right && w$1.top === w$1.bottom)) {
					const i$2 = t$1._camera.getWorldToCamera(t$1.worldSize, "meters" === t$1.projection.zAxisUnit ? v$1 : 1), r$2 = t$1._camera.getCameraToClipPerspective(t$1._fov, t$1.width / t$1.height, o$1, s$1);
					r$2[8] = 2 * -t$1.centerOffset.x / t$1.width, r$2[9] = 2 * t$1.centerOffset.y / t$1.height;
					const n$2 = new Float64Array(16);
					e.cP(n$2, r$2, i$2);
					const h$2 = new Float64Array(16);
					e.bl(h$2, n$2);
					const d$2 = e.cB.fromInvProjectionMatrix(h$2, c$1, a$1, !0);
					for (const i$3 of d$2.points) {
						const o$2 = ((T$1 = i$3)[0] /= l$1, T$1[1] /= l$1, T$1[2] = e.cf(T$1[2], t$1._center.lat), T$1);
						b$1 = Math.max(b$1, e.c6(e.da([], x$1, o$2)));
					}
				}
				var T$1;
				b$1 *= r$1 / (r$1 - 1);
				const E$1 = Math.acos(i$1[2]), S$1 = Math.atan2(-i$1[0], -i$1[1]), I$1 = new ro();
				I$1.position = x$1, I$1.setPitchBearing(E$1, S$1);
				const C$1 = I$1.getWorldToCamera(c$1, v$1), R$1 = b$1 * c$1, A$1 = Math.min(t$1._mercatorZfromZoom(17) * c$1 * -2, -2 * R$1), L$1 = I$1.getCameraToClipOrthographic(-R$1, R$1, -R$1, R$1, A$1, (R$1 + n$1 * v$1) / i$1[2]), D$1 = new Float64Array(16);
				e.aB(D$1, L$1, C$1);
				const P$1 = e.d5(Math.floor(1e6 * x$1[0]) / 1e6 * c$1, Math.floor(1e6 * x$1[1]) / 1e6 * c$1, 0), O$1 = .5 * r$1, z$1 = [
					0,
					0,
					0
				];
				e.af(z$1, P$1, D$1), e.c5(z$1, z$1, O$1);
				const M$1 = [
					Math.floor(z$1[0]),
					Math.floor(z$1[1]),
					Math.floor(z$1[2])
				], F$1 = [
					0,
					0,
					0
				];
				e.av(F$1, z$1, M$1), e.c5(F$1, F$1, -1 / O$1);
				const B$1 = new Float64Array(16);
				return e.bA(B$1), e.br(B$1, B$1, F$1), e.aB(D$1, B$1, D$1), [D$1, R$1];
			}
			class xo extends e.E {
				constructor(e$1) {
					super(), this.requestManager = e$1, this.models = { "": {} }, this.modelUris = { "": {} }, this.modelByURL = {}, this.numModelsLoading = {};
				}
				loadModel(t$1, i$1) {
					return e.dc(this.requestManager.transformRequest(i$1, e.R.Model).url).then(((o$1) => {
						if (!o$1) return;
						const s$1 = e.dd(o$1), r$1 = new e.de(t$1, i$1, void 0, void 0, s$1);
						return r$1.computeBoundsAndApplyParent(), r$1;
					})).catch(((o$1) => {
						if (o$1 && 404 === o$1.status) return null;
						this.fire(new e.y(/* @__PURE__ */ new Error(`Could not load model ${t$1} from ${i$1}: ${o$1.message}`)));
					}));
				}
				load(t$1, i$1, o$1 = { forceReload: !1 }) {
					this.models[i$1] || (this.models[i$1] = {});
					const s$1 = Object.keys(t$1), r$1 = [], n$1 = [];
					for (const e$1 of s$1) {
						const s$2 = t$1[e$1];
						this.hasURLBeenRequested(s$2) && !o$1.forceReload || (this.modelByURL[s$2] = {
							modelId: e$1,
							scope: i$1
						}, r$1.push(this.loadModel(e$1, s$2)), n$1.push(e$1)), this.models[i$1][e$1] || (this.models[i$1][e$1] = {
							model: null,
							numReferences: 1
						});
					}
					this.numModelsLoading[i$1] = (this.numModelsLoading[i$1] || 0) + n$1.length, Promise.allSettled(r$1).then(((t$2) => {
						for (let e$1 = 0; e$1 < t$2.length; e$1++) {
							const { status: o$2 } = t$2[e$1];
							if ("rejected" === o$2) continue;
							const { value: s$2 } = t$2[e$1];
							this.models[i$1][n$1[e$1]] || (this.models[i$1][n$1[e$1]] = {
								model: null,
								numReferences: 1
							}), this.models[i$1][n$1[e$1]].model = s$2;
						}
						this.numModelsLoading[i$1] -= n$1.length, this.fire(new e.z("data", { dataType: "style" }));
					})).catch(((t$2) => {
						this.fire(new e.y(/* @__PURE__ */ new Error(`Could not load models: ${t$2.message}`)));
					}));
				}
				isLoaded() {
					for (const e$1 in this.numModelsLoading) if (this.numModelsLoading[e$1] > 0) return !1;
					return !0;
				}
				hasModel(e$1, t$1, i$1 = { exactIdMatch: !1 }) {
					return !!(i$1.exactIdMatch ? this.getModel(e$1, t$1) : this.getModelByURL(this.modelUris[t$1][e$1]));
				}
				getModel(e$1, t$1) {
					return this.models[t$1] || (this.models[t$1] = {}), this.models[t$1][e$1] ? this.models[t$1][e$1].model : void 0;
				}
				getModelByURL(e$1) {
					if (!e$1) return null;
					const t$1 = this.modelByURL[e$1];
					return t$1 ? this.models[t$1.scope][t$1.modelId].model : null;
				}
				hasModelBeenAdded(e$1, t$1) {
					return this.models[t$1] && void 0 !== this.models[t$1][e$1];
				}
				getModelURIs(e$1) {
					return this.modelUris[e$1] || {};
				}
				addModel(e$1, t$1, i$1) {
					this.models[i$1] || (this.models[i$1] = {}), this.modelUris[i$1] || (this.modelUris[i$1] = {});
					const o$1 = this.requestManager.normalizeModelURL(t$1);
					if ((this.hasModel(e$1, i$1, { exactIdMatch: !0 }) || this.hasModelBeenAdded(e$1, i$1)) && this.modelUris[i$1][e$1] === o$1) this.models[i$1][e$1].numReferences++;
					else if (this.hasURLBeenRequested(o$1)) {
						const { scope: e$2, modelId: t$2 } = this.modelByURL[o$1];
						this.models[e$2][t$2].numReferences++;
					} else this.modelUris[i$1][e$1] = o$1, this.load({ [e$1]: this.modelUris[i$1][e$1] }, i$1);
				}
				addModelURLs(e$1, t$1) {
					this.models[t$1] || (this.models[t$1] = {}), this.modelUris[t$1] || (this.modelUris[t$1] = {});
					const i$1 = this.modelUris[t$1];
					for (const t$2 in e$1) i$1[t$2] = this.requestManager.normalizeModelURL(e$1[t$2]);
				}
				reloadModels(e$1) {
					this.load(this.modelUris[e$1], e$1, { forceReload: !0 });
				}
				addModelsFromBucket(t$1, i$1) {
					this.models[i$1] || (this.models[i$1] = {}), this.modelUris[i$1] || (this.modelUris[i$1] = {});
					const o$1 = {};
					for (const s$1 of t$1) this.hasModel(s$1, i$1, { exactIdMatch: !0 }) || this.hasURLBeenRequested(s$1) ? this.models[i$1][s$1].numReferences++ : this.modelUris[i$1][s$1] && !this.hasURLBeenRequested(s$1) ? o$1[s$1] = this.modelUris[i$1][s$1] : !this.hasURLBeenRequested(s$1) && e.df(s$1, !1) && (this.modelUris[i$1][s$1] = this.requestManager.normalizeModelURL(s$1), o$1[s$1] = this.modelUris[i$1][s$1]);
					this.load(o$1, i$1);
				}
				hasURLBeenRequested(e$1) {
					return void 0 !== this.modelByURL[e$1];
				}
				removeModel(e$1, t$1, i$1 = !1, o$1 = !1) {
					if (this.models[t$1] && this.models[t$1][e$1] && (this.models[t$1][e$1].numReferences--, 0 === this.models[t$1][e$1].numReferences || o$1)) {
						const o$2 = this.modelUris[t$1][e$1];
						i$1 || delete this.modelUris[t$1][e$1], delete this.modelByURL[o$2];
						const s$1 = this.models[t$1][e$1].model;
						if (!s$1) return;
						delete this.models[t$1][e$1], s$1.destroy();
					}
				}
				destroy() {
					for (const e$1 of Object.keys(this.models)) for (const t$1 of Object.keys(this.models[e$1])) {
						const i$1 = this.models[e$1][t$1].model;
						delete this.models[e$1][t$1], i$1 && i$1.destroy();
					}
					this.models = { "": {} }, this.modelUris = { "": {} }, this.modelByURL = {}, this.numModelsLoading = {};
				}
				listModels(e$1) {
					return this.models[e$1] || (this.models[e$1] = {}), Object.keys(this.models[e$1]);
				}
				upload(e$1, t$1) {
					this.models[t$1] || (this.models[t$1] = {});
					for (const i$1 in this.models[t$1]) this.models[t$1][i$1].model && this.models[t$1][i$1].model.upload(e$1.context);
				}
			}
			const bo = e.a6.colorTheme, wo = new e.a9({ data: new e.aa(bo.data) });
			function To(t$1) {
				if (!t$1.metadata || !t$1.metadata.content_area) return;
				const i$1 = e.o.devicePixelRatio, { left: o$1, top: s$1, width: r$1, height: n$1 } = t$1.metadata.content_area, a$1 = o$1 * i$1, l$1 = s$1 * i$1;
				return [
					a$1,
					l$1,
					a$1 + r$1 * i$1,
					l$1 + n$1 * i$1
				];
			}
			function Eo(t$1) {
				if (t$1) return t$1.map((([t$2, i$1]) => [t$2 * e.o.devicePixelRatio, i$1 * e.o.devicePixelRatio]));
			}
			class So {
				constructor(e$1, t$1, i$1) {
					this.id = e$1, this.scope = t$1, this.sourceCache = i$1, this.pendingRequests = /* @__PURE__ */ new Set(), this.missingRequests = /* @__PURE__ */ new Set();
				}
				addPendingRequest(e$1) {
					this.missingRequests.has(e$1.name) || this.pendingRequests.has(e$1.name) || this.pendingRequests.add(e$1.name);
				}
				hasPendingRequests() {
					return this.pendingRequests.size > 0;
				}
				resolvePendingRequests() {
					const t$1 = /* @__PURE__ */ new Map();
					if (!this.sourceCache.loaded()) return t$1;
					const i$1 = this.sourceCache.getVisibleCoordinates();
					if (0 === i$1.length) return t$1;
					const o$1 = this.sourceCache.getSource();
					if (!(o$1 instanceof pt)) return t$1;
					const s$1 = i$1.map(((e$1) => this.sourceCache.getTile(e$1))), r$1 = o$1.getImages(s$1, Array.from(this.pendingRequests));
					for (const [i$2, o$2] of r$1) t$1.set(e.I.from({
						name: i$2,
						iconsetId: this.id
					}), o$2), this.pendingRequests.delete(i$2);
					for (const e$1 of this.pendingRequests) this.missingRequests.add(e$1);
					return this.pendingRequests.clear(), t$1;
				}
			}
			const Io = (e$1, t$1) => Fe(e$1, t$1 && t$1.filter(((e$2) => "source.canvas" !== e$2.identifier))), Co = e.aH(Vt, [
				"addLayer",
				"removeLayer",
				"setLights",
				"setPaintProperty",
				"setLayoutProperty",
				"setLayerProperty",
				"setSlot",
				"setFilter",
				"addSource",
				"removeSource",
				"setLayerZoomRange",
				"setLight",
				"setTransition",
				"setGeoJSONSourceData",
				"setTerrain",
				"setFog",
				"setSnow",
				"setRain",
				"setProjection",
				"setCamera",
				"addImport",
				"removeImport",
				"updateImport",
				"addIconset",
				"removeIconset"
			]), Ro = e.aH(Vt, [
				"setCenter",
				"setZoom",
				"setBearing",
				"setPitch"
			]), Ao = new Set([
				"background",
				"sky",
				"slot",
				"custom"
			]), Lo = {
				version: 8,
				layers: [],
				sources: {}
			}, Do = {
				duration: 300,
				delay: 0
			};
			class Po extends e.E {
				constructor(t$1, i$1 = {}) {
					super(), this.map = t$1, this.scope = i$1.scope || "", this.globalId = null, this.fragments = [], this.importDepth = i$1.importDepth || 0, this.importsCache = i$1.importsCache || /* @__PURE__ */ new Map(), this.resolvedImports = i$1.resolvedImports || /* @__PURE__ */ new Set(), this.transition = Object.assign({}, Do), this._buildingIndex = new Ut(this), this.crossTileSymbolIndex = new Zi(), this._mergedOrder = [], this._drapedFirstOrder = [], this._mergedLayers = {}, this._mergedIndoor = {}, this._mergedSourceCaches = {}, this._mergedOtherSourceCaches = {}, this._mergedSymbolSourceCaches = {}, this._clipLayerPresent = !1, this._hasAppearances = !1, this._has3DLayers = !1, this._hasCircleLayers = !1, this._hasSymbolLayers = !1, this._importedAsBasemap = !1, this._changes = i$1.styleChanges || new W(), this._hasDataDrivenEmissive = !1, this.dispatcher = i$1.dispatcher ? i$1.dispatcher : new e.D(e.dh(), this), i$1.imageManager ? this.imageManager = i$1.imageManager : (this.imageManager = new X(this.map._spriteFormat), this.imageManager.setEventedParent(this)), this.imageManager.addScope(this.scope), this.glyphManager = i$1.glyphManager ? i$1.glyphManager : new e.di(t$1._requestManager, i$1.localFontFamily ? e.dj.all : i$1.localIdeographFontFamily ? e.dj.ideographs : e.dj.none, i$1.localFontFamily || i$1.localIdeographFontFamily), i$1.modelManager ? this.modelManager = i$1.modelManager : (this.modelManager = new xo(t$1._requestManager), this.modelManager.setEventedParent(this)), this._layers = {}, this._sourceCaches = {}, this._otherSourceCaches = {}, this._symbolSourceCaches = {}, this._loaded = !1, this._precompileDone = !1, this._shouldPrecompile = !1, this._availableImages = [], this._availableModels = {}, this._order = [], this._markersNeedUpdate = !1, this.options = i$1.configOptions ? i$1.configOptions : /* @__PURE__ */ new Map(), this._configDependentLayers = i$1.configDependentLayers ? i$1.configDependentLayers : /* @__PURE__ */ new Set(), this._indoorDependentLayers = i$1.indoorDependentLayers ? i$1.indoorDependentLayers : /* @__PURE__ */ new Set(), this._config = i$1.config, this._styleColorTheme = {
						lut: null,
						lutLoading: !1,
						lutLoadingCorrelationID: 0,
						colorTheme: null,
						colorThemeOverride: i$1.colorThemeOverride
					}, this._styleColorThemeForScope = {}, this._initialConfig = i$1.initialConfig, this.dispatcher.broadcast("setReferrer", e.dk());
					const o$1 = this;
					this._rtlTextPluginCallback = Po.registerForPluginStateChange(((t$2) => {
						o$1.dispatcher.broadcast("syncRTLPluginState", {
							pluginStatus: t$2.pluginStatus,
							pluginURL: t$2.pluginURL
						}, ((t$3, i$2) => {
							if (e.dl(t$3), i$2 && i$2.every(((e$1) => e$1))) for (const e$1 in o$1._sourceCaches) {
								const t$4 = o$1._sourceCaches[e$1], i$3 = t$4.getSource().type;
								"vector" !== i$3 && "geojson" !== i$3 || t$4.reload();
							}
						}));
					})), this.on("data", ((e$1) => {
						if ("source" !== e$1.dataType || "metadata" !== e$1.sourceDataType) return;
						const t$2 = this.getOwnSource(e$1.sourceId);
						if (t$2 && t$2.vectorLayerIds) for (const e$2 in this._layers) {
							const i$2 = this._layers[e$2];
							i$2.source === t$2.id && this._validateLayer(i$2);
						}
					}));
				}
				load(e$1) {
					return e$1 ? ("string" == typeof e$1 ? this.loadURL(e$1) : this.loadJSON(e$1), this) : this;
				}
				_getGlobalId(t$1) {
					if (!t$1) return null;
					if ("string" == typeof t$1) {
						if (e.h(t$1)) return t$1;
						const i$1 = e.dm(t$1);
						if (!i$1.startsWith("http")) try {
							return new URL(i$1, location.href).toString();
						} catch (e$1) {
							return i$1;
						}
						return i$1;
					}
					return `json://${e.dn(JSON.stringify(t$1))}`;
				}
				_diffStyle(t$1, i$1, o$1) {
					this.globalId = this._getGlobalId(t$1);
					const s$1 = (e$1, t$2) => {
						try {
							t$2(null, this.setState(e$1, o$1));
						} catch (e$2) {
							t$2(e$2, !1);
						}
					};
					if ("string" == typeof t$1) {
						const o$2 = this.map._requestManager.normalizeStyleURL(t$1), r$1 = this.map._requestManager.transformRequest(o$2, e.R.Style);
						e.m(r$1, ((t$2, o$3) => {
							t$2 ? this.fire(new e.y(t$2)) : o$3 && s$1(o$3, i$1);
						}));
					} else "object" == typeof t$1 && s$1(t$1, i$1);
				}
				loadURL(t$1, i$1 = {}) {
					this.fire(new e.z("dataloading", { dataType: "style" }));
					const o$1 = "boolean" == typeof i$1.validate ? i$1.validate : !e.h(t$1);
					this.globalId = this._getGlobalId(t$1), t$1 = this.map._requestManager.normalizeStyleURL(t$1, i$1.accessToken), this.resolvedImports.add(t$1);
					const s$1 = this.importsCache.get(t$1);
					if (s$1) return this._load(s$1, o$1);
					const r$1 = this.map._requestManager.transformRequest(t$1, e.R.Style);
					this._request = e.m(r$1, ((i$2, s$2) => {
						if (this._request = null, i$2) this.fire(new e.y(i$2));
						else if (s$2) return this.importsCache.set(t$1, s$2), this._load(s$2, o$1);
					}));
				}
				loadJSON(t$1, i$1 = {}) {
					this.fire(new e.z("dataloading", { dataType: "style" })), this.globalId = this._getGlobalId(t$1), this._request = e.o.frame((() => {
						this._request = null, this._load(t$1, !1 !== i$1.validate);
					}));
				}
				loadEmpty() {
					this.fire(new e.z("dataloading", { dataType: "style" })), this._load(Lo, !1);
				}
				_loadImports(t$1, i$1, o$1) {
					if (this.importDepth >= 4) return e.w("Style doesn't support nesting deeper than 5"), Promise.resolve();
					const s$1 = [];
					for (const e$1 of t$1) {
						const t$2 = this._createFragmentStyle(e$1), r$1 = new Promise(((e$2) => {
							t$2.once("style.import.load", e$2), t$2.once("error", e$2);
						})).then((() => this.mergeAll()));
						if (s$1.push(r$1), this.resolvedImports.has(e$1.url)) {
							t$2.loadEmpty();
							continue;
						}
						const n$1 = e$1.data || this.importsCache.get(e$1.url);
						n$1 ? (t$2.loadJSON(n$1, { validate: i$1 }), this._isInternalStyle(n$1) && (t$2.globalId = null)) : e$1.url ? t$2.loadURL(e$1.url, { validate: i$1 }) : t$2.loadEmpty();
						const a$1 = {
							style: t$2,
							id: e$1.id,
							config: e$1.config
						};
						if (o$1) {
							const e$2 = this.fragments.findIndex((({ id: e$3 }) => e$3 === o$1));
							this.fragments = this.fragments.slice(0, e$2).concat(a$1).concat(this.fragments.slice(e$2));
						} else this.fragments.push(a$1);
					}
					return Promise.allSettled(s$1);
				}
				getImportGlobalIds(e$1 = this, t$1 = /* @__PURE__ */ new Set()) {
					for (const i$1 of e$1.fragments) i$1.style.globalId && t$1.add(i$1.style.globalId), this.getImportGlobalIds(i$1.style, t$1);
					return [...t$1.values()];
				}
				_createFragmentStyle(t$1) {
					const i$1 = this.scope ? e.B(t$1.id, this.scope) : t$1.id;
					let o$1;
					const s$1 = this._initialConfig && this._initialConfig[i$1];
					(t$1.config || s$1) && (o$1 = Object.assign({}, t$1.config, s$1));
					const r$1 = new Po(this.map, {
						scope: i$1,
						styleChanges: this._changes,
						importDepth: this.importDepth + 1,
						importsCache: this.importsCache,
						resolvedImports: new Set(this.resolvedImports),
						dispatcher: this.dispatcher,
						imageManager: this.imageManager,
						glyphManager: this.glyphManager,
						modelManager: this.modelManager,
						config: o$1,
						configOptions: this.options,
						colorThemeOverride: t$1["color-theme"],
						configDependentLayers: this._configDependentLayers,
						indoorDependentLayers: this._indoorDependentLayers
					});
					return r$1.setEventedParent(this.map, { style: r$1 }), r$1;
				}
				_reloadImports() {
					this.mergeAll(), this._updateMapProjection(), this.updateConfigDependencies(), this._updateLayers(this._indoorDependentLayers), this.map._triggerCameraUpdate(this.camera), this.dispatcher.broadcast("setLayers", {
						layers: this._serializeLayers(this._order),
						scope: this.scope,
						options: this.options
					}), this._shouldPrecompile = this.map._precompilePrograms && this.isRootStyle();
				}
				_isInternalStyle(e$1) {
					return this.isRootStyle() && (e$1.fragment || !!e$1.schema && !1 !== e$1.fragment);
				}
				_load(t$1, i$1) {
					if (this._isInternalStyle(t$1)) {
						const e$1 = Object.assign({}, Lo, { imports: [{
							id: "basemap",
							data: t$1,
							url: ""
						}] }, t$1.center ? { center: t$1.center } : {}, t$1.bearing ? { bearing: t$1.bearing } : {}, t$1.pitch ? { pitch: t$1.pitch } : {}, t$1.zoom ? { zoom: t$1.zoom } : {}, t$1.light ? { light: t$1.light } : {});
						this._importedAsBasemap = !0, this._load(e$1, i$1);
						return;
					}
					if (this.updateConfig(this._config, t$1.schema), i$1 && Io(this, we(t$1))) return;
					this._loaded = !0, this.stylesheet = e.dp(t$1);
					const o$1 = () => {
						for (const e$1 in t$1.sources) this.addSource(e$1, t$1.sources[e$1], {
							validate: !1,
							isInitialLoad: !0
						});
						if (t$1.iconsets) for (const e$1 in t$1.iconsets) this.addIconset(e$1, t$1.iconsets[e$1]);
						t$1.sprite ? this._loadIconset(t$1.sprite) : (this.imageManager.setLoaded(!0, this.scope), this.dispatcher.broadcast("spriteLoaded", {
							scope: this.scope,
							isLoaded: !0
						})), !this.glyphManager.url && t$1.glyphs && this.glyphManager.setURL(t$1.glyphs);
						const o$2 = Gt(this.stylesheet.layers);
						if (this._order = o$2.map(((e$1) => e$1.id)), this.stylesheet.light && e.w("The `light` root property is deprecated, prefer using `lights` with `flat` light type instead."), this.stylesheet.lights) if (1 === this.stylesheet.lights.length && "flat" === this.stylesheet.lights[0].type) {
							const e$1 = this.stylesheet.lights[0];
							this.light = new Ne(e$1.properties, e$1.id);
						} else this.setLights(this.stylesheet.lights);
						this.light || (this.light = new Ne(this.stylesheet.light)), this._layers = {};
						for (const t$2 of o$2) {
							const i$2 = e.du(t$2, this.scope, this._styleColorTheme.lut, this.options);
							0 !== i$2.expressionDependencies.configDependencies.size && this._configDependentLayers.add(i$2.fqid), i$2.expressionDependencies.isIndoorDependent && this._indoorDependentLayers.add(i$2.fqid), this._hasAppearances = this._hasAppearances || 0 !== i$2.getAppearances().length, i$2.setEventedParent(this, { layer: { id: i$2.id } }), this._layers[i$2.id] = i$2;
							const o$3 = this.getOwnLayerSourceCache(i$2), s$3 = !!this.directionalLight && this.directionalLight.shadowsEnabled();
							o$3 && i$2.canCastShadows() && s$3 && (o$3.castsShadows = !0);
						}
						this.stylesheet.featuresets && this.setFeaturesetSelectors(this.stylesheet.featuresets), this.stylesheet.models && this.addModelURLs(this.stylesheet.models);
						const s$2 = this.stylesheet.terrain;
						s$2 && (this.checkCanvasFingerprintNoise(), this.disableElevatedTerrain || this.terrainSetForDrapingOnly() || this._createTerrain(s$2, 1)), this.stylesheet.fog && this._createFog(this.stylesheet.fog), this.stylesheet.snow && this._createSnow(this.stylesheet.snow), this.stylesheet.rain && this._createRain(this.stylesheet.rain), this.stylesheet.transition && this.setTransition(this.stylesheet.transition), this.fire(new e.z("data", { dataType: "style" }));
						const r$1 = this.isRootStyle();
						t$1.imports ? this._loadImports(t$1.imports, i$1).then((() => {
							this._reloadImports(), this.fire(new e.z(r$1 ? "style.load" : "style.import.load"));
						})).catch(((t$2) => {
							this.fire(new e.y(new Error("Failed to load imports", t$2))), this.fire(new e.z(r$1 ? "style.load" : "style.import.load"));
						})) : (this._reloadImports(), this.fire(new e.z(r$1 ? "style.load" : "style.import.load")));
					};
					this._styleColorTheme.colorTheme = this.stylesheet["color-theme"];
					const s$1 = this._styleColorTheme.colorThemeOverride ? this._styleColorTheme.colorThemeOverride : this._styleColorTheme.colorTheme;
					if (s$1) {
						const t$2 = this._evaluateColorThemeData(s$1);
						this._loadColorTheme(t$2).then((() => {
							o$1();
						})).catch(((t$3) => {
							e.w(`Couldn't load color theme from the stylesheet: ${t$3}`), o$1();
						}));
					} else this._styleColorTheme.lut = null, o$1();
				}
				isRootStyle() {
					return 0 === this.importDepth;
				}
				hasAppearances() {
					return this._hasAppearances || this.fragments.some(((e$1) => e$1.style.hasAppearances()));
				}
				mergeAll() {
					let e$1, t$1, i$1, o$1, s$1, r$1, n$1, a$1, l$1, c$1;
					const h$1 = {};
					this.terrain && this.terrain.scope !== this.scope && delete this.terrain, this.forEachFragmentStyle(((d$1) => {
						if (d$1.stylesheet) {
							if (null != d$1.light && (e$1 = d$1.light), d$1.stylesheet.lights) for (const e$2 of d$1.stylesheet.lights) "ambient" === e$2.type && null != d$1.ambientLight && (t$1 = d$1.ambientLight), "directional" === e$2.type && null != d$1.directionalLight && (i$1 = d$1.directionalLight);
							o$1 = this._prioritizeTerrain(o$1, d$1.terrain, d$1.stylesheet.terrain), d$1.stylesheet.fog && null != d$1.fog && (s$1 = d$1.fog), d$1.stylesheet.snow && null != d$1.snow && (r$1 = d$1.snow), d$1.stylesheet.rain && null != d$1.rain && (n$1 = d$1.rain), null != d$1.stylesheet.camera && (c$1 = d$1.stylesheet.camera), null != d$1.stylesheet.projection && (a$1 = d$1.stylesheet.projection), null != d$1.stylesheet.transition && (l$1 = d$1.stylesheet.transition), h$1[d$1.scope] = d$1._styleColorTheme;
						}
					})), this.light = e$1, this.ambientLight = t$1, this.directionalLight = i$1, this.fog = s$1, this.snow = r$1, this.rain = n$1, this._styleColorThemeForScope = h$1, null === o$1 ? delete this.terrain : this.terrain = o$1, this.camera = c$1 || { "camera-projection": "perspective" }, this.projection = a$1 || { name: "mercator" }, this.transition = Object.assign({}, Do, l$1), this.mergeSources(), this.mergeLayers(), this.mergeIndoor();
				}
				forEachFragmentStyle(e$1) {
					const t$1 = (i$1) => {
						for (const e$2 of i$1.fragments) t$1(e$2.style);
						e$1(i$1);
					};
					t$1(this);
				}
				_prioritizeTerrain(e$1, t$1, i$1) {
					const o$1 = e$1 && 0 === e$1.drapeRenderMode;
					return null === i$1 ? t$1 && 0 === t$1.drapeRenderMode ? t$1 : o$1 ? e$1 : null : null != t$1 && (!e$1 || o$1 || t$1 && 1 === t$1.drapeRenderMode) ? t$1 : e$1;
				}
				mergeTerrain() {
					let e$1;
					this.terrain && this.terrain.scope !== this.scope && delete this.terrain, this.forEachFragmentStyle(((t$1) => {
						e$1 = this._prioritizeTerrain(e$1, t$1.terrain, t$1.stylesheet.terrain);
					})), null === e$1 ? delete this.terrain : this.terrain = e$1;
				}
				mergeProjection() {
					let e$1;
					this.forEachFragmentStyle(((t$1) => {
						null != t$1.stylesheet.projection && (e$1 = t$1.stylesheet.projection);
					})), this.projection = e$1 || { name: "mercator" };
				}
				mergeSources() {
					const t$1 = {}, i$1 = {}, o$1 = {};
					this.forEachFragmentStyle(((s$1) => {
						for (const i$2 in s$1._sourceCaches) {
							const o$2 = e.B(i$2, s$1.scope);
							t$1[o$2] = s$1._sourceCaches[i$2];
						}
						for (const t$2 in s$1._otherSourceCaches) {
							const o$2 = e.B(t$2, s$1.scope);
							i$1[o$2] = s$1._otherSourceCaches[t$2];
						}
						for (const t$2 in s$1._symbolSourceCaches) {
							const i$2 = e.B(t$2, s$1.scope);
							o$1[i$2] = s$1._symbolSourceCaches[t$2];
						}
					})), this._mergedSourceCaches = t$1, this._mergedOtherSourceCaches = i$1, this._mergedSymbolSourceCaches = o$1;
				}
				mergeIndoor() {
					this.forEachFragmentStyle(((t$1) => {
						if (t$1.stylesheet && t$1.stylesheet.indoor) for (const i$1 of Object.values(t$1.stylesheet.indoor)) {
							const o$1 = i$1, s$1 = e.B(o$1.sourceId, t$1.scope);
							this._mergedIndoor[s$1] = new Set(o$1.sourceLayers || []);
						}
					}));
				}
				mergeLayers() {
					const t$1 = {}, i$1 = [], o$1 = {};
					this._mergedSlots = [], this._has3DLayers = !1, this._hasCircleLayers = !1, this._hasSymbolLayers = !1, this.forEachFragmentStyle(((o$2) => {
						for (const s$2 of o$2._order) {
							const r$2 = o$2._layers[s$2];
							if ("slot" === r$2.type) {
								const i$2 = e.dq(s$2);
								if (t$1[i$2]) continue;
								t$1[i$2] = [];
							}
							r$2.slot && t$1[r$2.slot] ? t$1[r$2.slot].push(r$2) : i$1.push(r$2);
						}
					})), this._mergedOrder = [];
					let s$1 = -1;
					const r$1 = (i$2 = []) => {
						for (const n$1 of i$2) if ("slot" === n$1.type) {
							const i$3 = e.dq(n$1.id);
							t$1[i$3] && r$1(t$1[i$3]), this._mergedSlots.push(i$3);
						} else {
							const t$2 = e.B(n$1.id, n$1.scope);
							this._mergedOrder.push(t$2), o$1[t$2] = n$1, n$1.is3D(!!this.terrain) && (this._has3DLayers = !0, s$1 = this._mergedOrder.length - 1), "circle" === n$1.type && (this._hasCircleLayers = !0), "symbol" === n$1.type && (this._hasSymbolLayers = !0), "clip" === n$1.type && (this._clipLayerPresent = !0);
						}
					};
					if (r$1(i$1), this._has3DLayers) {
						const e$1 = {};
						for (let t$2 = 0; t$2 < this._mergedOrder.length; ++t$2) {
							const i$2 = this._mergedOrder[t$2];
							e$1[i$2] = t$2 === s$1 ? 1 : t$2 < s$1 ? o$1[i$2].hasOcclusionOpacityProperties ? 2 : 0 : 4;
						}
						this._mergedOrder.sort(((t$2, i$2) => e$1[t$2] - e$1[i$2]));
					}
					this._mergedLayers = o$1, this.updateDrapeFirstLayers(), this._buildingIndex.processLayersChanged(), this._updateDataDrivenEmissiveStrength();
				}
				terrainSetForDrapingOnly() {
					return !!this.terrain && 0 === this.terrain.drapeRenderMode;
				}
				getCamera() {
					return this.stylesheet.camera;
				}
				setCamera(e$1) {
					return this.stylesheet.camera = Object.assign({}, this.stylesheet.camera, e$1), this.camera = this.stylesheet.camera, this;
				}
				_evaluateColorThemeData(t$1) {
					return t$1.data ? function(t$2, i$1, o$1, s$1) {
						const r$1 = Object.assign({}, i$1);
						for (const e$1 of Object.keys(bo)) void 0 === r$1[e$1] && (r$1[e$1] = bo[e$1].default);
						const n$1 = new e.a8(wo, t$2, new Map(o$1));
						return n$1.setTransitionOrValue(r$1, o$1), n$1.untransitioned().possiblyEvaluate(new e.ac(0, { worldview: void 0 }));
					}(this.scope, t$1, this.options).get("data") : null;
				}
				_loadColorTheme(t$1) {
					this._styleColorTheme.lutLoading = !0, this._styleColorTheme.lutLoadingCorrelationID += 1;
					const i$1 = this._styleColorTheme.lutLoadingCorrelationID;
					return new Promise(((o$1, s$1) => {
						const r$1 = "data:image/png;base64,";
						if (!t$1 || 0 === t$1.length) return this._styleColorTheme.lut = null, this._styleColorTheme.lutLoading = !1, void o$1();
						let n$1 = t$1;
						n$1.startsWith(r$1) || (n$1 = r$1 + n$1);
						const a$1 = e.I.from("mapbox-reserved-lut"), l$1 = new Image();
						l$1.src = n$1, l$1.onerror = () => {
							this._styleColorTheme.lutLoading = !1, s$1(/* @__PURE__ */ new Error("Failed to load image data"));
						}, l$1.onload = () => {
							if (this._styleColorTheme.lutLoadingCorrelationID !== i$1) return void o$1();
							this._styleColorTheme.lutLoading = !1;
							const { width: r$2, height: n$2, data: c$1 } = e.o.getImageData(l$1);
							if (n$2 > 32) return void s$1(/* @__PURE__ */ new Error("The height of the image must be less than or equal to 32 pixels."));
							if (r$2 !== n$2 * n$2) return void s$1(/* @__PURE__ */ new Error("The width of the image must be equal to the height squared."));
							this.getImage(a$1) && this.removeImage(a$1), this.addImage(a$1, {
								data: new e.q({
									width: r$2,
									height: n$2
								}, c$1),
								pixelRatio: 1,
								sdf: !1,
								usvg: !1,
								version: 0
							});
							const h$1 = this.imageManager.getImage(a$1, this.scope);
							h$1 ? (this._styleColorTheme.lut = {
								image: h$1.data,
								data: t$1
							}, o$1()) : s$1(/* @__PURE__ */ new Error("Missing LUT image."));
						};
					}));
				}
				getLut(e$1) {
					const t$1 = this._styleColorThemeForScope[e$1];
					return t$1 ? t$1.lut : null;
				}
				setProjection(e$1) {
					e$1 ? this.stylesheet.projection = e$1 : delete this.stylesheet.projection, this.mergeProjection(), this._updateMapProjection();
				}
				applyProjectionUpdate() {
					this._loaded && (this.dispatcher.broadcast("setProjection", this.map.transform.projectionOptions), this.map.transform.projection.requiresDraping ? (this.getTerrain() || this.stylesheet.terrain) && !this.disableElevatedTerrain || this.setTerrainForDraping() : this.terrainSetForDrapingOnly() && this.setTerrain(null, 0));
				}
				_updateMapProjection() {
					this.isRootStyle() && (this.map._useExplicitProjection ? this.applyProjectionUpdate() : this.map._prioritizeAndUpdateProjection(null, this.projection));
				}
				_loadSprite(t$1) {
					this._spriteRequest = function(t$2, i$1, o$1) {
						let s$1, r$1, n$1;
						const a$1 = e.o.devicePixelRatio > 1 ? "@2x" : "";
						let l$1 = e.m(i$1.transformRequest(i$1.normalizeSpriteURL(t$2, a$1, ".json"), e.R.SpriteJSON), ((e$1, t$3) => {
							l$1 = null, n$1 || (n$1 = e$1, s$1 = t$3, h$1());
						})), c$1 = e.n(i$1.transformRequest(i$1.normalizeSpriteURL(t$2, a$1, ".png"), e.R.SpriteImage), ((e$1, t$3) => {
							c$1 = null, n$1 || (n$1 = e$1, r$1 = t$3, h$1());
						}));
						function h$1() {
							if (n$1) o$1(n$1);
							else if (s$1 && r$1) {
								const t$3 = e.o.getImageData(r$1), i$2 = {};
								for (const o$2 in s$1) {
									const { width: r$2, height: n$2, x: a$2, y: l$2, sdf: c$2, pixelRatio: h$2, stretchX: d$1, stretchY: u$1, content: _$1 } = s$1[o$2], p$1 = new e.q({
										width: r$2,
										height: n$2
									});
									e.q.copy(t$3, p$1, {
										x: a$2,
										y: l$2
									}, {
										x: 0,
										y: 0
									}, {
										width: r$2,
										height: n$2
									}, null), i$2[o$2] = {
										data: p$1,
										pixelRatio: void 0 !== h$2 ? h$2 : 1,
										sdf: void 0 !== c$2 && c$2,
										stretchX: d$1,
										stretchY: u$1,
										content: _$1,
										usvg: !1,
										version: 0
									};
								}
								o$1(null, i$2);
							}
						}
						return { cancel() {
							l$1 && (l$1.cancel(), l$1 = null), c$1 && (c$1.cancel(), c$1 = null);
						} };
					}(t$1, this.map._requestManager, ((t$2, i$1) => {
						if (this._spriteRequest = null, t$2) this.fire(new e.y(t$2));
						else if (i$1) {
							const t$3 = /* @__PURE__ */ new Map();
							for (const o$1 in i$1) t$3.set(e.I.from(o$1), i$1[o$1]);
							this.addImages(t$3);
						}
						this.imageManager.setLoaded(!0, this.scope), this.dispatcher.broadcast("spriteLoaded", {
							scope: this.scope,
							isLoaded: !0
						}), this.fire(new e.z("data", { dataType: "style" }));
					}));
				}
				addIconset(t$1, i$1) {
					if ("sprite" === i$1.type) return void this._loadSprite(i$1.url);
					const o$1 = this.getOwnSourceCache(i$1.source);
					if (!o$1) return void this.fire(new e.y(/* @__PURE__ */ new Error(`Source "${i$1.source}" as specified by iconset "${t$1}" does not exist and cannot be used as an iconset source`)));
					const s$1 = o$1.getSource();
					if ("raster-array" !== s$1.type) return void this.fire(new e.y(/* @__PURE__ */ new Error(`Source "${i$1.source}" as specified by iconset "${t$1}" is not a "raster-array" source and cannot be used as an iconset source`)));
					s$1.partial = !1;
					const r$1 = new So(t$1, this.scope, o$1);
					this.imageManager.addImageProvider(r$1, this.scope);
				}
				removeIconset(e$1) {
					this.imageManager.removeImageProvider(e$1, this.scope);
				}
				_loadIconset(t$1) {
					if (!e.h(t$1) && "icon_set" !== this.map._spriteFormat || "raster" === this.map._spriteFormat) return void this._loadSprite(t$1);
					const i$1 = "auto" === this.map._spriteFormat;
					var o$1, s$1;
					this._spriteRequest = (s$1 = (o$2, s$2) => {
						if (this._spriteRequest = null, o$2) i$1 ? this._loadSprite(t$1) : this.fire(new e.y(o$2));
						else if (s$2) {
							const t$2 = /* @__PURE__ */ new Map();
							for (const i$2 in s$2) t$2.set(e.I.from(i$2), s$2[i$2]);
							this.addImages(t$2);
						}
						this.imageManager.setLoaded(!0, this.scope), this.dispatcher.broadcast("spriteLoaded", {
							scope: this.scope,
							isLoaded: !0
						}), this.fire(new e.z("data", { dataType: "style" }));
					}, e.bu((o$1 = this.map._requestManager).transformRequest(o$1.normalizeIconsetURL(t$1), e.R.Iconset), ((t$2, i$2) => {
						if (t$2) return void s$1(t$2);
						const o$2 = {}, r$1 = e.dg(new e.bt(i$2));
						for (const t$3 of r$1.icons) {
							const i$3 = {
								version: 1,
								pixelRatio: e.o.devicePixelRatio,
								content: To(t$3),
								stretchX: t$3.metadata ? Eo(t$3.metadata.stretch_x_areas) : void 0,
								stretchY: t$3.metadata ? Eo(t$3.metadata.stretch_y_areas) : void 0,
								sdf: !1,
								usvg: !0,
								icon: t$3
							};
							o$2[t$3.name] = i$3;
						}
						s$1(null, o$2);
					})));
				}
				_validateLayer(t$1) {
					const i$1 = this.getOwnSource(t$1.source);
					if (!i$1) return;
					const o$1 = t$1.sourceLayer;
					o$1 && ("geojson" === i$1.type || i$1.vectorLayerIds && -1 === i$1.vectorLayerIds.indexOf(o$1)) && this.fire(new e.y(/* @__PURE__ */ new Error(`Source layer "${o$1}" does not exist on source "${i$1.id}" as specified by style layer "${t$1.id}"`)));
				}
				loaded() {
					if (!this._loaded) return !1;
					if (Object.keys(this._changes.getUpdatedSourceCaches()).length) return !1;
					for (const e$1 in this._sourceCaches) if (!this._sourceCaches[e$1].loaded()) return !1;
					if (!this.imageManager.isLoaded()) return !1;
					if (this.imageManager.hasPatternsInFlight()) return !1;
					if (!this.modelManager.isLoaded()) return !1;
					if (this._styleColorTheme.lutLoading) return !1;
					for (const { style: e$1 } of this.fragments) if (!e$1.loaded()) return !1;
					return !0;
				}
				_serializeImports() {
					if (this.stylesheet.imports) return this.stylesheet.imports.map(((e$1, t$1) => {
						const i$1 = this.fragments[t$1];
						return i$1 && i$1.style && (e$1.data = i$1.style.serialize()), e$1;
					}));
				}
				_serializeSources() {
					const e$1 = {};
					for (const t$1 in this._sourceCaches) {
						const i$1 = this._sourceCaches[t$1].getSource();
						e$1[i$1.id] || (e$1[i$1.id] = i$1.serialize());
					}
					return e$1;
				}
				_serializeLayers(e$1) {
					const t$1 = [];
					for (const i$1 of e$1) {
						const e$2 = this._layers[i$1];
						e$2 && "custom" !== e$2.type && t$1.push(e$2.serialize());
					}
					return t$1;
				}
				hasLightTransitions() {
					return !(!this.light || !this.light.hasTransition()) || !(!this.ambientLight || !this.ambientLight.hasTransition()) || !(!this.directionalLight || !this.directionalLight.hasTransition());
				}
				hasFogTransition() {
					return !!this.fog && this.fog.hasTransition();
				}
				hasSnowTransition() {
					return !!this.snow && this.snow.hasTransition();
				}
				hasRainTransition() {
					return !!this.rain && this.rain.hasTransition();
				}
				hasTransitions() {
					if (this.hasLightTransitions()) return !0;
					if (this.hasFogTransition()) return !0;
					if (this.hasSnowTransition()) return !0;
					if (this.hasRainTransition()) return !0;
					for (const e$1 in this._sourceCaches) if (this._sourceCaches[e$1].hasTransition()) return !0;
					for (const e$1 in this._layers) if (this._layers[e$1].hasTransition()) return !0;
					return !1;
				}
				_updateDataDrivenEmissiveStrength() {
					for (const e$1 in this._mergedLayers) {
						const t$1 = this._mergedLayers[e$1];
						if (t$1._transitionablePaint && t$1._transitionablePaint._values) {
							const e$2 = t$1._transitionablePaint._values["line-emissive-strength"];
							if (e$2 && e$2.value && e$2.value.isDataDriven()) return void (this._hasDataDrivenEmissive = !0);
						}
					}
					this._hasDataDrivenEmissive = !1;
				}
				hasDataDrivenEmissiveStrength() {
					return this._hasDataDrivenEmissive;
				}
				get order() {
					return this.terrain ? this._drapedFirstOrder : this._mergedOrder;
				}
				_getOrder(e$1) {
					return e$1 ? this.order : this._mergedOrder;
				}
				isLayerDraped(e$1) {
					return !!this.terrain && e$1.isDraped(this.getLayerSourceCache(e$1));
				}
				_checkLoaded() {
					if (!this._loaded) throw new Error("Style is not done loading");
				}
				_checkLayer(t$1) {
					const i$1 = this.getOwnLayer(t$1);
					if (i$1) return i$1;
					this.fire(new e.y(/* @__PURE__ */ new Error(`The layer '${t$1}' does not exist in the map's style.`)));
				}
				_checkSource(t$1) {
					const i$1 = this.getOwnSource(t$1);
					if (i$1) return i$1;
					this.fire(new e.y(/* @__PURE__ */ new Error(`The source '${t$1}' does not exist in the map's style.`)));
				}
				precompilePrograms(e$1, t$1) {
					const i$1 = this.map.painter;
					if (i$1) for (let o$1 = e$1.minzoom || 0; o$1 < (e$1.maxzoom || 25.5); o$1++) {
						const o$2 = e$1.getProgramIds();
						if (o$2) for (const s$1 of o$2) {
							const o$3 = e$1.getDefaultProgramParams(s$1, t$1.zoom, this._styleColorTheme.lut);
							o$3 && (i$1.style = this, this.fog && (i$1._fogVisible = !0, o$3.overrideFog = !0, i$1.getOrCreateProgram(s$1, o$3)), i$1._fogVisible = !1, o$3.overrideFog = !1, i$1.getOrCreateProgram(s$1, o$3), (this.stylesheet.terrain || this.stylesheet.projection && "globe" === this.stylesheet.projection.name) && (o$3.overrideRtt = !0, i$1.getOrCreateProgram(s$1, o$3)));
						}
					}
				}
				update(t$1) {
					if (!this._loaded) return;
					this.ambientLight && this.ambientLight.recalculate(t$1), this.directionalLight && this.directionalLight.recalculate(t$1);
					const i$1 = this.calculateLightsBrightness();
					t$1.brightness = i$1 || 0, i$1 !== this._brightness && (this._brightness = i$1, this.dispatcher.broadcast("setBrightness", i$1)), t$1.worldview !== this._worldview && (this._worldview = t$1.worldview, this.dispatcher.broadcast("setWorldview", this._worldview));
					const o$1 = this._changes.isDirty();
					let s$1 = !1;
					if (this._changes.isDirty()) {
						const e$1 = this._changes.getLayerUpdatesByScope();
						for (const t$2 in e$1) {
							const { updatedIds: i$2, removedIds: o$2 } = e$1[t$2];
							(i$2 || o$2) && (this._updateWorkerLayers(t$2, i$2, o$2), s$1 = !0);
						}
						this.updateSourceCaches(), this._updateTilesForChangedImages(), this.updateLayers(t$1), this.light && this.light.updateTransitions(t$1), this.ambientLight && this.ambientLight.updateTransitions(t$1), this.directionalLight && this.directionalLight.updateTransitions(t$1), this.fog && this.fog.updateTransitions(t$1), this.snow && this.snow.updateTransitions(t$1), this.rain && this.rain.updateTransitions(t$1), this._changes.reset();
					}
					const r$1 = {};
					for (const e$1 in this._mergedSourceCaches) {
						const t$2 = this._mergedSourceCaches[e$1];
						r$1[e$1] = t$2.used, t$2.used = !1, t$2.tileCoverLift = 0;
					}
					for (const e$1 of this._mergedOrder) {
						const i$2 = this._mergedLayers[e$1];
						if ("none" !== i$2.visibility && i$2.recalculate(t$1, this._availableImages), !i$2.isHidden(t$1.zoom)) {
							const e$2 = this.getLayerSourceCache(i$2);
							e$2 && (e$2.used = !0, e$2.tileCoverLift = Math.max(e$2.tileCoverLift, i$2.tileCoverLift()));
						}
						!this._precompileDone && this._shouldPrecompile && ("requestIdleCallback" in window ? requestIdleCallback((() => {
							this.precompilePrograms(i$2, t$1);
						})) : this.precompilePrograms(i$2, t$1));
					}
					this._shouldPrecompile && (this._precompileDone = !0), this.terrain && s$1 && this.mergeLayers();
					const n$1 = this.imageManager.getPendingImageProviders();
					for (const e$1 of n$1) e$1.sourceCache.used = !0;
					for (const t$2 in r$1) {
						const i$2 = this._mergedSourceCaches[t$2];
						r$1[t$2] !== i$2.used && i$2.getSource().fire(new e.z("data", {
							sourceDataType: "visibility",
							dataType: "source",
							sourceId: i$2.getSource().id
						}));
					}
					this.light && this.light.recalculate(t$1), this.terrain && this.terrain.recalculate(t$1), this.fog && this.fog.recalculate(t$1), this.snow && this.snow.recalculate(t$1), this.rain && this.rain.recalculate(t$1), this.z = t$1.zoom, this._markersNeedUpdate && (this._updateMarkersOpacity(), this._markersNeedUpdate = !1), this.imageManager.clearUpdatedImages(this.scope), o$1 && this.fire(new e.z("data", { dataType: "style" }));
				}
				updateImageProviders() {
					const e$1 = this.imageManager.getPendingImageProviders();
					for (const t$1 of e$1) {
						const e$2 = t$1.resolvePendingRequests(), i$1 = this.getFragmentStyle(t$1.scope);
						i$1 && i$1.addImages(e$2);
					}
				}
				_updateTilesForChangedImages() {
					const e$1 = {};
					for (const t$1 in this._mergedSourceCaches) {
						const i$1 = this._mergedSourceCaches[t$1].getSource().scope;
						e$1[i$1] = e$1[i$1] || this._changes.getUpdatedImages(i$1), 0 !== e$1[i$1].length && this._mergedSourceCaches[t$1].reloadTilesForDependencies(["icons", "patterns"], e$1[i$1]);
					}
					for (const t$1 in e$1) this._changes.resetUpdatedImages(t$1);
				}
				_updateWorkerLayers(e$1, t$1, i$1) {
					const o$1 = this.getFragmentStyle(e$1);
					o$1 && this.dispatcher.broadcast("updateLayers", {
						layers: t$1 ? o$1._serializeLayers(t$1) : [],
						scope: e$1,
						removedIds: i$1 || [],
						options: o$1.options
					});
				}
				setState(t$1, i$1) {
					if (this._checkLoaded(), Io(this, we(t$1))) return !1;
					(t$1 = e.dp(t$1)).layers = Gt(t$1.layers);
					const o$1 = function(t$2, i$2) {
						if (!t$2) return [{
							command: Vt.setStyle,
							args: [i$2]
						}];
						let o$2 = [];
						try {
							if (!e.by(t$2.version, i$2.version)) return [{
								command: Vt.setStyle,
								args: [i$2]
							}];
							if (e.by(t$2.center, i$2.center) || o$2.push({
								command: Vt.setCenter,
								args: [i$2.center]
							}), e.by(t$2.zoom, i$2.zoom) || o$2.push({
								command: Vt.setZoom,
								args: [i$2.zoom]
							}), e.by(t$2.bearing, i$2.bearing) || o$2.push({
								command: Vt.setBearing,
								args: [i$2.bearing]
							}), e.by(t$2.pitch, i$2.pitch) || o$2.push({
								command: Vt.setPitch,
								args: [i$2.pitch]
							}), e.by(t$2.sprite, i$2.sprite) || o$2.push({
								command: Vt.setSprite,
								args: [i$2.sprite]
							}), e.by(t$2.glyphs, i$2.glyphs) || o$2.push({
								command: Vt.setGlyphs,
								args: [i$2.glyphs]
							}), e.by(t$2.imports, i$2.imports) || function(t$3 = [], i$3 = [], o$3) {
								i$3 = i$3 || [];
								const s$3 = (t$3 = t$3 || []).map(Xt), r$3 = i$3.map(Xt), n$2 = t$3.reduce(Yt, {}), a$2 = i$3.reduce(Yt, {}), l$1 = s$3.slice();
								let c$1, h$1, d$1, u$1;
								for (c$1 = 0, h$1 = 0; c$1 < s$3.length; c$1++) d$1 = s$3[c$1], a$2.hasOwnProperty(d$1) ? h$1++ : (o$3.push({
									command: Vt.removeImport,
									args: [d$1]
								}), l$1.splice(l$1.indexOf(d$1, h$1), 1));
								for (c$1 = 0, h$1 = 0; c$1 < r$3.length; c$1++) d$1 = r$3[r$3.length - 1 - c$1], l$1[l$1.length - 1 - c$1] !== d$1 && (n$2.hasOwnProperty(d$1) ? (o$3.push({
									command: Vt.removeImport,
									args: [d$1]
								}), l$1.splice(l$1.lastIndexOf(d$1, l$1.length - h$1), 1)) : h$1++, u$1 = l$1[l$1.length - c$1], o$3.push({
									command: Vt.addImport,
									args: [a$2[d$1], u$1]
								}), l$1.splice(l$1.length - c$1, 0, d$1));
								for (const t$4 of i$3) {
									const i$4 = n$2[t$4.id];
									i$4 && (delete i$4.data, e.by(i$4, t$4) || o$3.push({
										command: Vt.updateImport,
										args: [t$4.id, t$4]
									}));
								}
							}(t$2.imports, i$2.imports, o$2), e.by(t$2.transition, i$2.transition) || o$2.push({
								command: Vt.setTransition,
								args: [i$2.transition]
							}), e.by(t$2.light, i$2.light) || o$2.push({
								command: Vt.setLight,
								args: [i$2.light]
							}), e.by(t$2.fog, i$2.fog) || o$2.push({
								command: Vt.setFog,
								args: [i$2.fog]
							}), e.by(t$2.snow, i$2.snow) || o$2.push({
								command: Vt.setSnow,
								args: [i$2.snow]
							}), e.by(t$2.rain, i$2.rain) || o$2.push({
								command: Vt.setRain,
								args: [i$2.rain]
							}), e.by(t$2.projection, i$2.projection) || o$2.push({
								command: Vt.setProjection,
								args: [i$2.projection]
							}), e.by(t$2.lights, i$2.lights) || o$2.push({
								command: Vt.setLights,
								args: [i$2.lights]
							}), e.by(t$2.camera, i$2.camera) || o$2.push({
								command: Vt.setCamera,
								args: [i$2.camera]
							}), e.by(t$2.iconsets, i$2.iconsets) || function(t$3, i$3, o$3) {
								let s$3;
								for (s$3 in i$3 = i$3 || {}, t$3 = t$3 || {}) t$3.hasOwnProperty(s$3) && (i$3.hasOwnProperty(s$3) || o$3.push({
									command: Vt.removeIconset,
									args: [s$3]
								}));
								for (s$3 in i$3) {
									if (!i$3.hasOwnProperty(s$3)) continue;
									const r$3 = i$3[s$3];
									t$3.hasOwnProperty(s$3) ? e.by(t$3[s$3], r$3) || (o$3.push({
										command: Vt.removeIconset,
										args: [s$3]
									}), o$3.push({
										command: Vt.addIconset,
										args: [s$3, r$3]
									})) : o$3.push({
										command: Vt.addIconset,
										args: [s$3, r$3]
									});
								}
							}(t$2.iconsets, i$2.iconsets, o$2), !e.by(t$2["color-theme"], i$2["color-theme"])) return [{
								command: Vt.setStyle,
								args: [i$2]
							}];
							const s$2 = {}, r$2 = [];
							(function(t$3, i$3, o$3, s$3) {
								let r$3;
								for (r$3 in i$3 = i$3 || {}, t$3 = t$3 || {}) t$3.hasOwnProperty(r$3) && (i$3.hasOwnProperty(r$3) || qt(r$3, o$3, s$3));
								for (r$3 in i$3) {
									if (!i$3.hasOwnProperty(r$3)) continue;
									const n$2 = i$3[r$3];
									t$3.hasOwnProperty(r$3) ? e.by(t$3[r$3], n$2) || ("geojson" === t$3[r$3].type && "geojson" === n$2.type && Wt(t$3, i$3, r$3) ? o$3.push({
										command: Vt.setGeoJSONSourceData,
										args: [r$3, n$2.data]
									}) : Zt(r$3, i$3, o$3, s$3)) : Ht(r$3, i$3, o$3);
								}
							})(t$2.sources, i$2.sources, r$2, s$2);
							const n$1 = [];
							t$2.layers && t$2.layers.forEach(((e$1) => {
								e$1.source && s$2[e$1.source] ? o$2.push({
									command: Vt.removeLayer,
									args: [e$1.id]
								}) : n$1.push(e$1);
							}));
							let a$1 = t$2.terrain;
							a$1 && s$2[a$1.source] && (o$2.push({
								command: Vt.setTerrain,
								args: [void 0]
							}), a$1 = void 0), o$2 = o$2.concat(r$2), e.by(a$1, i$2.terrain) || o$2.push({
								command: Vt.setTerrain,
								args: [i$2.terrain]
							}), function(t$3, i$3, o$3) {
								i$3 = i$3 || [];
								const s$3 = (t$3 = t$3 || []).map(Xt), r$3 = i$3.map(Xt), n$2 = t$3.reduce(Yt, {}), a$2 = i$3.reduce(Yt, {}), l$1 = s$3.slice(), c$1 = Object.create(null);
								let h$1, d$1, u$1, _$1, p$1, f$1, m$1;
								for (h$1 = 0, d$1 = 0; h$1 < s$3.length; h$1++) u$1 = s$3[h$1], a$2.hasOwnProperty(u$1) ? d$1++ : (o$3.push({
									command: Vt.removeLayer,
									args: [u$1]
								}), l$1.splice(l$1.indexOf(u$1, d$1), 1));
								for (h$1 = 0, d$1 = 0; h$1 < r$3.length; h$1++) u$1 = r$3[r$3.length - 1 - h$1], l$1[l$1.length - 1 - h$1] !== u$1 && (n$2.hasOwnProperty(u$1) ? (o$3.push({
									command: Vt.removeLayer,
									args: [u$1]
								}), l$1.splice(l$1.lastIndexOf(u$1, l$1.length - d$1), 1)) : d$1++, f$1 = l$1[l$1.length - h$1], o$3.push({
									command: Vt.addLayer,
									args: [a$2[u$1], f$1]
								}), l$1.splice(l$1.length - h$1, 0, u$1), c$1[u$1] = !0);
								for (h$1 = 0; h$1 < r$3.length; h$1++) if (u$1 = r$3[h$1], _$1 = n$2[u$1], p$1 = a$2[u$1], !c$1[u$1] && !e.by(_$1, p$1)) if (e.by(_$1.source, p$1.source) && e.by(_$1["source-layer"], p$1["source-layer"]) && e.by(_$1.type, p$1.type)) {
									for (m$1 in $t(_$1.layout, p$1.layout, o$3, u$1, null, Vt.setLayoutProperty), $t(_$1.paint, p$1.paint, o$3, u$1, null, Vt.setPaintProperty), e.by(_$1.slot, p$1.slot) || o$3.push({
										command: Vt.setSlot,
										args: [u$1, p$1.slot]
									}), e.by(_$1.filter, p$1.filter) || o$3.push({
										command: Vt.setFilter,
										args: [u$1, p$1.filter]
									}), e.by(_$1.minzoom, p$1.minzoom) && e.by(_$1.maxzoom, p$1.maxzoom) || o$3.push({
										command: Vt.setLayerZoomRange,
										args: [
											u$1,
											p$1.minzoom,
											p$1.maxzoom
										]
									}), _$1) _$1.hasOwnProperty(m$1) && "layout" !== m$1 && "paint" !== m$1 && "filter" !== m$1 && "metadata" !== m$1 && "minzoom" !== m$1 && "maxzoom" !== m$1 && "slot" !== m$1 && (0 === m$1.indexOf("paint.") ? $t(_$1[m$1], p$1[m$1], o$3, u$1, m$1.slice(6), Vt.setPaintProperty) : e.by(_$1[m$1], p$1[m$1]) || o$3.push({
										command: Vt.setLayerProperty,
										args: [
											u$1,
											m$1,
											p$1[m$1]
										]
									}));
									for (m$1 in p$1) p$1.hasOwnProperty(m$1) && !_$1.hasOwnProperty(m$1) && "layout" !== m$1 && "paint" !== m$1 && "filter" !== m$1 && "metadata" !== m$1 && "minzoom" !== m$1 && "maxzoom" !== m$1 && "slot" !== m$1 && (0 === m$1.indexOf("paint.") ? $t(_$1[m$1], p$1[m$1], o$3, u$1, m$1.slice(6), Vt.setPaintProperty) : e.by(_$1[m$1], p$1[m$1]) || o$3.push({
										command: Vt.setLayerProperty,
										args: [
											u$1,
											m$1,
											p$1[m$1]
										]
									}));
								} else o$3.push({
									command: Vt.removeLayer,
									args: [u$1]
								}), f$1 = l$1[l$1.lastIndexOf(u$1) + 1], o$3.push({
									command: Vt.addLayer,
									args: [p$1, f$1]
								});
							}(n$1, i$2.layers, o$2);
						} catch (e$1) {
							console.warn("Unable to compute style diff:", e$1), o$2 = [{
								command: Vt.setStyle,
								args: [i$2]
							}];
						}
						return o$2;
					}(this.serialize(), t$1).filter(((e$1) => !(e$1.command in Ro)));
					if (0 === o$1.length) return !1;
					const s$1 = o$1.filter(((e$1) => !(e$1.command in Co)));
					if (s$1.length > 0) throw new Error(`Unimplemented: ${s$1.map(((e$1) => e$1.command)).join(", ")}.`);
					const r$1 = [];
					return o$1.forEach(((e$1) => {
						r$1.push(this[e$1.command](...e$1.args));
					})), i$1 && Promise.all(r$1).then(i$1).catch(i$1), this.stylesheet = t$1, this.mergeAll(), this.dispatcher.broadcast("setLayers", {
						layers: this._serializeLayers(this._order),
						scope: this.scope,
						options: this.options
					}), !0;
				}
				_updateWorkerImages() {
					this._availableImages = this.imageManager.listImages(this.scope), this.dispatcher.broadcast("setImages", {
						scope: this.scope,
						images: this._availableImages
					});
				}
				_updateWorkerModels() {
					this._availableModels = this.modelManager.getModelURIs(this.scope), this.dispatcher.broadcast("setModels", {
						scope: this.scope,
						models: this._availableModels
					});
				}
				addImages(t$1) {
					if (0 === t$1.size) return this;
					for (const [i$1, o$1] of t$1.entries()) {
						if (this.getImage(i$1)) return this.fire(new e.y(/* @__PURE__ */ new Error(`An image with the name "${i$1.name}" already exists.`)));
						this.imageManager.addImage(i$1, this.scope, o$1), this._changes.updateImage(i$1, this.scope);
					}
					return this._updateWorkerImages(), this.fire(new e.z("data", { dataType: "style" })), this;
				}
				addImage(t$1, i$1) {
					return this.getImage(t$1) ? this.fire(new e.y(/* @__PURE__ */ new Error(`An image with the name "${t$1.name}" already exists.`))) : (this.imageManager.addImage(t$1, this.scope, i$1), this._changes.updateImage(t$1, this.scope), this._updateWorkerImages(), this.fire(new e.z("data", { dataType: "style" })), this);
				}
				updateImage(t$1, i$1, o$1 = !1) {
					this.imageManager.updateImage(t$1, this.scope, i$1), o$1 && (this._changes.updateImage(t$1, this.scope), this._updateWorkerImages(), this.fire(new e.z("data", { dataType: "style" })));
				}
				getImage(e$1) {
					return this.imageManager.getImage(e$1, this.scope);
				}
				removeImage(t$1) {
					return this.getImage(t$1) ? (this.imageManager.removeImage(t$1, this.scope), this._changes.updateImage(t$1, this.scope), this._updateWorkerImages(), this.fire(new e.z("data", { dataType: "style" })), this) : this.fire(new e.y(/* @__PURE__ */ new Error("No image with this name exists.")));
				}
				listImages() {
					return this._checkLoaded(), this._availableImages.slice();
				}
				getActualScope() {
					return this._importedAsBasemap ? "basemap" : this.scope;
				}
				addModelURLs(t$1) {
					return this.modelManager.addModelURLs(t$1, this.getActualScope()), this._updateWorkerModels(), this.fire(new e.z("data", { dataType: "style" })), this;
				}
				addModel(t$1, i$1, o$1 = {}) {
					return this._checkLoaded(), this._validate(ze, `models.${t$1}`, i$1, null, o$1) || (this.modelManager.addModel(t$1, i$1, this.getActualScope()), this.fire(new e.z("data", { dataType: "style" }))), this;
				}
				hasModel(e$1) {
					return this.modelManager.hasModel(e$1, this.getActualScope());
				}
				removeModel(t$1) {
					return this.hasModel(t$1) ? (this.modelManager.removeModel(t$1, this.getActualScope(), !1, !0), this.fire(new e.z("data", { dataType: "style" })), this) : this.fire(new e.y(/* @__PURE__ */ new Error("No model with this ID exists.")));
				}
				listModels() {
					return this._checkLoaded(), this.modelManager.listModels(this.getActualScope());
				}
				addSource(t$1, i$1, o$1 = {}) {
					if (this._checkLoaded(), void 0 !== this.getOwnSource(t$1)) throw new Error(`There is already a source with ID "${t$1}".`);
					if (!i$1.type) throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(i$1).join(", ")}.`);
					if ([
						"vector",
						"raster",
						"geojson",
						"video",
						"image"
					].indexOf(i$1.type) >= 0 && this._validate(Te, `sources.${t$1}`, i$1, null, o$1)) return;
					this.map && this.map._collectResourceTiming && (i$1.collectResourceTiming = !0);
					const s$1 = mt(t$1, i$1, this.dispatcher, this);
					s$1.scope = this.scope, s$1.setEventedParent(this, (() => ({
						isSourceLoaded: this._isSourceCacheLoaded(s$1.id),
						source: s$1.serialize(),
						sourceId: s$1.id
					})));
					const r$1 = (t$2) => {
						const i$2 = (t$2 ? "symbol:" : "other:") + s$1.id, o$2 = e.B(i$2, this.scope), r$2 = this._sourceCaches[i$2] = new Ft(o$2, s$1, t$2);
						(t$2 ? this._symbolSourceCaches : this._otherSourceCaches)[s$1.id] = r$2, r$2.onAdd(this.map);
					};
					r$1(!1), "vector" !== i$1.type && "geojson" !== i$1.type || r$1(!0), s$1.onAdd && s$1.onAdd(this.map), o$1.isInitialLoad || (this.mergeSources(), this._changes.setDirty());
				}
				removeSource(t$1) {
					this._checkLoaded();
					const i$1 = this.getOwnSource(t$1);
					if (!i$1) throw new Error("There is no source with this ID");
					for (const i$2 in this._layers) if (this._layers[i$2].source === t$1) return this.fire(new e.y(/* @__PURE__ */ new Error(`Source "${t$1}" cannot be removed while layer "${i$2}" is using it.`)));
					if (this.terrain && this.terrain.scope === this.scope && this.terrain.get().source === t$1) return this.fire(new e.y(/* @__PURE__ */ new Error(`Source "${t$1}" cannot be removed while terrain is using it.`)));
					if (this.stylesheet.iconsets) {
						const i$2 = Object.entries(this.stylesheet.iconsets).find((([e$1, i$3]) => "source" === i$3.type && i$3.source === t$1));
						if (i$2) return this.fire(new e.y(/* @__PURE__ */ new Error(`Source "${t$1}" cannot be removed while iconset "${i$2[0]}" is using it.`)));
					}
					const o$1 = this.getOwnSourceCaches(t$1);
					for (const t$2 of o$1) {
						const i$2 = e.dq(t$2.id);
						delete this._sourceCaches[i$2], this._changes.discardSourceCacheUpdate(t$2.id), t$2.fire(new e.z("data", {
							sourceDataType: "metadata",
							dataType: "source",
							sourceId: t$2.getSource().id
						})), t$2.setEventedParent(null), t$2.clearTiles();
					}
					return delete this._otherSourceCaches[t$1], delete this._symbolSourceCaches[t$1], this.mergeSources(), i$1.setEventedParent(null), i$1.onRemove && i$1.onRemove(this.map), this._changes.setDirty(), this;
				}
				setGeoJSONSourceData(e$1, t$1) {
					this._checkLoaded(), this.getOwnSource(e$1).setData(t$1), this._changes.setDirty();
				}
				getOwnSource(e$1) {
					const t$1 = this.getOwnSourceCache(e$1);
					return t$1 && t$1.getSource();
				}
				getOwnSources() {
					const e$1 = [];
					for (const t$1 in this._otherSourceCaches) {
						const i$1 = this.getOwnSourceCache(t$1);
						i$1 && e$1.push(i$1.getSource());
					}
					return e$1;
				}
				areTilesLoaded() {
					const e$1 = this._mergedSourceCaches;
					for (const t$1 in e$1) {
						const i$1 = e$1[t$1]._tiles;
						for (const e$2 in i$1) {
							const t$2 = i$1[e$2];
							if ("loaded" !== t$2.state && "errored" !== t$2.state) return !1;
						}
					}
					return !0;
				}
				setLights(t$1) {
					if (this._checkLoaded(), !t$1) return delete this.ambientLight, void delete this.directionalLight;
					const i$1 = this._getTransitionParameters();
					for (const o$2 of t$1) {
						if (this._validate(Se, "lights", o$2)) return;
						switch (o$2.type) {
							case "ambient":
								if (this.ambientLight) {
									const e$1 = this.ambientLight;
									e$1.set(o$2), e$1.updateTransitions(i$1);
								} else this.ambientLight = new ot(o$2, Qe || (Qe = new e.a9({
									color: new e.aa(e.a6.properties_light_ambient.color),
									"color-use-theme": new e.aa({
										type: "string",
										default: "default",
										"property-type": "data-constant"
									}),
									intensity: new e.aa(e.a6.properties_light_ambient.intensity)
								})), this.scope, this.options);
								break;
							case "directional": if (this.directionalLight) {
								const e$1 = this.directionalLight;
								e$1.set(o$2), e$1.updateTransitions(i$1);
							} else this.directionalLight = new ot(o$2, et || (et = new e.a9({
								direction: new e.ap(e.a6.properties_light_directional.direction),
								color: new e.aa(e.a6.properties_light_directional.color),
								"color-use-theme": new e.aa({
									type: "string",
									default: "default",
									"property-type": "data-constant"
								}),
								intensity: new e.aa(e.a6.properties_light_directional.intensity),
								"cast-shadows": new e.aa(e.a6.properties_light_directional["cast-shadows"]),
								"shadow-quality": new e.aa(e.a6.properties_light_directional["shadow-quality"]),
								"shadow-intensity": new e.aa(e.a6.properties_light_directional["shadow-intensity"])
							})), this.scope, this.options);
						}
					}
					const o$1 = Object.assign(i$1, { worldview: this.map.getWorldview() }), s$1 = new e.ac(this.z || 0, o$1);
					this.ambientLight && this.ambientLight.recalculate(s$1), this.directionalLight && this.directionalLight.recalculate(s$1), this._brightness = this.calculateLightsBrightness(), this.dispatcher.broadcast("setBrightness", this._brightness);
				}
				calculateLightsBrightness() {
					const t$1 = this.directionalLight, i$1 = this.ambientLight;
					if (!t$1 || !i$1) return;
					const o$1 = (e$1) => .2126 * (e$1[0] <= .03928 ? e$1[0] / 12.92 : Math.pow((e$1[0] + .055) / 1.055, 2.4)) + .7152 * (e$1[1] <= .03928 ? e$1[1] / 12.92 : Math.pow((e$1[1] + .055) / 1.055, 2.4)) + .0722 * (e$1[2] <= .03928 ? e$1[2] / 12.92 : Math.pow((e$1[2] + .055) / 1.055, 2.4)), s$1 = t$1.properties.get("color").toNonPremultipliedRenderColor(null).toArray01(), r$1 = t$1.properties.get("intensity"), n$1 = t$1.properties.get("direction"), a$1 = 1 - e.d4(n$1.x, n$1.y, n$1.z)[2] / 90, l$1 = o$1(s$1) * r$1 * a$1, c$1 = i$1.properties.get("color").toNonPremultipliedRenderColor(null).toArray01(), h$1 = i$1.properties.get("intensity"), d$1 = o$1(c$1) * h$1;
					return Number(((l$1 + d$1) / 2).toFixed(6));
				}
				getBrightness() {
					return this._brightness;
				}
				getLights() {
					if (!this.enable3dLights()) return null;
					const e$1 = [];
					return this.directionalLight && e$1.push(this.directionalLight.get()), this.ambientLight && e$1.push(this.ambientLight.get()), e$1;
				}
				enable3dLights() {
					return !!this.ambientLight && !!this.directionalLight;
				}
				getFragmentStyle(t$1) {
					if (null == t$1 || "" === t$1 && this.isRootStyle()) return this;
					if (e.dr(t$1)) {
						const i$1 = e.ds(t$1), o$1 = this.fragments.find((({ id: e$1 }) => e$1 === i$1));
						if (!o$1) return;
						const s$1 = e.dq(t$1);
						return o$1.style.getFragmentStyle(s$1);
					}
					{
						const e$1 = this.fragments.find((({ id: e$2 }) => e$2 === t$1));
						return e$1 ? e$1.style : void 0;
					}
				}
				setFeaturesetSelectors(t$1) {
					if (!t$1) return;
					const i$1 = {}, o$1 = (e$1, t$2 = "") => `${e$1}::${t$2}`;
					this._featuresetSelectors = {};
					for (const s$1 in t$1) {
						const r$1 = this._featuresetSelectors[s$1] = [];
						for (const n$1 of t$1[s$1].selectors) {
							if (n$1.featureNamespace) {
								const t$3 = this.getOwnLayer(n$1.layer);
								if (!t$3) {
									e.w(`Layer is undefined for selector: ${n$1.layer}`);
									continue;
								}
								const r$2 = o$1(t$3.source, t$3.sourceLayer);
								if (r$2 in i$1 && i$1[r$2] !== n$1.featureNamespace) {
									e.w(`"featureNamespace ${n$1.featureNamespace} of featureset ${s$1}'s selector is not associated to the same source, skip this selector`);
									continue;
								}
								i$1[r$2] = n$1.featureNamespace;
							}
							let t$2;
							if (n$1.properties) for (const i$2 in n$1.properties) {
								const o$2 = e.U(n$1.properties[i$2]);
								"success" === o$2.result && (t$2 = t$2 || {}, t$2[i$2] = o$2.value);
							}
							r$1.push({
								layerId: n$1.layer,
								namespace: n$1.featureNamespace,
								properties: t$2,
								uniqueFeatureID: n$1._uniqueFeatureID
							});
						}
					}
				}
				getFeaturesetDescriptors(e$1) {
					const t$1 = this.getFragmentStyle(e$1);
					if (!t$1 || !t$1.stylesheet.featuresets) return [];
					const i$1 = [];
					for (const e$2 in t$1.stylesheet.featuresets) i$1.push({
						featuresetId: e$2,
						importId: t$1.scope ? t$1.scope : void 0
					});
					return i$1;
				}
				getFeaturesetLayers(t$1, i$1) {
					const o$1 = this.getFragmentStyle(i$1), s$1 = o$1.stylesheet.featuresets;
					if (!s$1 || !s$1[t$1]) return this.fire(new e.y(/* @__PURE__ */ new Error(`The featureset '${t$1}' does not exist in the map's style and cannot be queried.`))), [];
					const r$1 = [];
					for (const e$1 of s$1[t$1].selectors) {
						const t$2 = o$1.getOwnLayer(e$1.layer);
						t$2 && r$1.push(t$2);
					}
					return r$1;
				}
				getConfigProperty(t$1, i$1) {
					const o$1 = this.getFragmentStyle(t$1);
					if (!o$1) return null;
					const s$1 = e.B(i$1, o$1.scope), r$1 = o$1.options.get(s$1), n$1 = r$1 ? r$1.value || r$1.default : null;
					return n$1 ? n$1.serialize() : null;
				}
				isIndoorEnabled() {
					return Object.keys(this._mergedIndoor).length > 0;
				}
				getIndoorSourceLayers(t$1, i$1) {
					const o$1 = e.B(t$1, i$1);
					return this._mergedIndoor[o$1];
				}
				setIndoorData(e$1, t$1) {
					this.map.indoor.setIndoorData(t$1);
				}
				updateIndoorDependentLayers() {
					this._updateLayers(this._indoorDependentLayers), this.map._styleDirty = !0, this.map.triggerRepaint();
				}
				setConfigProperty(t$1, i$1, o$1) {
					const s$1 = this.getFragmentStyle(t$1);
					if (!s$1) return;
					const r$1 = s$1.stylesheet.schema;
					if (!r$1 || !r$1[i$1]) return;
					const n$1 = e.U(o$1);
					if ("success" !== n$1.result) return void Io(this, n$1.value);
					const a$1 = n$1.value.expression, l$1 = e.B(i$1, s$1.scope), c$1 = s$1.options.get(l$1);
					if (!c$1) return;
					let h$1;
					const { minValue: d$1, maxValue: u$1, stepValue: _$1, type: p$1, values: f$1 } = r$1[i$1], m$1 = e.U(r$1[i$1].default);
					"success" === m$1.result && (h$1 = m$1.value.expression), h$1 ? (this.options.set(l$1, Object.assign({}, c$1, {
						value: a$1,
						default: h$1,
						minValue: d$1,
						maxValue: u$1,
						stepValue: _$1,
						type: p$1,
						values: f$1
					})), this.updateConfigDependencies(i$1)) : this.fire(new e.y(/* @__PURE__ */ new Error(`No schema defined for the config option "${i$1}" in the "${t$1}" fragment.`)));
				}
				getConfig(t$1) {
					const i$1 = this.getFragmentStyle(t$1);
					if (!i$1) return null;
					const o$1 = i$1.stylesheet.schema;
					if (!o$1) return null;
					const s$1 = {};
					for (const t$2 in o$1) {
						const o$2 = e.B(t$2, i$1.scope), r$1 = i$1.options.get(o$2), n$1 = r$1 ? r$1.value || r$1.default : null;
						s$1[t$2] = n$1 ? n$1.serialize() : null;
					}
					return s$1;
				}
				setConfig(e$1, t$1) {
					const i$1 = this.getFragmentStyle(e$1);
					i$1 && (i$1.updateConfig(t$1, i$1.stylesheet.schema), this.updateConfigDependencies());
				}
				getSchema(e$1) {
					const t$1 = this.getFragmentStyle(e$1);
					return t$1 ? t$1.stylesheet.schema : null;
				}
				setSchema(e$1, t$1) {
					const i$1 = this.getFragmentStyle(e$1);
					i$1 && (i$1.stylesheet.schema = t$1, i$1.updateConfig(i$1._config, t$1), this.updateConfigDependencies());
				}
				updateConfig(t$1, i$1) {
					if (this._config = t$1, t$1 || i$1) if (i$1) for (const o$1 in i$1) {
						let s$1, r$1;
						const n$1 = e.U(i$1[o$1].default);
						if ("success" === n$1.result && (s$1 = n$1.value.expression), t$1 && void 0 !== t$1[o$1]) {
							const i$2 = e.U(t$1[o$1]);
							"success" === i$2.result && (r$1 = i$2.value.expression);
						}
						const { minValue: a$1, maxValue: l$1, stepValue: c$1, type: h$1, values: d$1 } = i$1[o$1];
						if (s$1) {
							const t$2 = e.B(o$1, this.scope);
							this.options.set(t$2, {
								default: s$1,
								value: r$1,
								minValue: a$1,
								maxValue: l$1,
								stepValue: c$1,
								type: h$1,
								values: d$1
							});
						} else this.fire(new e.y(/* @__PURE__ */ new Error(`No schema defined for config option "${o$1}".`)));
					}
					else this.fire(new e.y(/* @__PURE__ */ new Error("Attempting to set config for a style without schema.")));
				}
				_updateLayers(e$1, t$1 = (() => !0)) {
					for (const i$1 of e$1) {
						const e$2 = this.getLayer(i$1);
						e$2 && t$1(e$2) && (e$2.possiblyEvaluateVisibility(), this._updateLayer(e$2), this._changes.setDirty());
					}
				}
				updateConfigDependencies(e$1) {
					this._updateLayers(this._configDependentLayers, ((t$1) => !e$1 || t$1.expressionDependencies.configDependencies.has(e$1))), this.ambientLight && this.ambientLight.updateConfig(this.options), this.directionalLight && this.directionalLight.updateConfig(this.options), this.fog && this.fog.updateConfig(this.options), this.snow && this.snow.updateConfig(this.options), this.rain && this.rain.updateConfig(this.options), this.forEachFragmentStyle(((e$2) => {
						const t$1 = e$2._styleColorTheme.colorThemeOverride ? e$2._styleColorTheme.colorThemeOverride : e$2._styleColorTheme.colorTheme;
						if (t$1) {
							const i$1 = e$2._evaluateColorThemeData(t$1);
							(!e$2._styleColorTheme.lut && "" !== i$1 || e$2._styleColorTheme.lut && i$1 !== e$2._styleColorTheme.lut.data) && e$2.setColorTheme(t$1);
						}
					})), this._changes.setDirty();
				}
				addLayer(t$1, i$1, o$1 = {}) {
					this._checkLoaded();
					const s$1 = t$1.id;
					if (this._layers[s$1]) return void this.fire(new e.y(/* @__PURE__ */ new Error(`Layer with id "${s$1}" already exists on this map`)));
					let r$1;
					if ("custom" === t$1.type) {
						if (Io(this, e.dt(t$1))) return;
						r$1 = e.du(t$1, this.scope, this._styleColorTheme.lut, this.options);
					} else {
						if ("object" == typeof t$1.source && (this.addSource(s$1, t$1.source), t$1 = e.dp(t$1), t$1 = Object.assign(t$1, { source: s$1 })), this._validate(Le, `layers.${s$1}`, t$1, { arrayIndex: -1 }, o$1)) return;
						r$1 = e.du(t$1, this.scope, this._styleColorTheme.lut, this.options), this._validateLayer(r$1), r$1.setEventedParent(this, { layer: { id: s$1 } });
					}
					const n$1 = e.B(r$1.source, r$1.scope);
					0 !== r$1.expressionDependencies.configDependencies.size && this._configDependentLayers.add(n$1), r$1.expressionDependencies.isIndoorDependent && this._indoorDependentLayers.add(n$1);
					let a$1 = this._order.length;
					if (i$1) {
						const t$2 = this._order.indexOf(i$1);
						if (-1 === t$2) return void this.fire(new e.y(/* @__PURE__ */ new Error(`Layer with id "${i$1}" does not exist on this map.`)));
						r$1.slot === this._layers[i$1].slot ? a$1 = t$2 : e.w(`Layer with id "${i$1}" has a different slot. Layers can only be rearranged within the same slot.`);
					}
					this._order.splice(a$1, 0, s$1), this._layerOrderChanged = !0, this._layers[s$1] = r$1;
					const l$1 = this.getOwnLayerSourceCache(r$1), c$1 = !!this.directionalLight && this.directionalLight.shadowsEnabled();
					l$1 && r$1.canCastShadows() && c$1 && (l$1.castsShadows = !0);
					const h$1 = this._changes.getRemovedLayer(r$1);
					if (h$1 && r$1.source && l$1 && "custom" !== r$1.type) {
						this._changes.discardLayerRemoval(r$1);
						const t$2 = e.B(r$1.source, r$1.scope);
						h$1.type !== r$1.type ? this._changes.updateSourceCache(t$2, "clear") : (this._changes.updateSourceCache(t$2, "reload"), l$1.pause());
					}
					this._updateLayer(r$1), r$1.onAdd && r$1.onAdd(this.map), r$1.scope = this.scope, this.mergeLayers();
				}
				moveLayer(t$1, i$1) {
					this._checkLoaded();
					const o$1 = this._checkLayer(t$1);
					if (!o$1) return;
					if (t$1 === i$1) return;
					const s$1 = this._order.indexOf(t$1);
					this._order.splice(s$1, 1);
					let r$1 = this._order.length;
					if (i$1) {
						const t$2 = this._order.indexOf(i$1);
						if (-1 === t$2) return void this.fire(new e.y(/* @__PURE__ */ new Error(`Layer with id "${i$1}" does not exist on this map.`)));
						o$1.slot === this._layers[i$1].slot ? r$1 = t$2 : e.w(`Layer with id "${i$1}" has a different slot. Layers can only be rearranged within the same slot.`);
					}
					this._order.splice(r$1, 0, t$1), this._changes.setDirty(), this._layerOrderChanged = !0, this.mergeLayers();
				}
				removeLayer(e$1) {
					this._checkLoaded();
					const t$1 = this._checkLayer(e$1);
					if (!t$1) return;
					t$1.setEventedParent(null);
					const i$1 = this._order.indexOf(e$1);
					this._order.splice(i$1, 1), delete this._layers[e$1], this._changes.setDirty(), this._layerOrderChanged = !0, this._configDependentLayers.delete(t$1.fqid), this._indoorDependentLayers.delete(t$1.fqid), this._changes.removeLayer(t$1);
					const o$1 = this.getOwnLayerSourceCache(t$1);
					if (o$1 && o$1.castsShadows) {
						let e$2 = !1;
						for (const i$2 in this._layers) if (this._layers[i$2].source === t$1.source && this._layers[i$2].canCastShadows()) {
							e$2 = !0;
							break;
						}
						o$1.castsShadows = e$2;
					}
					t$1.onRemove && t$1.onRemove(this.map), this.mergeLayers();
				}
				getOwnLayer(e$1) {
					return this._layers[e$1];
				}
				hasLayer(e$1) {
					return e$1 in this._mergedLayers;
				}
				hasLayerType(e$1) {
					for (const t$1 in this._layers) if (this._layers[t$1].type === e$1) return !0;
					return !1;
				}
				setLayerZoomRange(e$1, t$1, i$1) {
					this._checkLoaded();
					const o$1 = this._checkLayer(e$1);
					o$1 && (o$1.minzoom === t$1 && o$1.maxzoom === i$1 || (null != t$1 && (o$1.minzoom = t$1), null != i$1 && (o$1.maxzoom = i$1), this._updateLayer(o$1)));
				}
				getSlots() {
					return this._checkLoaded(), this._mergedSlots;
				}
				setSlot(e$1, t$1) {
					this._checkLoaded();
					const i$1 = this._checkLayer(e$1);
					i$1 && i$1.slot !== t$1 && (i$1.slot = t$1, this._updateLayer(i$1));
				}
				setFilter(t$1, i$1, o$1 = {}) {
					this._checkLoaded();
					const s$1 = this._checkLayer(t$1);
					if (s$1 && !e.by(s$1.filter, i$1)) return null == i$1 ? (s$1.filter = void 0, void this._updateLayer(s$1)) : void (this._validate(De, `layers.${s$1.id}.filter`, i$1, { layerType: s$1.type }, o$1) || (s$1.filter = e.dp(i$1), this._updateLayer(s$1)));
				}
				getFilter(t$1) {
					const i$1 = this._checkLayer(t$1);
					if (i$1) return e.dp(i$1.filter);
				}
				setLayoutProperty(t$1, i$1, o$1, s$1 = {}) {
					this._checkLoaded();
					const r$1 = this._checkLayer(t$1);
					if (r$1 && !e.by(r$1.getLayoutProperty(i$1), o$1)) {
						if (null != o$1 && (!s$1 || !1 !== s$1.validate) && Io(r$1, Oe.call(we, {
							key: `layers.${t$1}.layout.${i$1}`,
							layerType: r$1.type,
							objectKey: i$1,
							value: o$1,
							styleSpec: e.a6,
							style: {
								glyphs: !0,
								sprite: !0
							}
						}))) return;
						r$1.setLayoutProperty(i$1, o$1), 0 !== r$1.expressionDependencies.configDependencies.size && this._configDependentLayers.add(r$1.fqid), r$1.expressionDependencies.isIndoorDependent && this._indoorDependentLayers.add(r$1.fqid), this._updateLayer(r$1);
					}
				}
				setLayerProperty(e$1, t$1, i$1, o$1 = {}) {
					this._checkLoaded();
					const s$1 = this._checkLayer(e$1);
					s$1 && ("appearances" === t$1 ? (s$1.setAppearances(i$1), this._changes.setDirty()) : s$1.isPaintProperty(t$1) ? this.setPaintProperty(e$1, t$1, i$1, o$1) : this.setLayoutProperty(e$1, t$1, i$1, o$1));
				}
				getLayoutProperty(e$1, t$1) {
					const i$1 = this._checkLayer(e$1);
					if (i$1) return i$1.getLayoutProperty(t$1);
				}
				setPaintProperty(t$1, i$1, o$1, s$1 = {}) {
					this._checkLoaded();
					const r$1 = this._checkLayer(t$1);
					if (!r$1) return;
					if (e.by(r$1.getPaintProperty(i$1), o$1)) return;
					if (null != o$1 && (!s$1 || !1 !== s$1.validate) && Io(r$1, Pe.call(we, {
						key: `layers.${t$1}.paint.${i$1}`,
						layerType: r$1.type,
						objectKey: i$1,
						value: o$1,
						styleSpec: e.a6
					}))) return;
					const n$1 = r$1.setPaintProperty(i$1, o$1);
					0 !== r$1.expressionDependencies.configDependencies.size && this._configDependentLayers.add(r$1.fqid), r$1.expressionDependencies.isIndoorDependent && this._indoorDependentLayers.add(r$1.fqid), n$1 && this._updateLayer(r$1), this._changes.updatePaintProperties(r$1);
				}
				getPaintProperty(e$1, t$1) {
					const i$1 = this._checkLayer(e$1);
					if (i$1) return i$1.getPaintProperty(t$1);
				}
				setFeatureState(t$1, i$1) {
					if (this._checkLoaded(), "target" in t$1) {
						if ("featuresetId" in t$1.target) {
							const { featuresetId: e$1, importId: o$2 } = t$1.target, s$2 = this.getFragmentStyle(o$2), r$2 = s$2.getFeaturesetLayers(e$1);
							for (const { source: e$2, sourceLayer: o$3 } of r$2) s$2.setFeatureState({
								id: t$1.id,
								source: e$2,
								sourceLayer: o$3
							}, i$1);
						} else if ("layerId" in t$1.target) {
							const { layerId: e$1 } = t$1.target, o$2 = this.getLayer(e$1);
							this.setFeatureState({
								id: t$1.id,
								source: o$2.source,
								sourceLayer: o$2.sourceLayer
							}, i$1);
						}
						return;
					}
					const o$1 = t$1.source, s$1 = t$1.sourceLayer, r$1 = this._checkSource(o$1);
					if (!r$1) return;
					const n$1 = r$1.type;
					if ("geojson" === n$1 && s$1) return void this.fire(new e.y(/* @__PURE__ */ new Error("GeoJSON sources cannot have a sourceLayer parameter.")));
					if ("vector" === n$1 && !s$1) return void this.fire(new e.y(/* @__PURE__ */ new Error("The sourceLayer parameter must be provided for vector source types.")));
					void 0 === t$1.id && this.fire(new e.y(/* @__PURE__ */ new Error("The feature id parameter must be provided.")));
					const a$1 = this.getOwnSourceCaches(o$1);
					for (const e$1 of a$1) e$1.setFeatureState(s$1, t$1.id, i$1);
				}
				removeFeatureState(t$1, i$1) {
					if (this._checkLoaded(), "target" in t$1) {
						if ("featuresetId" in t$1.target) {
							const { featuresetId: e$1, importId: o$2 } = t$1.target, s$2 = this.getFragmentStyle(o$2), r$2 = s$2.getFeaturesetLayers(e$1);
							for (const { source: e$2, sourceLayer: o$3 } of r$2) s$2.removeFeatureState({
								id: t$1.id,
								source: e$2,
								sourceLayer: o$3
							}, i$1);
						} else if ("layerId" in t$1.target) {
							const { layerId: e$1 } = t$1.target, o$2 = this.getLayer(e$1);
							this.removeFeatureState({
								id: t$1.id,
								source: o$2.source,
								sourceLayer: o$2.sourceLayer
							}, i$1);
						}
						return;
					}
					const o$1 = t$1.source, s$1 = this._checkSource(o$1);
					if (!s$1) return;
					const r$1 = s$1.type, n$1 = "vector" === r$1 ? t$1.sourceLayer : void 0;
					if ("vector" === r$1 && !n$1) return void this.fire(new e.y(/* @__PURE__ */ new Error("The sourceLayer parameter must be provided for vector source types.")));
					if (i$1 && "string" != typeof t$1.id && "number" != typeof t$1.id) return void this.fire(new e.y(/* @__PURE__ */ new Error("A feature id is required to remove its specific state property.")));
					const a$1 = this.getOwnSourceCaches(o$1);
					for (const e$1 of a$1) e$1.removeFeatureState(n$1, t$1.id, i$1);
				}
				getFeatureState(t$1) {
					if (this._checkLoaded(), "target" in t$1) {
						let i$2;
						if ("featuresetId" in t$1.target) {
							const { featuresetId: o$2, importId: s$2 } = t$1.target, r$1 = this.getFragmentStyle(s$2), n$1 = r$1.getFeaturesetLayers(o$2);
							for (const { source: o$3, sourceLayer: s$3 } of n$1) {
								const n$2 = r$1.getFeatureState({
									id: t$1.id,
									source: o$3,
									sourceLayer: s$3
								});
								if (n$2 && !i$2) i$2 = n$2;
								else if (!e.by(i$2, n$2)) return void this.fire(new e.y(/* @__PURE__ */ new Error("The same feature id exists in multiple sources in the featureset, but their feature states are not consistent through the sources.")));
							}
						} else if ("layerId" in t$1.target) {
							const { layerId: e$1 } = t$1.target, o$2 = this.getLayer(e$1);
							i$2 = this.getFeatureState({
								id: t$1.id,
								source: o$2.source,
								sourceLayer: o$2.sourceLayer
							});
						}
						return i$2;
					}
					const i$1 = t$1.source, o$1 = t$1.sourceLayer, s$1 = this._checkSource(i$1);
					if (s$1) {
						if ("vector" !== s$1.type || o$1) return void 0 === t$1.id && this.fire(new e.y(/* @__PURE__ */ new Error("The feature id parameter must be provided."))), this.getOwnSourceCaches(i$1)[0].getFeatureState(o$1, t$1.id);
						this.fire(new e.y(/* @__PURE__ */ new Error("The sourceLayer parameter must be provided for vector source types.")));
					}
				}
				setTransition(e$1) {
					return this.stylesheet.transition = Object.assign({}, this.stylesheet.transition, e$1), this.transition = this.stylesheet.transition, this;
				}
				getTransition() {
					return Object.assign({}, this.stylesheet.transition);
				}
				serialize() {
					this._checkLoaded();
					const t$1 = this.getTerrain(), i$1 = t$1 && this.terrain && this.terrain.scope === this.scope ? t$1 : this.stylesheet.terrain;
					return e.dv({
						version: this.stylesheet.version,
						name: this.stylesheet.name,
						metadata: this.stylesheet.metadata,
						fragment: this.stylesheet.fragment,
						iconsets: this.stylesheet.iconsets,
						imports: this._serializeImports(),
						schema: this.stylesheet.schema,
						camera: this.stylesheet.camera,
						light: this.stylesheet.light,
						lights: this.stylesheet.lights,
						terrain: i$1,
						fog: this.stylesheet.fog,
						snow: this.stylesheet.snow,
						rain: this.stylesheet.rain,
						center: this.stylesheet.center,
						"color-theme": this.stylesheet["color-theme"],
						zoom: this.stylesheet.zoom,
						bearing: this.stylesheet.bearing,
						pitch: this.stylesheet.pitch,
						sprite: this.stylesheet.sprite,
						glyphs: this.stylesheet.glyphs,
						transition: this.stylesheet.transition,
						projection: this.stylesheet.projection,
						sources: this._serializeSources(),
						layers: this._serializeLayers(this._order)
					}, ((e$1) => void 0 !== e$1));
				}
				_updateFilteredLayers(e$1) {
					for (const t$1 of Object.values(this._mergedLayers)) e$1(t$1) && this._updateLayer(t$1);
				}
				_updateLayer(t$1) {
					this._changes.updateLayer(t$1);
					const i$1 = this.getLayerSourceCache(t$1), o$1 = e.B(t$1.source, t$1.scope), s$1 = this._changes.getUpdatedSourceCaches();
					t$1.source && !s$1[o$1] && i$1 && "raster" !== i$1.getSource().type && (this._changes.updateSourceCache(o$1, "reload"), i$1.pause()), t$1.invalidateCompiledFilter();
				}
				_flattenAndSortRenderedFeatures(e$1) {
					const t$1 = (e$2) => this._mergedLayers[e$2].is3D(!!this.terrain), i$1 = this.order, o$1 = {}, s$1 = [];
					for (let r$2 = i$1.length - 1; r$2 >= 0; r$2--) {
						const n$1 = i$1[r$2];
						if (t$1(n$1)) {
							o$1[n$1] = r$2;
							for (const t$2 of e$1) {
								const e$2 = t$2[n$1];
								if (e$2) for (const t$3 of e$2) s$1.push(t$3);
							}
						}
					}
					s$1.sort(((e$2, t$2) => t$2.intersectionZ - e$2.intersectionZ));
					const r$1 = [];
					for (let n$1 = i$1.length - 1; n$1 >= 0; n$1--) {
						const a$1 = i$1[n$1];
						if (t$1(a$1)) for (let e$2 = s$1.length - 1; e$2 >= 0; e$2--) {
							const t$2 = s$1[e$2].feature;
							if (t$2.layer && o$1[t$2.layer.id] < n$1) break;
							r$1.push(t$2), s$1.pop();
						}
						else for (const t$2 of e$1) {
							const e$2 = t$2[a$1];
							if (e$2) for (const t$3 of e$2) r$1.push(t$3.feature);
						}
					}
					return r$1;
				}
				queryRasterValue(t$1, i$1, o$1) {
					const s$1 = this.getOwnSource(t$1);
					return s$1 ? "raster-array" !== s$1.type ? (this.fire(new e.y(/* @__PURE__ */ new Error("queryRasterValue support only \"raster-array\" sources."))), Promise.resolve(null)) : s$1.queryRasterArrayValue(i$1, o$1) : (this.fire(new e.y(/* @__PURE__ */ new Error(`Source with id "${t$1}" does not exist in the style.`))), Promise.resolve(null));
				}
				queryRenderedFeatures(t$1, i$1, o$1) {
					let s$1;
					i$1 && !Array.isArray(i$1) && i$1.filter && (this._validate(De, "queryRenderedFeatures.filter", i$1.filter, null, i$1), s$1 = e.b6(i$1.filter));
					const r$1 = {}, n$1 = (e$1) => {
						if (Ao.has(e$1.type)) return;
						const t$2 = this.getOwnLayerSourceCache(e$1), i$2 = r$1[t$2.id] = r$1[t$2.id] || {
							sourceCache: t$2,
							layers: {},
							has3DLayers: !1
						};
						e$1.is3D(!!this.terrain) && (i$2.has3DLayers = !0), i$2.layers[e$1.fqid] = i$2.layers[e$1.fqid] || {
							styleLayer: e$1,
							targets: []
						}, i$2.layers[e$1.fqid].targets.push({ filter: s$1 });
					};
					if (i$1 && i$1.layers) {
						if (!Array.isArray(i$1.layers)) return this.fire(new e.y(/* @__PURE__ */ new Error("parameters.layers must be an Array."))), [];
						for (const t$2 of i$1.layers) {
							const i$2 = this._layers[t$2];
							if (!i$2) return this.fire(new e.y(/* @__PURE__ */ new Error(`The layer '${t$2}' does not exist in the map's style and cannot be queried for features.`))), [];
							n$1(i$2);
						}
					} else for (const e$1 in this._layers) n$1(this._layers[e$1]);
					const a$1 = this._queryRenderedFeatures(t$1, r$1, o$1), l$1 = this._flattenAndSortRenderedFeatures(a$1), c$1 = [];
					for (const t$2 of l$1) e.dw(t$2.layer.id) === this.scope && c$1.push(t$2);
					return c$1;
				}
				queryRenderedFeatureset(t$1, i$1, o$1) {
					let s$1;
					i$1 && !Array.isArray(i$1) && i$1.filter && (this._validate(De, "queryRenderedFeatures.filter", i$1.filter, null, i$1), s$1 = e.b6(i$1.filter));
					const r$1 = "mock", n$1 = [];
					if (i$1 && i$1.target) n$1.push(Object.assign({}, i$1, {
						targetId: r$1,
						filter: s$1
					}));
					else {
						const e$1 = this.getFeaturesetDescriptors();
						for (const t$2 of e$1) n$1.push({
							targetId: r$1,
							filter: s$1,
							target: t$2
						});
						for (const { style: e$2 } of this.fragments) {
							const t$2 = e$2.getFeaturesetDescriptors();
							for (const e$3 of t$2) n$1.push({
								targetId: r$1,
								filter: s$1,
								target: e$3
							});
						}
					}
					const a$1 = this.queryRenderedTargets(t$1, n$1, o$1), l$1 = [], c$1 = /* @__PURE__ */ new Set();
					for (const t$2 of a$1) for (const i$2 of t$2.variants[r$1]) vt(i$2, t$2, c$1) || l$1.push(new e.dx(t$2, i$2));
					return l$1;
				}
				queryRenderedTargets(t$1, i$1, o$1) {
					const s$1 = {}, r$1 = (e$1, t$2, i$2, o$2) => {
						const r$2 = s$1[t$2.id] = s$1[t$2.id] || {
							sourceCache: t$2,
							layers: {},
							has3DLayers: !1
						};
						if (r$2.layers[e$1.fqid] = r$2.layers[e$1.fqid] || {
							styleLayer: e$1,
							targets: []
						}, e$1.is3D(!!this.terrain) && (r$2.has3DLayers = !0), !o$2) return i$2.uniqueFeatureID = !1, void r$2.layers[e$1.fqid].targets.push(i$2);
						r$2.layers[e$1.fqid].targets.push(Object.assign({}, i$2, {
							namespace: o$2.namespace,
							properties: o$2.properties,
							uniqueFeatureID: o$2.uniqueFeatureID
						}));
					};
					for (const t$2 of i$1) if ("featuresetId" in t$2.target) {
						const { featuresetId: i$2, importId: o$2 } = t$2.target, s$2 = this.getFragmentStyle(o$2);
						if (!s$2 || !s$2._featuresetSelectors) continue;
						const n$2 = s$2._featuresetSelectors[i$2];
						if (!n$2) {
							this.fire(new e.y(/* @__PURE__ */ new Error(`The featureset '${i$2}' does not exist in the map's style and cannot be queried for features.`)));
							continue;
						}
						for (const e$1 of n$2) {
							const i$3 = s$2.getOwnLayer(e$1.layerId);
							i$3 && !Ao.has(i$3.type) && r$1(i$3, s$2.getOwnLayerSourceCache(i$3), t$2, e$1);
						}
					} else if ("layerId" in t$2.target) {
						const { layerId: e$1 } = t$2.target, i$2 = this.getLayer(e$1);
						if (!i$2 || Ao.has(i$2.type)) continue;
						r$1(i$2, this.getLayerSourceCache(i$2), t$2);
					}
					const n$1 = this._queryRenderedFeatures(t$1, s$1, o$1);
					return this._flattenAndSortRenderedFeatures(n$1);
				}
				_queryRenderedFeatures(e$1, t$1, i$1) {
					const o$1 = [], s$1 = !!this.map._showQueryGeometry, r$1 = st.createFromScreenPoints(e$1, i$1);
					for (const e$2 in t$1) {
						const n$1 = yt(r$1, t$1[e$2], this._availableImages, i$1, s$1);
						Object.keys(n$1).length && o$1.push(n$1);
					}
					if (this.placement) for (const e$2 in t$1) {
						if (!t$1[e$2].sourceCache._onlySymbols) continue;
						const i$2 = xt(r$1.screenGeometry, t$1[e$2], this._availableImages, this.placement.collisionIndex, this.placement.retainedQueryData, this.map.getWorldview());
						Object.keys(i$2).length && o$1.push(i$2);
					}
					return o$1;
				}
				querySourceFeatures(e$1, t$1) {
					const i$1 = t$1 && t$1.filter;
					i$1 && this._validate(De, "querySourceFeatures.filter", i$1, null, t$1);
					let o$1 = [];
					const s$1 = this.getOwnSourceCaches(e$1);
					for (const e$2 of s$1) o$1 = o$1.concat(bt(e$2, t$1));
					return o$1;
				}
				addSourceType(e$1, t$1, i$1) {
					return Po.getSourceType(e$1) ? i$1(/* @__PURE__ */ new Error(`A source type called "${e$1}" already exists.`)) : (Po.setSourceType(e$1, t$1), t$1.workerSourceURL ? void this.dispatcher.broadcast("loadWorkerSource", {
						name: e$1,
						url: t$1.workerSourceURL
					}, i$1) : i$1(null, null));
				}
				getFlatLight() {
					return this.light.getLight();
				}
				setFlatLight(t$1, i$1, o$1 = {}) {
					this._checkLoaded();
					const s$1 = this.light.getLight();
					let r$1 = !1;
					for (const i$2 in t$1) if (!e.by(t$1[i$2], s$1[i$2])) {
						r$1 = !0;
						break;
					}
					if (!r$1) return;
					const n$1 = this._getTransitionParameters();
					this.light.setLight(t$1, i$1, o$1), this.light.updateTransitions(n$1);
				}
				getTerrain() {
					return this.terrain && 1 === this.terrain.drapeRenderMode ? this.terrain.get() : null;
				}
				setTerrainForDraping() {
					this.setTerrain({
						source: "",
						exaggeration: 0
					}, 0);
				}
				checkCanvasFingerprintNoise() {
					void 0 === this.disableElevatedTerrain && (this.disableElevatedTerrain = e.o.hasCanvasFingerprintNoise(), this.disableElevatedTerrain && e.w("Terrain and hillshade are disabled because of Canvas2D limitations when fingerprinting protection is enabled (e.g. in private browsing mode)."));
				}
				setTerrain(t$1, i$1 = 1) {
					if (this._checkLoaded(), !t$1) return this.terrainSetForDrapingOnly() || (delete this.terrain, this.map.transform.projection.requiresDraping && this.setTerrainForDraping()), 0 === i$1 && delete this.terrain, null === t$1 ? this.stylesheet.terrain = null : delete this.stylesheet.terrain, this._force3DLayerUpdate(), void (this._markersNeedUpdate = !0);
					this.checkCanvasFingerprintNoise();
					let o$1 = t$1;
					const s$1 = !("source" in t$1) || null == t$1.source;
					if (1 === i$1) {
						if (this.disableElevatedTerrain) return;
						if ("source" in o$1 && "object" == typeof o$1.source) {
							const t$3 = "terrain-dem-src";
							this.addSource(t$3, o$1.source), o$1 = e.dp(o$1), o$1 = Object.assign(o$1, { source: t$3 });
						}
						const t$2 = Object.assign({}, o$1), i$2 = {};
						if (this.terrain && s$1) {
							t$2.source = this.terrain.get().source;
							const e$1 = this.terrain ? this.getFragmentStyle(this.terrain.scope) : null;
							e$1 && (i$2.style = e$1.serialize());
						}
						if (this._validate(Ie, "terrain", t$2, i$2)) return;
					}
					if (!this.terrain || this.terrain.scope !== this.scope && !s$1 || this.terrain && i$1 !== this.terrain.drapeRenderMode) {
						if (!o$1) return;
						this._createTerrain(o$1, i$1), this.fire(new e.z("data", { dataType: "style" }));
					} else {
						const i$2 = this.terrain, s$2 = i$2.get();
						for (const t$2 of Object.keys(e.a6.terrain)) !o$1.hasOwnProperty(t$2) && e.a6.terrain[t$2].default && (o$1[t$2] = e.a6.terrain[t$2].default);
						for (const o$2 in t$1) if (!e.by(t$1[o$2], s$2[o$2])) {
							i$2.set(t$1, this.options), this.stylesheet.terrain = t$1;
							const o$3 = this._getTransitionParameters({ duration: 0 });
							i$2.updateTransitions(o$3), this.fire(new e.z("data", { dataType: "style" }));
							break;
						}
					}
					this.mergeTerrain(), this.updateDrapeFirstLayers(), this._markersNeedUpdate = !0;
				}
				_createFog(e$1) {
					const t$1 = this.fog = new Ye(e$1, this.map.transform, this.scope, this.options);
					this.stylesheet.fog = t$1.get();
					const i$1 = this._getTransitionParameters({ duration: 0 });
					t$1.updateTransitions(i$1);
				}
				_createSnow(e$1) {
					const t$1 = this.snow = new tt(e$1, this.map.transform, this.scope, this.options);
					this.stylesheet.snow = t$1.get();
					const i$1 = this._getTransitionParameters({ duration: 0 });
					t$1.updateTransitions(i$1);
				}
				_createRain(e$1) {
					const t$1 = this.rain = new it(e$1, this.map.transform, this.scope, this.options);
					this.stylesheet.rain = t$1.get();
					const i$1 = this._getTransitionParameters({ duration: 0 });
					t$1.updateTransitions(i$1);
				}
				_updateMarkersOpacity() {
					0 !== this.map._markers.length && this.map._requestDomTask((() => {
						for (const e$1 of this.map._markers) e$1._evaluateOpacity();
					}));
				}
				getFog() {
					return this.fog ? this.fog.get() : null;
				}
				setFog(t$1) {
					if (this._checkLoaded(), !t$1) return delete this.fog, delete this.stylesheet.fog, void (this._markersNeedUpdate = !0);
					if (this.fog) {
						const i$1 = this.fog;
						if (!e.by(i$1.get(), t$1)) {
							i$1.set(t$1, this.options), this.stylesheet.fog = i$1.get();
							const e$1 = this._getTransitionParameters({ duration: 0 });
							i$1.updateTransitions(e$1);
						}
					} else this._createFog(t$1);
					this._markersNeedUpdate = !0;
				}
				getSnow() {
					return this.snow ? this.snow.get() : null;
				}
				setSnow(t$1) {
					if (this._checkLoaded(), !t$1) return delete this.snow, void delete this.stylesheet.snow;
					if (this.snow) {
						const i$1 = this.snow;
						if (!e.by(i$1.get(), t$1)) {
							i$1.set(t$1, this.options), this.stylesheet.snow = i$1.get();
							const e$1 = this._getTransitionParameters({ duration: 0 });
							i$1.updateTransitions(e$1);
						}
					} else this._createSnow(t$1);
					this._markersNeedUpdate = !0;
				}
				getRain() {
					return this.rain ? this.rain.get() : null;
				}
				setRain(t$1) {
					if (this._checkLoaded(), !t$1) return delete this.rain, void delete this.stylesheet.rain;
					if (this.rain) {
						const i$1 = this.rain;
						if (!e.by(i$1.get(), t$1)) {
							i$1.set(t$1, this.options), this.stylesheet.rain = i$1.get();
							const e$1 = this._getTransitionParameters({ duration: 0 });
							i$1.updateTransitions(e$1);
						}
					} else this._createRain(t$1);
					this._markersNeedUpdate = !0;
				}
				_reloadColorTheme() {
					const t$1 = () => {
						for (const e$1 in this._layers) this._layers[e$1].lut = this._styleColorTheme.lut;
						for (const e$1 in this._sourceCaches) this._sourceCaches[e$1].clearTiles();
					}, i$1 = this._styleColorTheme.colorThemeOverride ? this._styleColorTheme.colorThemeOverride : this._styleColorTheme.colorTheme;
					if (!i$1) return this._styleColorTheme.lut = null, void t$1();
					const o$1 = this._evaluateColorThemeData(i$1);
					this._loadColorTheme(o$1).then((() => {
						this.fire(new e.z("colorthemeset")), t$1();
					})).catch(((t$2) => {
						e.w(`Couldn't set color theme: ${t$2}`);
					}));
				}
				setColorTheme(t$1) {
					this._checkLoaded(), this._styleColorTheme.colorThemeOverride && e.w("Note: setColorTheme is called on a style with a color-theme override, the passed color-theme won't be visible."), this._styleColorTheme.colorTheme = t$1, this._reloadColorTheme();
				}
				setImportColorTheme(e$1, t$1) {
					const i$1 = this.getFragmentStyle(e$1);
					i$1 && (i$1._styleColorTheme.colorThemeOverride = t$1, i$1._reloadColorTheme());
				}
				_getTransitionParameters(t$1) {
					return {
						now: e.o.now(),
						transition: Object.assign(this.transition, t$1)
					};
				}
				updateDrapeFirstLayers() {
					if (!this.terrain) return;
					const e$1 = [], t$1 = [];
					for (const i$1 of this._mergedOrder) this.isLayerDraped(this._mergedLayers[i$1]) ? e$1.push(i$1) : t$1.push(i$1);
					this._drapedFirstOrder = [], this._drapedFirstOrder.push(...e$1), this._drapedFirstOrder.push(...t$1);
				}
				_createTerrain(e$1, t$1) {
					const i$1 = this.terrain = new je(e$1, t$1, this.scope, this.options, this.map.getWorldview());
					1 === t$1 && (this.stylesheet.terrain = e$1), this.mergeTerrain(), this.updateDrapeFirstLayers(), this._force3DLayerUpdate();
					const o$1 = this._getTransitionParameters({ duration: 0 });
					i$1.updateTransitions(o$1);
				}
				_force3DLayerUpdate() {
					for (const e$1 in this._layers) {
						const t$1 = this._layers[e$1];
						"fill-extrusion" === t$1.type && this._updateLayer(t$1);
					}
				}
				_forceSymbolLayerUpdate() {
					for (const e$1 in this._layers) {
						const t$1 = this._layers[e$1];
						"symbol" === t$1.type && this._updateLayer(t$1);
					}
				}
				_validate(t$1, i$1, o$1, s$1, r$1 = {}) {
					if (r$1 && !1 === r$1.validate) return !1;
					const n$1 = Object.assign({}, this.serialize());
					return Io(this, t$1.call(we, Object.assign({
						key: i$1,
						style: n$1,
						value: o$1,
						styleSpec: e.a6
					}, s$1)));
				}
				_remove() {
					this._request && (this._request.cancel(), this._request = null), this._spriteRequest && (this._spriteRequest.cancel(), this._spriteRequest = null), e.dy.off("pluginStateChange", this._rtlTextPluginCallback);
					for (const e$1 in this._mergedLayers) this._mergedLayers[e$1].setEventedParent(null);
					for (const e$1 in this._mergedSourceCaches) this._mergedSourceCaches[e$1].clearTiles(), this._mergedSourceCaches[e$1].setEventedParent(null);
					this.imageManager.removeScope(this.scope), this.setEventedParent(null), delete this.fog, delete this.snow, delete this.rain, delete this.terrain, delete this.ambientLight, delete this.directionalLight, this.isRootStyle() && (this.imageManager.setEventedParent(null), this.imageManager.destroy(), this.modelManager.setEventedParent(null), this.modelManager.destroy(), this.dispatcher.remove());
				}
				clearSource(e$1) {
					const t$1 = this.getSourceCaches(e$1);
					for (const e$2 of t$1) e$2.clearTiles();
				}
				clearSources() {
					for (const e$1 in this._mergedSourceCaches) this._mergedSourceCaches[e$1].clearTiles();
				}
				clearLayers() {
					for (const e$1 in this._mergedLayers) {
						const t$1 = this._mergedLayers[e$1];
						t$1._clear && t$1._clear();
					}
				}
				reloadSource(e$1) {
					const t$1 = this.getSourceCaches(e$1);
					for (const e$2 of t$1) e$2.resume(), e$2.reload();
				}
				reloadSources() {
					for (const e$1 of this.getSources()) e$1.reload && e$1.reload();
				}
				reloadModels() {
					this.modelManager.reloadModels(""), this.forEachFragmentStyle(((e$1) => {
						e$1.modelManager.reloadModels(e$1.scope);
					}));
				}
				updateSources(e$1) {
					let t$1;
					this.directionalLight && (t$1 = go(this.directionalLight));
					const i$1 = /* @__PURE__ */ new Set(), o$1 = /* @__PURE__ */ new Set();
					for (const e$2 in this._mergedLayers) {
						const t$2 = this._mergedLayers[e$2];
						"building" === t$2.type && i$1.add(t$2.source), t$2.hasElevation() && !o$1.has(t$2.source) && o$1.add(t$2.source);
					}
					for (const s$1 in this._mergedSourceCaches) {
						const r$1 = this._mergedSourceCaches[s$1], n$1 = o$1.has(r$1._source.id);
						i$1.has(r$1._source.id) && (r$1._source.reparseOverscaled = !1), r$1.update(e$1, void 0, void 0, t$1, n$1);
					}
				}
				_generateCollisionBoxes() {
					for (const e$1 in this._sourceCaches) {
						const t$1 = this._sourceCaches[e$1];
						t$1.resume(), t$1.reload();
					}
				}
				_updatePlacement(t$1, i$1, o$1, s$1, r$1, n$1, a$1 = !1) {
					let l$1 = !1, c$1 = !1;
					const h$1 = {}, d$1 = {};
					for (const t$2 of this._mergedOrder) {
						const o$2 = this._mergedLayers[t$2];
						if ("symbol" !== o$2.type) continue;
						const s$2 = e.B(o$2.source, o$2.scope);
						let r$2 = h$1[s$2];
						if (!r$2) {
							const e$1 = this.getLayerSourceCache(o$2);
							if (!e$1) continue;
							const t$3 = e$1.getRenderableIds(!0).map(((t$4) => e$1.getTileByID(t$4)));
							d$1[s$2] = t$3.slice(), r$2 = h$1[s$2] = t$3.sort(((e$2, t$4) => t$4.tileID.overscaledZ - e$2.tileID.overscaledZ || (e$2.tileID.isLessThan(t$4.tileID) ? -1 : 1)));
						}
						const n$2 = this.crossTileSymbolIndex.addLayer(o$2, r$2, i$1.center.lng, i$1.projection);
						l$1 = l$1 || n$2;
					}
					this.crossTileSymbolIndex.pruneUnusedLayers(this._mergedOrder), a$1 = a$1 || this._layerOrderChanged, this._layerOrderChanged && this.fire(new e.z("neworder"));
					const u$1 = Boolean(this.placement && !i$1.equals(this.placement.transform)), _$1 = Boolean(this.placement && (0 !== this.placement.lastReplacementSourceUpdateTime && !n$1 || this.placement.lastReplacementSourceUpdateTime !== n$1.updateTime)), p$1 = (u$1 || _$1 || l$1 || this.placement && this.placement.isStale()) && 0 === s$1;
					if ((a$1 || !this.pauseablePlacement || p$1 || 0 !== s$1 && this.pauseablePlacement.isDone() && !this.placement.stillRecent(e.o.now(), i$1.zoom)) && (this.pauseablePlacement = new ji(i$1, this._mergedOrder, a$1 || 0 === s$1, o$1, s$1, r$1, this.placement, this.fog && i$1.projection.supportsFog ? this.fog.state : null, this._buildingIndex), this._layerOrderChanged = !1), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._mergedOrder, this._mergedLayers, h$1, d$1, this.map.painter.scaleFactor), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(e.o.now()), c$1 = !0), l$1 && this.pauseablePlacement.placement.setStale()), c$1 || l$1) {
						this._buildingIndex.onNewFrame(i$1.zoom);
						for (let t$2 = 0; t$2 < this._mergedOrder.length; t$2++) {
							const i$2 = this._mergedLayers[this._mergedOrder[t$2]];
							if ("symbol" !== i$2.type) continue;
							if ("none" === i$2.visibility) continue;
							const o$2 = this.isLayerClipped(i$2);
							this.placement.updateLayerOpacities(i$2, h$1[e.B(i$2.source, i$2.scope)], t$2, o$2 ? n$1 : null);
						}
					}
					return { needsRerender: !this.pauseablePlacement.isDone() || this.placement.hasTransitions(e.o.now()) };
				}
				_releaseSymbolFadeTiles() {
					for (const e$1 in this._sourceCaches) this._sourceCaches[e$1].releaseSymbolFadeTiles();
				}
				addImport(t$1, i$1) {
					this._checkLoaded();
					const o$1 = this.stylesheet.imports = this.stylesheet.imports || [];
					if (-1 !== o$1.findIndex((({ id: e$1 }) => e$1 === t$1.id))) return void this.fire(new e.y(/* @__PURE__ */ new Error(`Import with id '${t$1.id}' already exists in the map's style.`)));
					if (!i$1) return o$1.push(t$1), this._loadImports([t$1], !0);
					const s$1 = o$1.findIndex((({ id: e$1 }) => e$1 === i$1));
					return -1 === s$1 && this.fire(new e.y(/* @__PURE__ */ new Error(`Import with id "${i$1}" does not exist on this map.`))), this.stylesheet.imports = o$1.slice(0, s$1).concat(t$1).concat(o$1.slice(s$1)), this._loadImports([t$1], !0, i$1);
				}
				updateImport(t$1, i$1) {
					this._checkLoaded();
					const o$1 = this.stylesheet.imports || [], s$1 = this.getImportIndex(t$1);
					return -1 === s$1 ? this : "string" == typeof i$1 ? (this.setImportUrl(t$1, i$1), this) : (i$1.url && i$1.url !== o$1[s$1].url && this.setImportUrl(t$1, i$1.url), e.by(i$1.config, o$1[s$1].config) || this.setImportConfig(t$1, i$1.config, i$1.data.schema), e.by(i$1.data, o$1[s$1].data) || this.setImportData(t$1, i$1.data), this);
				}
				moveImport(e$1, t$1) {
					this._checkLoaded();
					let i$1 = this.stylesheet.imports || [];
					const o$1 = this.getImportIndex(e$1);
					if (-1 === o$1) return this;
					const s$1 = this.getImportIndex(t$1);
					if (-1 === s$1) return this;
					const r$1 = i$1[o$1], n$1 = this.fragments[o$1];
					return i$1 = i$1.filter((({ id: t$2 }) => t$2 !== e$1)), this.fragments = this.fragments.filter((({ id: t$2 }) => t$2 !== e$1)), this.stylesheet.imports = i$1.slice(0, s$1).concat(r$1).concat(i$1.slice(s$1)), this.fragments = this.fragments.slice(0, s$1).concat(n$1).concat(this.fragments.slice(s$1)), this.mergeLayers(), this;
				}
				setImportUrl(e$1, t$1) {
					this._checkLoaded();
					const i$1 = this.stylesheet.imports || [], o$1 = this.getImportIndex(e$1);
					if (-1 === o$1) return this;
					i$1[o$1].url = t$1;
					const s$1 = this.fragments[o$1];
					return s$1.style = this._createFragmentStyle(i$1[o$1]), s$1.style.on("style.import.load", (() => this.mergeAll())), s$1.style.loadURL(t$1), this;
				}
				setImportData(e$1, t$1) {
					this._checkLoaded();
					const i$1 = this.getImportIndex(e$1), o$1 = this.stylesheet.imports || [];
					return -1 === i$1 ? this : t$1 ? (this.fragments[i$1].style.setState(t$1), this._reloadImports(), this) : (delete o$1[i$1].data, this.setImportUrl(e$1, o$1[i$1].url));
				}
				setImportConfig(e$1, t$1, i$1) {
					this._checkLoaded();
					const o$1 = this.getImportIndex(e$1), s$1 = this.stylesheet.imports || [];
					if (-1 === o$1) return this;
					t$1 ? s$1[o$1].config = t$1 : delete s$1[o$1].config;
					const r$1 = this.fragments[o$1];
					i$1 && r$1.style.stylesheet && (r$1.style.stylesheet.schema = i$1);
					const n$1 = r$1.style.stylesheet && r$1.style.stylesheet.schema;
					return r$1.config = t$1, r$1.style.updateConfig(t$1, n$1), this.updateConfigDependencies(), this;
				}
				removeImport(e$1) {
					this._checkLoaded();
					const t$1 = this.stylesheet.imports || [], i$1 = this.getImportIndex(e$1);
					-1 !== i$1 && (t$1.splice(i$1, 1), this.fragments[i$1].style._remove(), this.fragments.splice(i$1, 1), this._reloadImports());
				}
				getImportIndex(t$1) {
					const i$1 = (this.stylesheet.imports || []).findIndex(((e$1) => e$1.id === t$1));
					return -1 === i$1 && this.fire(new e.y(/* @__PURE__ */ new Error(`Import '${t$1}' does not exist in the map's style and cannot be updated.`))), i$1;
				}
				getLayer(e$1) {
					return this._mergedLayers[e$1];
				}
				getSources() {
					const e$1 = [];
					for (const t$1 in this._mergedOtherSourceCaches) {
						const i$1 = this._mergedOtherSourceCaches[t$1];
						i$1 && e$1.push(i$1.getSource());
					}
					return e$1;
				}
				getSource(e$1, t$1) {
					const i$1 = this.getSourceCache(e$1, t$1);
					return i$1 && i$1.getSource();
				}
				getLayerSource(e$1) {
					const t$1 = this.getLayerSourceCache(e$1);
					return t$1 && t$1.getSource();
				}
				getSourceCache(t$1, i$1) {
					const o$1 = e.B(t$1, i$1);
					return this._mergedOtherSourceCaches[o$1];
				}
				getLayerSourceCache(t$1) {
					const i$1 = e.B(t$1.source, t$1.scope);
					return "symbol" === t$1.type ? this._mergedSymbolSourceCaches[i$1] : this._mergedOtherSourceCaches[i$1];
				}
				getSourceCaches(e$1) {
					if (null == e$1) return Object.values(this._mergedSourceCaches);
					const t$1 = [];
					return this._mergedOtherSourceCaches[e$1] && t$1.push(this._mergedOtherSourceCaches[e$1]), this._mergedSymbolSourceCaches[e$1] && t$1.push(this._mergedSymbolSourceCaches[e$1]), t$1;
				}
				updateSourceCaches() {
					const e$1 = this._changes.getUpdatedSourceCaches();
					for (const t$1 in e$1) {
						const i$1 = e$1[t$1];
						"reload" === i$1 ? this.reloadSource(t$1) : "clear" === i$1 && this.clearSource(t$1);
					}
				}
				updateLayers(e$1) {
					const t$1 = this._changes.getUpdatedPaintProperties();
					for (const i$1 of t$1) {
						const t$2 = this.getLayer(i$1);
						t$2 && t$2.updateTransitions(e$1);
					}
				}
				getGlyphsUrl() {
					return this.stylesheet.glyphs;
				}
				setGlyphsUrl(e$1) {
					this.stylesheet.glyphs = e$1, this.glyphManager.setURL(e$1);
				}
				getImages(t$1, i$1, o$1) {
					this.imageManager.getImages(i$1.images, i$1.scope, o$1), this._updateTilesForChangedImages();
					const s$1 = (t$2) => {
						if (t$2) {
							const o$2 = i$1.images.map(((t$3) => e.I.toString(t$3)));
							t$2.setDependencies(i$1.tileID.key, i$1.type, o$2);
						}
					}, r$1 = e.B(i$1.source, i$1.scope);
					s$1(this._mergedOtherSourceCaches[r$1]), s$1(this._mergedSymbolSourceCaches[r$1]), i$1.images.some(((e$1) => e$1.iconsetId)) && this.fire(new e.z("data", { dataType: "style" }));
				}
				rasterizeImages(e$1, t$1, i$1) {
					this.imageManager.rasterizeImages(t$1, i$1);
				}
				getGlyphs(e$1, t$1, i$1) {
					this.glyphManager.getGlyphs(t$1.stacks, i$1);
				}
				getResource(t$1, i$1, o$1) {
					return e.dz(i$1, o$1);
				}
				getOwnSourceCache(e$1) {
					return this._otherSourceCaches[e$1];
				}
				getOwnLayerSourceCache(e$1) {
					return "symbol" === e$1.type ? this._symbolSourceCaches[e$1.source] : this._otherSourceCaches[e$1.source];
				}
				getOwnSourceCaches(e$1) {
					const t$1 = [];
					return this._otherSourceCaches[e$1] && t$1.push(this._otherSourceCaches[e$1]), this._symbolSourceCaches[e$1] && t$1.push(this._symbolSourceCaches[e$1]), t$1;
				}
				_isSourceCacheLoaded(t$1) {
					const i$1 = this.getOwnSourceCaches(t$1);
					return 0 === i$1.length ? (this.fire(new e.y(/* @__PURE__ */ new Error(`There is no source with ID '${t$1}'`))), !1) : i$1.every(((e$1) => e$1.loaded()));
				}
				has3DLayers() {
					return this._has3DLayers;
				}
				hasSymbolLayers() {
					return this._hasSymbolLayers;
				}
				hasCircleLayers() {
					return this._hasCircleLayers;
				}
				isLayerClipped(e$1, t$1) {
					if (!this._clipLayerPresent && "fill-extrusion" !== e$1.type && "building" !== e$1.type) return !1;
					const i$1 = "fill-extrusion" === e$1.type && ("building" === e$1.sourceLayer || "procedural_buildings" === e$1.sourceLayer), o$1 = "building" === e$1.type;
					if (e$1.is3D(!!this.terrain)) {
						if (i$1 || o$1 || t$1 && "batched-model" === t$1.type) return !0;
						if ("model" === e$1.type) return !0;
					} else if ("symbol" === e$1.type) return !0;
					return !1;
				}
				_clearWorkerCaches() {
					this.dispatcher.broadcast("clearCaches");
				}
				destroy() {
					this._clearWorkerCaches(), this.fragments.forEach(((e$1) => {
						e$1.style._remove();
					})), this.terrainSetForDrapingOnly() && (delete this.terrain, delete this.stylesheet.terrain);
				}
			}
			Po.getSourceType = function(e$1) {
				return ft[e$1];
			}, Po.setSourceType = function(e$1, t$1) {
				ft[e$1] = t$1;
			}, Po.registerForPluginStateChange = e.dA;
			class Oo extends e.E {
				constructor(t$1) {
					super(), this._style = t$1, this._buildings = {}, this._activeFloors = /* @__PURE__ */ new Set(), this._activeFloorsVisible = !0, this._indoorState = {
						selectedFloorId: null,
						lastActiveFloors: null,
						activeFloorsVisible: !0
					}, e.aY(["_updateUI"], this);
				}
				destroy() {
					this._buildings = {}, this._activeFloors = /* @__PURE__ */ new Set(), this._indoorState = null;
				}
				selectFloor(e$1) {
					e$1 === this._selectedFloorId && this._activeFloorsVisible || (this._selectedFloorId = e$1, this._activeFloorsVisible = !0, this._updateActiveFloors());
				}
				setActiveFloorsVisibility(e$1) {
					this._activeFloorsVisible = e$1, this._updateActiveFloors(), this._updateIndoorSelector();
				}
				setIndoorData(e$1) {
					for (const [t$1, i$1] of Object.entries(e$1.buildings)) if (this._buildings[t$1]) for (const e$2 of i$1.floorIds) this._buildings[t$1].floors[e$2] || (this._buildings[t$1].floors[e$2] = i$1.floors[e$2]);
					else this._buildings[t$1] = i$1;
					for (const t$1 of e$1.activeFloors) this._activeFloors.add(t$1);
					this._updateIndoorSelector();
				}
				getIndoorTileOptions(e$1, t$1) {
					const i$1 = this._style.getIndoorSourceLayers(e$1, t$1);
					return i$1 && this._indoorState ? {
						sourceLayers: i$1,
						indoorState: this._indoorState
					} : null;
				}
				_updateUI(t$1, i$1, o$1) {
					const s$1 = function(t$2, i$2, o$2, s$2) {
						let r$1 = null, n$1 = Number.MAX_SAFE_INTEGER;
						if (s$2 < 16) return null;
						for (const [s$3, a$1] of Object.entries(t$2)) {
							const t$3 = a$1.center;
							if (t$3) {
								const a$2 = i$2.distanceTo(e.aT.convert(t$3));
								a$2 < n$1 && o$2.contains(t$3) && (n$1 = a$2, r$1 = s$3);
							}
						}
						return r$1;
					}(this._buildings, i$1, o$1, t$1);
					s$1 !== this._closestBuildingId && (this._closestBuildingId = s$1, this._updateIndoorSelector());
				}
				_updateIndoorSelector() {
					const t$1 = this._buildings, i$1 = this._closestBuildingId, o$1 = i$1 && t$1 ? t$1[i$1] : void 0;
					if (!o$1) return void this.fire(new e.z("selector-update", {
						selectedFloorId: null,
						activeFloorsVisible: this._activeFloorsVisible,
						floors: []
					}));
					let s$1 = null;
					for (const e$1 of o$1.floorIds) if (this._activeFloors && this._activeFloors.has(e$1)) {
						s$1 = e$1;
						break;
					}
					const r$1 = Array.from(o$1.floorIds).map(((e$1) => ({
						id: e$1,
						name: o$1.floors[e$1].name,
						zIndex: o$1.floors[e$1].zIndex
					}))).sort(((e$1, t$2) => t$2.zIndex - e$1.zIndex));
					this.fire(new e.z("selector-update", {
						selectedFloorId: s$1,
						activeFloorsVisible: this._activeFloorsVisible,
						floors: r$1
					}));
				}
				_updateActiveFloors() {
					const e$1 = this._activeFloors;
					this._activeFloors = /* @__PURE__ */ new Set(), this._indoorState = {
						selectedFloorId: this._selectedFloorId,
						lastActiveFloors: e$1,
						activeFloorsVisible: this._activeFloorsVisible
					}, this._style.updateIndoorDependentLayers();
				}
			}
			var zo = "\n#define EPSILON 0.0000001\n#define PI 3.141592653589793\n#ifdef RENDER_CUTOFF\nfloat cutoff_opacity(vec4 cutoff_params,float depth) {float near=cutoff_params.x;float far=cutoff_params.y;float cutoffStart=cutoff_params.z;float cutoffEnd=cutoff_params.w;float linearDepth=(depth-near)/(far-near);return clamp((linearDepth-cutoffStart)/(cutoffEnd-cutoffStart),0.0,1.0);}\n#endif", Mo = "\n#ifdef DUAL_SOURCE_BLENDING\nlayout(location=0,index=0) out vec4 glFragColor;layout(location=0,index=1) out vec4 glFragColorSrc1;\n#else\nlayout(location=0) out vec4 glFragColor;\n#endif\n#ifdef USE_MRT1\nlayout(location=1) out vec4 out_Target1;\n#endif\nhighp float unpack_depth(highp vec4 rgba_depth)\n{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}highp vec4 pack_depth(highp float ndc_z) {highp float depth=ndc_z*0.5+0.5;const highp vec4 bit_shift=vec4(255.0*255.0*255.0,255.0*255.0,255.0,1.0);const highp vec4 bit_mask =vec4(0.0,1.0/255.0,1.0/255.0,1.0/255.0);highp vec4 res=fract(depth*bit_shift);res-=res.xxyz*bit_mask;return res;}\n#ifdef INDICATOR_CUTOUT\nuniform vec3 u_indicator_cutout_centers;uniform vec4 u_indicator_cutout_params;\n#endif\nvec4 applyCutout(vec4 color,float height) {\n#ifdef INDICATOR_CUTOUT\nfloat verticalFadeRange=u_indicator_cutout_centers.z*0.25;float holeMinOpacity=mix(1.0,u_indicator_cutout_params.x,smoothstep(u_indicator_cutout_centers.z,u_indicator_cutout_centers.z+verticalFadeRange,height));float holeRadius=max(u_indicator_cutout_params.y,0.0);float holeAspectRatio=u_indicator_cutout_params.z;float fadeStart=u_indicator_cutout_params.w;float distA=distance(vec2(gl_FragCoord.x,gl_FragCoord.y*holeAspectRatio),vec2(u_indicator_cutout_centers[0],u_indicator_cutout_centers[1]*holeAspectRatio));return color*min(smoothstep(fadeStart,holeRadius,distA)+holeMinOpacity,1.0);\n#else\nreturn color;\n#endif\n}\n#ifdef DEBUG_WIREFRAME\n#define HANDLE_WIREFRAME_DEBUG \\\nglFragColor=vec4(0.7,0.0,0.0,0.7); \\\ngl_FragDepth=gl_FragCoord.z-0.0001;\n#else\n#define HANDLE_WIREFRAME_DEBUG\n#endif\n#ifdef RENDER_CUTOFF\nuniform highp vec4 u_cutoff_params;in float v_cutoff_opacity;\n#endif\nvec4 textureLodCustom(sampler2D image,highp vec2 pos,highp vec2 lod_coord) {highp vec2 size=vec2(textureSize(image,0));highp vec2 dx=dFdx(lod_coord.xy*size);highp vec2 dy=dFdy(lod_coord.xy*size);highp float delta_max_sqr=max(dot(dx,dx),dot(dy,dy));highp float lod=0.5*log2(delta_max_sqr);return textureLod(image,pos,lod);}vec4 applyLUT(highp sampler3D lut,vec4 col) {vec3 size=vec3(textureSize(lut,0));vec3 uvw=(col.rbg*float(size-1.0)+0.5)/size;return vec4(texture(lut,uvw).rgb*col.a,col.a);}vec3 applyLUT(highp sampler3D lut,vec3 col) {return applyLUT(lut,vec4(col,1.0)).rgb;}", Fo = "\n#define EXTENT 8192.0\n#define RAD_TO_DEG 180.0/PI\n#define DEG_TO_RAD PI/180.0\n#define GLOBE_RADIUS EXTENT/PI/2.0\nfloat wrap(float n,float min,float max) {float d=max-min;float w=mod(mod(n-min,d)+d,d)+min;return (w==min) ? max : w;}\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 mercator_tile_position(mat4 matrix,vec2 tile_anchor,vec3 tile_id,vec2 mercator_center) {\n#ifndef PROJECTED_POS_ON_VIEWPORT\nfloat tiles=tile_id.z;vec2 mercator=(tile_anchor/EXTENT+tile_id.xy)/tiles;mercator-=mercator_center;mercator.x=wrap(mercator.x,-0.5,0.5);vec4 mercator_tile=vec4(mercator.xy*EXTENT,EXTENT/(2.0*PI),1.0);mercator_tile=matrix*mercator_tile;return mercator_tile.xyz;\n#else\nreturn vec3(0.0);\n#endif\n}vec3 mix_globe_mercator(vec3 globe,vec3 mercator,float t) {return mix(globe,mercator,t);}mat3 globe_mercator_surface_vectors(vec3 pos_normal,vec3 up_dir,float zoom_transition) {vec3 normal=zoom_transition==0.0 ? pos_normal : normalize(mix(pos_normal,up_dir,zoom_transition));vec3 xAxis=normalize(vec3(normal.z,0.0,-normal.x));vec3 yAxis=normalize(cross(normal,xAxis));return mat3(xAxis,yAxis,normal);}\n#endif\nvec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(\nunpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0\n);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const vec2 units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (units_to_pixels*pos+offset)/pattern_size;}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {return get_pattern_pos(pixel_coord_upper,pixel_coord_lower,pattern_size,vec2(tile_units_to_pixels),pos);}float mercatorXfromLng(float lng) {return (180.0+lng)/360.0;}float mercatorYfromLat(float lat) {return (180.0-(RAD_TO_DEG*log(tan(PI/4.0+lat/2.0*DEG_TO_RAD))))/360.0;}vec3 latLngToECEF(vec2 latLng) {latLng=DEG_TO_RAD*latLng;float cosLat=cos(latLng[0]);float sinLat=sin(latLng[0]);float cosLng=cos(latLng[1]);float sinLng=sin(latLng[1]);float sx=cosLat*sinLng*GLOBE_RADIUS;float sy=-sinLat*GLOBE_RADIUS;float sz=cosLat*cosLng*GLOBE_RADIUS;return vec3(sx,sy,sz);}\n#ifdef RENDER_CUTOFF\nuniform vec4 u_cutoff_params;out float v_cutoff_opacity;\n#endif\nconst vec4 AWAY=vec4(-1000.0,-1000.0,-1000.0,1);const float skirtOffset=24575.0;vec3 decomposeToPosAndSkirt(vec2 posWithComposedSkirt)\n{float skirt=float(posWithComposedSkirt.x >=skirtOffset);vec2 pos=posWithComposedSkirt-vec2(skirt*skirtOffset,0.0);return vec3(pos,skirt);}\n#ifndef HAS_SHADER_STORAGE_BLOCK_material_buffer\n#define GET_ATTRIBUTE_float(attrib,matInfo,attrib_id) attrib\n#define GET_ATTRIBUTE_vec4(attrib,matInfo,attrib_id) attrib\n#define GET_ATTRIBUTE_vec2(attrib,matInfo,attrib_id) attrib\n#define DECLARE_MATERIAL_TABLE_INFO\n#endif", Bo = "in highp vec3 a_pos_3f;uniform lowp mat4 u_matrix;out highp vec3 v_uv;void main() {const mat3 half_neg_pi_around_x=mat3(1.0,0.0, 0.0,0.0,0.0,-1.0,0.0,1.0, 0.0);v_uv=half_neg_pi_around_x*a_pos_3f;vec4 pos=u_matrix*vec4(a_pos_3f,1.0);gl_Position=pos.xyww;}", ko = "\n#define ELEVATION_SCALE 7.0\n#define ELEVATION_OFFSET 450.0\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_tl_up;uniform vec3 u_tile_tr_up;uniform vec3 u_tile_br_up;uniform vec3 u_tile_bl_up;uniform float u_tile_up_scale;vec3 elevationVector(vec2 pos) {vec2 uv=pos/EXTENT;vec3 up=normalize(mix(\nmix(u_tile_tl_up,u_tile_tr_up,uv.xxx),mix(u_tile_bl_up,u_tile_br_up,uv.xxx),uv.yyy));return up*u_tile_up_scale;}\n#else\nvec3 elevationVector(vec2 pos) { return vec3(0,0,1); }\n#endif\n#ifdef TERRAIN\nuniform highp sampler2D u_dem;uniform highp sampler2D u_dem_prev;uniform vec2 u_dem_tl;uniform vec2 u_dem_tl_prev;uniform float u_dem_scale;uniform float u_dem_scale_prev;uniform float u_dem_size;uniform float u_dem_lerp;uniform float u_exaggeration;uniform float u_meter_to_dem;uniform mat4 u_label_plane_matrix_inv;vec4 tileUvToDemSample(vec2 uv,float dem_size,float dem_scale,vec2 dem_tl) {vec2 pos=dem_size*(uv*dem_scale+dem_tl)+1.0;vec2 f=fract(pos);return vec4((pos-f+0.5)/(dem_size+2.0),f);}float currentElevation(vec2 apos) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nvec2 pos=(u_dem_size*(apos/8192.0*u_dem_scale+u_dem_tl)+1.5)/(u_dem_size+2.0);return u_exaggeration*texture(u_dem,pos).r;\n#else\nfloat dd=1.0/(u_dem_size+2.0);vec4 r=tileUvToDemSample(apos/8192.0,u_dem_size,u_dem_scale,u_dem_tl);vec2 pos=r.xy;vec2 f=r.zw;float tl=texture(u_dem,pos).r;float tr=texture(u_dem,pos+vec2(dd,0)).r;float bl=texture(u_dem,pos+vec2(0,dd)).r;float br=texture(u_dem,pos+vec2(dd,dd)).r;return u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);\n#endif\n}float prevElevation(vec2 apos) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nvec2 pos=(u_dem_size*(apos/8192.0*u_dem_scale_prev+u_dem_tl_prev)+1.5)/(u_dem_size+2.0);return u_exaggeration*texture(u_dem_prev,pos).r;\n#else\nfloat dd=1.0/(u_dem_size+2.0);vec4 r=tileUvToDemSample(apos/8192.0,u_dem_size,u_dem_scale_prev,u_dem_tl_prev);vec2 pos=r.xy;vec2 f=r.zw;float tl=texture(u_dem_prev,pos).r;float tr=texture(u_dem_prev,pos+vec2(dd,0)).r;float bl=texture(u_dem_prev,pos+vec2(0,dd)).r;float br=texture(u_dem_prev,pos+vec2(dd,dd)).r;return u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);\n#endif\n}\n#ifdef TERRAIN_VERTEX_MORPHING\nfloat elevation(vec2 apos) {\n#ifdef ZERO_EXAGGERATION\nreturn 0.0;\n#endif\nfloat nextElevation=currentElevation(apos);float prevElevation=prevElevation(apos);return mix(prevElevation,nextElevation,u_dem_lerp);}\n#else\nfloat elevation(vec2 apos) {\n#ifdef ZERO_EXAGGERATION\nreturn 0.0;\n#endif\nreturn currentElevation(apos);}\n#endif\nvec4 fourSample(vec2 pos,vec2 off) {float tl=texture(u_dem,pos).r;float tr=texture(u_dem,pos+vec2(off.x,0.0)).r;float bl=texture(u_dem,pos+vec2(0.0,off.y)).r;float br=texture(u_dem,pos+off).r;return vec4(tl,tr,bl,br);}float flatElevation(vec2 pack) {vec2 apos=floor(pack/8.0);vec2 span=10.0*(pack-apos*8.0);vec2 uvTex=(apos-vec2(1.0,1.0))/8190.0;float size=u_dem_size+2.0;float dd=1.0/size;vec2 pos=u_dem_size*(uvTex*u_dem_scale+u_dem_tl)+1.0;vec2 f=fract(pos);pos=(pos-f+0.5)*dd;vec4 h=fourSample(pos,vec2(dd));float z=mix(mix(h.x,h.y,f.x),mix(h.z,h.w,f.x),f.y);vec2 w=floor(0.5*(span*u_meter_to_dem-1.0));vec2 d=dd*w;h=fourSample(pos-d,2.0*d+vec2(dd));vec4 diff=abs(h.xzxy-h.ywzw);vec2 slope=min(vec2(0.25),u_meter_to_dem*0.5*(diff.xz+diff.yw)/(2.0*w+vec2(1.0)));vec2 fix=slope*span;float base=z+max(fix.x,fix.y);return u_exaggeration*base;}float elevationFromUint16(float word) {return u_exaggeration*(word/ELEVATION_SCALE-ELEVATION_OFFSET);}\n#else\nfloat elevation(vec2 pos) { return 0.0; }\n#endif\n#ifdef DEPTH_OCCLUSION\nuniform highp sampler2D u_depth;uniform highp vec2 u_depth_size_inv;uniform highp vec2 u_depth_range_unpack;uniform highp float u_occluder_half_size;uniform highp float u_occlusion_depth_offset;\n#ifdef DEPTH_D24\nfloat unpack_depth(float depth) {return depth*u_depth_range_unpack.x+u_depth_range_unpack.y;}vec4 unpack_depth4(vec4 depth) {return depth*u_depth_range_unpack.x+vec4(u_depth_range_unpack.y);}\n#else\nhighp float unpack_depth_rgba(vec4 rgba_depth)\n{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}\n#endif\nbool isOccluded(vec4 frag) {vec3 coord=frag.xyz/frag.w;\n#ifdef CLIP_ZERO_TO_ONE\ncoord.z=-1.0+2.0*coord.z; \n#endif\n#ifdef DEPTH_D24\nfloat depth=unpack_depth(texture(u_depth,(coord.xy+1.0)*0.5).r);\n#else\nfloat depth=unpack_depth_rgba(texture(u_depth,(coord.xy+1.0)*0.5));\n#endif\nreturn coord.z+u_occlusion_depth_offset > depth;}highp vec4 getCornerDepths(vec2 coord) {highp vec3 df=vec3(u_occluder_half_size*u_depth_size_inv,0.0);highp vec2 uv=0.5*coord.xy+0.5;\n#ifdef DEPTH_D24\nhighp vec4 depth=vec4(\ntexture(u_depth,uv-df.xz).r,texture(u_depth,uv+df.xz).r,texture(u_depth,uv-df.zy).r,texture(u_depth,uv+df.zy).r\n);depth=unpack_depth4(depth);\n#else\nhighp vec4 depth=vec4(\nunpack_depth_rgba(texture(u_depth,uv-df.xz)),unpack_depth_rgba(texture(u_depth,uv+df.xz)),unpack_depth_rgba(texture(u_depth,uv-df.zy)),unpack_depth_rgba(texture(u_depth,uv+df.zy))\n);\n#endif\nreturn depth;}highp float occlusionFadeMultiSample(vec4 frag) {highp vec3 coord=frag.xyz/frag.w;highp vec2 uv=0.5*coord.xy+0.5;\n#ifdef CLIP_ZERO_TO_ONE\ncoord.z=-1.0+2.0*coord.z; \n#endif\nint NX=3;int NY=4;highp vec2 df=u_occluder_half_size*u_depth_size_inv;highp vec2 oneStep=2.0*u_occluder_half_size*u_depth_size_inv/vec2(NX-1,NY-1);highp float res=0.0;for (int y=0; y < NY;++y) {for (int x=0; x < NX;++x) {\n#ifdef DEPTH_D24\nhighp float depth=unpack_depth(texture(u_depth,uv-df+vec2(float(x)*oneStep.x,float(y)*oneStep.y)).r);\n#else\nhighp float depth=unpack_depth_rgba(texture(u_depth,uv-df+vec2(float(x)*oneStep.x,float(y)*oneStep.y)));\n#endif\nres+=1.0-clamp(300.0*(coord.z+u_occlusion_depth_offset-depth),0.0,1.0);}}res=clamp(2.0*res/float(NX*NY)-0.5,0.0,1.0);return res;}highp float occlusionFade(vec4 frag) {highp vec3 coord=frag.xyz/frag.w;\n#ifdef CLIP_ZERO_TO_ONE\ncoord.z=-1.0+2.0*coord.z; \n#endif\nhighp vec4 depth=getCornerDepths(coord.xy);return dot(vec4(0.25),vec4(1.0)-clamp(300.0*(vec4(coord.z+u_occlusion_depth_offset)-depth),0.0,1.0));}\n#else\nbool isOccluded(vec4 frag) { return false; }highp float occlusionFade(vec4 frag) { return 1.0; }highp float occlusionFadeMultiSample(vec4 frag) { return 1.0; }\n#endif", No = "#ifdef FOG\nuniform mediump vec4 u_fog_color;uniform mediump vec2 u_fog_range;uniform mediump float u_fog_horizon_blend;uniform mediump mat4 u_fog_matrix;out vec3 v_fog_pos;float fog_range(float depth) {return (depth-u_fog_range[0])/(u_fog_range[1]-u_fog_range[0]);}float fog_horizon_blending(vec3 camera_dir) {float t=max(0.0,camera_dir.z/u_fog_horizon_blend);return u_fog_color.a*exp(-3.0*t*t);}float fog_opacity(float t) {const float decay=6.0;float falloff=1.0-min(1.0,exp(-decay*t));falloff*=falloff*falloff;return u_fog_color.a*min(1.0,1.00747*falloff);}vec3 fog_position(vec3 pos) {return (u_fog_matrix*vec4(pos,1.0)).xyz;}vec3 fog_position(vec2 pos) {return fog_position(vec3(pos,0.0));}float fog(vec3 pos) {float depth=length(pos);float opacity=fog_opacity(fog_range(depth));return opacity*fog_horizon_blending(pos/depth);}\n#endif", Uo = "#ifdef FOG\nuniform mediump vec4 u_fog_color;uniform mediump vec2 u_fog_range;uniform mediump float u_fog_horizon_blend;uniform mediump vec2 u_fog_vertical_limit;uniform mediump float u_fog_temporal_offset;in vec3 v_fog_pos;uniform highp vec3 u_frustum_tl;uniform highp vec3 u_frustum_tr;uniform highp vec3 u_frustum_br;uniform highp vec3 u_frustum_bl;uniform highp vec3 u_globe_pos;uniform highp float u_globe_radius;uniform highp vec2 u_viewport;uniform float u_globe_transition;uniform int u_is_globe;float fog_range(float depth) {return (depth-u_fog_range[0])/(u_fog_range[1]-u_fog_range[0]);}float fog_horizon_blending(vec3 camera_dir) {float t=max(0.0,camera_dir.z/u_fog_horizon_blend);return u_fog_color.a*exp(-3.0*t*t);}float fog_opacity(float t) {const float decay=6.0;float falloff=1.0-min(1.0,exp(-decay*t));falloff*=falloff*falloff;return u_fog_color.a*min(1.0,1.00747*falloff);}float globe_glow_progress() {highp vec2 uv=gl_FragCoord.xy/u_viewport;\n#ifdef FLIP_Y\nuv.y=1.0-uv.y;\n#endif\nhighp vec3 ray_dir=mix(\nmix(u_frustum_tl,u_frustum_tr,uv.x),mix(u_frustum_bl,u_frustum_br,uv.x),1.0-uv.y);highp vec3 dir=normalize(ray_dir);highp vec3 closest_point=dot(u_globe_pos,dir)*dir;highp float sdf=length(closest_point-u_globe_pos)/u_globe_radius;return sdf+PI*0.5;}float fog_opacity(vec3 pos) {float depth=length(pos);return fog_opacity(fog_range(depth));}vec3 fog_apply(vec3 color,vec3 pos,float opacity_limit) {float depth=length(pos);float opacity;if (u_is_globe==1) {float glow_progress=globe_glow_progress();float t=mix(glow_progress,depth,u_globe_transition);opacity=fog_opacity(fog_range(t));} else {opacity=fog_opacity(fog_range(depth));opacity*=fog_horizon_blending(pos/depth);}return mix(color,u_fog_color.rgb,min(opacity,opacity_limit));}vec3 fog_apply(vec3 color,vec3 pos) {return fog_apply(color,pos,1.0);}vec4 fog_apply_from_vert(vec4 color,float fog_opac) {float alpha=EPSILON+color.a;color.rgb=mix(color.rgb/alpha,u_fog_color.rgb,fog_opac)*alpha;return color;}vec3 fog_apply_sky_gradient(vec3 camera_ray,vec3 sky_color) {float horizon_blend=fog_horizon_blending(normalize(camera_ray));return mix(sky_color,u_fog_color.rgb,horizon_blend);}vec4 fog_apply_premultiplied(vec4 color,vec3 pos) {float alpha=EPSILON+color.a;color.rgb=fog_apply(color.rgb/alpha,pos)*alpha;return color;}vec4 fog_apply_premultiplied(vec4 color,vec3 pos,float heightMeters) {float verticalProgress=(u_fog_vertical_limit.x > 0.0 || u_fog_vertical_limit.y > 0.0) ? smoothstep(u_fog_vertical_limit.x,u_fog_vertical_limit.y,heightMeters) : 0.0;float opacityLimit=1.0-smoothstep(0.9,1.0,fog_opacity(pos));return mix(fog_apply_premultiplied(color,pos),color,min(verticalProgress,opacityLimit));}vec3 fog_dither(vec3 color) {return color;}vec4 fog_dither(vec4 color) {return vec4(fog_dither(color.rgb),color.a);}\n#endif", jo = "#ifdef RASTER_ARRAY\nuniform highp sampler2D u_image0;uniform sampler2D u_image1;const vec4 NODATA=vec4(1);ivec4 _raTexLinearCoord(highp vec2 texCoord,highp vec2 texResolution,out highp vec2 fxy) {texCoord=texCoord*texResolution-0.5;fxy=fract(texCoord);texCoord-=fxy;return ivec4(texCoord.xxyy+vec2(1.5,0.5).xyxy);}vec2 _raTexLinearMix(highp vec2 fxy,highp vec4 colorMix,highp float colorOffset,highp vec4 t00,highp vec4 t10,highp vec4 t01,highp vec4 t11) {vec2 c00=t00==NODATA ? vec2(0) : vec2(colorOffset+dot(t00,colorMix),1);vec2 c10=t10==NODATA ? vec2(0) : vec2(colorOffset+dot(t10,colorMix),1);vec2 c01=t01==NODATA ? vec2(0) : vec2(colorOffset+dot(t01,colorMix),1);vec2 c11=t11==NODATA ? vec2(0) : vec2(colorOffset+dot(t11,colorMix),1);return mix(mix(c01,c11,fxy.x),mix(c00,c10,fxy.x),fxy.y);}vec2 raTexture2D_image0_linear(highp vec2 texCoord,highp vec2 texResolution,highp vec4 colorMix,highp float colorOffset) {vec2 fxy;ivec4 c=_raTexLinearCoord(texCoord,texResolution,fxy);return _raTexLinearMix(fxy,colorMix,colorOffset,texelFetch(u_image0,c.yz,0),texelFetch(u_image0,c.xz,0),texelFetch(u_image0,c.yw,0),texelFetch(u_image0,c.xw,0)\n);}vec2 raTexture2D_image1_linear(highp vec2 texCoord,highp vec2 texResolution,highp vec4 colorMix,highp float colorOffset) {vec2 fxy;ivec4 c=_raTexLinearCoord(texCoord,texResolution,fxy);return _raTexLinearMix(fxy,colorMix,colorOffset,texelFetch(u_image1,c.yz,0),texelFetch(u_image1,c.xz,0),texelFetch(u_image1,c.yw,0),texelFetch(u_image1,c.xw,0)\n);}vec2 raTexture2D_image0_nearest(highp vec2 texCoord,highp vec2 texResolution,highp vec4 colorMix,highp float colorOffset) {vec4 t=texelFetch(u_image0,ivec2(texCoord*texResolution),0);return t==NODATA ? vec2(0) : vec2(colorOffset+dot(t,colorMix),1);}vec2 raTexture2D_image1_nearest(highp vec2 texCoord,highp vec2 texResolution,highp vec4 colorMix,highp float colorOffset) {vec4 t=texelFetch(u_image1,ivec2(texCoord*texResolution),0);return t==NODATA ? vec2(0) : vec2(colorOffset+dot(t,colorMix),1);}\n#endif", Go = "#ifdef RASTER_ARRAY\nuniform sampler2D u_velocity;uniform mediump vec2 u_velocity_res;uniform mediump float u_max_speed;const vec4 NO_DATA=vec4(1);const vec2 INVALID_VELOCITY=vec2(-1);uniform highp vec2 u_uv_offset;uniform highp float u_data_offset;uniform highp vec2 u_data_scale;ivec4 rasterArrayLinearCoord(highp vec2 texCoord,highp vec2 texResolution,out highp vec2 fxy) {texCoord=texCoord*texResolution-0.5;fxy=fract(texCoord);texCoord-=fxy;return ivec4(texCoord.xxyy+vec2(1.5,0.5).xyxy);}highp vec2 lookup_velocity(highp vec2 uv) {uv=u_uv_offset.x+u_uv_offset.y*uv;highp vec2 fxy;ivec4 c=rasterArrayLinearCoord(uv,u_velocity_res,fxy);highp vec4 tl=texelFetch(u_velocity,c.yz,0);highp vec4 tr=texelFetch(u_velocity,c.xz,0);highp vec4 bl=texelFetch(u_velocity,c.yw,0);highp vec4 br=texelFetch(u_velocity,c.xw,0);if (tl==NO_DATA) {return INVALID_VELOCITY;}if (tr==NO_DATA) {return INVALID_VELOCITY;}if (bl==NO_DATA) {return INVALID_VELOCITY;}if (br==NO_DATA) {return INVALID_VELOCITY;}highp vec4 t=mix(mix(bl,br,fxy.x),mix(tl,tr,fxy.x),fxy.y);highp vec2 velocity=u_data_offset+vec2(dot(t.rg,u_data_scale),dot(t.ba,u_data_scale));velocity.y=-velocity.y;velocity/=max(u_max_speed,length(velocity));return velocity;}\n#endif\nuniform highp float u_particle_pos_scale;uniform highp vec2 u_particle_pos_offset;highp vec4 pack_pos_to_rgba(highp vec2 p) {highp vec2 v=(p+u_particle_pos_offset)/u_particle_pos_scale;highp vec4 r=vec4(v.x,fract(v.x*255.0),v.y,fract(v.y*255.0));return vec4(r.x-r.y/255.0,r.y,r.z-r.w/255.0,r.w);}highp vec2 unpack_pos_from_rgba(highp vec4 v) {v=floor(v*255.0+0.5)/255.0;highp vec2 p=vec2(v.x+(v.y/255.0),v.z+(v.w/255.0));return u_particle_pos_scale*p-u_particle_pos_offset;}", Vo = "#ifdef RENDER_SHADOWS\nuniform mediump vec3 u_shadow_direction;uniform highp vec3 u_shadow_normal_offset;vec3 shadow_normal_offset(vec3 normal) {float tileInMeters=u_shadow_normal_offset[0];vec3 n=vec3(-normal.xy,tileInMeters*normal.z);float dotScale=min(1.0-dot(normal,u_shadow_direction),1.0)*0.5+0.5;return n*dotScale;}vec3 shadow_normal_offset_model(vec3 normal) {vec3 transformed_normal=vec3(-normal.xy,normal.z);float NDotL=dot(normalize(transformed_normal),u_shadow_direction);float dotScale=min(1.0-NDotL,1.0)*0.5+0.5;return normal*dotScale;}float shadow_normal_offset_multiplier0() {return u_shadow_normal_offset[1];}float shadow_normal_offset_multiplier1() {return u_shadow_normal_offset[2];}\n#endif", Ho = "#ifdef RENDER_SHADOWS\nprecision highp sampler2DShadow;uniform sampler2DShadow u_shadowmap_0;uniform sampler2DShadow u_shadowmap_1;uniform float u_shadow_intensity;uniform float u_shadow_map_resolution;uniform float u_shadow_texel_size;uniform highp vec3 u_shadow_normal_offset;uniform vec2 u_fade_range;uniform mediump vec3 u_shadow_direction;uniform highp vec3 u_shadow_bias;float shadow_sample(sampler2DShadow shadowmap,highp vec3 pos,highp float bias) {\n#ifdef CLIP_ZERO_TO_ONE\nhighp vec3 coord=vec3(pos.xy*0.5+0.5,pos.z-bias);\n#else\nhighp vec3 coord=vec3(pos.xy*0.5+0.5,pos.z*0.5+0.5-bias);\n#endif\nreturn texture(shadowmap,coord);}float shadow_occlusion(highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth,highp float bias) {light_view_pos0.xyz/=light_view_pos0.w;\n#ifdef SHADOWS_SINGLE_CASCADE\nvec2 abs_bounds=abs(light_view_pos0.xy);if (abs_bounds.x >=1.0 || abs_bounds.y >=1.0) {return 0.0;}return shadow_sample(u_shadowmap_0,light_view_pos0.xyz,bias);\n#else\nlight_view_pos1.xyz/=light_view_pos1.w;vec4 abs_bounds=abs(vec4(light_view_pos0.xy,light_view_pos1.xy));if (abs_bounds.x < 1.0 && abs_bounds.y < 1.0) {return shadow_sample(u_shadowmap_0,light_view_pos0.xyz,bias);}if (abs_bounds.z >=1.0 || abs_bounds.w >=1.0) {return 0.0;}float occlusion1=shadow_sample(u_shadowmap_1,light_view_pos1.xyz,bias);return clamp(mix(occlusion1,0.0,smoothstep(u_fade_range.x,u_fade_range.y,view_depth)),0.0,1.0);\n#endif\n}highp float calculate_shadow_bias(float NDotL) {\n#ifdef NORMAL_OFFSET\nreturn 0.5*u_shadow_bias.x;\n#else\nreturn 0.5*(u_shadow_bias.x+clamp(u_shadow_bias.y*tan(acos(NDotL)),0.0,u_shadow_bias.z));\n#endif\n}float shadowed_light_factor_normal(vec3 N,highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {float NDotL=dot(N,u_shadow_direction);float bias=calculate_shadow_bias(NDotL);float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);return mix(0.0,(1.0-(u_shadow_intensity*occlusion))*NDotL,step(0.0,NDotL));}float shadowed_light_factor_normal_opacity(vec3 N,highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth,float shadow_opacity) {float NDotL=dot(N,u_shadow_direction);float bias=calculate_shadow_bias(NDotL);float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias)*shadow_opacity;return mix(0.0,(1.0-(u_shadow_intensity*occlusion))*NDotL,step(0.0,NDotL));}float shadowed_light_factor_normal_unbiased(vec3 N,highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {float NDotL=dot(N,u_shadow_direction);float bias=0.0;float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);return mix(0.0,(1.0-(u_shadow_intensity*occlusion))*NDotL,step(0.0,NDotL));}highp vec2 compute_receiver_plane_depth_bias(highp vec3 pos_dx,highp vec3 pos_dy)\n{highp vec2 biasUV=vec2(\npos_dy.y*pos_dx.z-pos_dx.y*pos_dy.z,pos_dx.x*pos_dy.z-pos_dy.x*pos_dx.z);biasUV*=1.0/((pos_dx.x*pos_dy.y)-(pos_dx.y*pos_dy.x));return biasUV;}float shadowed_light_factor_plane_bias(highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {highp vec3 light_view_pos0_xyz=light_view_pos0.xyz/light_view_pos0.w*0.5+0.5;highp vec3 light_view_pos0_ddx=dFdx(light_view_pos0_xyz);highp vec3 light_view_pos0_ddy=dFdy(light_view_pos0_xyz);highp vec2 plane_depth_bias=compute_receiver_plane_depth_bias(light_view_pos0_ddx,light_view_pos0_ddy);highp float bias=dot(vec2(u_shadow_texel_size,u_shadow_texel_size),plane_depth_bias)+0.0001;float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);return 1.0-(u_shadow_intensity*occlusion);}float shadowed_light_factor(highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {float bias=0.0;float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);return 1.0-(u_shadow_intensity*occlusion);}float shadow_occlusion(float ndotl,highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {float bias=calculate_shadow_bias(ndotl);return shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);}\n#endif";
			const qo = /#include\s+"([^"]+)"/g, Zo = /#pragma mapbox: ([\w\-]+) ([\w]+) ([\w]+) ([\w]+)/g, Wo = /\b[A-Za-z_][A-Za-z0-9_]*\b/g, $o = new Set([
				"ifdef",
				"ifndef",
				"elif",
				"if",
				"defined"
			]), Xo = /* @__PURE__ */ new Set();
			os(zo, Xo), os(Fo, Xo), os(Mo, Xo);
			const Yo = {
				"_prelude_fog.vertex.glsl": No,
				"_prelude_terrain.vertex.glsl": ko,
				"_prelude_shadow.vertex.glsl": Vo,
				"_prelude_material_table.vertex.glsl": "#ifdef HAS_SHADER_STORAGE_BLOCK_material_buffer\n#define MATERIAL_TABLE_DEBUG 0\nuniform int u_material_offset;uniform int u_vertex_offset;layout(std140,binding=0)readonly buffer material_buffer{uvec4 material_data[];};struct MaterialInfo{uint dataOffset;\n#if MATERIAL_TABLE_DEBUG\nvec4 colorDebug;\n#endif\n};uint read_buf_no_offset(uint iDword) {return material_data[iDword/4u][iDword % 4u];}uint read_buf(uint iDword) {iDword+=uint(u_material_offset/4);return read_buf_no_offset(iDword);}float read_buf_float(uint iDword){return uintBitsToFloat(read_buf(iDword));}uint read_buf_uint8(uint iDword,uint iUint8){uint dwordOffset=iDword+(iUint8/4u);uint byteOffset=iUint8 & 3u;uint bitOffset=8u*byteOffset;uint mask=0xffu << bitOffset;uint dwordVal=read_buf(dwordOffset);return (dwordVal & mask) >> bitOffset;}uint read_buf_uint16(uint iDword,uint iUint16){uint dwordOffset=iDword+(iUint16 >> 1u);uint bitOffset=(iUint16 & 1u)*16u;uint mask=0xffffu << bitOffset;uint dwordVal=read_buf(dwordOffset);return (dwordVal & mask) >> bitOffset;}uint nrDwordsForVertexIdEntries(uint nrMaterialLookupEntries) {return nrMaterialLookupEntries;}uint nrDwordsForMaterialIdEntries(uint nrMaterialLookupEntries) {return (nrMaterialLookupEntries*2u+3u)/4u;}uint findRangeBinarySearch(uint vertexId,uint numRanges,uint dwordOffset) {uint left=0u;uint right=numRanges-1u;for (uint i=0u; i < 16u; i++) { \nif (left > right) {break;}uint mid=(left+right)/2u;uint start=read_buf(dwordOffset+mid);uint nextStart=(mid+1u < numRanges) ? read_buf(dwordOffset+mid+1u) : 0xffffffffu;if (vertexId >=start && vertexId < nextStart) {return mid;} else if (vertexId < start) {if (mid==0u) {break;}right=mid-1u;} else {left=mid+1u;}}return 0u; \n}uint readVertexId(uint dwordOffset,uint iMaterialLookupEntry) {return read_buf(dwordOffset+iMaterialLookupEntry);}uint findRange(uint vertexId,uint numRanges,uint dwordOffset) {uint iRange;if(numRanges <=64u){uint vertexBegin;for(iRange=0u; iRange < numRanges;++iRange) {vertexBegin=readVertexId(dwordOffset,iRange);if(vertexBegin > vertexId) {break;}}iRange=iRange==0u? 0u : iRange-1u;} else { \niRange=findRangeBinarySearch(vertexId,numRanges,dwordOffset);}return iRange;}MaterialInfo read_material_info(uint vertex_id) {MaterialInfo info;\n#if MATERIAL_TABLE_DEBUG\nconst vec4 red=vec4(1.0,0.0,0.0,1.0);const vec4 orange=vec4(1.0,0.5,0.0,1.0);const vec4 yellow=vec4(1.0,1.0,0.0,1.0);const vec4 green=vec4(0.0,1.0,0.0,1.0);const vec4 indigo=vec4(0.294,0.0,0.510,1.0);const vec4 blue=vec4(0.0,0.0,1.0,1.0);const vec4 purple=vec4(0.5,0.0,0.5,1.0);const vec4 pink=vec4(1.0,0.0,1.0,1.0);info.colorDebug=green;\n#endif\nuint offset=0u;\n#if MATERIAL_TABLE_DEBUG\nbool keepFinding=true;uint magic=read_buf(offset);if(magic !=0xCAFEBABEu) {info.colorDebug=red;keepFinding=false;return info;}\n#endif\noffset++;\n#if MATERIAL_TABLE_DEBUG\nuint nrMaterials=read_buf(offset);uint nrVertices=read_buf(offset+1u);if(keepFinding && vertex_id >=nrVertices) {info.colorDebug=red;keepFinding=false;}\n#endif\noffset+=2u;uint nrMaterialLookupEntries=read_buf(offset++);uint perMaterialEntrySizeDwords=read_buf(offset++);\n#if MATERIAL_TABLE_DEBUG\nif(keepFinding && perMaterialEntrySizeDwords !=1u) {info.colorDebug=red;keepFinding=false;}\n#endif\nuint iMaterialLookup=findRange(vertex_id,nrMaterialLookupEntries,offset);\n#if MATERIAL_TABLE_DEBUG\nif(keepFinding)\n{uint vertexBeginCheck=readVertexId(offset,iMaterialLookup);if(vertexBeginCheck > vertex_id) {info.colorDebug=red;keepFinding=false;}if(iMaterialLookup < nrMaterialLookupEntries-1u) {uint vertexEndCheck=readVertexId(offset,iMaterialLookup+1u);if(vertexEndCheck <=vertex_id) {info.colorDebug=red;keepFinding=false;}}}\n#endif\noffset+=nrDwordsForVertexIdEntries(nrMaterialLookupEntries);uint materialId=iMaterialLookup;\n#if MATERIAL_TABLE_DEBUG\nif(keepFinding) {if(materialId >=nrMaterialLookupEntries) {info.colorDebug=red;}}\n#endif\ninfo.dataOffset=offset+materialId*perMaterialEntrySizeDwords;return info;}uint get_data_location(const MaterialInfo matInfo,uint attribOffsetBytes)\n{uint attribFieldOffsetDwords=attribOffsetBytes/4u;return matInfo.dataOffset+attribFieldOffsetDwords;}vec4 read_material_vec4(const MaterialInfo matInfo,uint attribOffsetBytes){uint loc=get_data_location(matInfo,attribOffsetBytes);return vec4(read_buf_float(loc),read_buf_float(loc+1u),read_buf_float(loc+2u),read_buf_float(loc+3u));}vec2 read_material_vec2(const MaterialInfo matInfo,uint attribOffsetBytes){uint loc=get_data_location(matInfo,attribOffsetBytes);return vec2(read_buf_float(loc),read_buf_float(loc+1u));}float read_material_float(const MaterialInfo matInfo,uint attribOffsetBytes){uint loc=get_data_location(matInfo,attribOffsetBytes);return read_buf_float(loc);}\n#define GET_ATTRIBUTE_float(attrib,matInfo,attrib_offset) read_material_float(matInfo,attrib_offset)\n#define GET_ATTRIBUTE_vec4(attrib,matInfo,attrib_offset) read_material_vec4(matInfo,attrib_offset)\n#define GET_ATTRIBUTE_vec2(attrib,matInfo,attrib_offset) read_material_vec2(matInfo,attrib_offset)\n#define DECLARE_MATERIAL_TABLE_INFO MaterialInfo materialInfo=read_material_info(uint(gl_VertexID));\n#define DECLARE_MATERIAL_TABLE_INFO_DEBUG(dbgColor) MaterialInfo materialInfo=read_material_info(uint(gl_VertexID)); dbgColor=materialInfo.colorDebug;\n#endif",
				"_prelude_fog.fragment.glsl": Uo,
				"_prelude_shadow.fragment.glsl": Ho,
				"_prelude_lighting.glsl": "\n#ifdef LIGHTING_3D_MODE\nuniform mediump vec3 u_lighting_ambient_color;uniform mediump vec3 u_lighting_directional_dir;uniform mediump vec3 u_lighting_directional_color;uniform mediump vec3 u_ground_radiance;float calculate_ambient_directional_factor(vec3 normal) {float NdotL=dot(normal,u_lighting_directional_dir);const float factor_reduction_max=0.3;float dir_luminance=dot(u_lighting_directional_color,vec3(0.2126,0.7152,0.0722));float directional_factor_min=1.0-factor_reduction_max*min(dir_luminance,1.0);float ambient_directional_factor=mix(directional_factor_min,1.0,min((NdotL+1.0),1.0));const float vertical_factor_min=0.92;float vertical_factor=mix(vertical_factor_min,1.0,normal.z*0.5+0.5);return vertical_factor*ambient_directional_factor;}vec3 linearProduct(vec3 srgbIn,vec3 k) {return srgbIn*pow(k,vec3(1./2.2));}vec3 apply_lighting(vec3 color,vec3 normal,float dir_factor) {float ambient_directional_factor=calculate_ambient_directional_factor(normal);vec3 ambient_contrib=ambient_directional_factor*u_lighting_ambient_color;vec3 directional_contrib=u_lighting_directional_color*dir_factor;return linearProduct(color,ambient_contrib+directional_contrib);}vec4 apply_lighting(vec4 color,vec3 normal,float dir_factor) {return vec4(apply_lighting(color.rgb,normal,dir_factor),color.a);}vec3 apply_lighting(vec3 color,vec3 normal) {float dir_factor=max(dot(normal,u_lighting_directional_dir),0.0);return apply_lighting(color.rgb,normal,dir_factor);}vec4 apply_lighting(vec4 color,vec3 normal) {float dir_factor=max(dot(normal,u_lighting_directional_dir),0.0);return vec4(apply_lighting(color.rgb,normal,dir_factor),color.a);}vec3 apply_lighting_ground(vec3 color) {return color*u_ground_radiance;}vec4 apply_lighting_ground(vec4 color) {return vec4(apply_lighting_ground(color.rgb),color.a);}float calculate_NdotL(vec3 normal) {const float ext=0.70710678118;return (clamp(dot(normal,u_lighting_directional_dir),-ext,1.0)+ext)/(1.0+ext);}vec4 apply_lighting_with_emission_ground(vec4 color,float emissive_strength) {return mix(apply_lighting_ground(color),color,emissive_strength);}vec3 compute_flood_lighting(vec3 flood_light_color,float fully_occluded_factor,float occlusion,vec3 ground_shadow_factor) {vec3 fully_occluded_color=flood_light_color*mix(ground_shadow_factor,vec3(1.0),fully_occluded_factor);float occlusion_ramp=smoothstep(0.0,0.2,1.0-occlusion);return mix(fully_occluded_color,flood_light_color,occlusion_ramp);}vec3 compute_emissive_draped(vec3 unlit_color,float fully_occluded_factor,float occlusion,vec3 ground_shadow_factor) {vec3 fully_occluded_color=unlit_color*mix(ground_shadow_factor,vec3(1.0),fully_occluded_factor);return mix(fully_occluded_color,unlit_color,1.0-occlusion);}\n#endif",
				"_prelude_raster_array.glsl": jo,
				"_prelude_raster_particle.glsl": Go
			}, Ko = {};
			ss("", ko), ss(Uo, No), ss(Ho, Vo), ss(jo, ""), ss(Go, "");
			const Jo = ss(Mo, Fo), Qo = zo, es = [
				"\n#if defined(GL_EXT_blend_func_extended) && defined(DUAL_SOURCE_BLENDING)\n#extension GL_EXT_blend_func_extended : require\n#endif",
				"precision mediump float;",
				Qo,
				Jo.fragmentSource
			].join("\n"), ts = [
				"precision highp float;",
				Qo,
				Jo.vertexSource
			].join("\n");
			var is = {
				background: ss("#include \"_prelude_fog.fragment.glsl\"\n#include \"_prelude_lighting.glsl\"\nuniform vec4 u_color;uniform float u_opacity;uniform mediump float u_emissive_strength;\n#ifdef LIGHTING_3D_MODE\nin vec4 v_color;\n#endif\nvoid main() {vec4 out_color;\n#ifdef LIGHTING_3D_MODE\nout_color=v_color;\n#else\nout_color=u_color;\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\nglFragColor=out_color*u_opacity;\n#ifdef USE_MRT1\nout_Target1=vec4(u_emissive_strength*glFragColor.a,0.0,0.0,glFragColor.a);\n#endif\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}", "#include \"_prelude_fog.vertex.glsl\"\n#include \"_prelude_lighting.glsl\"\nin vec2 a_pos;uniform mat4 u_matrix;uniform mediump float u_emissive_strength;\n#ifdef LIGHTING_3D_MODE\nuniform mediump vec4 u_color;out vec4 v_color;\n#endif\nvoid main() {gl_Position=u_matrix*vec4(a_pos,0,1);\n#ifdef LIGHTING_3D_MODE\nv_color=apply_lighting_with_emission_ground(u_color,u_emissive_strength);\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"),
				backgroundPattern: ss("#include \"_prelude_fog.fragment.glsl\"\n#include \"_prelude_lighting.glsl\"\nuniform vec2 u_pattern_tl;uniform vec2 u_pattern_br;uniform vec2 u_texsize;uniform float u_opacity;uniform float u_emissive_strength;uniform sampler2D u_image;in highp vec2 v_pos;void main() {highp vec2 imagecoord=mod(v_pos,1.0);highp vec2 pos=mix(u_pattern_tl/u_texsize,u_pattern_br/u_texsize,imagecoord);vec4 out_color=textureLodCustom(u_image,pos,v_pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\nglFragColor=out_color*u_opacity;\n#ifdef USE_MRT1\nout_Target1=vec4(u_emissive_strength*glFragColor.a,0.0,0.0,glFragColor.a);\n#endif\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}", "#include \"_prelude_fog.vertex.glsl\"\nuniform mat4 u_matrix;uniform vec2 u_pattern_size;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec2 u_pattern_units_to_pixels;in vec2 a_pos;out highp vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_pattern_size,u_pattern_units_to_pixels,a_pos);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"),
				building: ss("#include \"_prelude_fog.fragment.glsl\"\n#include \"_prelude_shadow.fragment.glsl\"\n#include \"_prelude_lighting.glsl\"\nconst float window_depth=0.5;const float ao_radius=0.2;in vec4 v_color;in highp vec3 v_normal;in highp vec3 v_pos;\n#ifdef BUILDING_FAUX_FACADE\nin lowp float v_faux_facade;in highp float v_faux_facade_ed;in highp vec2 v_faux_facade_window;in highp vec2 v_faux_facade_floor;in highp vec2 v_faux_facade_range;in highp float v_aspect;in highp vec3 v_tbn_0;in highp vec3 v_tbn_1;in highp vec3 v_tbn_2;in highp vec4 v_faux_color_emissive;uniform float u_faux_facade_ao_intensity;\n#endif\n#ifdef RENDER_SHADOWS\nin highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;\n#endif\n#ifdef FLOOD_LIGHT\nin highp float v_flood_radius;in float v_has_flood_light;\n#endif\nuniform lowp float u_opacity;uniform vec3 u_camera_pos;uniform highp float u_tile_to_meter;uniform float u_facade_emissive_chance;uniform vec3 u_flood_light_color;uniform float u_flood_light_intensity;vec3 linearTosRGB(in vec3 color) {return pow(color,vec3(1./2.2));}\n#ifdef BUILDING_FAUX_FACADE\nfloat hash12(in vec2 p) {vec3 p3 =fract(vec3(p.xyx)*0.1031);p3+=dot(p3,p3.yzx+33.33);return fract((p3.x+p3.y)*p3.z);}float min3(in vec3 v) {return min(min(v.x,v.y),v.z);}vec2 get_uv_mask_id(in vec2 q,out float mask,out vec2 id) {vec2 p=q;mask=step(v_faux_facade_range.x,p.y)*step(p.y,v_faux_facade_range.y);p.y=p.y-v_faux_facade_range.x;vec2 uv=modf(p/v_faux_facade_floor,id);vec4 d=(v_faux_facade_floor.xyxy+vec4(-v_faux_facade_window,v_faux_facade_window))*0.5;vec4 edge=d/v_faux_facade_floor.xyxy;vec2 m=step(edge.xy,uv)*step(uv,edge.zw);mask*=m.x*m.y;uv-=vec2(0.5);uv*=vec2(0.5)/(vec2(0.5)-edge.xy);uv+=vec2(0.5);return uv;}float ray_unit_box(in vec3 ray_o,in vec3 ray_d,in vec3 bmin,in vec3 bmax) {vec3 planes=mix(bmin,bmax,step(0.0,ray_d));vec3 t=(planes-ray_o)/ray_d;return min3(t);}float get_emissive(in vec2 id) {if (u_facade_emissive_chance > 0.0) {return (step(hash12(id),u_facade_emissive_chance)+0.05)*v_faux_color_emissive.a;}return 0.0;}vec3 get_shade_info(in vec3 v,in vec3 v_normalized,in vec3 color,in vec2 id,in mat3 tbn,inout vec3 out_normal,inout float out_emissive) {vec3 out_color=color;vec3 abs_v=abs(v_normalized);bool x_major=abs_v.x >=abs_v.y && abs_v.x >=abs_v.z;bool y_major=abs_v.y >=abs_v.x && abs_v.y >=abs_v.z;bool z_major=abs_v.z >=abs_v.x && abs_v.z >=abs_v.y;\n#if 0\nif (x_major) {out_color=v.x > 0.0 ? vec3(1.0,0.0,0.0) : vec3(0.0,1.0,1.0);} else if (y_major) {out_color=v.y > 0.0 ? vec3(0.0,1.0,0.0) : vec3(1.0,0.0,1.0);} else if (z_major) {out_color=v.z > 0.0 ? vec3(0.0,0.0,1.0) : vec3(1.0,1.0,0.0);}out_emissive=1.0;\n#else\nif (x_major) {out_normal=sign(v.x)*tbn[0];} else if (y_major) {out_normal=vec3(0.0,0.0,-sign(v.y));} else if (z_major) {out_color=v_faux_color_emissive.rgb;out_emissive=v.z <=0.0 ? get_emissive(id) : out_emissive;}float ao=1.0;if (u_faux_facade_ao_intensity > 0.0) {vec4 ao_range=v_faux_facade_window.xxyy*0.5-vec4(0,ao_radius,0,ao_radius);vec2 ao_range_z=vec2(window_depth*0.5)-vec2(0.0,ao_radius);if (x_major || y_major) {ao*=smoothstep(-ao_range_z.x,-ao_range_z.y,v.z);} else if (z_major) {ao*=smoothstep(-ao_range.x,-ao_range.y,v.x)*(1.0-smoothstep(ao_range.y,ao_range.x,v.x));ao*=smoothstep(-ao_range.z,-ao_range.w,v.y)*(1.0-smoothstep(ao_range.w,ao_range.z,v.y));}ao=mix(1.0,min(1.0,ao+0.25),u_faux_facade_ao_intensity);}out_color*=ao;\n#endif\nreturn out_color;}\n#endif\nvec3 apply_lighting_linear(in vec3 color,in vec3 normal,in float dir_factor) {float ambient_directional_factor=calculate_ambient_directional_factor(normal);vec3 ambient_contrib=ambient_directional_factor*u_lighting_ambient_color;vec3 directional_contrib=u_lighting_directional_color*dir_factor;return color*(ambient_contrib+directional_contrib);}void main() {vec3 normal=normalize(v_normal);vec3 base_color=v_color.rgb;float emissive=v_color.a;\n#ifdef BUILDING_FAUX_FACADE\nif (v_faux_facade > 0.0) {mat3 tbn=mat3(v_tbn_0,v_tbn_1,v_tbn_2);vec3 v=vec3(v_pos.xy,v_pos.z/u_tile_to_meter)-u_camera_pos;vec3 view_tangent=transpose(tbn)*v;vec2 q=vec2(v_faux_facade_ed,v_pos.z);float mask=0.0;vec2 id=vec2(0.0);vec2 uv=get_uv_mask_id(q,mask,id);uv*=v_faux_facade_window;vec3 bmin=vec3(0.0,0.0,-window_depth);vec3 bmax=bmin+vec3(v_faux_facade_window,window_depth);vec3 ray_o=vec3(uv,0.0);vec3 ray_d=normalize(view_tangent);float t_min=ray_unit_box(ray_o,ray_d,bmin,bmax);vec3 hit=ray_o+t_min*ray_d;vec3 r=vec3(v_faux_facade_window,-window_depth);hit-=r*0.5;vec3 normalized=hit/r;vec3 out_normal=normal;float out_emissive=emissive;vec3 room_color=get_shade_info(hit,normalized,base_color,id,tbn,out_normal,out_emissive);base_color=mix(base_color,room_color,mask);normal=mix(normal,out_normal,mask);emissive=mix(emissive,out_emissive,mask);}\n#endif\nvec4 color=vec4(base_color,1.0);vec3 xy_flipped_normal=vec3(-normal.xy,normal.z);float shadowed_lighting_factor=0.0;\n#ifdef RENDER_SHADOWS\n#ifdef RENDER_CUTOFF\nshadowed_lighting_factor=shadowed_light_factor_normal_opacity(xy_flipped_normal,v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w,v_cutoff_opacity);if (v_cutoff_opacity==0.0) {discard;}\n#else\nshadowed_lighting_factor=shadowed_light_factor_normal(xy_flipped_normal,v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w);\n#endif\n#else\nshadowed_lighting_factor=dot(xy_flipped_normal,u_lighting_directional_dir);\n#endif\ncolor.rgb=apply_lighting_linear(color.rgb,xy_flipped_normal,shadowed_lighting_factor);color.rgb=linearTosRGB(color.rgb);\n#ifdef FLOOD_LIGHT\nfloat flood_radiance=(1.0-min(v_pos.z/v_flood_radius,1.0))*u_flood_light_intensity*v_has_flood_light;color.rgb=mix(color.rgb,u_flood_light_color,flood_radiance);\n#endif\ncolor.rgb=mix(color.rgb,linearTosRGB(base_color.rgb),emissive);\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos,v_pos.z));\n#endif\ncolor*=u_opacity;\n#ifdef INDICATOR_CUTOUT\ncolor=applyCutout(color,v_pos.z);\n#endif\n#ifdef FEATURE_CUTOUT\ncolor=apply_feature_cutout(color,gl_FragCoord);\n#endif\nglFragColor=color; \n#ifdef DEBUG_SHOW_NORMALS\ncolor.rgb=xy_flipped_normal*0.5+vec3(0.5,0.5,0.5);color.a=1.0;glFragColor=color;\n#endif\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}", "#include \"_prelude_fog.vertex.glsl\"\n#include \"_prelude_shadow.vertex.glsl\"\nin vec3 a_pos_3f;in vec3 a_normal_3;in vec3 a_centroid_3;in float a_flood_light_wall_radius_1i16;in vec4 a_faux_facade_data;in vec2 a_faux_facade_vertical_range;uniform mat4 u_matrix;uniform mat4 u_normal_matrix;uniform highp float u_tile_to_meter;out vec4 v_color;out vec3 v_normal;out highp vec3 v_pos;\n#ifdef BUILDING_FAUX_FACADE\nout lowp float v_faux_facade;out highp float v_faux_facade_ed;out highp vec2 v_faux_facade_window;out highp vec2 v_faux_facade_floor;out highp vec2 v_faux_facade_range;out highp float v_aspect;out highp vec3 v_tbn_0;out highp vec3 v_tbn_1;out highp vec3 v_tbn_2;out highp vec4 v_faux_color_emissive;\n#endif\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;\n#endif\n#ifdef FLOOD_LIGHT\nout highp float v_flood_radius;out float v_has_flood_light;\n#endif\nconst float MAX_UINT_16=65535.0;const float MAX_INT_16=32767.0;const float MAX_UINT_8=255.0;const float TWO_POW_8=256.0;const float FLOOD_LIGHT_MAX_RADIUS_METER=2048.0;vec3 sRGBToLinear(vec3 srgbIn) {return pow(srgbIn,vec3(2.2));}\n#ifdef BUILDING_FAUX_FACADE\nmat3 get_tbn(in vec3 normal) {const vec3 bitangent=vec3(0.0,0.0,1.0);vec3 tangent=normalize(vec3(normal.y,-normal.x,0.0));return mat3(tangent,bitangent,normal);}\n#endif\n#pragma mapbox: define-attribute-vertex-shader-only highp vec2 part_color_emissive\n#pragma mapbox: define-attribute-vertex-shader-only highp vec2 faux_facade_color_emissive\nvoid main() {\n#pragma mapbox: initialize-attribute-custom highp vec2 part_color_emissive\n#pragma mapbox: initialize-attribute-custom highp vec2 faux_facade_color_emissive\n#ifdef FLOOD_LIGHT\nv_flood_radius=(a_flood_light_wall_radius_1i16/MAX_INT_16*FLOOD_LIGHT_MAX_RADIUS_METER);v_has_flood_light=step(0.0,v_flood_radius);\n#endif\nvec4 color_emissive=decode_color(part_color_emissive);v_color=vec4(sRGBToLinear(color_emissive.rgb),color_emissive.a);vec3 a_normal_3f=a_normal_3/MAX_INT_16;v_normal=vec3(u_normal_matrix*vec4(a_normal_3f,0.0));float hidden=0.0;float depth_offset=0.0;\n#ifdef BUILDING_FAUX_FACADE\nv_faux_facade=a_faux_facade_data.x;if (v_faux_facade > 0.0) {v_faux_facade_ed=a_faux_facade_data.x *u_tile_to_meter;float window_x_perc=floor(a_faux_facade_data.y/TWO_POW_8);float window_y_perc=a_faux_facade_data.y-TWO_POW_8*window_x_perc;vec2 window_perc=vec2(window_x_perc,window_y_perc)/MAX_UINT_8;v_faux_facade_floor=(a_faux_facade_data.zw/MAX_UINT_16*EXTENT)*u_tile_to_meter;v_faux_facade_window=window_perc*v_faux_facade_floor;v_faux_facade_range=(a_faux_facade_vertical_range/MAX_UINT_16*EXTENT)*u_tile_to_meter;v_aspect=v_faux_facade_window.x/v_faux_facade_window.y;mat3 tbn=get_tbn(normalize(v_normal));v_tbn_0=tbn[0];v_tbn_1=tbn[1];v_tbn_2=tbn[2];v_faux_color_emissive=decode_color(faux_facade_color_emissive);v_faux_color_emissive.rgb=sRGBToLinear(v_faux_color_emissive.rgb);float height=a_centroid_3.z;depth_offset=min(1000.0,height)*0.0000002;}\n#endif\nv_pos=a_pos_3f;\n#ifdef RENDER_CUTOFF\nvec4 ground=u_matrix*vec4(a_centroid_3,1.0);v_cutoff_opacity=cutoff_opacity(u_cutoff_params,ground.z);hidden=float(v_cutoff_opacity==0.0);v_pos.z*=v_cutoff_opacity;\n#endif\n#ifdef RENDER_SHADOWS\nvec3 shadow_pos=v_pos;\n#ifdef NORMAL_OFFSET\nvec3 offset=shadow_normal_offset_model(v_normal);shadow_pos+=offset*shadow_normal_offset_multiplier0();\n#endif\nv_pos_light_view_0=u_light_matrix_0*vec4(shadow_pos,1.0);v_pos_light_view_1=u_light_matrix_1*vec4(shadow_pos,1.0);\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(v_pos);\n#endif\ngl_Position=mix(u_matrix*vec4(v_pos,1),AWAY,hidden);gl_Position.z-=depth_offset*gl_Position.w;}"),
				buildingBloom: ss("in vec4 v_color_emissive;\n#pragma mapbox: define-attribute highp vec4 bloom_attenuation\n#pragma mapbox: initialize-attribute highp vec4 bloom_attenuation\nfloat saturate(float val) {return clamp(val,0.0,1.0);}void main() {float emission=v_color_emissive.a;float opacity=1.0;\n#ifdef HAS_ATTRIBUTE_a_bloom_attenuation\nfloat distance=length(vec2(1.3*max(0.0,abs(bloom_attenuation.x)-bloom_attenuation.z),bloom_attenuation.y));distance+= mix(0.5,0.0,clamp(emission-1.0,0.0,1.0));opacity*=saturate(1.0-distance*distance);\n#endif\n#ifdef RENDER_CUTOFF\nopacity*=v_cutoff_opacity;\n#endif\nglFragColor=vec4(v_color_emissive.rgb,1.0)*opacity;}", "in vec3 a_pos_3f;\n#pragma mapbox: define-attribute-vertex-shader-only highp vec2 part_color_emissive\n#pragma mapbox: define-attribute highp vec4 bloom_attenuation\nout vec4 v_color_emissive;uniform mat4 u_matrix;vec3 sRGBToLinear(vec3 srgbIn) {return pow(srgbIn,vec3(2.2));}void main() {\n#pragma mapbox: initialize-attribute-custom highp vec2 part_color_emissive\n#pragma mapbox: initialize-attribute highp vec4 bloom_attenuation\n#ifdef HAS_ATTRIBUTE_a_part_color_emissive\nvec4 color_emissive=decode_color(part_color_emissive);float part_emissive=color_emissive.a*5.0;v_color_emissive=vec4(sRGBToLinear(color_emissive.rgb),part_emissive);\n#else\nv_color_emissive=vec4(1.0);\n#endif\ngl_Position=u_matrix*vec4(a_pos_3f,1.0);\n#ifdef RENDER_CUTOFF\nv_cutoff_opacity=cutoff_opacity(u_cutoff_params,gl_Position.z);\n#endif\n}"),
				buildingDepth: ss("in highp float v_depth;void main() {\n#ifndef DEPTH_TEXTURE\nglFragColor=pack_depth(v_depth);\n#endif\n}", "in vec3 a_pos_3f;uniform mat4 u_matrix;out highp float v_depth;void main() {gl_Position=u_matrix*vec4(a_pos_3f,1.0);v_depth=gl_Position.z/gl_Position.w;}"),
				circle: ss("#include \"_prelude_fog.fragment.glsl\"\n#include \"_prelude_lighting.glsl\"\nin vec3 v_data;in float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nuniform float u_emissive_strength;void main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=v_data.xy;float blur_positive=blur < 0.0 ? 0.0 : 1.0;lowp float antialiasblur=v_data.z;float extrude_length=length(extrude)+antialiasblur*(1.0-blur_positive);float antialiased_blur=-max(abs(blur),antialiasblur);float antialiase_blur_opacity=smoothstep(0.0,antialiasblur,extrude_length-1.0);float opacity_t=blur_positive==1.0 ? \nsmoothstep(0.0,-antialiased_blur,1.0-extrude_length) : \nsmoothstep(antialiased_blur,0.0,extrude_length-1.0)-antialiase_blur_opacity;float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(\nantialiased_blur,0.0,extrude_length-radius/(radius+stroke_width)\n);vec4 out_color=mix(color*opacity,stroke_color*stroke_opacity,color_t);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#endif\n#ifdef FOG\nout_color=fog_apply_premultiplied(out_color,v_fog_pos);\n#endif\nglFragColor=out_color*(v_visibility*opacity_t);\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\n}", "#include \"_prelude_fog.vertex.glsl\"\n#include \"_prelude_terrain.vertex.glsl\"\n#define NUM_VISIBILITY_RINGS 2\n#define INV_SQRT2 0.70710678\n#define ELEVATION_BIAS 0.0001\n#define NUM_SAMPLES_PER_RING 16\nuniform mat4 u_matrix;uniform mat2 u_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;in vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nin vec3 a_pos_3;in vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;\n#endif\n#ifdef ELEVATED_ROADS\nin float a_circle_z_offset;\n#endif\nout vec3 v_data;out float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvec2 calc_offset(vec2 extrusion,float radius,float stroke_width, float view_scale) {return extrusion*(radius+stroke_width)*u_extrude_scale*view_scale;}float cantilevered_elevation(vec2 pos,float radius,float stroke_width,float view_scale) {vec2 c1=pos+calc_offset(vec2(-1,-1),radius,stroke_width,view_scale);vec2 c2=pos+calc_offset(vec2(1,-1),radius,stroke_width,view_scale);vec2 c3=pos+calc_offset(vec2(1,1),radius,stroke_width,view_scale);vec2 c4=pos+calc_offset(vec2(-1,1),radius,stroke_width,view_scale);float h1=elevation(c1)+ELEVATION_BIAS;float h2=elevation(c2)+ELEVATION_BIAS;float h3=elevation(c3)+ELEVATION_BIAS;float h4=elevation(c4)+ELEVATION_BIAS;return max(h4,max(h3,max(h1,h2)));}float circle_elevation(vec2 pos) {\n#if defined(TERRAIN)\nreturn elevation(pos)+ELEVATION_BIAS;\n#else\nreturn 0.0;\n#endif\n}vec4 project_vertex(vec2 extrusion,vec4 world_center,vec4 projected_center,float radius,float stroke_width, float view_scale,mat3 surface_vectors) {vec2 sample_offset=calc_offset(extrusion,radius,stroke_width,view_scale);\n#ifdef PITCH_WITH_MAP\n#ifdef PROJECTION_GLOBE_VIEW\nreturn u_matrix*( world_center+vec4(sample_offset.x*surface_vectors[0]+sample_offset.y*surface_vectors[1],0) );\n#else\nreturn u_matrix*( world_center+vec4(sample_offset,0,0) );\n#endif\n#else\nreturn projected_center+vec4(sample_offset,0,0);\n#endif\n}float get_sample_step() {\n#ifdef PITCH_WITH_MAP\nreturn 2.0*PI/float(NUM_SAMPLES_PER_RING);\n#else\nreturn PI/float(NUM_SAMPLES_PER_RING);\n#endif\n}void main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=vec2(mod(a_pos,2.0)*2.0-1.0);vec2 circle_center=floor(a_pos*0.5);vec4 world_center;mat3 surface_vectors;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 pos_normal_3=a_pos_normal_3/16384.0;surface_vectors=globe_mercator_surface_vectors(pos_normal_3,u_up_dir,u_zoom_transition);vec3 surface_extrusion=extrude.x*surface_vectors[0]+extrude.y*surface_vectors[1];vec3 globe_elevation=elevationVector(circle_center)*circle_elevation(circle_center);vec3 globe_pos=a_pos_3+surface_extrusion+globe_elevation;vec3 mercator_elevation=u_up_dir*u_tile_up_scale*circle_elevation(circle_center);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,circle_center,u_tile_id,u_merc_center)+surface_extrusion+mercator_elevation;vec3 pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);world_center=vec4(pos,1);\n#else \nsurface_vectors=mat3(1.0);float height=circle_elevation(circle_center);world_center=vec4(circle_center,height,1);\n#endif\n#ifdef ELEVATED_ROADS\nworld_center.z+=a_circle_z_offset+ELEVATION_BIAS;\n#endif\nvec4 projected_center=u_matrix*world_center;float view_scale=0.0;\n#ifdef PITCH_WITH_MAP\n#ifdef SCALE_WITH_MAP\nview_scale=1.0;\n#else\nview_scale=projected_center.w/u_camera_to_center_distance;\n#endif\n#else\n#ifdef SCALE_WITH_MAP\nview_scale=u_camera_to_center_distance;\n#else\nview_scale=projected_center.w;\n#endif\n#endif\ngl_Position=project_vertex(extrude,world_center,projected_center,radius,stroke_width,view_scale,surface_vectors);float visibility=0.0;\n#ifdef TERRAIN\nfloat step=get_sample_step();vec4 occlusion_world_center;vec4 occlusion_projected_center;\n#ifdef PITCH_WITH_MAP\nfloat cantilevered_height=cantilevered_elevation(circle_center,radius,stroke_width,view_scale);occlusion_world_center=vec4(circle_center,cantilevered_height,1);occlusion_projected_center=u_matrix*occlusion_world_center;\n#else\nocclusion_world_center=world_center;occlusion_projected_center=projected_center;\n#endif\nfor(int ring=0; ring < NUM_VISIBILITY_RINGS; ring++) {float scale=(float(ring)+1.0)/float(NUM_VISIBILITY_RINGS);for(int i=0; i < NUM_SAMPLES_PER_RING; i++) {vec2 extrusion=vec2(cos(step*float(i)),-sin(step*float(i)))*scale;vec4 frag_pos=project_vertex(extrusion,occlusion_world_center,occlusion_projected_center,radius,stroke_width,view_scale,surface_vectors);visibility+=float(!isOccluded(frag_pos));}}visibility/=float(NUM_VISIBILITY_RINGS)*float(NUM_SAMPLES_PER_RING);\n#else\nvisibility=1.0;\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nvisibility=1.0;\n#endif\nv_visibility=visibility;lowp float antialiasblur=1.0/u_device_pixel_ratio/(radius+stroke_width);v_data=vec3(extrude.x,extrude.y,antialiasblur);\n#ifdef FOG\nv_fog_pos=fog_position(world_center.xyz);\n#endif\n}"),
				clippingMask: ss("void main() {glFragColor=vec4(1.0);}", "in vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"),
				heatmap: ss("#include \"_prelude_fog.fragment.glsl\"\nuniform highp float u_intensity;in vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#define GAUSS_COEF 0.3989422804014327\nvoid main() {\n#pragma mapbox: initialize highp float weight\nfloat d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);glFragColor=vec4(val,1.0,1.0,1.0);\n#ifdef FOG\nif (u_is_globe==0) {glFragColor.r*=pow(1.0-fog_opacity(v_fog_pos),2.0);}\n#endif\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}", "#include \"_prelude_terrain.vertex.glsl\"\n#include \"_prelude_fog.vertex.glsl\"\nuniform mat4 u_matrix;uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;in vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nin vec3 a_pos_3;in vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;\n#endif\nout vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#pragma mapbox: define mediump float radius\nconst highp float ZERO=1.0/255.0/16.0;\n#define GAUSS_COEF 0.3989422804014327\nvoid main() {\n#pragma mapbox: initialize highp float weight\n#pragma mapbox: initialize mediump float radius\nvec2 unscaled_extrude=vec2(mod(a_pos,2.0)*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec2 tilePos=floor(a_pos*0.5);vec3 pos;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 pos_normal_3=a_pos_normal_3/16384.0;mat3 surface_vectors=globe_mercator_surface_vectors(pos_normal_3,u_up_dir,u_zoom_transition);vec3 surface_extrusion=extrude.x*surface_vectors[0]+extrude.y*surface_vectors[1];vec3 globe_elevation=elevationVector(tilePos)*elevation(tilePos);vec3 globe_pos=a_pos_3+surface_extrusion+globe_elevation;vec3 mercator_elevation=u_up_dir*u_tile_up_scale*elevation(tilePos);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,tilePos,u_tile_id,u_merc_center)+surface_extrusion+mercator_elevation;pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\n#else\npos=vec3(tilePos+extrude,elevation(tilePos));\n#endif\ngl_Position=u_matrix*vec4(pos,1);\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}"),
				heatmapTexture: ss("uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;in vec2 v_pos;void main() {float t=texture(u_image,v_pos).r;vec4 color=texture(u_color_ramp,vec2(t,0.5));glFragColor=color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(0.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}", "in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=vec4(a_pos,0,1);v_pos=a_pos*0.5+0.5;}"),
				collisionBox: ss("in float v_placed;in float v_notUsed;void main() {vec4 red =vec4(1.0,0.0,0.0,1.0);vec4 blue=vec4(0.0,0.0,1.0,0.5);glFragColor =mix(red,blue,step(0.5,v_placed))*0.5;glFragColor*=mix(1.0,0.1,step(0.5,v_notUsed));}", "#include \"_prelude_terrain.vertex.glsl\"\nin vec3 a_pos;in vec2 a_anchor_pos;in vec2 a_extrude;in vec2 a_placed;in vec2 a_shift;in vec2 a_elevation_from_sea;in float a_size_scale;in vec2 a_padding;in float a_auto_z_offset;uniform mat4 u_matrix;uniform vec2 u_extrude_scale;uniform float u_camera_to_center_distance;\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform float u_zoom_transition;\n#endif\nout float v_placed;out float v_notUsed;void main() {float feature_elevation=a_elevation_from_sea.x+a_auto_z_offset;float terrain_elevation=(a_elevation_from_sea.y==1.0 ? 0.0 : elevation(a_anchor_pos));vec3 proj_pos=a_pos+elevationVector(a_anchor_pos)*(feature_elevation+terrain_elevation);\n#ifdef PROJECTION_GLOBE_VIEW\n#ifndef PROJECTED_POS_ON_VIEWPORT\nvec3 globe_pos=proj_pos;vec3 mercator_pos=mercator_tile_position(u_inv_rot_matrix,a_anchor_pos,u_tile_id,u_merc_center);proj_pos=mix_globe_mercator(globe_pos,mercator_pos,u_zoom_transition);\n#endif\n#endif\nvec4 projectedPoint=u_matrix*vec4(proj_pos,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float collision_perspective_ratio=clamp(\n0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,1.5);gl_Position=projectedPoint;gl_Position.xy+=(a_extrude*a_size_scale+a_shift+a_padding)*u_extrude_scale*gl_Position.w*collision_perspective_ratio;v_placed=a_placed.x;v_notUsed=a_placed.y;}"),
				collisionCircle: ss("in float v_radius;in vec2 v_extrude;in float v_perspective_ratio;in float v_collision;void main() {float alpha=0.5*min(v_perspective_ratio,1.0);float stroke_radius=0.9*max(v_perspective_ratio,1.0);float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);glFragColor=color*alpha*opacity_t;}", "in vec2 a_pos_2f;in float a_radius;in vec2 a_flags;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform vec2 u_viewport_size;uniform float u_camera_to_center_distance;out float v_radius;out vec2 v_extrude;out float v_perspective_ratio;out float v_collision;vec3 toTilePosition(vec2 screenPos) {vec4 rayStart=u_inv_matrix*vec4(screenPos,-1.0,1.0);vec4 rayEnd  =u_inv_matrix*vec4(screenPos, 1.0,1.0);rayStart.xyz/=rayStart.w;rayEnd.xyz  /=rayEnd.w;highp float t=(0.0-rayStart.z)/(rayEnd.z-rayStart.z);return mix(rayStart.xyz,rayEnd.xyz,t);}void main() {vec2 quadCenterPos=a_pos_2f;float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(\nmix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;vec3 tilePos=toTilePosition(quadCenterPos);vec4 clipPos=u_matrix*vec4(tilePos,1.0);highp float camera_to_anchor_distance=clipPos.w;highp float collision_perspective_ratio=clamp(\n0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_perspective_ratio=collision_perspective_ratio;v_collision=collision;gl_Position=vec4(clipPos.xyz/clipPos.w,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"),
				debug: ss("uniform highp vec4 u_color;uniform sampler2D u_overlay;in vec2 v_uv;void main() {vec4 overlay_color=texture(u_overlay,v_uv);glFragColor=mix(u_color,overlay_color,overlay_color.a);}", "#include \"_prelude_terrain.vertex.glsl\"\nin vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nin vec3 a_pos_3;\n#endif\nout vec2 v_uv;uniform mat4 u_matrix;uniform float u_overlay_scale;void main() {float h=elevation(a_pos);v_uv=a_pos/8192.0;\n#ifdef PROJECTION_GLOBE_VIEW\ngl_Position=u_matrix*vec4(a_pos_3+elevationVector(a_pos)*h,1);\n#else\ngl_Position=u_matrix*vec4(a_pos*u_overlay_scale,h,1);\n#endif\n}"),
				elevatedStructuresDepth: ss("void main() {\n#ifndef DEPTH_TEXTURE\nglFragColor=vec4(0.);\n#endif\n}", "in vec2 a_pos;in float a_height;uniform mat4 u_matrix;uniform float u_depth_bias;void main() {gl_Position=u_matrix*vec4(a_pos,a_height,1);gl_Position.z=gl_Position.z+u_depth_bias;}"),
				elevatedStructuresDepthReconstruct: ss("#ifdef DEPTH_RECONSTRUCTION\nin float v_height;\n#endif\nvoid main() {\n#ifdef DEPTH_RECONSTRUCTION\nif (v_height >=0.0)\ndiscard;\n#else\n#ifdef FEATURE_CUTOUT\napply_feature_cutout(vec4(0.0,0.0,0.0,1.0),gl_FragCoord);\n#endif\n#endif\nglFragColor=vec4(1.0,0.0,0.0,1.0);}", "in vec2 a_pos;in float a_height;uniform mat4 u_matrix;uniform vec3 u_camera_pos;uniform highp float u_depth_bias;uniform lowp float u_height_scale;uniform lowp float u_reset_depth;\n#ifdef DEPTH_RECONSTRUCTION\nout float v_height;\n#endif\nvoid main() {vec3 vpos=vec3(a_pos,a_height*u_height_scale);\n#ifdef DEPTH_RECONSTRUCTION\nif (u_camera_pos.z > vpos.z) {vpos-=(u_camera_pos-vpos)*(vpos.z/(u_camera_pos.z-vpos.z));}v_height=a_height;\n#endif\ngl_Position=u_matrix*vec4(vpos,1);gl_Position.z=u_reset_depth==1.0 ? gl_Position.w : gl_Position.z+u_depth_bias;}"),
				elevatedStructures: ss("#include \"_prelude_fog.fragment.glsl\"\n#include \"_prelude_lighting.glsl\"\n#include \"_prelude_shadow.fragment.glsl\"\nin vec3 v_normal;in float v_height;\n#ifdef RENDER_SHADOWS\nin highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in float v_depth;\n#endif\nvec3 linearTosRGB(vec3 color) {return pow(color,vec3(1./2.2));}vec3 sRGBToLinear(vec3 srgbIn) {return pow(srgbIn,vec3(2.2));}vec3 compute_view_dependent_emissive_color(float ndotl,float emissive_strength,vec3 color)\n{color=sRGBToLinear(color);color=color*(ndotl+(1.0-min(ndotl*57.29,1.0))*emissive_strength);color=linearTosRGB(color.rgb);return color;}uniform float u_emissive_strength;\n#pragma mapbox: define highp vec4 structure_color\nvoid main() {\n#pragma mapbox: initialize highp vec4 structure_color\nvec3 color=structure_color.xyz;\n#ifdef LIGHTING_3D_MODE\nvec3 normal=normalize(v_normal);vec3 transformed_normal=vec3(-normal.xy,normal.z);float ndotl=calculate_NdotL(transformed_normal);float emissive_strength=u_emissive_strength;emissive_strength=0.0;vec3 emissive_color=compute_view_dependent_emissive_color(ndotl,emissive_strength,color.xyz);\n#ifdef RENDER_SHADOWS\nfloat shadowed_lighting_factor=shadowed_light_factor_normal(transformed_normal,v_pos_light_view_0,v_pos_light_view_1,v_depth);color.rgb=apply_lighting(color.rgb,transformed_normal,shadowed_lighting_factor);\n#else\ncolor=apply_lighting(color,transformed_normal);\n#endif\ncolor=mix(color,emissive_color,emissive_strength);if (v_height < 0.0) {float penetration=max(v_height+7.5,0.0);float occlusion=1.0-1.0/PI*acos(1.0-penetration/4.0);color=color*(1.0-pow(occlusion,2.0)*0.3);}\n#endif\n#ifdef FOG\ncolor=fog_apply(color,v_fog_pos);\n#endif\nvec4 out_color=vec4(color,1.0);\n#ifdef INDICATOR_CUTOUT\nout_color=applyCutout(out_color,v_height);\n#endif\n#ifdef FEATURE_CUTOUT\nout_color=apply_feature_cutout(out_color,gl_FragCoord);\n#endif\nglFragColor=out_color;HANDLE_WIREFRAME_DEBUG;}", "#include \"_prelude_fog.vertex.glsl\"\n#include \"_prelude_shadow.vertex.glsl\"\nin vec2 a_pos;in float a_height;in vec3 a_pos_normal_3;uniform mat4 u_matrix;out vec3 v_normal;out float v_height;\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out float v_depth;\n#endif\n#pragma mapbox: define highp vec4 structure_color\nvoid main() {\n#pragma mapbox: initialize highp vec4 structure_color\nv_normal=a_pos_normal_3/16384.0;v_height=a_height;vec3 pos=vec3(a_pos,a_height);gl_Position=u_matrix*vec4(pos,1);\n#ifdef RENDER_SHADOWS\nvec3 shd_pos0=pos;vec3 shd_pos1=pos;\n#ifdef NORMAL_OFFSET\nvec3 offset=shadow_normal_offset(vec3(-v_normal.xy,v_normal.z));shd_pos0+=offset*shadow_normal_offset_multiplier0();shd_pos1+=offset*shadow_normal_offset_multiplier1();\n#endif\nv_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"),
				fill: ss("#include \"_prelude_fog.fragment.glsl\"\n#include \"_prelude_lighting.glsl\"\n#include \"_prelude_shadow.fragment.glsl\"\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nuniform float u_emissive_strength;\n#ifdef RENDER_SHADOWS\nuniform vec3 u_ground_shadow_factor;in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in highp float v_depth;\n#endif\n#ifdef ELEVATED_ROADS\nin highp float v_road_z_offset;\n#endif\n#ifdef INDICATOR_CUTOUT\nin highp float v_z_offset;\n#endif\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\nvec4 out_color=color;\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#ifdef RENDER_SHADOWS\nfloat light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);out_color.rgb*=mix(u_ground_shadow_factor,vec3(1.0),light);\n#endif\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\nout_color*=opacity;\n#ifdef INDICATOR_CUTOUT\nif (v_z_offset >=0.0) {out_color=applyCutout(out_color,v_z_offset);}\n#endif\n#ifdef FEATURE_CUTOUT\nout_color=apply_feature_cutout(out_color,gl_FragCoord);\n#endif\nglFragColor=out_color;\n#ifdef USE_MRT1\nout_Target1=vec4(u_emissive_strength*glFragColor.a,0.0,0.0,glFragColor.a);\n#endif\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}", "#include \"_prelude_fog.vertex.glsl\"\n#include \"_prelude_shadow.vertex.glsl\"\nin vec2 a_pos;\n#ifdef ELEVATED_ROADS\nin float a_road_z_offset;out highp float v_road_z_offset;\n#endif\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out highp float v_depth;\n#endif\n#ifdef INDICATOR_CUTOUT\nout highp float v_z_offset;\n#endif\nuniform mat4 u_matrix;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp float z_offset\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp float z_offset\n#ifdef ELEVATED_ROADS\nz_offset+=a_road_z_offset;v_road_z_offset=z_offset;\n#endif\nfloat hidden=float(opacity==0.0);gl_Position=mix(u_matrix*vec4(a_pos,z_offset,1),AWAY,hidden);\n#ifdef RENDER_SHADOWS\nvec3 shd_pos0=vec3(a_pos,z_offset);vec3 shd_pos1=vec3(a_pos,z_offset);\n#ifdef NORMAL_OFFSET\nvec3 offset=shadow_normal_offset(vec3(0.0,0.0,1.0));shd_pos0+=offset*shadow_normal_offset_multiplier0();shd_pos1+=offset*shadow_normal_offset_multiplier1();\n#endif\nv_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n#ifdef INDICATOR_CUTOUT\nv_z_offset=z_offset;\n#endif\n}"),
				fillOutline: ss("#include \"_prelude_fog.fragment.glsl\"\n#include \"_prelude_lighting.glsl\"\n#include \"_prelude_shadow.fragment.glsl\"\nin highp vec2 v_pos;uniform float u_emissive_strength;\n#ifdef RENDER_SHADOWS\nuniform vec3 u_ground_shadow_factor;in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in highp float v_depth;\n#endif\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 out_color=outline_color;\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#ifdef RENDER_SHADOWS\nfloat light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);out_color.rgb*=mix(u_ground_shadow_factor,vec3(1.0),light);\n#endif\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\n#ifdef FEATURE_CUTOUT\nout_color=apply_feature_cutout(out_color,gl_FragCoord);\n#endif\nglFragColor=out_color*(alpha*opacity);\n#ifdef USE_MRT1\nout_Target1=vec4(u_emissive_strength*glFragColor.a,0.0,0.0,glFragColor.a);\n#endif\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}", "#include \"_prelude_fog.vertex.glsl\"\n#include \"_prelude_shadow.vertex.glsl\"\nin vec2 a_pos;\n#ifdef ELEVATED_ROADS\nin float a_road_z_offset;\n#endif\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out highp float v_depth;\n#endif\nuniform mat4 u_matrix;uniform vec2 u_world;out highp vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp float z_offset\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp float z_offset\n#ifdef ELEVATED_ROADS\nz_offset+=a_road_z_offset;\n#endif\nfloat hidden=float(opacity==0.0);gl_Position=mix(u_matrix*vec4(a_pos,z_offset,1),AWAY,hidden);\n#ifdef FLIP_Y\nv_pos=(vec2(gl_Position.x,-gl_Position.y)/gl_Position.w+1.0)/2.0*u_world;\n#else\nv_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\n#endif\n#ifdef RENDER_SHADOWS\nvec3 shd_pos0=vec3(a_pos,z_offset);vec3 shd_pos1=vec3(a_pos,z_offset);\n#ifdef NORMAL_OFFSET\nvec3 offset=shadow_normal_offset(vec3(0.0,0.0,1.0));shd_pos0+=offset*shadow_normal_offset_multiplier0();shd_pos1+=offset*shadow_normal_offset_multiplier1();\n#endif\nv_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"),
				fillOutlinePattern: ss("#include \"_prelude_fog.fragment.glsl\"\n#include \"_prelude_lighting.glsl\"\n#include \"_prelude_shadow.fragment.glsl\"\nuniform vec2 u_texsize;uniform sampler2D u_image;\n#ifdef FILL_PATTERN_TRANSITION\nuniform float u_pattern_transition;\n#endif\nuniform float u_emissive_strength;\n#ifdef APPLY_LUT_ON_GPU\nuniform highp sampler3D u_lutTexture;\n#endif\n#ifdef RENDER_SHADOWS\nuniform vec3 u_ground_shadow_factor;in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in highp float v_depth;\n#endif\nin highp vec2 v_pos;in highp vec2 v_pos_world;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\n#ifdef FILL_PATTERN_TRANSITION\n#pragma mapbox: define mediump vec4 pattern_b\n#endif\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\n#ifdef FILL_PATTERN_TRANSITION\n#pragma mapbox: initialize mediump vec4 pattern_b\n#endif\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;highp vec2 imagecoord=mod(v_pos,1.0);highp vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);highp vec2 lod_pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,v_pos);float dist=length(v_pos_world-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 out_color=textureLodCustom(u_image,pos,lod_pos);\n#ifdef APPLY_LUT_ON_GPU\nout_color=applyLUT(u_lutTexture,out_color);\n#endif\n#ifdef FILL_PATTERN_TRANSITION\nvec2 pattern_b_tl=pattern_b.xy;vec2 pattern_b_br=pattern_b.zw;highp vec2 pos_b=mix(pattern_b_tl/u_texsize,pattern_b_br/u_texsize,imagecoord);vec4 color_b=textureLodCustom(u_image,pos_b,lod_pos);out_color=out_color*(1.0-u_pattern_transition)+color_b*u_pattern_transition;\n#endif\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#ifdef RENDER_SHADOWS\nfloat light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);out_color.rgb*=mix(u_ground_shadow_factor,vec3(1.0),light);\n#endif\n#endif\n#ifdef FEATURE_CUTOUT\nout_color=apply_feature_cutout(out_color,gl_FragCoord);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\nglFragColor=out_color*(alpha*opacity);\n#ifdef USE_MRT1\nout_Target1=vec4(u_emissive_strength*glFragColor.a,0.0,0.0,glFragColor.a);\n#endif\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}", "#include \"_prelude_fog.vertex.glsl\"\n#include \"_prelude_shadow.vertex.glsl\"\nuniform mat4 u_matrix;uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;in vec2 a_pos;\n#ifdef ELEVATED_ROADS\nin float a_road_z_offset;\n#endif\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out highp float v_depth;\n#endif\nout highp vec2 v_pos;out highp vec2 v_pos_world;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\n#ifdef FILL_PATTERN_TRANSITION\n#pragma mapbox: define mediump vec4 pattern_b\n#endif\n#pragma mapbox: define lowp float pixel_ratio\n#pragma mapbox: define highp float z_offset\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\n#ifdef FILL_PATTERN_TRANSITION\n#pragma mapbox: initialize mediump vec4 pattern_b\n#endif\n#pragma mapbox: initialize lowp float pixel_ratio\n#pragma mapbox: initialize highp float z_offset\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;\n#ifdef ELEVATED_ROADS\nz_offset+=a_road_z_offset;\n#endif\nfloat hidden=float(opacity==0.0);gl_Position=mix(u_matrix*vec4(a_pos,z_offset,1),AWAY,hidden);vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,a_pos);\n#ifdef FLIP_Y\nv_pos_world=(vec2(gl_Position.x,-gl_Position.y)/gl_Position.w+1.0)/2.0*u_world;\n#else\nv_pos_world=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\n#endif\n#ifdef RENDER_SHADOWS\nvec3 shd_pos0=vec3(a_pos,z_offset);vec3 shd_pos1=vec3(a_pos,z_offset);\n#ifdef NORMAL_OFFSET\nvec3 offset=shadow_normal_offset(vec3(0.0,0.0,1.0));shd_pos0+=offset*shadow_normal_offset_multiplier0();shd_pos1+=offset*shadow_normal_offset_multiplier1();\n#endif\nv_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"),
				fillPattern: ss("#include \"_prelude_fog.fragment.glsl\"\n#include \"_prelude_lighting.glsl\"\n#include \"_prelude_shadow.fragment.glsl\"\nuniform vec2 u_texsize;uniform sampler2D u_image;\n#ifdef FILL_PATTERN_TRANSITION\nuniform float u_pattern_transition;\n#endif\nin highp vec2 v_pos;uniform float u_emissive_strength;\n#ifdef RENDER_SHADOWS\nuniform vec3 u_ground_shadow_factor;in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in highp float v_depth;\n#endif\n#ifdef ELEVATED_ROADS\nin highp float v_road_z_offset;\n#endif\n#ifdef APPLY_LUT_ON_GPU\nuniform highp sampler3D u_lutTexture;\n#endif\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\n#ifdef FILL_PATTERN_TRANSITION\n#pragma mapbox: define mediump vec4 pattern_b\n#endif\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\n#ifdef FILL_PATTERN_TRANSITION\n#pragma mapbox: initialize mediump vec4 pattern_b\n#endif\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;highp vec2 imagecoord=mod(v_pos,1.0);highp vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);highp vec2 lod_pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,v_pos);vec4 out_color=textureLodCustom(u_image,pos,lod_pos);\n#ifdef APPLY_LUT_ON_GPU\nout_color=applyLUT(u_lutTexture,out_color);\n#endif\n#ifdef FILL_PATTERN_TRANSITION\nvec2 pattern_b_tl=pattern_b.xy;vec2 pattern_b_br=pattern_b.zw;highp vec2 pos_b=mix(pattern_b_tl/u_texsize,pattern_b_br/u_texsize,imagecoord);vec4 color_b=textureLodCustom(u_image,pos_b,lod_pos);out_color=out_color*(1.0-u_pattern_transition)+color_b*u_pattern_transition;\n#endif\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#ifdef RENDER_SHADOWS\nfloat light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);\n#ifdef ELEVATED_ROADS\nout_color.rgb*=mix(v_road_z_offset !=0.0 ? u_ground_shadow_factor : vec3(1.0),vec3(1.0),light);\n#else\nout_color.rgb*=mix(u_ground_shadow_factor,vec3(1.0),light);\n#endif\n#endif\n#endif\n#ifdef FEATURE_CUTOUT\nout_color=apply_feature_cutout(out_color,gl_FragCoord);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\nglFragColor=out_color*opacity;\n#ifdef USE_MRT1\nout_Target1=vec4(u_emissive_strength*glFragColor.a,0.0,0.0,glFragColor.a);\n#endif\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}", "#include \"_prelude_fog.vertex.glsl\"\n#include \"_prelude_shadow.vertex.glsl\"\nuniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;in vec2 a_pos;\n#ifdef ELEVATED_ROADS\nin float a_road_z_offset;out highp float v_road_z_offset;\n#endif\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out highp float v_depth;\n#endif\nout highp vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\n#ifdef FILL_PATTERN_TRANSITION\n#pragma mapbox: define mediump vec4 pattern_b\n#endif\n#pragma mapbox: define lowp float pixel_ratio\n#pragma mapbox: define highp float z_offset\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\n#pragma mapbox: initialize highp float z_offset\n#ifdef FILL_PATTERN_TRANSITION\n#pragma mapbox: initialize mediump vec4 pattern_b\n#endif\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;\n#ifdef ELEVATED_ROADS\nz_offset+=a_road_z_offset;v_road_z_offset=z_offset;\n#endif\nfloat hidden=float(opacity==0.0);gl_Position=mix(u_matrix*vec4(a_pos,z_offset,1),AWAY,hidden);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,a_pos);\n#ifdef RENDER_SHADOWS\nvec3 shd_pos0=vec3(a_pos,z_offset);vec3 shd_pos1=vec3(a_pos,z_offset);\n#ifdef NORMAL_OFFSET\nvec3 offset=shadow_normal_offset(vec3(0.0,0.0,1.0));shd_pos0+=offset*shadow_normal_offset_multiplier0();shd_pos1+=offset*shadow_normal_offset_multiplier1();\n#endif\nv_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"),
				fillExtrusion: ss("#include \"_prelude_fog.fragment.glsl\"\n#include \"_prelude_shadow.fragment.glsl\"\n#include \"_prelude_lighting.glsl\"\nin vec4 v_color;in vec4 v_flat;\n#ifdef RENDER_SHADOWS\nin highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;\n#endif\nuniform lowp float u_opacity;\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;in vec2 v_ao;\n#endif\n#if defined(ZERO_ROOF_RADIUS) && !defined(LIGHTING_3D_MODE)\nin vec4 v_roof_color;\n#endif\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS) || defined(LIGHTING_3D_MODE)\nin highp vec3 v_normal;\n#endif\nuniform vec3 u_flood_light_color;uniform highp float u_vertical_scale;uniform float u_flood_light_intensity;uniform vec3 u_ground_shadow_factor;\n#if defined(LIGHTING_3D_MODE) && defined(FLOOD_LIGHT)\nin float v_flood_radius;in float v_has_floodlight;\n#endif\nin float v_height;\n#pragma mapbox: define highp float emissive_strength\nvoid main() {\n#pragma mapbox: initialize highp float emissive_strength\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS) || defined(LIGHTING_3D_MODE)\nvec3 normal=normalize(v_normal);\n#endif\nfloat z;vec4 color=v_color;\n#ifdef ZERO_ROOF_RADIUS\nz=float(normal.z > 0.00001);\n#ifdef LIGHTING_3D_MODE\nnormal=mix(normal,vec3(0.0,0.0,1.0),z);\n#else\ncolor=mix(v_color,v_roof_color,z);\n#endif\n#endif\nfloat h=max(0.0,v_height);float ao_shade=1.0;\n#ifdef FAUX_AO\nfloat intensity=u_ao[0];float h_floors=h/(u_ao[1]*u_vertical_scale);float y_shade=1.0-0.9*intensity*min(v_ao.y,1.0);ao_shade=(1.0-0.08*intensity)*(y_shade+(1.0-y_shade)*(1.0-pow(1.0-min(h_floors/16.0,1.0),16.0)))+0.08*intensity*min(h_floors/160.0,1.0);float concave=v_ao.x*v_ao.x;\n#ifdef ZERO_ROOF_RADIUS\nconcave*=(1.0-z);\n#endif\nfloat x_shade=mix(1.0,mix(0.6,0.75,min(h_floors/30.0,1.0)),intensity)+0.1*intensity*min(h,1.0);ao_shade*=mix(1.0,x_shade*x_shade*x_shade,concave);\n#ifdef LIGHTING_3D_MODE\n#ifdef FLOOD_LIGHT\ncolor.rgb*=mix(ao_shade,1.0,v_has_floodlight);\n#else\ncolor.rgb*=ao_shade;\n#endif\n#else\ncolor.rgb*=ao_shade;\n#endif\n#endif\n#ifdef LIGHTING_3D_MODE\nfloat flood_radiance=0.0;\n#ifdef FLOOD_LIGHT\nflood_radiance=(1.0-min(h/v_flood_radius,1.0))*u_flood_light_intensity*v_has_floodlight;\n#endif\n#ifdef RENDER_SHADOWS\n#ifdef FLOOD_LIGHT\nfloat ndotl_unclamped=dot(normal,u_shadow_direction);float ndotl=max(0.0,ndotl_unclamped);float occlusion=ndotl_unclamped < 0.0 ? 1.0 : shadow_occlusion(ndotl,v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w);vec3 litColor=apply_lighting(color.rgb,normal,(1.0-u_shadow_intensity*occlusion)*ndotl);vec3 floodLitColor=compute_flood_lighting(u_flood_light_color*u_opacity,1.0-u_shadow_intensity,occlusion,u_ground_shadow_factor);color.rgb=mix(litColor,floodLitColor,flood_radiance);\n#else\nfloat shadowed_lighting_factor;\n#ifdef RENDER_CUTOFF\nshadowed_lighting_factor=shadowed_light_factor_normal_opacity(normal,v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w,v_cutoff_opacity);if (v_cutoff_opacity==0.0) {discard;}\n#else\nshadowed_lighting_factor=shadowed_light_factor_normal(normal,v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w);\n#endif\ncolor.rgb=apply_lighting(color.rgb,normal,shadowed_lighting_factor);\n#endif\n#else\ncolor.rgb=apply_lighting(color.rgb,normal);\n#ifdef FLOOD_LIGHT\ncolor.rgb=mix(color.rgb,u_flood_light_color*u_opacity,flood_radiance);\n#endif\n#endif\ncolor.rgb=mix(color.rgb,v_flat.rgb,emissive_strength);color*=u_opacity;\n#endif\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos,h));\n#endif\n#ifdef INDICATOR_CUTOUT\ncolor=applyCutout(color,h);\n#endif\n#ifdef FEATURE_CUTOUT\ncolor=apply_feature_cutout(color,gl_FragCoord);\n#endif\nglFragColor=color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}", "#include \"_prelude_fog.vertex.glsl\"\n#include \"_prelude_terrain.vertex.glsl\"\n#include \"_prelude_shadow.vertex.glsl\"\n#include \"_prelude_lighting.glsl\"\n#include \"_prelude_material_table.vertex.glsl\"\nuniform mat4 u_matrix;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform float u_edge_radius;uniform float u_width_scale;in vec4 a_pos_normal_ed;in vec2 a_centroid_pos;\n#ifdef RENDER_WALL_MODE\nin vec3 a_join_normal_inside;\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nin vec3 a_pos_3;in vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;uniform float u_height_lift;\n#endif\n#ifdef TERRAIN\nuniform int u_height_type;uniform int u_base_type;\n#endif\nuniform highp float u_vertical_scale;out vec4 v_color;out vec4 v_flat;\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;\n#endif\n#if defined(ZERO_ROOF_RADIUS) && !defined(LIGHTING_3D_MODE)\nout vec4 v_roof_color;\n#endif\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS) || defined(LIGHTING_3D_MODE)\nout highp vec3 v_normal;\n#endif\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;out vec2 v_ao;\n#endif\n#if defined(LIGHTING_3D_MODE) && defined(FLOOD_LIGHT)\nout float v_flood_radius;out float v_has_floodlight;\n#endif\nout float v_height;vec3 linearTosRGB(vec3 color) {return pow(color,vec3(1./2.2));}vec3 sRGBToLinear(vec3 srgbIn) {return pow(srgbIn,vec3(2.2));}\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define highp float flood_light_wall_radius\n#pragma mapbox: define highp float line_width\n#pragma mapbox: define highp float emissive_strength\nvoid main() {DECLARE_MATERIAL_TABLE_INFO\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize highp float flood_light_wall_radius\n#pragma mapbox: initialize highp float line_width\n#pragma mapbox: initialize highp float emissive_strength\nbase*=u_vertical_scale;height*=u_vertical_scale;vec4 pos_nx=floor(a_pos_normal_ed*0.5);vec4 top_up_ny_start=a_pos_normal_ed-2.0*pos_nx;vec3 top_up_ny=top_up_ny_start.xyz;float x_normal=pos_nx.z/8192.0;vec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS) || defined(LIGHTING_3D_MODE)\nv_normal=normal;\n#endif\nbase=max(0.0,base);float attr_height=height;height=max(0.0,top_up_ny.y==0.0 && top_up_ny.x==1.0 ? height-u_edge_radius : height);float t=top_up_ny.x;vec2 centroid_pos=vec2(0.0);\n#if defined(HAS_CENTROID) || defined(TERRAIN)\ncentroid_pos=a_centroid_pos;\n#endif\nfloat ele=0.0;float h=0.0;float c_ele=0.0;vec3 pos;\n#ifdef TERRAIN\nbool is_flat_height=centroid_pos.x !=0.0 && u_height_type==1;bool is_flat_base=centroid_pos.x !=0.0 && u_base_type==1;ele=elevation(pos_nx.xy);c_ele=is_flat_height || is_flat_base ? (centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos)) : ele;float h_height=is_flat_height ? max(c_ele+height,ele+base+2.0) : ele+height;float h_base=is_flat_base ? max(c_ele+base,ele+base) : ele+(base==0.0 ?-5.0 : base);h=t > 0.0 ? max(h_base,h_height) : h_base;pos=vec3(pos_nx.xy,h);\n#else\nh=t > 0.0 ? height : base;pos=vec3(pos_nx.xy,h);\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nfloat lift=float((t+base) > 0.0)*u_height_lift;h+=lift;vec3 globe_normal=normalize(mix(a_pos_normal_3/16384.0,u_up_dir,u_zoom_transition));vec3 globe_pos=a_pos_3+globe_normal*(u_tile_up_scale*h);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,pos.xy,u_tile_id,u_merc_center)+u_up_dir*u_tile_up_scale*pos.z;pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\n#endif\nfloat cutoff=1.0;vec3 scaled_pos=pos;\n#ifdef RENDER_CUTOFF\nvec3 centroid_random=vec3(centroid_pos.xy,centroid_pos.x+centroid_pos.y+1.0);vec3 ground_pos=centroid_pos.x==0.0 ? pos.xyz : (centroid_random/8.0);vec4 ground=u_matrix*vec4(ground_pos.xy,ele,1.0);\n#ifdef CLIP_ZERO_TO_ONE\ncutoff=cutoff_opacity(u_cutoff_params,ground.z*2.0-ground.w);\n#else\ncutoff=cutoff_opacity(u_cutoff_params,ground.z);\n#endif\nif (centroid_pos.y !=0.0 && centroid_pos.x !=0.0) {vec3 g=floor(ground_pos);vec3 mod_=centroid_random-g*8.0;float seed=min(1.0,0.1*(min(3.5,max(mod_.x+mod_.y,0.2*attr_height))*0.35+mod_.z));if (cutoff < 0.8-seed) {cutoff=0.0;}}float cutoff_scale=cutoff;v_cutoff_opacity=cutoff;scaled_pos.z=mix(c_ele,h,cutoff_scale);\n#endif\nfloat hidden=float((centroid_pos.x==0.0 && centroid_pos.y==1.0) || (cutoff==0.0 && centroid_pos.x !=0.0) || (color.a==0.0));\n#ifdef RENDER_WALL_MODE\nvec2 wall_offset=u_width_scale*line_width*(a_join_normal_inside.xy/EXTENT);scaled_pos.xy+=(1.0-a_join_normal_inside.z)*wall_offset*0.5;scaled_pos.xy-=a_join_normal_inside.z*wall_offset*0.5;\n#endif\ngl_Position=mix(u_matrix*vec4(scaled_pos,1),AWAY,hidden);h=h-ele;v_height=h;\n#ifdef RENDER_SHADOWS\nvec3 shd_pos0=pos;vec3 shd_pos1=pos;\n#ifdef NORMAL_OFFSET\nvec3 offset=shadow_normal_offset(normal);shd_pos0+=offset*shadow_normal_offset_multiplier0();shd_pos1+=offset*shadow_normal_offset_multiplier1();\n#endif\nv_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);\n#endif\nfloat NdotL=0.0;float colorvalue=0.0;\n#ifndef LIGHTING_3D_MODE\ncolorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;NdotL=clamp(dot(normal,u_lightpos),0.0,1.0);NdotL=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),NdotL);if (normal.y !=0.0) {float r=0.84;r=mix(0.7,0.98,1.0-u_lightintensity);NdotL*=(\n(1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),r,1.0)));}\n#endif\n#ifdef FAUX_AO\nfloat concave=pos_nx.w-floor(pos_nx.w*0.5)*2.0;float start=top_up_ny_start.w;float y_ground=1.0-clamp(t+base,0.0,1.0);float top_height=height;\n#ifdef TERRAIN\ntop_height=mix(max(c_ele+height,ele+base+2.0),ele+height,float(centroid_pos.x==0.0))-ele;y_ground+=y_ground*5.0/max(3.0,top_height);\n#endif\nv_ao=vec2(mix(concave,-concave,start),y_ground);NdotL*=(1.0+0.05*(1.0-top_up_ny.y)*u_ao[0]);\n#ifdef PROJECTION_GLOBE_VIEW\ntop_height+=u_height_lift;\n#endif\ngl_Position.z-=(0.0000006*(min(top_height,500.)+2.0*min(base,500.0)+60.0*concave+3.0*start))*gl_Position.w;\n#endif\n#ifdef LIGHTING_3D_MODE\n#ifdef FLOOD_LIGHT\nfloat is_wall=1.0-float(t > 0.0 && top_up_ny.y > 0.0);v_has_floodlight=float(flood_light_wall_radius > 0.0 && is_wall > 0.0);v_flood_radius=flood_light_wall_radius*u_vertical_scale;\n#endif\nv_color=vec4(color.rgb,1.0);float ndotl=calculate_NdotL(normal);v_flat.rgb=sRGBToLinear(color.rgb);v_flat.rgb=v_flat.rgb*(ndotl+(1.0-min(ndotl*57.29,1.0))*emissive_strength);v_flat=vec4(linearTosRGB(v_flat.rgb),1.0);\n#else\nv_color=vec4(0.0,0.0,0.0,1.0);v_color.rgb+=clamp(color.rgb*NdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_color*=u_opacity;\n#endif\n#if defined(ZERO_ROOF_RADIUS) && !defined(LIGHTING_3D_MODE)\nfloat roofNdotL=clamp(u_lightpos.z,0.0,1.0);roofNdotL=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),roofNdotL);v_roof_color=vec4(0.0,0.0,0.0,1.0);v_roof_color.rgb+=clamp(color.rgb*roofNdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_roof_color*=u_opacity;\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}"),
				fillExtrusionDepth: ss("in highp float v_depth;void main() {\n#ifndef DEPTH_TEXTURE\nglFragColor=pack_depth(v_depth);\n#endif\n}", "#include \"_prelude_terrain.vertex.glsl\"\n#include \"_prelude_material_table.vertex.glsl\"\nuniform mat4 u_matrix;uniform float u_edge_radius;uniform float u_width_scale;uniform float u_vertical_scale;\n#ifdef TERRAIN\nuniform int u_height_type;uniform int u_base_type;\n#endif\nin vec4 a_pos_normal_ed;in vec2 a_centroid_pos;\n#ifdef RENDER_WALL_MODE\nin vec3 a_join_normal_inside;\n#endif\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define highp float line_width\n#pragma mapbox: define highp vec4 color\nout highp float v_depth;void main() {DECLARE_MATERIAL_TABLE_INFO\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize highp float line_width\n#pragma mapbox: initialize highp vec4 color\nbase*=u_vertical_scale;height*=u_vertical_scale;vec3 pos_nx=floor(a_pos_normal_ed.xyz*0.5);mediump vec3 top_up_ny=a_pos_normal_ed.xyz-2.0*pos_nx;base=max(0.0,base);height=max(0.0,top_up_ny.y==0.0 && top_up_ny.x==1.0 ? height-u_edge_radius : height);float t=top_up_ny.x;vec2 centroid_pos=vec2(0.0);\n#if defined(HAS_CENTROID) || defined(TERRAIN)\ncentroid_pos=a_centroid_pos;\n#endif\nvec3 pos;\n#ifdef TERRAIN\nbool is_flat_height=centroid_pos.x !=0.0 && u_height_type==1;bool is_flat_base=centroid_pos.x !=0.0 && u_base_type==1;float ele=elevation(pos_nx.xy);float c_ele=is_flat_height || is_flat_base ? (centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos)) : ele;float h_height=is_flat_height ? max(c_ele+height,ele+base+2.0) : ele+height;float h_base=is_flat_base ? max(c_ele+base,ele+base) : ele+(base==0.0 ?-5.0 : base);float h=t > 0.0 ? max(h_base,h_height) : h_base;pos=vec3(pos_nx.xy,h);\n#else\npos=vec3(pos_nx.xy,t > 0.0 ? height : base);\n#endif\n#ifdef RENDER_WALL_MODE\nvec2 wall_offset=u_width_scale*line_width*(a_join_normal_inside.xy/EXTENT);pos.xy+=(1.0-a_join_normal_inside.z)*wall_offset*0.5;pos.xy-=a_join_normal_inside.z*wall_offset*0.5;\n#endif\nfloat hidden=float((centroid_pos.x==0.0 && centroid_pos.y==1.0) || (color.a==0.0));gl_Position=mix(u_matrix*vec4(pos,1),AWAY,hidden);v_depth=gl_Position.z/gl_Position.w;}"),
				fillExtrusionPattern: ss("#include \"_prelude_fog.fragment.glsl\"\n#include \"_prelude_lighting.glsl\"\nuniform vec2 u_texsize;uniform sampler2D u_image;\n#ifdef FILL_EXTRUSION_PATTERN_TRANSITION\nuniform float u_pattern_transition;\n#endif\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;in vec3 v_ao;\n#endif\n#ifdef LIGHTING_3D_MODE\nin vec3 v_normal;\n#endif\n#ifdef APPLY_LUT_ON_GPU\nuniform highp sampler3D u_lutTexture;\n#endif\nin highp vec2 v_pos;in vec4 v_lighting;uniform lowp float u_opacity;\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define mediump vec4 pattern\n#ifdef FILL_EXTRUSION_PATTERN_TRANSITION\n#pragma mapbox: define mediump vec4 pattern_b\n#endif\n#pragma mapbox: define highp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize mediump vec4 pattern\n#ifdef FILL_EXTRUSION_PATTERN_TRANSITION\n#pragma mapbox: initialize mediump vec4 pattern_b\n#endif\n#pragma mapbox: initialize highp float pixel_ratio\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;highp vec2 imagecoord=mod(v_pos,1.0);highp vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);highp vec2 lod_pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,v_pos);vec4 out_color=textureLodCustom(u_image,pos,lod_pos);\n#ifdef APPLY_LUT_ON_GPU\nout_color=applyLUT(u_lutTexture,out_color);\n#endif\n#ifdef FILL_EXTRUSION_PATTERN_TRANSITION\nvec2 pattern_b_tl=pattern_b.xy;vec2 pattern_b_br=pattern_b.zw;highp vec2 pos_b=mix(pattern_b_tl/u_texsize,pattern_b_br/u_texsize,imagecoord);vec4 color_b=textureLodCustom(u_image,pos_b,lod_pos);out_color=out_color*(1.0-u_pattern_transition)+color_b*u_pattern_transition;\n#endif\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color,normalize(v_normal))*u_opacity;\n#else\nout_color=out_color*v_lighting;\n#endif\n#ifdef FAUX_AO\nfloat intensity=u_ao[0];float h=max(0.0,v_ao.z);float h_floors=h/u_ao[1];float y_shade=1.0-0.9*intensity*min(v_ao.y,1.0);float shade=(1.0-0.08*intensity)*(y_shade+(1.0-y_shade)*(1.0-pow(1.0-min(h_floors/16.0,1.0),16.0)))+0.08*intensity*min(h_floors/160.0,1.0);float concave=v_ao.x*v_ao.x;float x_shade=mix(1.0,mix(0.6,0.75,min(h_floors/30.0,1.0)),intensity)+0.1*intensity*min(h,1.0);shade*=mix(1.0,x_shade*x_shade*x_shade,concave);out_color.rgb=out_color.rgb*shade;\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\n#ifdef INDICATOR_CUTOUT\nout_color=applyCutout(out_color,height);\n#endif\nglFragColor=out_color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}", "#include \"_prelude_fog.vertex.glsl\"\n#include \"_prelude_terrain.vertex.glsl\"\n#include \"_prelude_lighting.glsl\"\n#include \"_prelude_material_table.vertex.glsl\"\nuniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform float u_tile_units_to_pixels;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform float u_width_scale;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;in vec4 a_pos_normal_ed;in vec2 a_centroid_pos;\n#ifdef RENDER_WALL_MODE\nin vec3 a_join_normal_inside;\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nin vec3 a_pos_3;in vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;uniform float u_height_lift;\n#endif\n#ifdef TERRAIN\nuniform int u_height_type;uniform int u_base_type;\n#endif\nout highp vec2 v_pos;out vec4 v_lighting;\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;out vec3 v_ao;\n#endif\n#ifdef LIGHTING_3D_MODE\nout vec3 v_normal;\n#endif\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump vec4 pattern\n#ifdef FILL_EXTRUSION_PATTERN_TRANSITION\n#pragma mapbox: define mediump vec4 pattern_b\n#endif\n#pragma mapbox: define highp float pixel_ratio\n#pragma mapbox: define highp float line_width\nvoid main() {DECLARE_MATERIAL_TABLE_INFO\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump vec4 pattern\n#ifdef FILL_EXTRUSION_PATTERN_TRANSITION\n#pragma mapbox: initialize mediump vec4 pattern_b\n#endif\n#pragma mapbox: initialize highp float pixel_ratio\n#pragma mapbox: initialize highp float line_width\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec4 pos_nx=floor(a_pos_normal_ed*0.5);mediump vec4 top_up_ny_start=a_pos_normal_ed-2.0*pos_nx;mediump vec3 top_up_ny=top_up_ny_start.xyz;float x_normal=pos_nx.z/8192.0;vec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));float edgedistance=a_pos_normal_ed.w;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;base=max(0.0,base);height=max(0.0,height);float t=top_up_ny.x;float z=t > 0.0 ? height : base;vec2 centroid_pos=vec2(0.0);\n#if defined(HAS_CENTROID) || defined(TERRAIN)\ncentroid_pos=a_centroid_pos;\n#endif\nfloat ele=0.0;float h=z;vec3 p;float c_ele;\n#ifdef TERRAIN\nbool is_flat_height=centroid_pos.x !=0.0 && u_height_type==1;bool is_flat_base=centroid_pos.x !=0.0 && u_base_type==1;ele=elevation(pos_nx.xy);c_ele=is_flat_height || is_flat_base ? (centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos)) : ele;float h_height=is_flat_height ? max(c_ele+height,ele+base+2.0) : ele+height;float h_base=is_flat_base ? max(c_ele+base,ele+base) : ele+(base==0.0 ?-5.0 : base);h=t > 0.0 ? max(h_base,h_height) : h_base;p=vec3(pos_nx.xy,h);\n#else\np=vec3(pos_nx.xy,z);\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nfloat lift=float((t+base) > 0.0)*u_height_lift;h+=lift;vec3 globe_normal=normalize(mix(a_pos_normal_3/16384.0,u_up_dir,u_zoom_transition));vec3 globe_pos=a_pos_3+globe_normal*(u_tile_up_scale*(p.z+lift));vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,p.xy,u_tile_id,u_merc_center)+u_up_dir*u_tile_up_scale*p.z;p=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\n#endif\n#ifdef RENDER_WALL_MODE\nvec2 wall_offset=u_width_scale*line_width*(a_join_normal_inside.xy/EXTENT);p.xy+=(1.0-a_join_normal_inside.z)*wall_offset*0.5;p.xy-=a_join_normal_inside.z*wall_offset*0.5;\n#endif\nfloat hidden=float((centroid_pos.x==0.0 && centroid_pos.y==1.0) || (color.a==0.0));gl_Position=mix(u_matrix*vec4(p,1),AWAY,hidden);vec2 pos=normal.z==1.0\n? pos_nx.xy\n: vec2(edgedistance,z*u_height_factor);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float NdotL=0.0;\n#ifdef LIGHTING_3D_MODE\nNdotL=calculate_NdotL(normal);\n#else\nNdotL=clamp(dot(normal,u_lightpos),0.0,1.0);NdotL=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),NdotL);\n#endif\nif (normal.y !=0.0) {float r=0.84;\n#ifndef LIGHTING_3D_MODE\nr=mix(0.7,0.98,1.0-u_lightintensity);\n#endif\nNdotL*=(\n(1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),r,1.0)));}\n#ifdef FAUX_AO\nfloat concave=pos_nx.w-floor(pos_nx.w*0.5)*2.0;float start=top_up_ny_start.w;float y_ground=1.0-clamp(t+base,0.0,1.0);float top_height=height;\n#ifdef TERRAIN\ntop_height=mix(max(c_ele+height,ele+base+2.0),ele+height,float(centroid_pos.x==0.0))-ele;y_ground+=y_ground*5.0/max(3.0,top_height);\n#endif\nv_ao=vec3(mix(concave,-concave,start),y_ground,h-ele);NdotL*=(1.0+0.05*(1.0-top_up_ny.y)*u_ao[0]);\n#ifdef PROJECTION_GLOBE_VIEW\ntop_height+=u_height_lift;\n#endif\ngl_Position.z-=(0.0000006*(min(top_height,500.)+2.0*min(base,500.0)+60.0*concave+3.0*start))*gl_Position.w;\n#endif\n#ifdef LIGHTING_3D_MODE\nv_normal=normal;\n#else\nv_lighting.rgb+=clamp(NdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(p);\n#endif\n}"),
				groundShadow: ss("#include \"_prelude_shadow.fragment.glsl\"\nprecision highp float;uniform vec3 u_ground_shadow_factor;in vec4 v_pos_light_view_0;in vec4 v_pos_light_view_1;\n#ifdef FOG\nin float v_fog_opacity;\n#endif\nvoid main() {float light=shadowed_light_factor_plane_bias(v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w);vec3 shadow=mix(u_ground_shadow_factor,vec3(1.0),light);\n#ifdef RENDER_CUTOFF\nshadow=mix(vec3(1.0),shadow,cutoff_opacity(u_cutoff_params,1.0/gl_FragCoord.w));\n#endif\n#ifdef FOG\nshadow=mix(shadow,vec3(1.0),v_fog_opacity);\n#endif\n#ifdef INDICATOR_CUTOUT\nshadow=mix(shadow,vec3(1.0),1.0-applyCutout(vec4(1.0),0.0).r);\n#endif\nglFragColor=vec4(shadow,1.0);}", "#include \"_prelude_fog.vertex.glsl\"\nuniform mat4 u_matrix;uniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;in vec2 a_pos;out vec4 v_pos_light_view_0;out vec4 v_pos_light_view_1;\n#ifdef FOG\nout float v_fog_opacity;\n#endif\nvoid main() {gl_Position=u_matrix*vec4(a_pos,0.0,1.0);v_pos_light_view_0=u_light_matrix_0*vec4(a_pos,0.0,1.0);v_pos_light_view_1=u_light_matrix_1*vec4(a_pos,0.0,1.0);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);v_fog_opacity=fog(v_fog_pos);\n#endif\n}"),
				fillExtrusionGroundEffect: ss("uniform highp float u_ao_pass;uniform highp float u_opacity;uniform highp float u_flood_light_intensity;uniform highp vec3 u_flood_light_color;uniform highp float u_attenuation;uniform sampler2D u_fb;uniform float u_fb_size;\n#ifdef SDF_SUBPASS\nin highp vec2 v_pos;in highp vec4 v_line_segment;in highp float v_flood_light_radius_tile;in highp vec2 v_ao;float line_df(highp vec2 a,highp vec2 b,highp vec2 p) {highp vec2 ba=b-a;highp vec2 pa=p-a;highp float r=clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);return length(pa-r*ba);}\n#ifdef FOG\nin highp float v_fog;\n#endif\n#endif\nvoid main() {\n#ifdef CLEAR_SUBPASS\nvec4 color=vec4(1.0);\n#ifdef CLEAR_FROM_TEXTURE\ncolor=texture(u_fb,gl_FragCoord.xy/vec2(u_fb_size));\n#endif\nglFragColor=color;\n#else\n#ifdef SDF_SUBPASS\nhighp float d=line_df(v_line_segment.xy,v_line_segment.zw,v_pos);highp float effect_radius=mix(v_flood_light_radius_tile,v_ao.y,u_ao_pass);d/=effect_radius;d=min(d,1.0);d=1.0-pow(1.0-d,u_attenuation);highp float effect_intensity=mix(u_flood_light_intensity,v_ao.x,u_ao_pass);highp float fog=1.0;\n#ifdef FOG\nfog=v_fog;\n#endif\n#ifdef RENDER_CUTOFF\nfog*=v_cutoff_opacity;\n#endif\nglFragColor=vec4(vec3(0.0),mix(1.0,d,effect_intensity*u_opacity*fog));\n#else\n#ifdef USE_MRT1\nout_Target1=vec4(1.0-texture(u_fb,gl_FragCoord.xy/vec2(u_fb_size)).a,0.0,0.0,0.0);\n#else\nvec4 color=mix(vec4(u_flood_light_color,1.0),vec4(vec3(0.0),1.0),u_ao_pass);\n#ifdef OVERDRAW_INSPECTOR\ncolor=vec4(1.0);\n#endif\nglFragColor=color;\n#endif\n#endif\nHANDLE_WIREFRAME_DEBUG;\n#endif\n}", "#include \"_prelude_fog.vertex.glsl\"\nin highp vec4 a_pos_end;in highp float a_angular_offset_factor;in highp float a_hidden_by_landmark;\n#ifdef SDF_SUBPASS\nout highp vec2 v_pos;out highp vec4 v_line_segment;out highp float v_flood_light_radius_tile;out highp vec2 v_ao;\n#ifdef FOG\nout highp float v_fog;\n#endif\n#endif\nuniform highp float u_flood_light_intensity;uniform highp mat4 u_matrix;uniform highp float u_ao_pass;uniform highp float u_meter_to_tile;uniform highp float u_edge_radius;uniform highp float u_dynamic_offset;uniform highp vec2 u_ao;\n#pragma mapbox: define highp float flood_light_ground_radius\nconst float TANGENT_CUTOFF=4.0;const float NORM=32767.0;void main() {\n#pragma mapbox: initialize highp float flood_light_ground_radius\nvec2 p=a_pos_end.xy;vec2 q=floor(a_pos_end.zw*0.5);vec2 start_bottom=a_pos_end.zw-q*2.0;float fl_ground_radius=flood_light_ground_radius;fl_ground_radius=abs(flood_light_ground_radius);float direction=flood_light_ground_radius < 0.0 ?-1.0 : 1.0;float flood_radius_tile=fl_ground_radius*u_meter_to_tile;vec2 v=normalize(q-p);float ao_radius=u_ao.y/3.5;float effect_radius=mix(flood_radius_tile,ao_radius,u_ao_pass)+u_edge_radius;float angular_offset_factor=a_angular_offset_factor/NORM*TANGENT_CUTOFF;float angular_offset=direction*angular_offset_factor*effect_radius;float top=1.0-start_bottom.y;float side=(0.5-start_bottom.x)*2.0;vec2 extrusion_parallel=v*side*mix(u_dynamic_offset,angular_offset,top);vec2 perp=vec2(v.y,-v.x);vec2 extrusion_perp=direction*perp*effect_radius*top;vec3 pos=vec3(mix(q,p,start_bottom.x),0.0);pos.xy+=extrusion_parallel+extrusion_perp;\n#ifdef SDF_SUBPASS\nv_pos=pos.xy;v_line_segment=vec4(p,q)+perp.xyxy*u_edge_radius;v_flood_light_radius_tile=flood_radius_tile;v_ao=vec2(u_ao.x,ao_radius);\n#ifdef FOG\nv_fog_pos=fog_position(pos);v_fog=1.0-fog(v_fog_pos);\n#endif\n#endif\nfloat hidden_by_landmark=0.0;\n#ifdef HAS_CENTROID\nhidden_by_landmark=a_hidden_by_landmark;\n#endif\nfloat isFloodlit=float(fl_ground_radius > 0.0 && u_flood_light_intensity > 0.0);float hidden=mix(1.0-isFloodlit,isFloodlit,u_ao_pass);hidden+=hidden_by_landmark;gl_Position=mix(u_matrix*vec4(pos,1.0),AWAY,float(hidden > 0.0));\n#ifdef RENDER_CUTOFF\nv_cutoff_opacity=cutoff_opacity(u_cutoff_params,gl_Position.z);\n#endif\n}"),
				hillshadePrepare: ss("precision highp float;uniform highp sampler2D u_image;in vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;float getElevation(vec2 coord) {return texture(u_image,coord).r/4.0;}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y));float b=getElevation(v_pos+vec2(0,-epsilon.y));float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y));float d=getElevation(v_pos+vec2(-epsilon.x,0));float e=getElevation(v_pos+vec2(epsilon.x,0));float f=getElevation(v_pos+vec2(-epsilon.x,epsilon.y));float g=getElevation(v_pos+vec2(0,epsilon.y));float h=getElevation(v_pos+vec2(epsilon.x,epsilon.y));float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2(\n(c+e+e+h)-(a+d+d+f),(f+g+g+h)-(a+b+b+c)\n)/pow(2.0,exaggeration+(19.2562-u_zoom));glFragColor=clamp(vec4(\nderiv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);}", "uniform mat4 u_matrix;uniform vec2 u_dimension;in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"),
				hillshade: ss("#include \"_prelude_fog.fragment.glsl\"\n#include \"_prelude_lighting.glsl\"\nuniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;uniform float u_emissive_strength;void main() {vec4 pixel=texture(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);glFragColor=accent_color*(1.0-shade_color.a)+shade_color;\n#ifdef LIGHTING_3D_MODE\nglFragColor=apply_lighting_with_emission_ground(glFragColor,u_emissive_strength);\n#endif\n#ifdef FOG\nglFragColor=fog_dither(fog_apply_premultiplied(glFragColor,v_fog_pos));\n#endif\n#ifdef USE_MRT1\nout_Target1=vec4(u_emissive_strength*glFragColor.a,0.0,0.0,glFragColor.a);\n#endif\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}", "#include \"_prelude_fog.vertex.glsl\"\nuniform mat4 u_matrix;in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=a_texture_pos/8192.0;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"),
				line: ss("#include \"_prelude_fog.fragment.glsl\"\n#include \"_prelude_lighting.glsl\"\n#include \"_prelude_shadow.fragment.glsl\"\nuniform lowp float u_device_pixel_ratio;uniform highp float u_width_scale;uniform highp float u_floor_width_scale;uniform float u_alpha_discard_threshold;uniform highp vec2 u_trim_offset;uniform highp vec2 u_trim_fade_range;uniform lowp vec4 u_trim_color;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;in highp vec3 v_uv;\n#ifdef ELEVATED_ROADS\nin highp float v_road_z_offset;\n#endif\n#ifdef RENDER_LINE_DASH\nuniform sampler2D u_dash_image;in vec2 v_tex;\n#endif\n#ifdef RENDER_LINE_GRADIENT\nuniform sampler2D u_gradient_image;\n#endif\n#ifdef INDICATOR_CUTOUT\nin highp float v_z_offset;\n#endif\n#ifdef RENDER_SHADOWS\nuniform vec3 u_ground_shadow_factor;in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in highp float v_depth;\n#endif\nfloat luminance(vec3 c) {return (c.r+c.r+c.b+c.g+c.g+c.g)*0.1667;}\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 dash\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float side_z_offset\n#pragma mapbox: define lowp float border_width\n#pragma mapbox: define lowp vec4 border_color\n#pragma mapbox: define lowp float emissive_strength\nfloat linearstep(float edge0,float edge1,float x) {return  clamp((x-edge0)/(edge1-edge0),0.0,1.0);}void main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize lowp vec4 dash\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float side_z_offset\n#pragma mapbox: initialize lowp float border_width\n#pragma mapbox: initialize lowp vec4 border_color\n#pragma mapbox: initialize lowp float emissive_strength\nfloat dist=length(v_normal)*v_width2.s;float blur2=(u_width_scale*blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);alpha=side_z_offset > 0.0 ? 1.0-alpha : alpha;\n#ifdef RENDER_LINE_DASH\nfloat sdfdist=texture(u_dash_image,v_tex).r;float sdfgamma=1.0/(2.0*u_device_pixel_ratio)/dash.z;float scaled_floorwidth=(floorwidth*u_floor_width_scale);alpha*=linearstep(0.5-sdfgamma/scaled_floorwidth,0.5+sdfgamma/scaled_floorwidth,sdfdist);\n#endif\nhighp vec4 out_color;\n#ifdef RENDER_LINE_GRADIENT\nout_color=texture(u_gradient_image,v_uv.xy);\n#ifdef MULTIPLY_LINE_GRADIENT_COLOR\nout_color*=color;\n#endif\n#else\nout_color=color;\n#endif\nfloat trim_alpha=1.0;\n#ifdef RENDER_LINE_TRIM_OFFSET\nhighp float trim_start=u_trim_offset[0];highp float trim_end=u_trim_offset[1];highp float line_progress=v_uv[2];if (trim_end > trim_start) {highp float start_transition=max(0.0,min(1.0,(line_progress-trim_start)/max(u_trim_fade_range[0],1.0e-9)));highp float end_transition=max(0.0,min(1.0,(trim_end-line_progress)/max(u_trim_fade_range[1],1.0e-9)));highp float transition_factor=min(start_transition,end_transition);out_color=mix(out_color,u_trim_color,transition_factor);trim_alpha=1.0-transition_factor;}\n#endif\nif (u_alpha_discard_threshold !=0.0) {if (alpha < u_alpha_discard_threshold) {discard;}}\n#ifdef RENDER_LINE_BORDER\nfloat edgeBlur=((border_width*u_width_scale)+1.0/u_device_pixel_ratio);float alpha2=clamp(min(dist-(v_width2.t-edgeBlur),v_width2.s-dist)/edgeBlur,0.0,1.0);if (alpha2 < 1.) {float smoothAlpha=smoothstep(0.6,1.0,alpha2);if (border_color.a==0.0) {float Y=(out_color.a > 0.01) ? luminance(out_color.rgb/out_color.a) : 1.;float adjustment=(Y > 0.) ? 0.5/Y : 0.45;if (out_color.a > 0.25 && Y < 0.25) {vec3 borderColor=(Y > 0.) ? out_color.rgb : vec3(1,1,1)*out_color.a;out_color.rgb=out_color.rgb+borderColor*(adjustment*(1.0-smoothAlpha));} else {out_color.rgb*=(0.6 +0.4*smoothAlpha);}} else {out_color=mix(border_color*trim_alpha,out_color,smoothAlpha);}}\n#endif\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,emissive_strength);\n#ifdef RENDER_SHADOWS\nfloat light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);\n#ifdef ELEVATED_ROADS\nout_color.rgb*=mix(v_road_z_offset !=0.0 ? u_ground_shadow_factor : vec3(1.0),vec3(1.0),light);\n#else\nout_color.rgb*=mix(u_ground_shadow_factor,vec3(1.0),light);\n#endif\n#endif\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\nout_color*=(alpha*opacity);\n#ifdef INDICATOR_CUTOUT\nout_color=applyCutout(out_color,v_z_offset);\n#endif\n#ifdef FEATURE_CUTOUT\nout_color=apply_feature_cutout(out_color,gl_FragCoord);\n#endif\nglFragColor=out_color;\n#ifdef DUAL_SOURCE_BLENDING\nglFragColorSrc1=vec4(vec3(0.0),emissive_strength);\n#else\n#ifdef USE_MRT1\nout_Target1=vec4(emissive_strength*glFragColor.a,0.0,0.0,glFragColor.a);\n#endif\n#endif\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}", "#include \"_prelude_fog.vertex.glsl\"\n#include \"_prelude_shadow.vertex.glsl\"\n#include \"_prelude_terrain.vertex.glsl\"\n#define EXTRUDE_SCALE 0.015873016\nin vec2 a_pos_normal;in vec4 a_data;\n#if defined(ELEVATED) || defined(ELEVATED_ROADS) || defined(VARIABLE_LINE_WIDTH)\nin vec3 a_z_offset_width;\n#endif\n#if defined(RENDER_LINE_GRADIENT) || defined(RENDER_LINE_TRIM_OFFSET)\nin highp vec3 a_packed;\n#endif\n#ifdef RENDER_LINE_DASH\nin float a_linesofar;\n#endif\nuniform mat4 u_matrix;uniform mat2 u_pixels_to_tile_units;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;uniform float u_width_scale;uniform highp float u_floor_width_scale;\n#ifdef ELEVATED\nuniform lowp float u_zbias_factor;uniform lowp float u_tile_to_meter;float sample_elevation(vec2 apos) {\n#ifdef ELEVATION_REFERENCE_SEA\nreturn 0.0;\n#else\nreturn elevation(apos);\n#endif\n}\n#endif\nout vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp vec3 v_uv;\n#ifdef ELEVATED_ROADS\nout highp float v_road_z_offset;\n#endif\n#ifdef RENDER_LINE_DASH\nuniform vec2 u_texsize;uniform float u_tile_units_to_pixels;out vec2 v_tex;\n#endif\n#ifdef RENDER_LINE_GRADIENT\nuniform float u_image_height;\n#endif\n#ifdef INDICATOR_CUTOUT\nout highp float v_z_offset;\n#endif\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out highp float v_depth;\n#endif\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 dash\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\n#pragma mapbox: define mediump float side_z_offset\n#pragma mapbox: define lowp float border_width\n#pragma mapbox: define lowp vec4 border_color\n#pragma mapbox: define lowp float emissive_strength\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize lowp vec4 dash\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize mediump float side_z_offset\n#pragma mapbox: initialize lowp float border_width\n#pragma mapbox: initialize lowp vec4 border_color\n#pragma mapbox: initialize lowp float emissive_strength\nfloat a_z_offset;\n#if defined(ELEVATED) || defined(ELEVATED_ROADS)\na_z_offset=a_z_offset_width.x;\n#endif\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth;\n#ifdef VARIABLE_LINE_WIDTH\nbool left=normal.y==1.0;halfwidth=(u_width_scale*(left ? a_z_offset_width.y : a_z_offset_width.z))/2.0;a_z_offset+=left ? side_z_offset : 0.0;v_normal=side_z_offset > 0.0 && left ? vec2(0.0) : v_normal;\n#else\nhalfwidth=(u_width_scale*width)/2.0;\n#endif\noffset=-1.0*offset*u_width_scale;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*EXTRUDE_SCALE;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*EXTRUDE_SCALE*normal.y*mat2(t,-u,u,t);float hidden=float(opacity==0.0);vec2 extrude=dist*u_pixels_to_tile_units;vec4 projected_extrude=u_matrix*vec4(extrude,0.0,0.0);vec2 projected_extrude_xy=projected_extrude.xy;\n#ifdef ELEVATED_ROADS\nv_road_z_offset=a_z_offset;gl_Position=u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,a_z_offset,1.0)+projected_extrude;\n#else\n#ifdef ELEVATED\nvec2 offsetTile=offset2*u_pixels_to_tile_units;vec2 offset_pos=pos+offsetTile;float ele=0.0;\n#ifdef CROSS_SLOPE_VERTICAL\nfloat top=a_pos_normal.y-2.0*floor(a_pos_normal.y*0.5);float line_height=2.0*u_tile_to_meter*outset*top*u_pixels_to_tile_units[1][1]+a_z_offset;ele=sample_elevation(offset_pos)+line_height;projected_extrude=vec4(0);\n#else\n#ifdef CROSS_SLOPE_HORIZONTAL\nfloat ele0=sample_elevation(offset_pos);float ele1=max(sample_elevation(offset_pos+extrude),sample_elevation(offset_pos+extrude/2.0));float ele2=max(sample_elevation(offset_pos-extrude),sample_elevation(offset_pos-extrude/2.0));float ele_max=max(ele0,max(ele1,ele2));ele=ele_max+a_z_offset;\n#else\nfloat ele0=sample_elevation(offset_pos);float ele1=max(sample_elevation(offset_pos+extrude),sample_elevation(offset_pos+extrude/2.0));float ele2=max(sample_elevation(offset_pos-extrude),sample_elevation(offset_pos-extrude/2.0));float ele_max=max(ele0,0.5*(ele1+ele2));ele=ele_max-ele0+ele1+a_z_offset;\n#endif\n#endif\ngl_Position=u_matrix*vec4(offset_pos,ele,1.0)+projected_extrude;float z=clamp(gl_Position.z/gl_Position.w,0.5,1.0);float zbias=max(0.00005,(pow(z,0.8)-z)*u_zbias_factor*u_exaggeration);gl_Position.z-=(gl_Position.w*zbias);gl_Position=mix(gl_Position,AWAY,hidden);\n#else\ngl_Position=mix(u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,0.0,1.0)+projected_extrude,AWAY,hidden);\n#endif\n#endif\n#ifdef ELEVATED_ROADS\n#ifdef RENDER_SHADOWS\nvec3 shd_pos=vec3(pos+(offset2+dist)*u_pixels_to_tile_units,a_z_offset);vec3 shd_pos0=shd_pos;vec3 shd_pos1=shd_pos;\n#ifdef NORMAL_OFFSET\nvec3 shd_pos_offset=shadow_normal_offset(vec3(0.0,0.0,1.0));shd_pos0+=shd_pos_offset*shadow_normal_offset_multiplier0();shd_pos1+=shd_pos_offset*shadow_normal_offset_multiplier1();\n#endif\nv_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;\n#endif\n#endif\n#ifndef RENDER_TO_TEXTURE\nfloat epsilon=0.0001;float extrude_length_without_perspective=max(length(dist),epsilon);float extrude_length_with_perspective=max(length(projected_extrude_xy/gl_Position.w*u_units_to_pixels),epsilon);v_gamma_scale=mix(extrude_length_without_perspective/extrude_length_with_perspective,1.0,step(0.01,blur));\n#else\nv_gamma_scale=1.0;\n#endif\n#if defined(RENDER_LINE_GRADIENT) || defined(RENDER_LINE_TRIM_OFFSET)\nhighp float a_uv_x=a_packed[0];float a_split_index=a_packed[1];highp float line_progress=a_packed[2];\n#ifdef RENDER_LINE_GRADIENT\nhighp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec3(a_uv_x,a_split_index*texel_height-half_texel_height,line_progress);\n#else\nv_uv=vec3(a_uv_x,0.0,line_progress);\n#endif\n#endif\n#ifdef RENDER_LINE_DASH\nfloat scale=dash.z==0.0 ? 0.0 : u_tile_units_to_pixels/dash.z;float height=dash.y;v_tex=vec2(a_linesofar*scale/(floorwidth*u_floor_width_scale),(-normal.y*height+dash.x+0.5)/u_texsize.y);\n#endif\nv_width2=vec2(outset,inset);\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n#ifdef INDICATOR_CUTOUT\nv_z_offset=a_z_offset;\n#endif\n}"),
				linePattern: ss("#include \"_prelude_fog.fragment.glsl\"\n#include \"_prelude_lighting.glsl\"\n#include \"_prelude_shadow.fragment.glsl\"\nuniform highp float u_device_pixel_ratio;uniform highp float u_width_scale;uniform highp float u_alpha_discard_threshold;uniform highp vec2 u_texsize;uniform highp float u_tile_units_to_pixels;uniform highp vec2 u_trim_offset;uniform highp vec2 u_trim_fade_range;uniform lowp vec4 u_trim_color;uniform sampler2D u_image;\n#ifdef APPLY_LUT_ON_GPU\nuniform highp sampler3D u_lutTexture;\n#endif\n#ifdef LINE_PATTERN_TRANSITION\nuniform float u_pattern_transition;\n#endif\nin vec2 v_normal;in vec2 v_width2;in highp float v_linesofar;in float v_gamma_scale;in float v_width;\n#ifdef RENDER_LINE_TRIM_OFFSET\nin highp vec3 v_uv;\n#endif\n#ifdef ELEVATED_ROADS\nin highp float v_road_z_offset;\n#endif\n#ifdef LINE_JOIN_NONE\nin vec2 v_pattern_data;\n#endif\n#ifdef INDICATOR_CUTOUT\nin highp float v_z_offset;\n#endif\n#ifdef RENDER_SHADOWS\nuniform vec3 u_ground_shadow_factor;in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in highp float v_depth;\n#endif\n#pragma mapbox: define mediump vec4 pattern\n#ifdef LINE_PATTERN_TRANSITION\n#pragma mapbox: define mediump vec4 pattern_b\n#endif\n#pragma mapbox: define mediump float pixel_ratio\n#pragma mapbox: define mediump float blur\n#pragma mapbox: define mediump float opacity\n#pragma mapbox: define lowp float emissive_strength\nvoid main() {\n#pragma mapbox: initialize mediump vec4 pattern\n#ifdef LINE_PATTERN_TRANSITION\n#pragma mapbox: initialize mediump vec4 pattern_b\n#endif\n#pragma mapbox: initialize mediump float pixel_ratio\n#pragma mapbox: initialize mediump float blur\n#pragma mapbox: initialize mediump float opacity\n#pragma mapbox: initialize lowp float emissive_strength\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;highp float pattern_size=display_size.x/u_tile_units_to_pixels;float aspect=display_size.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(u_width_scale*blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);highp float pattern_x=v_linesofar/pattern_size*aspect;highp float x=mod(pattern_x,1.0);highp float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;highp vec2 pos=mix(pattern_tl*texel_size-texel_size,pattern_br*texel_size+texel_size,vec2(x,y));highp vec2 lod_pos=mix(pattern_tl*texel_size-texel_size,pattern_br*texel_size+texel_size,vec2(pattern_x,y));vec4 color=textureLodCustom(u_image,pos,lod_pos);\n#ifdef APPLY_LUT_ON_GPU\ncolor=applyLUT(u_lutTexture,color);\n#endif\n#ifdef LINE_PATTERN_TRANSITION\nvec2 pattern_b_tl=pattern_b.xy;vec2 pattern_b_br=pattern_b.zw;highp vec2 pos_b=mix(pattern_b_tl*texel_size-texel_size,pattern_b_br*texel_size+texel_size,vec2(x,y));vec4 color_b=textureLodCustom(u_image,pos_b,lod_pos);color=color*(1.0-u_pattern_transition)+color_b*u_pattern_transition;\n#endif\n#ifdef RENDER_LINE_TRIM_OFFSET\nhighp float trim_start=u_trim_offset[0];highp float trim_end=u_trim_offset[1];highp float line_progress=v_uv[2];if (trim_end > trim_start) {highp float start_transition=max(0.0,min(1.0,(line_progress-trim_start)/max(u_trim_fade_range[0],1.0e-9)));highp float end_transition=max(0.0,min(1.0,(trim_end-line_progress)/max(u_trim_fade_range[1],1.0e-9)));highp float transition_factor=min(start_transition,end_transition);color=mix(color,color.a*u_trim_color,transition_factor);}\n#endif\n#ifdef LINE_JOIN_NONE\nhighp float pattern_len=pattern_size/aspect;highp float segment_phase=pattern_len-mod(v_linesofar-v_pattern_data.x+pattern_len,pattern_len);highp float visible_start=segment_phase-step(pattern_len*0.5,segment_phase)*pattern_len;highp float visible_end=floor((v_pattern_data.y-segment_phase)/pattern_len)*pattern_len+segment_phase;visible_end+=step(pattern_len*0.5,v_pattern_data.y-visible_end)*pattern_len;if (v_pattern_data.x < visible_start || v_pattern_data.x >=visible_end) {color=vec4(0.0);}\n#endif\n#ifdef LIGHTING_3D_MODE\ncolor=apply_lighting_with_emission_ground(color,emissive_strength);\n#ifdef RENDER_SHADOWS\nfloat light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);\n#ifdef ELEVATED_ROADS\ncolor.rgb*=mix(v_road_z_offset !=0.0 ? u_ground_shadow_factor : vec3(1.0),vec3(1.0),light);\n#else\ncolor.rgb*=mix(u_ground_shadow_factor,vec3(1.0),light);\n#endif\n#endif\n#endif\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#endif\ncolor*=(alpha*opacity);if (u_alpha_discard_threshold !=0.0) {if (color.a < u_alpha_discard_threshold) {discard;}}\n#ifdef INDICATOR_CUTOUT\ncolor=applyCutout(color,v_z_offset);\n#endif\nglFragColor=color;\n#ifdef DUAL_SOURCE_BLENDING\nglFragColorSrc1=vec4(vec3(0.0),emissive_strength);\n#else\n#ifdef USE_MRT1\nout_Target1=vec4(emissive_strength*glFragColor.a,0.0,0.0,glFragColor.a);\n#endif\n#endif\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}", "#include \"_prelude_fog.vertex.glsl\"\n#include \"_prelude_shadow.vertex.glsl\"\n#include \"_prelude_terrain.vertex.glsl\"\n#define scale 0.015873016\nin vec2 a_pos_normal;in vec4 a_data;\n#if defined(ELEVATED) || defined(ELEVATED_ROADS)\nin vec3 a_z_offset_width;\n#endif\n#ifdef RENDER_LINE_TRIM_OFFSET\nin highp vec3 a_packed;\n#endif\nin highp float a_linesofar;\n#ifdef LINE_JOIN_NONE\nin highp vec3 a_pattern_data;out vec2 v_pattern_data;\n#endif\n#ifdef INDICATOR_CUTOUT\nout highp float v_z_offset;\n#endif\nuniform mat4 u_matrix;uniform float u_tile_units_to_pixels;uniform vec2 u_units_to_pixels;uniform mat2 u_pixels_to_tile_units;uniform float u_device_pixel_ratio;uniform float u_width_scale;uniform float u_floor_width_scale;\n#ifdef ELEVATED\nuniform lowp float u_zbias_factor;uniform lowp float u_tile_to_meter;float sample_elevation(vec2 apos) {\n#ifdef ELEVATION_REFERENCE_SEA\nreturn 0.0;\n#else\nreturn elevation(apos);\n#endif\n}\n#endif\nout vec2 v_normal;out vec2 v_width2;out highp float v_linesofar;out float v_gamma_scale;out float v_width;\n#ifdef RENDER_LINE_TRIM_OFFSET\nout highp vec3 v_uv;\n#endif\n#ifdef ELEVATED_ROADS\nout highp float v_road_z_offset;\n#endif\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out highp float v_depth;\n#endif\n#pragma mapbox: define mediump float blur\n#pragma mapbox: define mediump float opacity\n#pragma mapbox: define mediump float offset\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define mediump float width\n#pragma mapbox: define mediump float floorwidth\n#pragma mapbox: define mediump vec4 pattern\n#ifdef LINE_PATTERN_TRANSITION\n#pragma mapbox: define mediump vec4 pattern_b\n#endif\n#pragma mapbox: define mediump float pixel_ratio\n#pragma mapbox: define lowp float emissive_strength\nvoid main() {\n#pragma mapbox: initialize mediump float blur\n#pragma mapbox: initialize mediump float opacity\n#pragma mapbox: initialize mediump float offset\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize mediump float floorwidth\n#pragma mapbox: initialize mediump vec4 pattern\n#ifdef LINE_PATTERN_TRANSITION\n#pragma mapbox: initialize mediump vec4 pattern_b\n#endif\n#pragma mapbox: initialize mediump float pixel_ratio\n#pragma mapbox: initialize lowp float emissive_strength\nfloat a_z_offset;\n#if defined(ELEVATED) || defined(ELEVATED_ROADS)\na_z_offset=a_z_offset_width.x;\n#endif\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=(u_width_scale*width)/2.0;offset=-1.0*offset*u_width_scale;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);vec2 dist=outset*a_extrude*scale;float u=0.5*a_direction;float t=1.0-abs(u);vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float hidden=float(opacity==0.0);vec2 extrude=dist*u_pixels_to_tile_units;vec4 projected_extrude=u_matrix*vec4(extrude,0.0,0.0);vec2 projected_extrude_xy=projected_extrude.xy;\n#ifdef ELEVATED_ROADS\nv_road_z_offset=a_z_offset;gl_Position=u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,a_z_offset,1.0)+projected_extrude;\n#else\n#ifdef ELEVATED\nvec2 offsetTile=offset2*u_pixels_to_tile_units;vec2 offset_pos=pos+offsetTile;float ele=0.0;\n#ifdef CROSS_SLOPE_VERTICAL\nfloat top=a_pos_normal.y-2.0*floor(a_pos_normal.y*0.5);float line_height=2.0*u_tile_to_meter*outset*top*u_pixels_to_tile_units[1][1]+a_z_offset;ele=sample_elevation(offset_pos)+line_height;projected_extrude=vec4(0);\n#else\n#ifdef CROSS_SLOPE_HORIZONTAL\nfloat ele0=sample_elevation(offset_pos);float ele1=max(sample_elevation(offset_pos+extrude),sample_elevation(offset_pos+extrude/2.0));float ele2=max(sample_elevation(offset_pos-extrude),sample_elevation(offset_pos-extrude/2.0));float ele_max=max(ele0,max(ele1,ele2));ele=ele_max+a_z_offset;\n#else\nfloat ele0=sample_elevation(offset_pos);float ele1=max(sample_elevation(offset_pos+extrude),sample_elevation(offset_pos+extrude/2.0));float ele2=max(sample_elevation(offset_pos-extrude),sample_elevation(offset_pos-extrude/2.0));float ele_max=max(ele0,0.5*(ele1+ele2));ele=ele_max-ele0+ele1+a_z_offset;\n#endif\n#endif\ngl_Position=u_matrix*vec4(offset_pos,ele,1.0)+projected_extrude;float z=clamp(gl_Position.z/gl_Position.w,0.5,1.0);float zbias=max(0.00005,(pow(z,0.8)-z)*u_zbias_factor*u_exaggeration);gl_Position.z-=(gl_Position.w*zbias);gl_Position=mix(gl_Position,AWAY,hidden);\n#else\ngl_Position=mix(u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,0.0,1.0)+projected_extrude,AWAY,hidden);\n#endif\n#endif\n#ifdef ELEVATED_ROADS\n#ifdef RENDER_SHADOWS\nvec3 shd_pos=vec3(pos+(offset2+dist)*u_pixels_to_tile_units,a_z_offset);vec3 shd_pos0=shd_pos;vec3 shd_pos1=shd_pos;\n#ifdef NORMAL_OFFSET\nvec3 shd_pos_offset=shadow_normal_offset(vec3(0.0,0.0,1.0));shd_pos0+=shd_pos_offset*shadow_normal_offset_multiplier0();shd_pos1+=shd_pos_offset*shadow_normal_offset_multiplier1();\n#endif\nv_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;\n#endif\n#endif\n#ifndef RENDER_TO_TEXTURE\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude_xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=mix(extrude_length_without_perspective/extrude_length_with_perspective,1.0,step(0.01,blur));\n#else\nv_gamma_scale=1.0;\n#endif\n#ifdef RENDER_LINE_TRIM_OFFSET\nhighp float a_uv_x=a_packed[0];highp float line_progress=a_packed[2];v_uv=vec3(a_uv_x,0.0,line_progress);\n#endif\nv_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=(floorwidth*u_floor_width_scale);\n#ifdef LINE_JOIN_NONE\nv_width=(floorwidth*u_floor_width_scale)+ANTIALIASING;mediump float pixels_to_tile_units=1.0/u_tile_units_to_pixels;mediump float pixel_ratio_inverse=1.0/pixel_ratio;mediump float aspect=v_width/((pattern.w-pattern.y)*pixel_ratio_inverse);highp float subt_multiple=(pattern.z-pattern.x)*pixel_ratio_inverse*pixels_to_tile_units*aspect*32.0;highp float subt=floor(a_pattern_data.z/subt_multiple)*subt_multiple;float offset_sign=(fract(a_pattern_data.x)-0.5)*4.0;float line_progress_offset=offset_sign*v_width*0.5*pixels_to_tile_units;v_linesofar=(a_pattern_data.z-subt)+a_linesofar+line_progress_offset;v_pattern_data=vec2(a_pattern_data.x+line_progress_offset,a_pattern_data.y);\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n#ifdef INDICATOR_CUTOUT\nv_z_offset=a_z_offset;\n#endif\n}"),
				raster: ss("#include \"_prelude_fog.fragment.glsl\"\n#include \"_prelude_lighting.glsl\"\n#include \"_prelude_raster_array.glsl\"\nuniform float u_fade_t;uniform float u_opacity;uniform highp float u_raster_elevation;uniform highp float u_zoom_transition;in vec2 v_pos0;in vec2 v_pos1;in float v_depth;\n#ifdef PROJECTION_GLOBE_VIEW\nin float v_split_fade;\n#endif\nuniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;uniform float u_emissive_strength;\n#ifndef RASTER_ARRAY\nuniform highp sampler2D u_image0;uniform sampler2D u_image1;\n#endif\n#ifdef RASTER_COLOR\nuniform sampler2D u_color_ramp;uniform highp vec4 u_colorization_mix;uniform highp float u_colorization_offset;uniform vec2 u_texture_res;\n#endif\nvoid main() {vec4 color0,color1,color;vec2 value;\n#ifdef RASTER_COLOR\n#ifdef RASTER_ARRAY\n#ifdef RASTER_ARRAY_LINEAR\nvalue=mix(\nraTexture2D_image0_linear(v_pos0,u_texture_res,u_colorization_mix,u_colorization_offset),raTexture2D_image1_linear(v_pos1,u_texture_res,u_colorization_mix,u_colorization_offset),u_fade_t\n);\n#else\nvalue=mix(\nraTexture2D_image0_nearest(v_pos0,u_texture_res,u_colorization_mix,u_colorization_offset),raTexture2D_image1_nearest(v_pos1,u_texture_res,u_colorization_mix,u_colorization_offset),u_fade_t\n);\n#endif\nif (value.y > 0.0) value.x/=value.y;\n#else\ncolor=mix(texture(u_image0,v_pos0),texture(u_image1,v_pos1),u_fade_t);value=vec2(u_colorization_offset+dot(color.rgb,u_colorization_mix.rgb),color.a);\n#endif\ncolor=texture(u_color_ramp,vec2(value.x,0.5));if (color.a > 0.0) color.rgb/=color.a;color.a*=value.y;\n#else\ncolor0=texture(u_image0,v_pos0);color1=texture(u_image1,v_pos1);if (color0.a > 0.0) color0.rgb/=color0.a;if (color1.a > 0.0) color1.rgb/=color1.a;color=mix(color0,color1,u_fade_t);\n#endif\ncolor.a*=u_opacity;\n#ifdef GLOBE_POLES\ncolor.a*=1.0-smoothstep(0.0,0.05,u_zoom_transition);\n#endif\nvec3 rgb=color.rgb;rgb=vec3(\ndot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);vec3 out_color=mix(u_high_vec,u_low_vec,rgb);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(vec4(out_color,1.0),u_emissive_strength).rgb;\n#endif\n#ifdef FOG\nhighp float fog_limit_high_meters=1000000.0;highp float fog_limit_low_meters=600000.0;float fog_limit=1.0-smoothstep(fog_limit_low_meters,fog_limit_high_meters,u_raster_elevation);out_color=fog_dither(fog_apply(out_color,v_fog_pos,fog_limit));\n#endif\nglFragColor=vec4(out_color*color.a,color.a);\n#ifdef PROJECTION_GLOBE_VIEW\nglFragColor*=mix(1.0,1.0-smoothstep(0.0,0.05,u_zoom_transition),smoothstep(0.8,0.9,v_split_fade));\n#endif\n#ifdef RENDER_CUTOFF\nglFragColor=glFragColor*cutoff_opacity(u_cutoff_params,v_depth);\n#endif\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\n#ifdef USE_MRT1\nout_Target1=vec4(u_emissive_strength*glFragColor.a,0.0,0.0,glFragColor.a);\n#endif\nHANDLE_WIREFRAME_DEBUG;}", "#include \"_prelude_fog.vertex.glsl\"\nuniform mat4 u_matrix;uniform mat4 u_normalize_matrix;uniform mat4 u_globe_matrix;uniform mat4 u_merc_matrix;uniform mat3 u_grid_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform vec2 u_perspective_transform;uniform vec2 u_texture_offset;uniform float u_raster_elevation;uniform float u_zoom_transition;uniform vec2 u_merc_center;\n#define GLOBE_UPSCALE GLOBE_RADIUS/6371008.8\n#ifdef GLOBE_POLES\nin vec3 a_globe_pos;in vec2 a_uv;\n#else\nin vec2 a_pos;in vec2 a_texture_pos;\n#endif\nout vec2 v_pos0;out vec2 v_pos1;out float v_depth;\n#ifdef PROJECTION_GLOBE_VIEW\nout float v_split_fade;\n#endif\nvoid main() {vec2 uv;\n#ifdef GLOBE_POLES\nvec3 globe_pos=a_globe_pos;globe_pos+=normalize(globe_pos)*u_raster_elevation*GLOBE_UPSCALE;gl_Position=u_matrix*u_globe_matrix*vec4(globe_pos   ,1.0);uv=a_uv;\n#ifdef FOG\nv_fog_pos=fog_position((u_normalize_matrix*vec4(a_globe_pos,1.0)).xyz);\n#endif\n#else\nfloat w=1.0+dot(a_texture_pos,u_perspective_transform);uv=a_texture_pos/8192.0;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 decomposed_pos_and_skirt=decomposeToPosAndSkirt(a_pos);vec3 latLng=u_grid_matrix*vec3(decomposed_pos_and_skirt.xy,1.0);vec3 globe_pos=latLngToECEF(latLng.xy);globe_pos+=normalize(globe_pos)*u_raster_elevation*GLOBE_UPSCALE;vec4 globe_world_pos=u_globe_matrix*vec4(globe_pos,1.0);vec4 merc_world_pos=vec4(0.0);float mercatorY=mercatorYfromLat(latLng[0]);float mercatorX=mercatorXfromLng(latLng[1]);    \nv_split_fade=0.0;if (u_zoom_transition > 0.0) {vec2 merc_pos=vec2(mercatorX,mercatorY);merc_world_pos=vec4(merc_pos,u_raster_elevation,1.0);merc_world_pos.xy-=u_merc_center;merc_world_pos.x=wrap(merc_world_pos.x,-0.5,0.5);merc_world_pos=u_merc_matrix*merc_world_pos;float opposite_merc_center=mod(u_merc_center.x+0.5,1.0);float dist_from_poles=(abs(mercatorY-0.5)*2.0);float range=0.1;v_split_fade=abs(opposite_merc_center-mercatorX);v_split_fade=clamp(1.0-v_split_fade,0.0,1.0);v_split_fade=max(smoothstep(1.0-range,1.0,dist_from_poles),max(smoothstep(1.0-range,1.0,v_split_fade),smoothstep(1.0-range,1.0,1.0-v_split_fade)));}float tiles=u_grid_matrix[0][2];if (tiles > 0.0) {float idx=u_grid_matrix[1][2];float idy=u_grid_matrix[2][2];float uvY=mercatorY*tiles-idy;float uvX=mercatorX*tiles-idx;uv=vec2(uvX,uvY);}vec4 interpolated_pos=vec4(mix(globe_world_pos.xyz,merc_world_pos.xyz,u_zoom_transition)*w,w);gl_Position=u_matrix*interpolated_pos;\n#ifdef FOG\nv_fog_pos=fog_position((u_normalize_matrix*vec4(globe_pos,1.0)).xyz);\n#endif\n#else\ngl_Position=u_matrix*vec4(a_pos*w,u_raster_elevation*w,w);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n#endif\n#endif\nv_pos0=uv;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;v_pos0=u_texture_offset.x+u_texture_offset.y*v_pos0;v_pos1=u_texture_offset.x+u_texture_offset.y*v_pos1;\n#ifdef RENDER_CUTOFF\nv_depth=gl_Position.z;\n#endif\n}"),
				rasterParticle: ss("#include \"_prelude_fog.fragment.glsl\"\n#include \"_prelude_lighting.glsl\"\nuniform float u_fade_t;uniform float u_opacity;uniform highp float u_raster_elevation;in vec2 v_pos0;in vec2 v_pos1;uniform sampler2D u_image0;uniform sampler2D u_image1;void main() {vec4 color0,color1,color;color0=texture(u_image0,v_pos0);color1=texture(u_image1,v_pos1);if (color0.a > 0.0) color0.rgb/=color0.a;if (color1.a > 0.0) color1.rgb/=color1.a;color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 out_color=color.rgb;\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(vec4(out_color,1.0),1.0).rgb;\n#endif\n#ifdef FOG\nhighp float fog_limit_high_meters=1000000.0;highp float fog_limit_low_meters=600000.0;float fog_limit=1.0-smoothstep(fog_limit_low_meters,fog_limit_high_meters,u_raster_elevation);out_color=fog_dither(fog_apply(out_color,v_fog_pos,fog_limit));\n#endif\nglFragColor=vec4(out_color*color.a,color.a);\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}", "#include \"_prelude_fog.vertex.glsl\"\nuniform mat4 u_matrix;uniform mat4 u_normalize_matrix;uniform mat4 u_globe_matrix;uniform mat4 u_merc_matrix;uniform mat3 u_grid_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_raster_elevation;uniform float u_zoom_transition;uniform vec2 u_merc_center;\n#define GLOBE_UPSCALE GLOBE_RADIUS/6371008.8\nin vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos0;out vec2 v_pos1;void main() {float w=1.0;vec2 uv;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 decomposed_pos_and_skirt=decomposeToPosAndSkirt(a_pos);vec3 latLng=u_grid_matrix*vec3(decomposed_pos_and_skirt.xy,1.0);float mercatorY=mercatorYfromLat(latLng[0]);float mercatorX=mercatorXfromLng(latLng[1]);float tiles=u_grid_matrix[0][2];float idx=u_grid_matrix[1][2];float idy=u_grid_matrix[2][2];float uvX=mercatorX*tiles-idx;float uvY=mercatorY*tiles-idy;uv=vec2(uvX,uvY);vec3 globe_pos=latLngToECEF(latLng.xy);globe_pos+=normalize(globe_pos)*u_raster_elevation*GLOBE_UPSCALE;vec4 globe_world_pos=u_globe_matrix*vec4(globe_pos,1.0);vec4 merc_world_pos=vec4(0.0);if (u_zoom_transition > 0.0) {vec2 merc_pos=vec2(mercatorX,mercatorY);merc_world_pos=vec4(merc_pos,u_raster_elevation,1.0);merc_world_pos.xy-=u_merc_center;merc_world_pos.x=wrap(merc_world_pos.x,-0.5,0.5);merc_world_pos=u_merc_matrix*merc_world_pos;}vec4 interpolated_pos=vec4(mix(globe_world_pos.xyz,merc_world_pos.xyz,u_zoom_transition)*w,w);gl_Position=u_matrix*interpolated_pos;\n#ifdef FOG\nv_fog_pos=fog_position((u_normalize_matrix*vec4(globe_pos,1.0)).xyz);\n#endif\n#else\nuv=a_texture_pos/8192.0;gl_Position=u_matrix*vec4(a_pos*w,u_raster_elevation*w,w);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n#endif\nv_pos0=uv;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}"),
				rasterParticleDraw: ss("uniform sampler2D u_color_ramp;in float v_particle_speed;void main() {glFragColor=texture(u_color_ramp,vec2(v_particle_speed,0.5));}", "#include \"_prelude_raster_particle.glsl\"\nin float a_index;uniform sampler2D u_particle_texture;uniform float u_particle_texture_side_len;uniform vec2 u_tile_offset;out float v_particle_speed;void main() {ivec2 pixel_coord=ivec2(\nmod(a_index,u_particle_texture_side_len),a_index/u_particle_texture_side_len);vec4 pixel=texelFetch(u_particle_texture,pixel_coord,0);vec2 pos=unpack_pos_from_rgba(pixel)+u_tile_offset;vec2 tex_coord=fract(pos);vec2 velocity=lookup_velocity(tex_coord);if (velocity==INVALID_VELOCITY) {gl_Position=AWAY;v_particle_speed=0.0;} else {gl_Position=vec4(2.0*pos-1.0,0,1);v_particle_speed=length(velocity);}gl_PointSize=1.0;}"),
				rasterParticleTexture: ss("uniform sampler2D u_texture;uniform float u_opacity;in vec2 v_tex_pos;void main() {vec4 color=texture(u_texture,v_tex_pos);glFragColor=vec4(floor(255.0*color*u_opacity)/255.0);}", "in vec2 a_pos;out vec2 v_tex_pos;void main() {vec2 uv=0.5*a_pos+vec2(0.5);v_tex_pos=uv;gl_Position=vec4(a_pos,0.0,1.0);}"),
				rasterParticleUpdate: ss("#include \"_prelude_raster_particle.glsl\"\nuniform sampler2D u_particle_texture;uniform mediump float u_particle_texture_side_len;uniform mediump float u_speed_factor;uniform highp float u_reset_rate;uniform highp float u_rand_seed;in highp vec2 v_tex_coord;vec2 linearstep(vec2 edge0,vec2 edge1,vec2 x) {return  clamp((x-edge0)/(edge1-edge0),vec2(0),vec2(1));}const highp vec3 rand_constants=vec3(12.9898,78.233,4375.85453);highp float rand(const highp vec2 co) {highp float t=dot(rand_constants.xy,co);return fract(sin(t)*(rand_constants.z+t));}void main() {ivec2 pixel_coord=ivec2(v_tex_coord*u_particle_texture_side_len);highp vec4 pixel=texelFetch(u_particle_texture,pixel_coord,0);highp vec2 pos=unpack_pos_from_rgba(pixel);highp vec2 velocity=lookup_velocity(clamp(pos,0.0,1.0));highp vec2 dp=velocity==INVALID_VELOCITY ? vec2(0) : velocity*u_speed_factor;pos=pos+dp;highp vec2 seed=(pos+v_tex_coord)*u_rand_seed;highp vec2 random_pos=vec2(rand(seed+1.3),rand(seed+2.1));highp vec2 persist_rate=pow(\nlinearstep(vec2(-u_particle_pos_offset),vec2(0),pos)*linearstep(vec2(1.0+u_particle_pos_offset),vec2(1),pos),vec2(4)\n);highp vec2 per_frame_persist=pow(persist_rate,abs(dp)/u_particle_pos_offset);highp float drop_rate=1.0-per_frame_persist.x*per_frame_persist.y;drop_rate=any(greaterThanEqual(abs(pos-0.5),vec2(0.5+u_particle_pos_offset))) ? 1.0 : drop_rate;highp float drop=step(1.0-drop_rate-u_reset_rate,rand(seed));highp vec2 next_pos=mix(pos,random_pos,drop);glFragColor=pack_pos_to_rgba(next_pos);}", "in vec2 a_pos;out vec2 v_tex_coord;void main() {v_tex_coord=0.5*(a_pos+vec2(1.0));gl_Position=vec4(a_pos,0.0,1.0);}"),
				symbol: ss("#include \"_prelude_lighting.glsl\"\n#include \"_prelude_shadow.fragment.glsl\"\n#define SDF_PX 8.0\n#define SDF 1.0\n#define ICON 0.0\nuniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;uniform bool u_is_halo;uniform lowp float u_scale_factor;\n#ifdef ICON_TRANSITION\nuniform float u_icon_transition;\n#endif\n#ifdef COLOR_ADJUSTMENT\nuniform mat4 u_color_adj_mat;\n#endif\n#ifdef INDICATOR_CUTOUT\nin highp float v_z_offset;\n#else\n#ifdef RENDER_SHADOWS\nin highp float v_z_offset;\n#endif\n#endif\nin vec2 v_tex_a;\n#ifdef ICON_TRANSITION\nin vec2 v_tex_b;\n#endif\nin float v_draw_halo;in vec3 v_gamma_scale_size_fade_opacity;\n#ifdef RENDER_TEXT_AND_SYMBOL\nin float is_sdf;in vec2 v_tex_a_icon;\n#endif\n#ifdef RENDER_SHADOWS\nuniform vec3 u_ground_shadow_factor;in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in highp float v_depth;\n#endif\n#ifdef APPLY_LUT_ON_GPU\nuniform highp sampler3D u_lutTexture;\n#endif\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\n#pragma mapbox: define lowp float emissive_strength\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\n#pragma mapbox: initialize lowp float emissive_strength\nvec4 out_color;float fade_opacity=v_gamma_scale_size_fade_opacity[2];\n#ifdef RENDER_TEXT_AND_SYMBOL\nif (is_sdf==ICON) {vec2 tex_icon=v_tex_a_icon;lowp float alpha=opacity*fade_opacity;glFragColor=texture(u_texture_icon,tex_icon)*alpha;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nreturn;}\n#endif\n#ifdef RENDER_SDF\nfloat EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_gamma_scale_size_fade_opacity.x;float size=v_gamma_scale_size_fade_opacity.y;float fontScale=u_is_text ? size/24.0 : size;out_color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;bool draw_halo=v_draw_halo > 0.0;if (draw_halo) {out_color=halo_color;gamma=(halo_blur*u_scale_factor*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width*u_scale_factor/fontScale)/SDF_PX;}lowp float dist=texture(u_texture,v_tex_a).r;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);out_color*=alpha;\n#else\n#ifdef ICON_TRANSITION\nvec4 a=texture(u_texture,v_tex_a)*(1.0-u_icon_transition);vec4 b=texture(u_texture,v_tex_b)*u_icon_transition;out_color=(a+b);\n#else\nout_color=texture(u_texture,v_tex_a);\n#endif\n#ifdef APPLY_LUT_ON_GPU\nout_color=applyLUT(u_lutTexture,out_color);\n#endif\n#ifdef COLOR_ADJUSTMENT\nout_color=u_color_adj_mat*out_color;\n#endif\n#endif\nout_color*=opacity*fade_opacity;\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,emissive_strength);\n#ifdef RENDER_SHADOWS\nfloat light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);\n#ifdef TERRAIN\nout_color.rgb*=mix(u_ground_shadow_factor,vec3(1.0),light);\n#else\nout_color.rgb*=mix(v_z_offset !=0.0 ? u_ground_shadow_factor : vec3(1.0),vec3(1.0),light);\n#endif\n#endif\n#endif\n#ifdef INDICATOR_CUTOUT\nout_color=applyCutout(out_color,v_z_offset);\n#endif\n#ifdef FEATURE_CUTOUT\nout_color=apply_feature_cutout(out_color,gl_FragCoord);\n#endif\nglFragColor=out_color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}", "#include \"_prelude_terrain.vertex.glsl\"\n#include \"_prelude_shadow.vertex.glsl\"\n#define APPEARANCE_ICON 1.0\nin vec4 a_pos_offset;in vec4 a_tex_size;in vec4 a_pixeloffset;in vec4 a_projected_pos;in float a_fade_opacity;\n#ifdef Z_OFFSET\nin float a_auto_z_offset;\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nin vec3 a_globe_anchor;in vec3 a_globe_normal;\n#endif\n#ifdef ICON_TRANSITION\nin vec2 a_texb;\n#endif\n#ifdef OCCLUSION_QUERIES\nin float a_occlusion_query_opacity;\n#endif\n#ifdef ELEVATED_ROADS\nin vec3 a_x_axis;in vec3 a_y_axis;uniform float u_normal_scale;\n#endif\n#ifdef INDICATOR_CUTOUT\nout highp float v_z_offset;\n#else\n#ifdef RENDER_SHADOWS\nout highp float v_z_offset;\n#endif\n#endif\nuniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_elevation_from_sea;uniform bool u_pitch_with_map;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec3 u_up_vector;uniform vec2 u_texsize_icon;uniform bool u_is_halo;\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_camera_forward;uniform float u_zoom_transition;uniform vec3 u_ecef_origin;uniform mat4 u_tile_matrix;\n#endif\nout vec2 v_tex_a;\n#ifdef ICON_TRANSITION\nout vec2 v_tex_b;\n#endif\nout float v_draw_halo;out vec3 v_gamma_scale_size_fade_opacity;\n#ifdef RENDER_TEXT_AND_SYMBOL\nout float is_sdf;out vec2 v_tex_a_icon;\n#endif\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out highp float v_depth;\n#endif\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\n#pragma mapbox: define lowp float emissive_strength\n#pragma mapbox: define lowp float occlusion_opacity\n#pragma mapbox: define lowp float z_offset\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\n#pragma mapbox: initialize lowp float emissive_strength\n#pragma mapbox: initialize lowp float occlusion_opacity\n#pragma mapbox: initialize lowp float z_offset\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);float a_size_max= floor(a_size[1]*0.5);float a_apperance_icon=a_size[1]-2.0*a_size_max;vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_min_font_scale=a_pixeloffset.zw/256.0;highp float segment_angle=-a_projected_pos[3];float size;if (a_apperance_icon==APPEARANCE_ICON) {size=a_size_max/128.0;} else if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size_max,u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 tile_anchor=a_pos;float e=u_elevation_from_sea ? z_offset : z_offset+elevation(tile_anchor);\n#ifdef Z_OFFSET\ne+=a_auto_z_offset;\n#endif\nvec3 h=elevationVector(tile_anchor)*e;float globe_occlusion_fade;vec3 world_pos;vec3 mercator_pos;vec3 world_pos_globe;\n#ifdef PROJECTION_GLOBE_VIEW\nmercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);world_pos_globe=a_globe_anchor+h;world_pos=mix_globe_mercator(world_pos_globe,mercator_pos,u_zoom_transition);vec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);vec3 origin_to_point=ecef_point.xyz-u_ecef_origin;globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;\n#else\nworld_pos=vec3(tile_anchor,0)+h;globe_occlusion_fade=1.0;\n#endif\nvec4 projected_point=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(\n0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float font_scale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetprojected_point;vec2 a;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 displacement=vec3(a_globe_normal.z,0,-a_globe_normal.x);offsetprojected_point=u_matrix*vec4(a_globe_anchor+displacement,1);vec4 projected_point_globe=u_matrix*vec4(world_pos_globe,1);a=projected_point_globe.xy/projected_point_globe.w;\n#else\noffsetprojected_point=u_matrix*vec4(tile_anchor+vec2(1,0),0,1);a=projected_point.xy/projected_point.w;\n#endif\nvec2 b=offsetprojected_point.xy/offsetprojected_point.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}vec4 projected_pos;\n#ifdef PROJECTION_GLOBE_VIEW\n#ifdef PROJECTED_POS_ON_VIEWPORT\nprojected_pos=u_label_plane_matrix*vec4(a_projected_pos.xyz+h,1.0);\n#else\nvec3 proj_pos=mix_globe_mercator(a_projected_pos.xyz,mercator_pos,u_zoom_transition)+h;projected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);    \n#endif\n#else\nprojected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h.z,1.0);\n#endif\nhighp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*max(a_min_font_scale,font_scale)+a_pxoffset/16.0);\n#ifdef TERRAIN\n#ifdef PITCH_WITH_MAP_TERRAIN\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);\n#endif\n#endif\n#ifdef Z_OFFSET\nz+=u_pitch_with_map ? a_auto_z_offset+z_offset : 0.0;\n#else\nz+=u_pitch_with_map ? z_offset : 0.0;\n#endif\nfloat occlusion_fade=globe_occlusion_fade;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float out_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change));\n#ifdef DEPTH_OCCLUSION\nfloat depth_occlusion=occlusionFadeMultiSample(projected_point);float depth_occlusion_multplier=mix(occlusion_opacity,1.0,depth_occlusion);out_fade_opacity*=depth_occlusion_multplier;\n#endif\n#ifdef OCCLUSION_QUERIES\nfloat occludedFadeMultiplier=mix(occlusion_opacity,1.0,a_occlusion_query_opacity);out_fade_opacity*=occludedFadeMultiplier;\n#endif\n#ifdef Z_TEST_OCCLUSION\nout_fade_opacity*=occlusion_opacity;\n#endif\nfloat alpha=opacity*out_fade_opacity;float hidden=float(alpha==0.0 || projected_point.w <=0.0 || occlusion_fade==0.0);vec3 pos;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 xAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,u_up_vector)) : vec3(1,0,0);vec3 yAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,xAxis)) : vec3(0,1,0);pos=projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y;\n#else\n#ifdef ELEVATED_ROADS\nvec3 xAxis=vec3(a_x_axis.xy,a_x_axis.z*u_normal_scale);vec3 yAxis=vec3(a_y_axis.xy,a_y_axis.z*u_normal_scale);pos=projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y;\n#else\npos=vec3(projected_pos.xy/projected_pos.w+offset,z);\n#endif\n#endif\ngl_Position=mix(u_coord_matrix*vec4(pos,1.0),AWAY,hidden);float gamma_scale=gl_Position.w;v_draw_halo=(u_is_halo && float(gl_InstanceID)==0.0) ? 1.0 : 0.0;v_gamma_scale_size_fade_opacity=vec3(gamma_scale,size,out_fade_opacity);v_tex_a=a_tex/u_texsize;\n#ifdef RENDER_TEXT_AND_SYMBOL\nis_sdf=a_size[0]-2.0*a_size_min;v_tex_a_icon=a_tex/u_texsize_icon;\n#endif\n#ifdef ICON_TRANSITION\nv_tex_b=a_texb/u_texsize;\n#endif\n#ifdef RENDER_SHADOWS\nvec4 shd_pos=u_inv_matrix*vec4(pos,1.0);vec3 shd_pos0=shd_pos.xyz;vec3 shd_pos1=shd_pos.xyz;\n#ifdef NORMAL_OFFSET\nvec3 shd_pos_offset=shadow_normal_offset(vec3(0.0,0.0,1.0));shd_pos0+=shd_pos_offset*shadow_normal_offset_multiplier0();shd_pos1+=shd_pos_offset*shadow_normal_offset_multiplier1();\n#endif\nv_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;\n#endif\n#ifdef INDICATOR_CUTOUT\nv_z_offset=e;\n#else\n#ifdef RENDER_SHADOWS\nv_z_offset=e;\n#endif\n#endif\n}"),
				terrainRaster: ss("#include \"_prelude_fog.fragment.glsl\"\n#include \"_prelude_shadow.fragment.glsl\"\n#include \"_prelude_lighting.glsl\"\nuniform sampler2D u_image0;\n#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS\nuniform sampler2D u_image1;uniform float u_emissive_texture_available;\n#endif\nin vec2 v_pos0;\n#ifdef FOG\nin float v_fog_opacity;\n#endif\n#ifdef RENDER_SHADOWS\nin vec4 v_pos_light_view_0;in vec4 v_pos_light_view_1;\n#endif\nuniform vec3 u_ground_shadow_factor;void main() {vec4 image_color=texture(u_image0,v_pos0);vec4 color;\n#ifdef LIGHTING_3D_MODE\nconst vec3 normal=vec3(0.0,0.0,1.0);\n#ifdef RENDER_SHADOWS\nfloat cutoffOpacity=1.0;\n#ifdef RENDER_CUTOFF\ncutoffOpacity=cutoff_opacity(u_cutoff_params,1.0/gl_FragCoord.w);\n#endif\n#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS\nfloat emissive_strength=u_emissive_texture_available > 0.5 ? texture(u_image1,v_pos0).r : image_color.a;vec3 unlit_base=image_color.rgb*(1.0-emissive_strength);vec3 emissive_base=image_color.rgb*emissive_strength;float ndotl=u_shadow_direction.z;float occlusion=ndotl < 0.0 ? 1.0 : shadow_occlusion(v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w,0.0);ndotl=max(0.0,ndotl);vec3 lit=apply_lighting(unlit_base,normal,mix(1.0,(1.0-(u_shadow_intensity*occlusion))*ndotl,cutoffOpacity));vec3 emissive=compute_emissive_draped(emissive_base,1.0-u_shadow_intensity,occlusion,u_ground_shadow_factor);color.rgb=lit+emissive;color.a=1.0;\n#else\nfloat lighting_factor=shadowed_light_factor_normal_unbiased(normal,v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w);color=apply_lighting(image_color,normal,mix(1.0,lighting_factor,cutoffOpacity));\n#endif\n#else\nfloat lighting_factor=u_lighting_directional_dir.z;color=apply_lighting(image_color,normal,lighting_factor);\n#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS\nfloat emissive_strength=u_emissive_texture_available > 0.5 ? texture(u_image1,v_pos0).r : image_color.a;color.rgb=mix(color.rgb,image_color.rgb,emissive_strength);color.a=1.0;\n#endif\n#endif\n#else\ncolor=image_color;\n#endif\n#ifdef FOG\n#ifdef ZERO_EXAGGERATION\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#else\ncolor=fog_dither(fog_apply_from_vert(color,v_fog_opacity));\n#endif\n#endif\nglFragColor=color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}", "#include \"_prelude_fog.vertex.glsl\"\n#include \"_prelude_terrain.vertex.glsl\"\nuniform mat4 u_matrix;uniform float u_skirt_height;in vec2 a_pos;out vec2 v_pos0;\n#ifdef FOG\nout float v_fog_opacity;\n#endif\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out vec4 v_pos_light_view_0;out vec4 v_pos_light_view_1;\n#endif\nvoid main() {vec3 decomposedPosAndSkirt=decomposeToPosAndSkirt(a_pos);float skirt=decomposedPosAndSkirt.z;vec2 decodedPos=decomposedPosAndSkirt.xy;float elevation=elevation(decodedPos)-skirt*u_skirt_height;v_pos0=decodedPos/8192.0;gl_Position=u_matrix*vec4(decodedPos,elevation,1.0);\n#ifdef FOG\n#ifdef ZERO_EXAGGERATION\nv_fog_pos=fog_position(decodedPos);\n#else\nv_fog_opacity=fog(fog_position(vec3(decodedPos,elevation)));\n#endif\n#endif\n#ifdef RENDER_SHADOWS\nvec3 pos=vec3(decodedPos,elevation);v_pos_light_view_0=u_light_matrix_0*vec4(pos,1.);v_pos_light_view_1=u_light_matrix_1*vec4(pos,1.);\n#endif\n}"),
				terrainDepth: ss("precision highp float;in float v_depth;void main() {glFragColor=pack_depth(v_depth);}", "#include \"_prelude_terrain.vertex.glsl\"\nuniform mat4 u_matrix;in vec2 a_pos;out float v_depth;void main() {float elevation=elevation(a_pos);gl_Position=u_matrix*vec4(a_pos,elevation,1.0);v_depth=gl_Position.z/gl_Position.w;}"),
				skybox: ss("#include \"_prelude_fog.fragment.glsl\"\nin lowp vec3 v_uv;uniform lowp samplerCube u_cubemap;uniform lowp float u_opacity;uniform highp float u_temporal_offset;uniform highp vec3 u_sun_direction;float sun_disk(highp vec3 ray_direction,highp vec3 sun_direction) {highp float cos_angle=dot(normalize(ray_direction),sun_direction);const highp float cos_sun_angular_diameter=0.99996192306;const highp float smoothstep_delta=1e-5;return smoothstep(\ncos_sun_angular_diameter-smoothstep_delta,cos_sun_angular_diameter+smoothstep_delta,cos_angle);}float map(float value,float start,float end,float new_start,float new_end) {return ((value-start)*(new_end-new_start))/(end-start)+new_start;}void main() {vec3 uv=v_uv;const float y_bias=0.015;uv.y+=y_bias;uv.y=pow(abs(uv.y),1.0/5.0);uv.y=map(uv.y,0.0,1.0,-1.0,1.0);vec3 sky_color=texture(u_cubemap,uv).rgb;\n#ifdef FOG\nsky_color=fog_apply_sky_gradient(v_uv.xzy,sky_color);\n#endif\nsky_color+=0.1*sun_disk(v_uv,u_sun_direction);glFragColor=vec4(sky_color*u_opacity,u_opacity);\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\n}", Bo),
				skyboxGradient: ss("#include \"_prelude_fog.fragment.glsl\"\nin highp vec3 v_uv;uniform lowp sampler2D u_color_ramp;uniform highp vec3 u_center_direction;uniform lowp float u_radius;uniform lowp float u_opacity;uniform highp float u_temporal_offset;void main() {float progress=acos(dot(normalize(v_uv),u_center_direction))/u_radius;vec4 color=texture(u_color_ramp,vec2(progress,0.5));\n#ifdef FOG\ncolor.rgb=fog_apply_sky_gradient(v_uv.xzy,color.rgb/color.a)*color.a;\n#endif\ncolor*=u_opacity;glFragColor=color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\n}", Bo),
				skyboxCapture: ss("\nin highp vec3 v_position;uniform highp float u_sun_intensity;uniform highp float u_luminance;uniform lowp vec3 u_sun_direction;uniform highp vec4 u_color_tint_r;uniform highp vec4 u_color_tint_m;precision highp float;\n#define BETA_R                  vec3(5.5e-6,13.0e-6,22.4e-6)\n#define BETA_M                  vec3(21e-6,21e-6,21e-6)\n#define MIE_G                   0.76\n#define DENSITY_HEIGHT_SCALE_R  8000.0\n#define DENSITY_HEIGHT_SCALE_M  1200.0\n#define PLANET_RADIUS           6360e3\n#define ATMOSPHERE_RADIUS       6420e3\n#define SAMPLE_STEPS            10\n#define DENSITY_STEPS           4\nfloat ray_sphere_exit(vec3 orig,vec3 dir,float radius) {float a=dot(dir,dir);float b=2.0*dot(dir,orig);float c=dot(orig,orig)-radius*radius;float d=sqrt(b*b-4.0*a*c);return (-b+d)/(2.0*a);}vec3 extinction(vec2 density) {return exp(-vec3(BETA_R*u_color_tint_r.a*density.x+BETA_M*u_color_tint_m.a*density.y));}vec2 local_density(vec3 point) {float height=max(length(point)-PLANET_RADIUS,0.0);float exp_r=exp(-height/DENSITY_HEIGHT_SCALE_R);float exp_m=exp(-height/DENSITY_HEIGHT_SCALE_M);return vec2(exp_r,exp_m);}float phase_ray(float cos_angle) {return (3.0/(16.0*PI))*(1.0+cos_angle*cos_angle);}float phase_mie(float cos_angle) {return (3.0/(8.0*PI))*((1.0-MIE_G*MIE_G)*(1.0+cos_angle*cos_angle))/((2.0+MIE_G*MIE_G)*pow(1.0+MIE_G*MIE_G-2.0*MIE_G*cos_angle,1.5));}vec2 density_to_atmosphere(vec3 point,vec3 light_dir) {float ray_len=ray_sphere_exit(point,light_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(DENSITY_STEPS);vec2 density_point_to_atmosphere=vec2(0.0);for (int i=0; i < DENSITY_STEPS;++i) {vec3 point_on_ray=point+light_dir*((float(i)+0.5)*step_len);density_point_to_atmosphere+=local_density(point_on_ray)*step_len;;}return density_point_to_atmosphere;}vec3 atmosphere(vec3 ray_dir,vec3 sun_direction,float sun_intensity) {vec2 density_orig_to_point=vec2(0.0);vec3 scatter_r=vec3(0.0);vec3 scatter_m=vec3(0.0);vec3 origin=vec3(0.0,PLANET_RADIUS,0.0);float ray_len=ray_sphere_exit(origin,ray_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(SAMPLE_STEPS);for (int i=0; i < SAMPLE_STEPS;++i) {vec3 point_on_ray=origin+ray_dir*((float(i)+0.5)*step_len);vec2 density=local_density(point_on_ray)*step_len;density_orig_to_point+=density;vec2 density_point_to_atmosphere=density_to_atmosphere(point_on_ray,sun_direction);vec2 density_orig_to_atmosphere=density_orig_to_point+density_point_to_atmosphere;vec3 extinction=extinction(density_orig_to_atmosphere);scatter_r+=density.x*extinction;scatter_m+=density.y*extinction;}float cos_angle=dot(ray_dir,sun_direction);float phase_r=phase_ray(cos_angle);float phase_m=phase_mie(cos_angle);vec3 beta_r=BETA_R*u_color_tint_r.rgb*u_color_tint_r.a;vec3 beta_m=BETA_M*u_color_tint_m.rgb*u_color_tint_m.a;return (scatter_r*phase_r*beta_r+scatter_m*phase_m*beta_m)*sun_intensity;}const float A=0.15;const float B=0.50;const float C=0.10;const float D=0.20;const float E=0.02;const float F=0.30;vec3 uncharted2_tonemap(vec3 x) {return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;}void main() {vec3 ray_direction=v_position;ray_direction.y=pow(ray_direction.y,5.0);const float y_bias=0.015;ray_direction.y+=y_bias;vec3 color=atmosphere(normalize(ray_direction),u_sun_direction,u_sun_intensity);float white_scale=1.0748724675633854;color=uncharted2_tonemap((log2(2.0/pow(u_luminance,4.0)))*color)*white_scale;glFragColor=vec4(color,1.0);}", "in highp vec3 a_pos_3f;uniform mat3 u_matrix_3f;out highp vec3 v_position;float map(float value,float start,float end,float new_start,float new_end) {return ((value-start)*(new_end-new_start))/(end-start)+new_start;}void main() {vec4 pos=vec4(u_matrix_3f*a_pos_3f,1.0);v_position=pos.xyz;v_position.y*=-1.0;v_position.y=map(v_position.y,-1.0,1.0,0.0,1.0);gl_Position=vec4(a_pos_3f.xy,0.0,1.0);}"),
				globeRaster: ss("#include \"_prelude_fog.fragment.glsl\"\n#include \"_prelude_lighting.glsl\"\nuniform sampler2D u_image0;\n#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS\nuniform sampler2D u_image1;uniform float u_emissive_texture_available;\n#endif\nuniform float u_far_z_cutoff;in vec2 v_pos0;\n#ifndef FOG\nuniform highp vec3 u_frustum_tl;uniform highp vec3 u_frustum_tr;uniform highp vec3 u_frustum_br;uniform highp vec3 u_frustum_bl;uniform highp vec3 u_globe_pos;uniform highp float u_globe_radius;uniform vec2 u_viewport;\n#endif\nvoid main() {vec4 color;\n#ifdef CUSTOM_ANTIALIASING\nhighp vec2 uv=gl_FragCoord.xy/u_viewport;\n#ifdef FLIP_Y\nuv.y=1.0-uv.y;\n#endif\nhighp vec3 ray_dir=mix(\nmix(u_frustum_tl,u_frustum_tr,uv.x),mix(u_frustum_bl,u_frustum_br,uv.x),1.0-uv.y);highp vec3 dir=normalize(ray_dir);highp vec3 closest_point=dot(u_globe_pos,dir)*dir;highp float norm_dist_from_center=1.0-length(closest_point-u_globe_pos)/u_globe_radius;const float antialias_pixel=2.0;highp float antialias_factor=antialias_pixel*fwidth(norm_dist_from_center);highp float antialias=smoothstep(0.0,antialias_factor,norm_dist_from_center);vec4 raster=texture(u_image0,v_pos0);\n#ifdef LIGHTING_3D_MODE\n#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS\nfloat emissive_strength=u_emissive_texture_available > 0.5 ? texture(u_image1,v_pos0).r : raster.a;raster=apply_lighting_with_emission_ground(raster,emissive_strength);color=vec4(clamp(raster.rgb,vec3(0),vec3(1))*antialias,antialias);\n#else\nraster=apply_lighting_ground(raster);color=vec4(raster.rgb*antialias,raster.a*antialias);\n#endif\n#else\ncolor=vec4(raster.rgb*antialias,raster.a*antialias);\n#endif\n#else\ncolor=texture(u_image0,v_pos0);\n#ifdef LIGHTING_3D_MODE\n#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS\nfloat emissive_strength=u_emissive_texture_available > 0.5 ? texture(u_image1,v_pos0).r : color.a;color=apply_lighting_with_emission_ground(color,emissive_strength);color.a=1.0;\n#else\ncolor=apply_lighting_ground(color);\n#endif\n#endif\n#endif\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#endif\ncolor*=1.0-step(u_far_z_cutoff,1.0/gl_FragCoord.w);glFragColor=color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}", "#include \"_prelude_fog.vertex.glsl\"\n#include \"_prelude_terrain.vertex.glsl\"\nuniform mat4 u_proj_matrix;uniform mat4 u_normalize_matrix;uniform mat4 u_globe_matrix;uniform mat4 u_merc_matrix;uniform float u_zoom_transition;uniform vec2 u_merc_center;uniform mat3 u_grid_matrix;uniform float u_skirt_height;\n#ifdef GLOBE_POLES\nin vec3 a_globe_pos;in vec2 a_uv;\n#else\nin vec2 a_pos;\n#endif\nout vec2 v_pos0;void main() {\n#ifdef GLOBE_POLES\nvec3 globe_pos=a_globe_pos;vec2 uv=a_uv;\n#else\nfloat tiles=u_grid_matrix[0][2];float idx=u_grid_matrix[1][2];float idy=u_grid_matrix[2][2];vec3 decomposed_pos_and_skirt=decomposeToPosAndSkirt(a_pos);vec3 latLng=u_grid_matrix*vec3(decomposed_pos_and_skirt.xy,1.0);float mercatorY=mercatorYfromLat(latLng[0]);float uvY=mercatorY*tiles-idy;float mercatorX=mercatorXfromLng(latLng[1]);float uvX=mercatorX*tiles-idx;vec3 globe_pos=latLngToECEF(latLng.xy);vec2 merc_pos=vec2(mercatorX,mercatorY);vec2 uv=vec2(uvX,uvY);\n#endif\nv_pos0=uv;vec2 tile_pos=uv*EXTENT;vec3 globe_derived_up_vector=normalize(globe_pos)*u_tile_up_scale;\n#ifdef GLOBE_POLES\nvec3 up_vector=globe_derived_up_vector;\n#else\nvec3 up_vector=elevationVector(tile_pos);\n#endif\nfloat height=elevation(tile_pos);globe_pos+=up_vector*height;\n#ifndef GLOBE_POLES\nglobe_pos-=globe_derived_up_vector*u_skirt_height*decomposed_pos_and_skirt.z;\n#endif\n#ifdef GLOBE_POLES\nvec4 interpolated_pos=u_globe_matrix*vec4(globe_pos,1.0);\n#else\nvec4 globe_world_pos=u_globe_matrix*vec4(globe_pos,1.0);vec4 merc_world_pos=vec4(0.0);if (u_zoom_transition > 0.0) {merc_world_pos=vec4(merc_pos,height-u_skirt_height*decomposed_pos_and_skirt.z,1.0);merc_world_pos.xy-=u_merc_center;merc_world_pos.x=wrap(merc_world_pos.x,-0.5,0.5);merc_world_pos=u_merc_matrix*merc_world_pos;}vec4 interpolated_pos=vec4(mix(globe_world_pos.xyz,merc_world_pos.xyz,u_zoom_transition),1.0);\n#endif\ngl_Position=u_proj_matrix*interpolated_pos;\n#ifdef FOG\nv_fog_pos=fog_position((u_normalize_matrix*vec4(globe_pos,1.0)).xyz);\n#endif\n}"),
				globeAtmosphere: ss("#include \"_prelude_fog.fragment.glsl\"\nuniform float u_transition;uniform highp float u_fadeout_range;uniform highp float u_temporal_offset;uniform vec4 u_atmosphere_fog_color;uniform vec4 u_high_color;uniform vec4 u_space_color;uniform float u_horizon_angle;in highp vec3 v_ray_dir;in highp vec3 v_horizon_dir;void main() {highp vec3 dir=normalize(v_ray_dir);float globe_pos_dot_dir;\n#ifdef PROJECTION_GLOBE_VIEW\nglobe_pos_dot_dir=dot(u_globe_pos,dir);highp vec3 closest_point_forward=abs(globe_pos_dot_dir)*dir;float norm_dist_from_center=length(closest_point_forward-u_globe_pos)/u_globe_radius;if (norm_dist_from_center < 0.98) {\n#ifdef ALPHA_PASS\nglFragColor=vec4(0,0,0,0);return;\n#else\n#ifdef NATIVE\nglFragColor=vec4(1,1,1,1);\n#else\nglFragColor=vec4(0,0,0,1);\n#endif\nreturn;\n#endif\n}\n#endif\nhighp vec3 horizon_dir=normalize(v_horizon_dir);float horizon_angle_mercator=dir.y < horizon_dir.y ?\n0.0 : max(acos(clamp(dot(dir,horizon_dir),-1.0,1.0)),0.0);float horizon_angle;\n#ifdef PROJECTION_GLOBE_VIEW\nhighp vec3 closest_point=globe_pos_dot_dir*dir;highp float closest_point_to_center=length(closest_point-u_globe_pos);highp float theta=asin(clamp(closest_point_to_center/length(u_globe_pos),-1.0,1.0));horizon_angle=globe_pos_dot_dir < 0.0 ?\nPI-theta-u_horizon_angle : theta-u_horizon_angle;float angle_t=pow(u_transition,10.0);horizon_angle=mix(horizon_angle,horizon_angle_mercator,angle_t);\n#else\nhorizon_angle=horizon_angle_mercator;\n#endif\nhorizon_angle/=PI;float t=exp(-horizon_angle/u_fadeout_range);float alpha_0=u_atmosphere_fog_color.a;float alpha_1=u_high_color.a;float alpha_2=u_space_color.a;vec3 color_stop_0=u_atmosphere_fog_color.rgb;vec3 color_stop_1=u_high_color.rgb;vec3 color_stop_2=u_space_color.rgb;\n#ifdef ALPHA_PASS\nfloat a0=mix(alpha_2,1.0,alpha_1);float a1=mix(a0,1.0,alpha_0);float a2=mix(a0,a1,t);float a =mix(alpha_2,a2,t);glFragColor=vec4(1.0,1.0,1.0,a);\n#else\nvec3 c0=mix(color_stop_2,color_stop_1,alpha_1);vec3 c1=mix(c0,color_stop_0,alpha_0);vec3 c2=mix(c0,c1,t);vec3 c=c2;glFragColor=vec4(c*t,t);\n#endif\n}", "in vec3 a_pos;in vec2 a_uv;uniform vec3 u_frustum_tl;uniform vec3 u_frustum_tr;uniform vec3 u_frustum_br;uniform vec3 u_frustum_bl;uniform float u_horizon;out highp vec3 v_ray_dir;out highp vec3 v_horizon_dir;void main() {v_ray_dir=mix(\nmix(u_frustum_tl,u_frustum_tr,a_uv.x),mix(u_frustum_bl,u_frustum_br,a_uv.x),a_uv.y);v_horizon_dir=mix(\nmix(u_frustum_tl,u_frustum_bl,u_horizon),mix(u_frustum_tr,u_frustum_br,u_horizon),a_uv.x);gl_Position=vec4(a_pos,1.0);}"),
				model: ss("#include \"_prelude_fog.fragment.glsl\"\n#include \"_prelude_shadow.fragment.glsl\"\n#include \"_prelude_lighting.glsl\"\nuniform float u_opacity;uniform vec3 u_lightcolor;uniform vec3 u_lightpos;uniform float u_lightintensity;uniform vec4 u_baseColorFactor;uniform vec4 u_emissiveFactor;uniform float u_metallicFactor;uniform float u_roughnessFactor;uniform float u_emissive_strength;in highp vec4 v_position_height;in lowp vec4 v_color_mix;\n#ifdef RENDER_SHADOWS\nin highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in float v_depth_shadows;\n#endif\n#ifdef OCCLUSION_TEXTURE_TRANSFORM\nuniform vec4 u_occlusionTextureTransform;\n#endif\n#pragma mapbox: define-attribute highp vec3 normal_3f\n#pragma mapbox: define-attribute highp vec3 color_3f\n#pragma mapbox: define-attribute highp vec4 color_4f\n#pragma mapbox: define-attribute highp vec2 uv_2f\n#pragma mapbox: initialize-attribute highp vec3 normal_3f\n#pragma mapbox: initialize-attribute highp vec3 color_3f\n#pragma mapbox: initialize-attribute highp vec4 color_4f\n#pragma mapbox: initialize-attribute highp vec2 uv_2f\n#ifdef HAS_ATTRIBUTE_a_pbr\nin lowp vec4 v_roughness_metallic_emissive_alpha;in mediump vec4 v_height_based_emission_params;\n#endif\n#ifdef HAS_TEXTURE_u_baseColorTexture\nuniform sampler2D u_baseColorTexture;uniform bool u_baseTextureIsAlpha;uniform bool u_alphaMask;uniform float u_alphaCutoff;\n#endif\n#ifdef HAS_TEXTURE_u_metallicRoughnessTexture\nuniform sampler2D u_metallicRoughnessTexture;\n#endif\n#ifdef HAS_TEXTURE_u_occlusionTexture\nuniform sampler2D u_occlusionTexture;uniform float u_aoIntensity;\n#endif\n#ifdef HAS_TEXTURE_u_normalTexture\nuniform sampler2D u_normalTexture;\n#endif\n#ifdef HAS_TEXTURE_u_emissionTexture\nuniform sampler2D u_emissionTexture;\n#endif\n#ifdef APPLY_LUT_ON_GPU\nuniform highp sampler3D u_lutTexture;\n#endif\n#ifdef TERRAIN_FRAGMENT_OCCLUSION\nin highp float v_depth;uniform highp sampler2D u_depthTexture;uniform highp vec2 u_inv_depth_size;uniform highp vec2 u_depth_range_unpack;\n#ifdef DEPTH_D24\nhighp float unpack_depth(highp float depth) {return  depth*u_depth_range_unpack.x+u_depth_range_unpack.y;}\n#else\nhighp float unpack_depth_rgba(highp vec4 rgba_depth)\n{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}\n#endif\nbool isOccluded() {highp vec2 coord=gl_FragCoord.xy*u_inv_depth_size;\n#ifdef FLIP_Y\ncoord.y=1.0-coord.y;\n#endif\n#ifdef DEPTH_D24\nhighp float depth=unpack_depth(texture(u_depthTexture,coord).r);\n#else\nhighp float depth=unpack_depth_rgba(texture(u_depthTexture,coord));\n#endif\nreturn v_depth > depth+0.0005;}\n#endif\n#define saturate(_x) clamp(_x,0.,1.)\nvec3 linearTosRGB(vec3 color) {return pow(color,vec3(1./2.2));}vec3 sRGBToLinear(vec3 srgbIn) {return pow(srgbIn,vec3(2.2));}float calculate_NdotL(vec3 normal,vec3 lightDir) {const float ext=0.70710678118;return (clamp(dot(normal,lightDir),-ext,1.0)+ext)/(1.0+ext);}vec3 getDiffuseShadedColor(vec3 albedo,vec3 normal,vec3 lightDir,vec3 lightColor)\n{\n#ifdef LIGHTING_3D_MODE\nvec3 transformed_normal=vec3(-normal.xy,normal.z);float lighting_factor;\n#ifdef RENDER_SHADOWS\nlighting_factor=shadowed_light_factor_normal(transformed_normal,v_pos_light_view_0,v_pos_light_view_1,v_depth_shadows);\n#else\nlighting_factor=saturate(dot(transformed_normal,u_lighting_directional_dir));\n#endif\nreturn apply_lighting(albedo,transformed_normal,lighting_factor);\n#else\nvec3 n=normal;float colorvalue=((albedo.x*0.2126)+(albedo.y*0.7152))+(albedo.z*0.0722);vec3 c=vec3(0.03,0.03,0.03);float directional=clamp(dot(n,vec3(lightDir)),0.0,1.0);directional=mix(1.0-u_lightintensity,max((1.0-colorvalue)+u_lightintensity,1.0),directional);vec3 c3=c+clamp((albedo*directional)*lightColor,mix(vec3(0.0),vec3(0.3),vec3(1.0)-lightColor),vec3(1.0));return c3;\n#endif\n}vec4 getBaseColor() {vec4 albedo=u_baseColorFactor;\n#ifdef HAS_ATTRIBUTE_a_color_3f\nalbedo*=vec4(color_3f,1.0);\n#endif\n#ifdef HAS_ATTRIBUTE_a_pbr\n#else\n#ifdef HAS_ATTRIBUTE_a_color_4f\nalbedo*=color_4f;\n#endif\n#endif\n#if defined (HAS_TEXTURE_u_baseColorTexture) && defined (HAS_ATTRIBUTE_a_uv_2f)\nvec4 texColor=texture(u_baseColorTexture,uv_2f);if(u_alphaMask) {if (texColor.w < u_alphaCutoff) {discard;}}\n#ifdef UNPREMULT_TEXTURE_IN_SHADER\nif(texColor.w > 0.0) {texColor.rgb/=texColor.w;}texColor.w=1.0;\n#endif\nif(u_baseTextureIsAlpha) {if (texColor.r < 0.5) {discard;}} else {texColor.rgb=sRGBToLinear(texColor.rgb);albedo*=texColor;}\n#endif\nvec4 color=vec4(mix(albedo.rgb,v_color_mix.rgb,v_color_mix.a),albedo.a);\n#ifdef APPLY_LUT_ON_GPU\ncolor=applyLUT(u_lutTexture,color);\n#endif\nreturn color;}highp mat3 cotangentFrame(highp vec3 N,highp vec3 p,highp vec2 uv ) {\n#ifdef HAS_TEXTURE_u_normalTexture\nhighp vec3 dp1=vec3(dFdx(p.x),dFdx(p.y),dFdx(p.z));highp vec3 dp2=vec3(dFdy(p.x),dFdy(p.y),dFdy(p.z));highp vec2 duv1=vec2(dFdx(uv.x),dFdx(uv.y));highp vec2 duv2=vec2(dFdy(uv.x),dFdy(uv.y));highp vec3 dp2perp=cross( dp2,N );highp vec3 dp1perp=cross( N,dp1 );highp vec3 T=dp2perp*duv1.x+dp1perp*duv2.x;highp vec3 B=dp2perp*duv1.y+dp1perp*duv2.y;\n#ifdef FLIP_Y\nT=-T;B=-B;\n#endif\nhighp float lengthT=dot(T,T);highp float lengthB=dot(B,B);highp float maxLength=max(lengthT,lengthB);highp float invmax=inversesqrt( maxLength );highp mat3 res=mat3( T*invmax,B*invmax,N );return res;\n#else\nreturn mat3(1.0);\n#endif\n}highp vec3 getNormal(){highp vec3 n;\n#ifdef HAS_ATTRIBUTE_a_normal_3f\nn=normalize(normal_3f);\n#else\nhighp vec3 fdx=vec3(dFdx(v_position_height.x),dFdx(v_position_height.y),dFdx(v_position_height.z));highp vec3 fdy=vec3(dFdy(v_position_height.x),dFdy(v_position_height.y),dFdy(v_position_height.z));\n#ifdef FLIP_Y\nn=normalize(cross(fdx,fdy));\n#else\nn=normalize(cross(fdx,fdy))*-1.0;\n#endif\n#endif\n#if defined(HAS_TEXTURE_u_normalTexture) && defined(HAS_ATTRIBUTE_a_uv_2f)\nvec3 nMap=texture( u_normalTexture,uv_2f).xyz;nMap=normalize(2.0*nMap-vec3(1.0));highp vec3 v=normalize(-v_position_height.xyz);highp mat3 TBN=cotangentFrame(n,v,uv_2f);n=normalize(TBN*nMap);\n#endif\nreturn n;}struct Material {float perceptualRoughness;float alphaRoughness;float metallic;vec3 f90;vec4 baseColor;vec3 diffuseColor;vec3 specularColor;highp vec3 normal;};Material getPBRMaterial() {Material mat;mat.baseColor=getBaseColor();mat.perceptualRoughness=u_roughnessFactor;mat.metallic=u_metallicFactor;\n#ifdef HAS_ATTRIBUTE_a_pbr\nmat.perceptualRoughness=v_roughness_metallic_emissive_alpha.x;mat.metallic=v_roughness_metallic_emissive_alpha.y;mat.baseColor.w*=v_roughness_metallic_emissive_alpha.w;\n#endif\n#if defined(HAS_TEXTURE_u_metallicRoughnessTexture) && defined(HAS_ATTRIBUTE_a_uv_2f) \nvec4 mrSample=texture(u_metallicRoughnessTexture,uv_2f);mat.perceptualRoughness*=mrSample.g;mat.metallic*=mrSample.b;\n#endif\nconst float c_minRoughness=0.04;mat.perceptualRoughness=clamp(mat.perceptualRoughness,c_minRoughness,1.0);mat.metallic=saturate(mat.metallic);mat.alphaRoughness=mat.perceptualRoughness*mat.perceptualRoughness;const vec3 f0=vec3(0.04);mat.diffuseColor=mat.baseColor.rgb*(vec3(1.0)-f0);mat.diffuseColor*=1.0-mat.metallic;mat.specularColor=mix(f0,mat.baseColor.rgb,mat.metallic);highp float reflectance=max(max(mat.specularColor.r,mat.specularColor.g),mat.specularColor.b);highp float reflectance90=saturate(reflectance*25.0);mat.f90=vec3(reflectance90);mat.normal=getNormal();return mat;}float V_GGX(float NdotL,float NdotV,float roughness)\n{float a2=roughness*roughness;float GGXV=NdotL*sqrt(NdotV*NdotV*(1.0-a2)+a2);float GGXL=NdotV*sqrt(NdotL*NdotL*(1.0-a2)+a2);return 0.5/(GGXV+GGXL);}float V_GGXFast(float NdotL,float NdotV,float roughness) {float a=roughness;float GGXV=NdotL*(NdotV*(1.0-a)+a);float GGXL=NdotV*(NdotL*(1.0-a)+a);return 0.5/(GGXV+GGXL);}vec3 F_Schlick(vec3 specularColor,vec3 f90,float VdotH)\n{return specularColor+(f90-specularColor)*pow(clamp(1.0-VdotH,0.0,1.0),5.0);}vec3 F_SchlickFast(vec3 specularColor,float VdotH)\n{float x=1.0-VdotH;float x4=x*x*x*x;return specularColor+(1.0-specularColor)*x4*x;}float D_GGX(highp float NdotH,float alphaRoughness)\n{highp float a4=alphaRoughness*alphaRoughness;highp float f=(NdotH*a4-NdotH)*NdotH+1.0;return a4/(PI*f*f);}vec3 diffuseBurley(Material mat,float LdotH,float NdotL,float NdotV)\n{float f90=2.0*LdotH*LdotH*mat.alphaRoughness-0.5;return (mat.diffuseColor/PI)*(1.0+f90*pow((1.0-NdotL),5.0))*(1.0+f90*pow((1.0-NdotV),5.0));}vec3 diffuseLambertian(Material mat)\n{\n#ifdef LIGHTING_3D_MODE\nreturn mat.diffuseColor;\n#else\nreturn mat.diffuseColor/PI;\n#endif\n}vec3 EnvBRDFApprox(vec3 specularColor,float roughness,highp float NdotV)\n{vec4 c0=vec4(-1,-0.0275,-0.572,0.022);vec4 c1=vec4(1,0.0425,1.04,-0.04);highp vec4 r=roughness*c0+c1;highp float a004=min(r.x*r.x,exp2(-9.28*NdotV))*r.x+r.y;vec2 AB=vec2(-1.04,1.04)*a004+r.zw;return specularColor*AB.x+AB.y;}vec3 computeIndirectLightContribution(Material mat,float NdotV,vec3 normal)\n{vec3 env_light=vec3(0.65,0.65,0.65);\n#ifdef LIGHTING_3D_MODE\nfloat ambient_factor=calculate_ambient_directional_factor(normal);env_light=u_lighting_ambient_color*ambient_factor;\n#endif\nvec3 envBRDF=EnvBRDFApprox(mat.specularColor,mat.perceptualRoughness,NdotV);vec3 indirectSpecular= envBRDF*env_light;vec3 indirectDiffuse=mat.diffuseColor*env_light;return indirectSpecular+indirectDiffuse;}vec3 computeLightContribution(Material mat,vec3 lightPosition,vec3 lightColor)\n{highp vec3 n=mat.normal;highp vec3 v=normalize(-v_position_height.xyz);highp vec3 l=normalize(lightPosition);highp vec3 h=normalize(v+l);float NdotV=clamp(abs(dot(n,v)),0.001,1.0);float NdotL=saturate(dot(n,l));highp float NdotH=saturate(dot(n,h));float VdotH=saturate(dot(v,h));vec3 f=F_SchlickFast(mat.specularColor,VdotH);float g=V_GGXFast(NdotL,NdotV,mat.alphaRoughness);float d=D_GGX(NdotH,mat.alphaRoughness);vec3 diffuseTerm=(1.0-f)*diffuseLambertian(mat);vec3 specularTerm=f*g*d;vec3 transformed_normal=vec3(-n.xy,n.z);float lighting_factor;\n#ifdef RENDER_SHADOWS\nlighting_factor=shadowed_light_factor_normal(transformed_normal,v_pos_light_view_0,v_pos_light_view_1,v_depth_shadows);\n#else\nlighting_factor=NdotL;\n#endif\nvec3 directLightColor=(specularTerm+diffuseTerm)*lighting_factor*lightColor;vec3 indirectLightColor=computeIndirectLightContribution(mat,NdotV,transformed_normal);vec3 color=(saturate(directLightColor)+indirectLightColor);float intensityFactor=1.0;\n#if !defined(LIGHTING_3D_MODE)\nconst vec3 luminosityFactor=vec3(0.2126,0.7152,0.0722);float luminance=dot(diffuseTerm,luminosityFactor);intensityFactor=mix((1.0-u_lightintensity),max((1.0-luminance+u_lightintensity),1.0),NdotL);\n#endif\ncolor*=intensityFactor;return color;}void main() {\n#ifdef TERRAIN_FRAGMENT_OCCLUSION\nif (isOccluded()) {discard;}\n#endif\nvec3 lightDir=u_lightpos;vec3 lightColor=u_lightcolor;\n#ifdef LIGHTING_3D_MODE\nlightDir=u_lighting_directional_dir;lightDir.xy=-lightDir.xy;lightColor=u_lighting_directional_color;\n#endif\nvec4 finalColor;\n#ifdef DIFFUSE_SHADED\nvec3 N=getNormal();vec3 baseColor=getBaseColor().rgb;vec3 diffuse=getDiffuseShadedColor(baseColor,N,lightDir,lightColor);\n#ifdef HAS_TEXTURE_u_occlusionTexture\nfloat ao=(texture(u_occlusionTexture,uv_2f).r-1.0)*u_aoIntensity+1.0;diffuse*=ao;\n#endif\nfinalColor=vec4(mix(diffuse,baseColor,u_emissive_strength),1.0)*u_opacity;\n#else\nMaterial mat=getPBRMaterial();vec3 color=computeLightContribution(mat,lightDir,lightColor);float ao=1.0;\n#if defined (HAS_TEXTURE_u_occlusionTexture) && defined(HAS_ATTRIBUTE_a_uv_2f)\n#ifdef OCCLUSION_TEXTURE_TRANSFORM\nvec2 uv=uv_2f.xy*u_occlusionTextureTransform.zw+u_occlusionTextureTransform.xy;\n#else\nvec2 uv=uv_2f;\n#endif\nao=(texture(u_occlusionTexture,uv).x-1.0)*u_aoIntensity+1.0;color*=ao;\n#endif\nvec4 emissive=u_emissiveFactor;\n#if defined(HAS_TEXTURE_u_emissionTexture) && defined(HAS_ATTRIBUTE_a_uv_2f)\nemissive.rgb*=sRGBToLinear(texture(u_emissionTexture,uv_2f).rgb);\n#endif\n#ifdef APPLY_LUT_ON_GPU\nfloat emissiveFactorLength=max(length(u_emissiveFactor.rgb),0.001);emissive.rgb=sRGBToLinear(applyLUT(u_lutTexture,linearTosRGB(emissive.rgb/emissiveFactorLength).rbg))*emissiveFactorLength;\n#endif\ncolor+=emissive.rgb;float opacity=mat.baseColor.w*u_opacity;\n#ifdef HAS_ATTRIBUTE_a_pbr\nfloat resEmission=v_roughness_metallic_emissive_alpha.z;resEmission*=v_height_based_emission_params.z+v_height_based_emission_params.w*pow(clamp(v_height_based_emission_params.x,0.0,1.0),v_height_based_emission_params.y);vec3 color_mix=v_color_mix.rgb;\n#ifdef APPLY_LUT_ON_GPU\ncolor_mix=applyLUT(u_lutTexture,color_mix);\n#endif\ncolor=mix(color,color_mix,min(1.0,resEmission));\n#ifdef HAS_ATTRIBUTE_a_color_4f\nfloat distance=length(vec2(1.3*max(0.0,abs(color_4f.x)-color_4f.z),color_4f.y));distance+= mix(0.5,0.0,clamp(resEmission-1.0,0.0,1.0));opacity*=v_roughness_metallic_emissive_alpha.w*saturate(1.0-distance*distance);\n#endif\n#endif\nvec3 unlitColor=mat.baseColor.rgb*ao+emissive.rgb;color=mix(color,unlitColor,u_emissive_strength);color=linearTosRGB(color);color*=opacity;finalColor=vec4(color,opacity);\n#endif\n#ifdef FOG\nfinalColor=fog_dither(fog_apply_premultiplied(finalColor,v_fog_pos,v_position_height.w));\n#endif\n#ifdef RENDER_CUTOFF\nfinalColor*=v_cutoff_opacity;\n#endif\n#ifdef INDICATOR_CUTOUT\nfinalColor=applyCutout(finalColor,v_position_height.w);\n#endif\n#ifdef FEATURE_CUTOUT\nfinalColor=apply_feature_cutout(finalColor,gl_FragCoord);\n#endif\nglFragColor=finalColor;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}", "#include \"_prelude_fog.vertex.glsl\"\n#include \"_prelude_shadow.vertex.glsl\"\nin vec3 a_pos_3f;\n#pragma mapbox: define-attribute highp vec3 normal_3f\n#pragma mapbox: define-attribute highp vec2 uv_2f\n#pragma mapbox: define-attribute highp vec3 color_3f\n#pragma mapbox: define-attribute highp vec4 color_4f\n#pragma mapbox: define-attribute-vertex-shader-only highp vec4 pbr\n#pragma mapbox: define-attribute-vertex-shader-only highp vec3 heightBasedEmissiveStrength\nuniform mat4 u_matrix;uniform mat4 u_node_matrix;uniform mat4 u_lighting_matrix;uniform vec3 u_camera_pos;uniform vec4 u_color_mix;\n#ifdef INSTANCED_ARRAYS\nin vec4 a_normal_matrix0;in vec4 a_normal_matrix1;in vec4 a_normal_matrix2;in vec4 a_normal_matrix3;\n#else\nuniform highp mat4 u_normal_matrix;\n#endif\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out float v_depth_shadows;\n#endif\nout vec4 v_position_height;out lowp vec4 v_color_mix;\n#ifdef TERRAIN_FRAGMENT_OCCLUSION\nout highp float v_depth;\n#endif\n#ifdef HAS_ATTRIBUTE_a_pbr\nout lowp vec4 v_roughness_metallic_emissive_alpha;out mediump vec4 v_height_based_emission_params;\n#endif\nvec3 sRGBToLinear(vec3 srgbIn) {return pow(srgbIn,vec3(2.2));}void main() {\n#pragma mapbox: initialize-attribute highp vec3 normal_3f\n#pragma mapbox: initialize-attribute highp vec2 uv_2f\n#pragma mapbox: initialize-attribute highp vec3 color_3f\n#pragma mapbox: initialize-attribute highp vec4 color_4f\n#pragma mapbox: initialize-attribute-custom highp vec4 pbr\n#pragma mapbox: initialize-attribute-custom highp vec3 heightBasedEmissiveStrength\nhighp mat4 normal_matrix;\n#ifdef INSTANCED_ARRAYS\nnormal_matrix=mat4(a_normal_matrix0,a_normal_matrix1,a_normal_matrix2,a_normal_matrix3);\n#else\nnormal_matrix=u_normal_matrix;\n#endif\nvec3 local_pos;mat3 rs;\n#ifdef MODEL_POSITION_ON_GPU\nvec3 pos_color=normal_matrix[0].xyz;vec4 translate=normal_matrix[1];vec3 pos_a=floor(pos_color);vec3 rgb=1.05*(pos_color-pos_a);float hidden=float(pos_a.x > EXTENT);float color_mix=pos_a.z/100.0;v_color_mix=vec4(sRGBToLinear(rgb),color_mix);float meter_to_tile=normal_matrix[0].w;vec4 pos=vec4(pos_a.xy,translate.z,1.0);rs[0].x=normal_matrix[1].w;rs[0].yz=normal_matrix[2].xy;rs[1].xy=normal_matrix[2].zw;rs[1].z=normal_matrix[3].x;rs[2].xyz=normal_matrix[3].yzw;vec4 pos_node=u_lighting_matrix*vec4(a_pos_3f,1.0);vec3 rotated_pos_node=rs*pos_node.xyz;vec3 pos_model_tile=(rotated_pos_node+vec3(translate.xy,0.0))*vec3(meter_to_tile,meter_to_tile,1.0);pos.xyz+=pos_model_tile;local_pos=pos.xyz;gl_Position=mix(u_matrix*pos,AWAY,hidden);pos.z*=meter_to_tile;v_position_height.xyz=pos.xyz-u_camera_pos;\n#else\nlocal_pos=a_pos_3f;gl_Position=u_matrix*vec4(a_pos_3f,1);v_position_height.xyz=vec3(u_lighting_matrix*vec4(a_pos_3f,1));v_color_mix=vec4(sRGBToLinear(u_color_mix.rgb),u_color_mix.a);\n#endif\nv_position_height.w=a_pos_3f.z;\n#ifdef HAS_ATTRIBUTE_a_pbr\nvec4 albedo_c=decode_color(pbr.xy);vec2 e_r_m=unpack_float(pbr.z);vec2 r_m= unpack_float(e_r_m.y*16.0);r_m.r=r_m.r*16.0;v_color_mix=vec4(albedo_c.rgb,1.0);v_roughness_metallic_emissive_alpha=vec4(vec3(r_m,e_r_m.x)/255.0,albedo_c.a);v_roughness_metallic_emissive_alpha.z*=2.0;float heightBasedRelativeIntepolation=a_pos_3f.z*heightBasedEmissiveStrength.x+heightBasedEmissiveStrength.y;v_height_based_emission_params.x=heightBasedRelativeIntepolation;v_height_based_emission_params.y=heightBasedEmissiveStrength.z;vec2 emissionMultiplierValues=unpack_float(pbr.w)/256.0;v_height_based_emission_params.z=emissionMultiplierValues.x;v_height_based_emission_params.w=emissionMultiplierValues.y-emissionMultiplierValues.x;\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(local_pos);\n#endif\n#ifdef RENDER_CUTOFF\nv_cutoff_opacity=cutoff_opacity(u_cutoff_params,gl_Position.z);\n#endif\n#ifdef TERRAIN_FRAGMENT_OCCLUSION\nv_depth=gl_Position.z/gl_Position.w;\n#ifdef CLIP_ZERO_TO_ONE\nv_depth=-1.0+2.0*v_depth; \n#endif\n#endif\n#ifdef HAS_ATTRIBUTE_a_normal_3f\n#ifdef MODEL_POSITION_ON_GPU\nfloat x_squared_scale=dot(rs[0],rs[0]);float y_squared_scale=dot(rs[1],rs[1]);float z_squared_scale=dot(rs[2],rs[2]);vec3 squared_scale=vec3(x_squared_scale,y_squared_scale,z_squared_scale);normal_3f=rs*((u_lighting_matrix*vec4(normal_3f,0.0)).xyz/squared_scale);normal_3f=normalize(normal_3f);\n#else\nnormal_3f=vec3(normal_matrix*vec4(normal_3f,0));\n#endif\n#endif\n#ifdef HAS_ATTRIBUTE_a_pbr\n#ifdef HAS_ATTRIBUTE_a_color_4f\nv_roughness_metallic_emissive_alpha.w=clamp(color_4f.a*v_roughness_metallic_emissive_alpha.w*(v_roughness_metallic_emissive_alpha.z-1.0),0.0,1.0);\n#endif\n#endif\n#ifdef RENDER_SHADOWS\nvec4 shadow_pos=u_node_matrix*vec4(local_pos,1.0);\n#ifdef NORMAL_OFFSET\n#ifdef HAS_ATTRIBUTE_a_normal_3f\n#ifdef MODEL_POSITION_ON_GPU\nvec3 offset=shadow_normal_offset(vec3(-normal_3f.xy,normal_3f.z));shadow_pos.xyz+=offset*shadow_normal_offset_multiplier0();\n#else\nvec3 offset=shadow_normal_offset_model(normal_3f);shadow_pos.xyz+=offset*shadow_normal_offset_multiplier0();\n#endif\n#endif\n#endif\nv_pos_light_view_0=u_light_matrix_0*shadow_pos;v_pos_light_view_1=u_light_matrix_1*shadow_pos;v_depth_shadows=gl_Position.w;\n#endif\n}"),
				modelDepth: ss("in highp float v_depth;void main() {\n#ifndef DEPTH_TEXTURE\nglFragColor=pack_depth(v_depth);\n#endif\n}", "in vec3 a_pos_3f;uniform mat4 u_matrix;out highp float v_depth;\n#ifdef MODEL_POSITION_ON_GPU\n#ifdef INSTANCED_ARRAYS\nin vec4 a_normal_matrix0;in vec4 a_normal_matrix1;in vec4 a_normal_matrix2;in vec4 a_normal_matrix3;\n#else\nuniform highp mat4 u_instance;\n#endif\nuniform highp mat4 u_node_matrix;\n#endif\nvoid main() {\n#ifdef MODEL_POSITION_ON_GPU\nhighp mat4 instance;\n#ifdef INSTANCED_ARRAYS\ninstance=mat4(a_normal_matrix0,a_normal_matrix1,a_normal_matrix2,a_normal_matrix3);\n#else\ninstance=u_instance;\n#endif\nvec3 pos_color=instance[0].xyz;vec4 translate=instance[1];vec3 pos_a=floor(pos_color);float hidden=float(pos_a.x > EXTENT);float meter_to_tile=instance[0].w;vec4 pos=vec4(pos_a.xy,translate.z,1.0);mat3 rs;rs[0].x=instance[1].w;rs[0].yz=instance[2].xy;rs[1].xy=instance[2].zw;rs[1].z=instance[3].x;rs[2].xyz=instance[3].yzw;vec4 pos_node=u_node_matrix*vec4(a_pos_3f,1.0);vec3 rotated_pos_node=rs*pos_node.xyz;vec3 pos_model_tile=(rotated_pos_node+vec3(translate.xy,0.0))*vec3(meter_to_tile,meter_to_tile,1.0);pos.xyz+=pos_model_tile;gl_Position=mix(u_matrix*pos,AWAY,hidden);\n#else\ngl_Position=u_matrix*vec4(a_pos_3f,1);\n#endif\nv_depth=gl_Position.z/gl_Position.w;}"),
				stars: ss("in highp vec2 v_uv;in mediump float v_intensity;float shapeCircle(in vec2 uv)\n{float beginFade=0.6;float lengthFromCenter=length(v_uv);return 1.0-clamp((lengthFromCenter-beginFade)/(1.0-beginFade),0.0,1.0);}void main() {float alpha=shapeCircle(v_uv);vec3 color=vec3(1.0,1.0,1.0);alpha*=v_intensity;glFragColor=vec4(color*alpha,alpha);HANDLE_WIREFRAME_DEBUG;}", "\nin vec3 a_pos_3f;in vec2 a_uv;in float a_size_scale;in float a_fade_opacity;uniform mat4 u_matrix;uniform vec3 u_up;uniform vec3 u_right;uniform float u_intensity_multiplier;out highp vec2 v_uv;out mediump float v_intensity;void main() {v_uv=a_uv;v_intensity=a_fade_opacity*u_intensity_multiplier;vec3 pos=a_pos_3f;pos+=a_uv.x*u_right*a_size_scale;pos+=a_uv.y*u_up*a_size_scale;gl_Position=u_matrix*vec4(pos,1.0);}"),
				snowParticle: ss("in highp vec2 uv;in highp float alphaMultiplier;uniform vec4 u_particleColor;uniform vec2 u_simpleShapeParameters;void main() {float t=clamp((length(uv)-u_simpleShapeParameters.x)/(1.0-u_simpleShapeParameters.x),0.0,1.0);float alpha=1.0-pow(t,pow(10.0,u_simpleShapeParameters.y));alpha*=alphaMultiplier;alpha*=u_particleColor.a;vec3 color=u_particleColor.rgb*alpha;glFragColor=vec4(color,alpha) ;HANDLE_WIREFRAME_DEBUG;}", "\nin highp vec3 a_pos_3f;in highp vec2 a_uv;in highp vec4 a_snowParticleData;in highp vec4 a_snowParticleDataHorizontalOscillation;uniform mat4 u_modelview;uniform mat4 u_projection;uniform vec3 u_cam_pos;uniform vec2 u_screenSize;uniform float u_time;uniform float u_boxSize;uniform float u_velocityConeAperture; \nuniform float u_velocity;uniform vec3 u_direction;uniform float u_horizontalOscillationRadius; \nuniform float u_horizontalOscillationRate; \nuniform float u_billboardSize;uniform vec2 u_thinningCenterPos;uniform vec3 u_thinningShape;uniform float u_thinningAffectedRatio;uniform float u_thinningParticleOffset;out highp vec2 uv;out highp float alphaMultiplier;void main() {vec3 pos=a_pos_3f;float halfBoxSize=0.5*u_boxSize;pos.xyz*=halfBoxSize;pos+=u_cam_pos;float velocityConeApertureRad=radians(u_velocityConeAperture*0.5);float coneAnglePichRad=velocityConeApertureRad*a_snowParticleData.z;float coneAngleHeadingRad=a_snowParticleData.w*radians(360.0);vec3 localZ=normalize(u_direction);vec3 localX=normalize(cross(localZ,vec3(1,0,0)));vec3 localY=normalize(cross(localZ,localX));vec3 direction;direction.x=cos(coneAngleHeadingRad)*sin(coneAnglePichRad);direction.y=sin(coneAngleHeadingRad)*sin(coneAnglePichRad);direction.z=cos(coneAnglePichRad);direction=normalize(direction);vec3 simPosLocal=vec3(0,0,0);float velocityScale=(1.0+3.0*a_snowParticleData.y)*u_velocity;simPosLocal+=direction*velocityScale*u_time;float horizontalOscillationRadius=u_horizontalOscillationRadius*a_snowParticleDataHorizontalOscillation.x;float horizontalOscillationAngle=u_horizontalOscillationRate*u_time*(-1.0+2.0*a_snowParticleDataHorizontalOscillation.y);simPosLocal.xy+=horizontalOscillationRadius*vec2(cos(horizontalOscillationAngle),sin(horizontalOscillationAngle));vec3 simPos=localX*simPosLocal.x+\nlocalY*simPosLocal.y+localZ*simPosLocal.z;pos+=simPos;pos=fract((pos+vec3(halfBoxSize))/vec3(u_boxSize))*u_boxSize-vec3(halfBoxSize);float clipZ=-u_cam_pos.z+pos.z;vec4 posView=u_modelview*vec4(pos,1.0);float size=u_billboardSize;alphaMultiplier=1.0;vec4 posScreen=u_projection*posView;posScreen/=posScreen.w;posScreen.xy=vec2(0.5)+posScreen.xy*0.5;posScreen.xy*=u_screenSize;vec2 thinningCenterPos=u_thinningCenterPos.xy;thinningCenterPos.y=u_screenSize.y-thinningCenterPos.y;float screenDist=length((thinningCenterPos-posScreen.xy)/(0.5*u_screenSize));screenDist+=a_snowParticleData.x*u_thinningParticleOffset;float scaleFactorMode=0.0;float thinningShapeDist=u_thinningShape.x+u_thinningShape.y;if (screenDist < thinningShapeDist) {float thinningFadeRatio=clamp((screenDist-u_thinningShape.x)/u_thinningShape.y,0.0,1.0);thinningFadeRatio=pow(thinningFadeRatio,u_thinningShape.z);if (a_snowParticleData.x < u_thinningAffectedRatio) {scaleFactorMode=1.0-thinningFadeRatio;alphaMultiplier=thinningFadeRatio;}}vec4 posScreen1=u_projection*vec4(posView.x-size,posView.yzw);posScreen1/=posScreen1.w;vec4 posScreen2=u_projection*vec4(posView.x+size,posView.yzw);posScreen2/=posScreen2.w;posScreen1.xy=vec2(0.5)+posScreen1.xy*0.5;posScreen1.xy*=u_screenSize;posScreen2.xy=vec2(0.5)+posScreen2.xy*0.5;posScreen2.xy*=u_screenSize;float screenLength=length(posScreen1.xy-posScreen2.xy);float screenEpsilon=3.0;float scaleFactor=1.0;if (screenLength < screenEpsilon) {scaleFactor=screenEpsilon/max(screenLength,0.01);scaleFactor=mix(scaleFactor,1.0,scaleFactorMode);}float screenEpsilon2=15.0;if (screenLength > screenEpsilon2) {scaleFactor=screenEpsilon2/max(screenLength,0.01);}size*=scaleFactor;vec2 right=size*vec2(1,0);vec2 up=size*vec2(0,1);posView.xy+=right*a_uv.x;posView.xy+=up*a_uv.y;uv=a_uv;gl_Position=u_projection*posView;}"),
				rainParticle: ss("in highp vec2 uv;in highp float particleRandomValue;uniform sampler2D u_texScreen;uniform float u_distortionStrength;uniform vec4 u_color;uniform vec2 u_thinningCenterPos;uniform vec3 u_thinningShape;uniform float u_thinningAffectedRatio;uniform float u_thinningParticleOffset;uniform float u_shapeDirectionalPower;uniform float u_mode;void main() {vec2 st=uv*0.5+vec2(0.5);vec2 uvm=uv;uvm.y=-1.0+2.0*pow(st.y,u_shapeDirectionalPower);float shape=clamp(1.0-length(uvm),0.0,1.0);float alpha=abs(shape)*u_color.a;vec2 screenSize=vec2(textureSize(u_texScreen,0));vec2 thinningCenterPos=u_thinningCenterPos.xy;thinningCenterPos.y=screenSize.y-thinningCenterPos.y;float screenDist=length((thinningCenterPos-gl_FragCoord.xy)/(0.5*screenSize));screenDist+=(0.5+0.5*particleRandomValue)*u_thinningParticleOffset;float thinningShapeDist=u_thinningShape.x+u_thinningShape.y;float thinningAlpha=1.0;if (screenDist < thinningShapeDist) {float thinningFadeRatio=clamp((screenDist-u_thinningShape.x)/u_thinningShape.y,0.0,1.0);thinningFadeRatio=pow(thinningFadeRatio,u_thinningShape.z);thinningAlpha*=thinningFadeRatio;}vec2 offsetXY=normalize(uvm)*abs(shape);vec2 stScreen=(gl_FragCoord.xy+offsetXY*u_distortionStrength*thinningAlpha)/screenSize;vec3 colorScreen=texture(u_texScreen,stScreen).rgb;alpha*=thinningAlpha;glFragColor=mix(vec4(colorScreen,1.0),vec4(u_color.rgb*alpha,alpha),u_mode);HANDLE_WIREFRAME_DEBUG;}", "\nin highp vec3 a_pos_3f;in highp vec2 a_uv;in highp vec4 a_rainParticleData;uniform mat4 u_modelview;uniform mat4 u_projection;uniform vec3 u_cam_pos;uniform float u_time;uniform float u_boxSize;uniform float u_velocityConeAperture; \nuniform float u_velocity; \nuniform vec2 u_rainDropletSize;uniform vec3 u_rainDirection;out highp vec2 uv;out highp float particleRandomValue;void main() {vec3 pos=a_pos_3f;float halfBoxSize=0.5*u_boxSize;pos*=halfBoxSize; \npos+=u_cam_pos;float velocityConeApertureRad=radians(u_velocityConeAperture*0.5);float coneAnglePichRad=velocityConeApertureRad*a_rainParticleData.z;float coneAngleHeadingRad=a_rainParticleData.w*radians(360.0);vec3 localZ=normalize(u_rainDirection);vec3 localX=normalize(cross(localZ,vec3(1,0,0)));vec3 localY=normalize(cross(localZ,localX));vec3 directionLocal;directionLocal.x=cos(coneAngleHeadingRad)*sin(coneAnglePichRad);directionLocal.y=sin(coneAngleHeadingRad)*sin(coneAnglePichRad);directionLocal.z=cos(coneAnglePichRad);directionLocal=normalize(directionLocal);vec3 directionWorld=localX*directionLocal.x+localY*directionLocal.y+localZ*directionLocal.z;float velocityScale=(1.0+3.0*a_rainParticleData.y)*u_velocity;vec3 simPosLocal=vec3(0,0,0);simPosLocal+=directionLocal*velocityScale*u_time;vec3 simPos=localX*simPosLocal.x+\nlocalY*simPosLocal.y+localZ*simPosLocal.z;pos+=simPos;pos=fract((pos+vec3(halfBoxSize))/vec3(u_boxSize))*u_boxSize-vec3(halfBoxSize);vec4 posView=u_modelview*vec4(pos,1.0);vec3 directionView=normalize((u_modelview*vec4(directionWorld,0.0)).xyz);vec3 side=cross(directionView,normalize(posView.xyz));posView.xyz+=side*a_uv.x*u_rainDropletSize.x;posView.xyz+=directionView*a_uv.y*u_rainDropletSize.y;uv=a_uv;particleRandomValue=a_rainParticleData.x;gl_Position=u_projection*posView;}"),
				vignette: ss("uniform vec3 u_vignetteShape;uniform vec4 u_vignetteColor;in vec2 st;void main() {float screenDist=length(st);float alpha=clamp((screenDist-u_vignetteShape.x)/u_vignetteShape.y,0.0,1.0);alpha=pow(alpha,u_vignetteShape.z)*u_vignetteColor.a;vec3 color=u_vignetteColor.rgb;glFragColor=vec4(color*alpha,alpha) ;}", "in vec2 a_pos_2f;out vec2 st;void main() {st=a_pos_2f;gl_Position=vec4(a_pos_2f,0,1);}"),
				occlusion: ss("uniform vec4 u_color;void main() {glFragColor=u_color;}", "#include \"_prelude_terrain.vertex.glsl\"\nin highp vec2 a_offset_xy;uniform highp vec3 u_anchorPos;uniform mat4 u_matrix;uniform vec2 u_screenSizePx;uniform vec2 u_occluderSizePx;void main() {vec3 world_pos=u_anchorPos;\n#ifdef TERRAIN\nfloat e=elevation(world_pos.xy);world_pos.z+=e;\n#endif\nvec4 projected_point=u_matrix*vec4(world_pos,1.0);projected_point.xy+=projected_point.w*a_offset_xy*0.5*u_occluderSizePx/u_screenSizePx;gl_Position=projected_point;}")
			};
			function os(e$1, t$1) {
				const i$1 = e$1.split("\n");
				for (let e$2 of i$1) {
					if (e$2 = e$2.trimStart(), "#" !== e$2[0]) continue;
					if (!e$2.includes("if")) continue;
					if (e$2.startsWith("#endif")) continue;
					const i$2 = e$2.match(Wo);
					if (i$2) for (const e$3 of i$2) $o.has(e$3) || t$1.add(e$3);
				}
			}
			function ss(e$1, t$1) {
				const i$1 = /* @__PURE__ */ new Set(), o$1 = [], s$1 = [];
				e$1 = e$1.replace(qo, ((e$2, t$2) => (s$1.push(t$2), ""))), t$1 = t$1.replace(qo, ((e$2, t$2) => (o$1.push(t$2), "")));
				let r$1 = new Set(Xo);
				os(e$1, r$1), os(t$1, r$1);
				for (const e$2 of [...o$1, ...s$1]) Ko[e$2] || (Ko[e$2] = /* @__PURE__ */ new Set(), os(Yo[e$2], Ko[e$2])), r$1 = new Set([...r$1, ...Ko[e$2]]);
				return {
					fragmentSource: e$1 = e$1.replace(Zo, ((e$2, t$2, o$2, s$2, r$2) => (i$1.add(r$2), "define" === t$2 ? `\n#ifndef HAS_UNIFORM_u_${r$2}\nin ${o$2} ${s$2} ${r$2};\n#else\nuniform ${o$2} ${s$2} u_${r$2};\n#endif\n` : "initialize" === t$2 ? `\n#ifdef HAS_UNIFORM_u_${r$2}\n    ${o$2} ${s$2} ${r$2} = u_${r$2};\n#endif\n` : "define-attribute" === t$2 ? `\n#ifdef HAS_ATTRIBUTE_a_${r$2}\n    in ${o$2} ${s$2} ${r$2};\n#endif\n` : "initialize-attribute" === t$2 ? "" : void 0))),
					vertexSource: t$1 = t$1.replace(Zo, ((e$2, t$2, o$2, s$2, r$2) => {
						const n$1 = `MATERIAL_ATTRIBUTE_OFFSET_${r$2}`, a$1 = "float" === s$2 ? "vec2" : s$2, l$1 = `GET_ATTRIBUTE_${a$1}(a_${r$2}, materialInfo, ${n$1})`, c$1 = r$2.match(/color/) ? "color" : a$1;
						return "define-attribute-vertex-shader-only" === t$2 ? `\n#ifdef HAS_ATTRIBUTE_a_${r$2}\nin ${o$2} ${s$2} a_${r$2};\n#endif\n` : i$1.has(r$2) ? "define" === t$2 ? `\n#ifndef HAS_UNIFORM_u_${r$2}\nuniform lowp float u_${r$2}_t;\n    #if !defined(${n$1})\n        in ${o$2} ${a$1} a_${r$2};\n    #endif\nout ${o$2} ${s$2} ${r$2};\n#else\nuniform ${o$2} ${s$2} u_${r$2};\n#endif\n` : "initialize" === t$2 ? "vec4" === c$1 ? `\n#ifndef HAS_UNIFORM_u_${r$2}\n    ${r$2} = a_${r$2};\n#else\n    ${o$2} ${s$2} ${r$2} = u_${r$2};\n#endif\n` : `\n#if !defined(HAS_UNIFORM_u_${r$2})\n    #ifdef ${n$1}\n        ${r$2} = unpack_mix_${c$1}(${l$1}, u_${r$2}_t);\n    #else\n        ${r$2} = unpack_mix_${c$1}(a_${r$2}, u_${r$2}_t);\n    #endif\n#else\n    ${o$2} ${s$2} ${r$2} = u_${r$2};\n#endif\n` : "define-attribute" === t$2 ? `\n#ifdef HAS_ATTRIBUTE_a_${r$2}\n    in ${o$2} ${s$2} a_${r$2};\n    out ${o$2} ${s$2} ${r$2};\n#endif\n` : "initialize-attribute" === t$2 ? `\n#ifdef HAS_ATTRIBUTE_a_${r$2}\n    ${r$2} = a_${r$2};\n#endif\n` : void 0 : "define" === t$2 ? `\n#ifndef HAS_UNIFORM_u_${r$2}\nuniform lowp float u_${r$2}_t;\n    #if !defined(${n$1})\n        in ${o$2} ${a$1} a_${r$2};\n    #endif\n#else\nuniform ${o$2} ${s$2} u_${r$2};\n#endif\n` : "define-instanced" === t$2 ? "mat4" === c$1 ? `\n#ifdef INSTANCED_ARRAYS\nin vec4 a_${r$2}0;\nin vec4 a_${r$2}1;\nin vec4 a_${r$2}2;\nin vec4 a_${r$2}3;\n#else\nuniform ${o$2} ${s$2} u_${r$2};\n#endif\n` : `\n#ifdef INSTANCED_ARRAYS\nin ${o$2} ${a$1} a_${r$2};\n#else\nuniform ${o$2} ${s$2} u_${r$2};\n#endif\n` : "initialize-attribute-custom" === t$2 ? `\n#ifdef HAS_ATTRIBUTE_a_${r$2}\n    ${o$2} ${s$2} ${r$2} = a_${r$2};\n#endif\n` : "vec4" === c$1 ? `\n#ifndef HAS_UNIFORM_u_${r$2}\n    #ifdef ${n$1}\n        ${o$2} ${s$2} ${r$2} = ${l$1};\n    #else\n        ${o$2} ${s$2} ${r$2} = a_${r$2};\n    #endif\n#else\n    ${o$2} ${s$2} ${r$2} = u_${r$2};\n#endif\n` : `\n#ifndef HAS_UNIFORM_u_${r$2}\n    #ifdef ${n$1}\n        ${o$2} ${s$2} ${r$2} = unpack_mix_${c$1}(${l$1}, u_${r$2}_t);\n    #else\n        ${o$2} ${s$2} ${r$2} = unpack_mix_${c$1}(a_${r$2}, u_${r$2}_t);\n    #endif\n#else\n    ${o$2} ${s$2} ${r$2} = u_${r$2};\n#endif\n`;
					})),
					usedDefines: r$1,
					vertexIncludes: o$1,
					fragmentIncludes: s$1
				};
			}
			class rs {
				constructor() {
					this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffers = [], this.vao = null;
				}
				bind(e$1, t$1, i$1, o$1, s$1, r$1, n$1, a$1) {
					this.context = e$1;
					let l$1 = this.boundPaintVertexBuffers.length !== o$1.length;
					for (let e$2 = 0; !l$1 && e$2 < o$1.length; e$2++) this.boundPaintVertexBuffers[e$2] !== o$1[e$2] && (l$1 = !0);
					let c$1 = this.boundDynamicVertexBuffers.length !== n$1.length;
					for (let e$2 = 0; !c$1 && e$2 < n$1.length; e$2++) this.boundDynamicVertexBuffers[e$2] !== n$1[e$2] && (c$1 = !0);
					if (!this.vao || this.boundProgram !== t$1 || this.boundLayoutVertexBuffer !== i$1 || l$1 || c$1 || this.boundIndexBuffer !== s$1 || this.boundVertexOffset !== r$1) this.freshBind(t$1, i$1, o$1, s$1, r$1, n$1, a$1);
					else {
						e$1.bindVertexArrayOES.set(this.vao);
						for (const i$2 of n$1) i$2 && (i$2.bind(), a$1 && i$2.instanceCount && i$2.setVertexAttribDivisor(e$1.gl, t$1, a$1));
						s$1 && s$1.dynamicDraw && s$1.bind();
					}
				}
				freshBind(e$1, t$1, i$1, o$1, s$1, r$1, n$1) {
					const a$1 = this.context, l$1 = a$1.gl;
					this.vao && this.destroy(), this.vao = a$1.gl.createVertexArray(), a$1.bindVertexArrayOES.set(this.vao), this.boundProgram = e$1, this.boundLayoutVertexBuffer = t$1, this.boundPaintVertexBuffers = i$1, this.boundIndexBuffer = o$1, this.boundVertexOffset = s$1, this.boundDynamicVertexBuffers = r$1, t$1.enableAttributes(l$1, e$1), t$1.bind(), t$1.setVertexAttribPointers(l$1, e$1, s$1);
					for (const t$2 of i$1) t$2.enableAttributes(l$1, e$1), t$2.bind(), t$2.setVertexAttribPointers(l$1, e$1, s$1);
					for (const t$2 of r$1) t$2 && (t$2.enableAttributes(l$1, e$1), t$2.bind(), t$2.setVertexAttribPointers(l$1, e$1, s$1), n$1 && t$2.instanceCount && t$2.setVertexAttribDivisor(l$1, e$1, n$1));
					o$1 && o$1.bind();
				}
				destroy() {
					this.vao && (this.context.gl.deleteVertexArray(this.vao), this.vao = null);
				}
			}
			function ns(t$1, i$1) {
				const o$1 = Math.pow(2, i$1.canonical.z), s$1 = i$1.canonical.y;
				return [new e.ae(0, s$1 / o$1).toLngLat().lat, new e.ae(0, (s$1 + 1) / o$1).toLngLat().lat];
			}
			function as(t$1, i$1, o$1, s$1, r$1, n$1, a$1) {
				const l$1 = t$1.context, c$1 = l$1.gl, h$1 = o$1.hillshadeFBO;
				if (!h$1) return;
				t$1.prepareDrawTile();
				const d$1 = t$1.isTileAffectedByFog(i$1), u$1 = [];
				t$1.terrain && t$1.terrain.renderingToTexture && "mrt-fallback" === t$1.emissiveMode && u$1.push("USE_MRT1");
				const _$1 = t$1.getOrCreateProgram("hillshade", {
					overrideFog: d$1,
					defines: u$1
				});
				l$1.activeTexture.set(c$1.TEXTURE0), c$1.bindTexture(c$1.TEXTURE_2D, h$1.colorAttachment0.get());
				const p$1 = ((t$2, i$2, o$2, s$2) => {
					const r$2 = o$2.paint.get("hillshade-shadow-color"), n$2 = "none" === o$2.paint.get("hillshade-shadow-color-use-theme").constantOr("default"), a$2 = o$2.paint.get("hillshade-highlight-color"), l$2 = "none" === o$2.paint.get("hillshade-highlight-color-use-theme").constantOr("default"), c$2 = o$2.paint.get("hillshade-accent-color"), h$2 = "none" === o$2.paint.get("hillshade-accent-color-use-theme").constantOr("default"), d$2 = o$2.paint.get("hillshade-emissive-strength");
					let u$2 = e.an(o$2.paint.get("hillshade-illumination-direction"));
					if ("viewport" === o$2.paint.get("hillshade-illumination-anchor")) u$2 -= t$2.transform.angle;
					else if (t$2.style && t$2.style.enable3dLights() && t$2.style.directionalLight) {
						const i$3 = t$2.style.directionalLight.properties.get("direction"), o$3 = e.d4(i$3.x, i$3.y, i$3.z);
						u$2 = e.an(o$3[1]);
					}
					const _$2 = !t$2.options.moving;
					return {
						u_matrix: s$2 || t$2.transform.calculateProjMatrix(i$2.tileID.toUnwrapped(), _$2),
						u_image: 0,
						u_latrange: ns(0, i$2.tileID),
						u_light: [o$2.paint.get("hillshade-exaggeration"), u$2],
						u_shadow: r$2.toPremultipliedRenderColor(n$2 ? null : o$2.lut),
						u_highlight: a$2.toPremultipliedRenderColor(l$2 ? null : o$2.lut),
						u_emissive_strength: d$2,
						u_accent: c$2.toPremultipliedRenderColor(h$2 ? null : o$2.lut)
					};
				})(t$1, o$1, s$1, t$1.terrain ? i$1.projMatrix : null);
				t$1.uploadCommonUniforms(l$1, _$1, i$1.toUnwrapped());
				const { tileBoundsBuffer: f$1, tileBoundsIndexBuffer: m$1, tileBoundsSegments: g$1 } = t$1.getTileBoundsBuffers(o$1);
				_$1.draw(t$1, c$1.TRIANGLES, r$1, n$1, a$1, eo.disabled, p$1, s$1.id, f$1, m$1, g$1);
			}
			function ls(t$1, i$1, o$1) {
				if (!i$1.needsDEMTextureUpload) return;
				const s$1 = t$1.context, r$1 = s$1.gl;
				s$1.pixelStoreUnpackPremultiplyAlpha.set(!1), i$1.demTexture = i$1.demTexture || t$1.getTileTexture(o$1.stride);
				const n$1 = o$1.getPixels();
				i$1.demTexture ? i$1.demTexture.update(n$1, { premultiply: !1 }) : i$1.demTexture = new e.T(s$1, n$1, r$1.R32F, { premultiply: !1 }), i$1.needsDEMTextureUpload = !1;
			}
			function cs(t$1, i$1, o$1) {
				const s$1 = t$1.context, r$1 = s$1.gl;
				if (!i$1.dem) return;
				const n$1 = i$1.dem;
				if (s$1.activeTexture.set(r$1.TEXTURE1), ls(t$1, i$1, n$1), !i$1.demTexture) return;
				i$1.demTexture.bind(r$1.NEAREST, r$1.CLAMP_TO_EDGE);
				const a$1 = n$1.dim;
				s$1.activeTexture.set(r$1.TEXTURE0);
				let l$1 = i$1.hillshadeFBO;
				if (!l$1) {
					const t$2 = new e.T(s$1, {
						width: a$1,
						height: a$1,
						data: null
					}, r$1.RGBA8);
					t$2.bind(r$1.LINEAR, r$1.CLAMP_TO_EDGE), l$1 = i$1.hillshadeFBO = s$1.createFramebuffer(a$1, a$1, 1, "renderbuffer"), l$1.colorAttachment0.set(t$2.texture);
				}
				s$1.bindFramebuffer.set(l$1.framebuffer), s$1.viewport.set([
					0,
					0,
					a$1,
					a$1
				]);
				const { tileBoundsBuffer: c$1, tileBoundsIndexBuffer: h$1, tileBoundsSegments: d$1 } = t$1.getMercatorTileBoundsBuffers(), u$1 = [];
				t$1.linearFloatFilteringSupported() && u$1.push("TERRAIN_DEM_FLOAT_FORMAT"), t$1.terrain && t$1.terrain.renderingToTexture && "mrt-fallback" === t$1.emissiveMode && u$1.push("USE_MRT1"), t$1.getOrCreateProgram("hillshadePrepare", { defines: u$1 }).draw(t$1, r$1.TRIANGLES, Xi.disabled, Ki.disabled, $i.unblended, eo.disabled, ((t$2, i$2) => {
					const o$2 = i$2.stride, s$2 = e.bC();
					return e.ce(s$2, 0, e.al, -e.al, 0, 0, 1), e.br(s$2, s$2, [
						0,
						-e.al,
						0
					]), {
						u_matrix: s$2,
						u_image: 1,
						u_dimension: [o$2, o$2],
						u_zoom: t$2.overscaledZ
					};
				})(i$1.tileID, n$1), o$1.id, c$1, h$1, d$1), i$1.needsHillshadePrepare = !1;
			}
			class hs {
				constructor(e$1) {
					this.gl = e$1.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = !1;
				}
				get() {
					return this.current;
				}
				set(e$1) {}
				getDefault() {
					return this.default;
				}
				setDefault() {
					this.set(this.default);
				}
			}
			class ds extends hs {
				getDefault() {
					return e.ao.transparent.toNonPremultipliedRenderColor(null);
				}
				set(e$1) {
					const t$1 = this.current;
					(e$1.r !== t$1.r || e$1.g !== t$1.g || e$1.b !== t$1.b || e$1.a !== t$1.a || this.dirty) && (this.gl.clearColor(e$1.r, e$1.g, e$1.b, e$1.a), this.current = e$1, this.dirty = !1);
				}
			}
			class us extends hs {
				getDefault() {
					return 1;
				}
				set(e$1) {
					(e$1 !== this.current || this.dirty) && (this.gl.clearDepth(e$1), this.current = e$1, this.dirty = !1);
				}
			}
			class _s extends hs {
				getDefault() {
					return 0;
				}
				set(e$1) {
					(e$1 !== this.current || this.dirty) && (this.gl.clearStencil(e$1), this.current = e$1, this.dirty = !1);
				}
			}
			class ps extends hs {
				getDefault() {
					return [
						!0,
						!0,
						!0,
						!0
					];
				}
				set(e$1) {
					const t$1 = this.current;
					(e$1[0] !== t$1[0] || e$1[1] !== t$1[1] || e$1[2] !== t$1[2] || e$1[3] !== t$1[3] || this.dirty) && (this.gl.colorMask(e$1[0], e$1[1], e$1[2], e$1[3]), this.current = e$1, this.dirty = !1);
				}
			}
			class fs extends hs {
				getDefault() {
					return !0;
				}
				set(e$1) {
					(e$1 !== this.current || this.dirty) && (this.gl.depthMask(e$1), this.current = e$1, this.dirty = !1);
				}
			}
			class ms extends hs {
				getDefault() {
					return 255;
				}
				set(e$1) {
					(e$1 !== this.current || this.dirty) && (this.gl.stencilMask(e$1), this.current = e$1, this.dirty = !1);
				}
			}
			class gs extends hs {
				getDefault() {
					return {
						func: this.gl.ALWAYS,
						ref: 0,
						mask: 255
					};
				}
				set(e$1) {
					const t$1 = this.current;
					(e$1.func !== t$1.func || e$1.ref !== t$1.ref || e$1.mask !== t$1.mask || this.dirty) && (this.gl.stencilFunc(e$1.func, e$1.ref, e$1.mask), this.current = e$1, this.dirty = !1);
				}
			}
			class vs extends hs {
				getDefault() {
					const e$1 = this.gl;
					return [
						e$1.KEEP,
						e$1.KEEP,
						e$1.KEEP
					];
				}
				set(e$1) {
					const t$1 = this.current;
					(e$1[0] !== t$1[0] || e$1[1] !== t$1[1] || e$1[2] !== t$1[2] || this.dirty) && (this.gl.stencilOp(e$1[0], e$1[1], e$1[2]), this.current = e$1, this.dirty = !1);
				}
			}
			class ys extends hs {
				getDefault() {
					return !1;
				}
				set(e$1) {
					if (e$1 === this.current && !this.dirty) return;
					const t$1 = this.gl;
					e$1 ? t$1.enable(t$1.STENCIL_TEST) : t$1.disable(t$1.STENCIL_TEST), this.current = e$1, this.dirty = !1;
				}
			}
			class xs extends hs {
				getDefault() {
					return [0, 1];
				}
				set(e$1) {
					const t$1 = this.current;
					(e$1[0] !== t$1[0] || e$1[1] !== t$1[1] || this.dirty) && (this.gl.depthRange(e$1[0], e$1[1]), this.current = e$1, this.dirty = !1);
				}
			}
			class bs extends hs {
				getDefault() {
					return !1;
				}
				set(e$1) {
					if (e$1 === this.current && !this.dirty) return;
					const t$1 = this.gl;
					e$1 ? t$1.enable(t$1.DEPTH_TEST) : t$1.disable(t$1.DEPTH_TEST), this.current = e$1, this.dirty = !1;
				}
			}
			class ws extends hs {
				getDefault() {
					return this.gl.LESS;
				}
				set(e$1) {
					(e$1 !== this.current || this.dirty) && (this.gl.depthFunc(e$1), this.current = e$1, this.dirty = !1);
				}
			}
			class Ts extends hs {
				getDefault() {
					return !1;
				}
				set(e$1) {
					if (e$1 === this.current && !this.dirty) return;
					const t$1 = this.gl;
					e$1 ? t$1.enable(t$1.BLEND) : t$1.disable(t$1.BLEND), this.current = e$1, this.dirty = !1;
				}
			}
			class Es extends hs {
				getDefault() {
					const e$1 = this.gl;
					return [
						e$1.ONE,
						e$1.ZERO,
						e$1.ONE,
						e$1.ZERO
					];
				}
				set(e$1) {
					const t$1 = this.current;
					(e$1[0] !== t$1[0] || e$1[1] !== t$1[1] || e$1[2] !== t$1[2] || e$1[3] !== t$1[3] || this.dirty) && (this.gl.blendFuncSeparate(e$1[0], e$1[1], e$1[2], e$1[3]), this.current = e$1, this.dirty = !1);
				}
			}
			class Ss extends hs {
				getDefault() {
					return e.ao.transparent.toNonPremultipliedRenderColor(null);
				}
				set(e$1) {
					const t$1 = this.current;
					(e$1.r !== t$1.r || e$1.g !== t$1.g || e$1.b !== t$1.b || e$1.a !== t$1.a || this.dirty) && (this.gl.blendColor(e$1.r, e$1.g, e$1.b, e$1.a), this.current = e$1, this.dirty = !1);
				}
			}
			class Is extends hs {
				getDefault() {
					return this.gl.FUNC_ADD;
				}
				set(e$1) {
					(e$1 !== this.current || this.dirty) && (this.gl.blendEquationSeparate(e$1, e$1), this.current = e$1, this.dirty = !1);
				}
			}
			class Cs extends hs {
				getDefault() {
					return !1;
				}
				set(e$1) {
					if (e$1 === this.current && !this.dirty) return;
					const t$1 = this.gl;
					e$1 ? t$1.enable(t$1.CULL_FACE) : t$1.disable(t$1.CULL_FACE), this.current = e$1, this.dirty = !1;
				}
			}
			class Rs extends hs {
				getDefault() {
					return this.gl.BACK;
				}
				set(e$1) {
					(e$1 !== this.current || this.dirty) && (this.gl.cullFace(e$1), this.current = e$1, this.dirty = !1);
				}
			}
			class As extends hs {
				getDefault() {
					return this.gl.CCW;
				}
				set(e$1) {
					(e$1 !== this.current || this.dirty) && (this.gl.frontFace(e$1), this.current = e$1, this.dirty = !1);
				}
			}
			let Ls = class extends hs {
				getDefault() {
					return null;
				}
				set(e$1) {
					(e$1 !== this.current || this.dirty) && (this.gl.useProgram(e$1), this.current = e$1, this.dirty = !1);
				}
			};
			class Ds extends hs {
				getDefault() {
					return this.gl.TEXTURE0;
				}
				set(e$1) {
					(e$1 !== this.current || this.dirty) && (this.gl.activeTexture(e$1), this.current = e$1, this.dirty = !1);
				}
			}
			class Ps extends hs {
				getDefault() {
					const e$1 = this.gl;
					return [
						0,
						0,
						e$1.drawingBufferWidth,
						e$1.drawingBufferHeight
					];
				}
				set(e$1) {
					const t$1 = this.current;
					(e$1[0] !== t$1[0] || e$1[1] !== t$1[1] || e$1[2] !== t$1[2] || e$1[3] !== t$1[3] || this.dirty) && (this.gl.viewport(e$1[0], e$1[1], e$1[2], e$1[3]), this.current = e$1, this.dirty = !1);
				}
			}
			class Os extends hs {
				getDefault() {
					return null;
				}
				set(e$1) {
					if (e$1 === this.current && !this.dirty) return;
					const t$1 = this.gl;
					t$1.bindFramebuffer(t$1.FRAMEBUFFER, e$1), this.current = e$1, this.dirty = !1;
				}
			}
			class zs extends hs {
				getDefault() {
					return null;
				}
				set(e$1) {
					if (e$1 === this.current && !this.dirty) return;
					const t$1 = this.gl;
					t$1.bindRenderbuffer(t$1.RENDERBUFFER, e$1), this.current = e$1, this.dirty = !1;
				}
			}
			class Ms extends hs {
				getDefault() {
					return null;
				}
				set(e$1) {
					if (e$1 === this.current && !this.dirty) return;
					const t$1 = this.gl;
					t$1.bindTexture(t$1.TEXTURE_2D, e$1), this.current = e$1, this.dirty = !1;
				}
			}
			class Fs extends hs {
				getDefault() {
					return null;
				}
				set(e$1) {
					if (e$1 === this.current && !this.dirty) return;
					const t$1 = this.gl;
					t$1.bindBuffer(t$1.ARRAY_BUFFER, e$1), this.current = e$1, this.dirty = !1;
				}
			}
			class Bs extends hs {
				getDefault() {
					return null;
				}
				set(e$1) {
					const t$1 = this.gl;
					t$1.bindBuffer(t$1.ELEMENT_ARRAY_BUFFER, e$1), this.current = e$1, this.dirty = !1;
				}
			}
			class ks extends hs {
				getDefault() {
					return null;
				}
				set(e$1) {
					this.gl && (e$1 !== this.current || this.dirty) && (this.gl.bindVertexArray(e$1), this.current = e$1, this.dirty = !1);
				}
			}
			class Ns extends hs {
				getDefault() {
					return 4;
				}
				set(e$1) {
					if (e$1 === this.current && !this.dirty) return;
					const t$1 = this.gl;
					t$1.pixelStorei(t$1.UNPACK_ALIGNMENT, e$1), this.current = e$1, this.dirty = !1;
				}
			}
			class Us extends hs {
				getDefault() {
					return !1;
				}
				set(e$1) {
					if (e$1 === this.current && !this.dirty) return;
					const t$1 = this.gl;
					t$1.pixelStorei(t$1.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e$1), this.current = e$1, this.dirty = !1;
				}
			}
			class js extends hs {
				getDefault() {
					return !1;
				}
				set(e$1) {
					if (e$1 === this.current && !this.dirty) return;
					const t$1 = this.gl;
					t$1.pixelStorei(t$1.UNPACK_FLIP_Y_WEBGL, e$1), this.current = e$1, this.dirty = !1;
				}
			}
			class Gs extends hs {
				constructor(e$1, t$1) {
					super(e$1), this.context = e$1, this.parent = t$1;
				}
				getDefault() {
					return null;
				}
			}
			class Vs extends Gs {
				constructor(e$1, t$1, i$1 = 0) {
					super(e$1, t$1), this.attachmentPoint = e$1.gl.COLOR_ATTACHMENT0 + i$1;
				}
				setDirty() {
					this.dirty = !0;
				}
				set(e$1) {
					if (e$1 === this.current && !this.dirty) return;
					this.context.bindFramebuffer.set(this.parent);
					const t$1 = this.gl;
					t$1.framebufferTexture2D(t$1.FRAMEBUFFER, this.attachmentPoint, t$1.TEXTURE_2D, e$1, 0), this.current = e$1, this.dirty = !1;
				}
			}
			class Hs extends Gs {
				attachment() {
					return this.gl.DEPTH_ATTACHMENT;
				}
				set(e$1) {
					if (e$1 === this.current && !this.dirty) return;
					this.context.bindFramebuffer.set(this.parent);
					const t$1 = this.gl;
					t$1.framebufferRenderbuffer(t$1.FRAMEBUFFER, this.attachment(), t$1.RENDERBUFFER, e$1), this.current = e$1, this.dirty = !1;
				}
			}
			class qs extends Gs {
				attachment() {
					return this.gl.DEPTH_ATTACHMENT;
				}
				set(e$1) {
					if (e$1 === this.current && !this.dirty) return;
					this.context.bindFramebuffer.set(this.parent);
					const t$1 = this.gl;
					t$1.framebufferTexture2D(t$1.FRAMEBUFFER, this.attachment(), t$1.TEXTURE_2D, e$1, 0), this.current = e$1, this.dirty = !1;
				}
			}
			class Zs extends Hs {
				attachment() {
					return this.gl.DEPTH_STENCIL_ATTACHMENT;
				}
			}
			const Ws = (e$1, t$1, i$1, o$1) => ({
				u_matrix: e$1,
				u_image0: 0,
				u_image1: 1,
				u_skirt_height: t$1,
				u_ground_shadow_factor: i$1,
				u_emissive_texture_available: o$1
			}), $s = (e$1, t$1, i$1, o$1, s$1, r$1, n$1, a$1, l$1, c$1, h$1, d$1, u$1, _$1, p$1, f$1, m$1) => ({
				u_proj_matrix: Float32Array.from(e$1),
				u_globe_matrix: t$1,
				u_normalize_matrix: Float32Array.from(o$1),
				u_merc_matrix: i$1,
				u_zoom_transition: s$1,
				u_merc_center: r$1,
				u_image0: 0,
				u_image1: 1,
				u_frustum_tl: n$1,
				u_frustum_tr: a$1,
				u_frustum_br: l$1,
				u_frustum_bl: c$1,
				u_globe_pos: h$1,
				u_globe_radius: d$1,
				u_viewport: u$1,
				u_grid_matrix: m$1 ? Float32Array.from(m$1) : new Float32Array(9),
				u_skirt_height: _$1,
				u_far_z_cutoff: p$1,
				u_emissive_texture_available: f$1
			});
			function Xs(e$1, t$1) {
				return null != e$1 && null != t$1 && !(!e$1.hasData() || !t$1.hasData()) && null != e$1.demTexture && null != t$1.demTexture && e$1.tileID.key !== t$1.tileID.key;
			}
			const Ys = new class {
				constructor() {
					this.operations = {};
				}
				newMorphing(e$1, t$1, i$1, o$1, s$1) {
					if (e$1 in this.operations) {
						const t$2 = this.operations[e$1];
						t$2.to.tileID.key !== i$1.tileID.key && (t$2.queued = i$1);
					} else this.operations[e$1] = {
						startTime: o$1,
						phase: 0,
						duration: s$1,
						from: t$1,
						to: i$1,
						queued: null
					};
				}
				getMorphValuesForProxy(e$1) {
					if (!(e$1 in this.operations)) return null;
					const t$1 = this.operations[e$1];
					return {
						from: t$1.from,
						to: t$1.to,
						phase: t$1.phase
					};
				}
				update(e$1) {
					for (const t$1 in this.operations) {
						const i$1 = this.operations[t$1];
						for (i$1.phase = (e$1 - i$1.startTime) / i$1.duration; i$1.phase >= 1 || !this._validOp(i$1);) if (!this._nextOp(i$1, e$1)) {
							delete this.operations[t$1];
							break;
						}
					}
				}
				_nextOp(e$1, t$1) {
					return !!e$1.queued && (e$1.from = e$1.to, e$1.to = e$1.queued, e$1.queued = null, e$1.phase = 0, e$1.startTime = t$1, !0);
				}
				_validOp(e$1) {
					return e$1.from.hasData() && e$1.to.hasData();
				}
			}(), Ks = {
				0: null,
				1: "TERRAIN_VERTEX_MORPHING"
			};
			function Js(e$1, t$1, i$1) {
				if (0 === t$1) return 0;
				const o$1 = t$1 < 1 && 514 === i$1 ? .25 / t$1 : 1;
				return 6 * Math.pow(1.5, 22 - e$1) * Math.max(t$1, 1) * o$1;
			}
			function Qs(e$1, t$1) {
				const i$1 = 1 << e$1.z;
				return !t$1 && (0 === e$1.x || e$1.x === i$1 - 1) || 0 === e$1.y || e$1.y === i$1 - 1;
			}
			function er(e$1, t$1) {
				if (!e$1.style || !e$1.style.enable3dLights()) return;
				const i$1 = e$1.context, o$1 = i$1.gl;
				i$1.activeTexture.set(o$1.TEXTURE1), t$1 ? t$1.bind(o$1.LINEAR, o$1.CLAMP_TO_EDGE) : e$1.emptyTexture.bind(o$1.LINEAR, o$1.CLAMP_TO_EDGE);
			}
			const tr = (e$1) => ({ u_matrix: e$1 });
			function ir(t$1, i$1, o$1, s$1, r$1) {
				if (r$1 > 0) {
					const n$1 = e.o.now(), a$1 = (n$1 - t$1.timeAdded) / r$1, l$1 = i$1 ? (n$1 - i$1.timeAdded) / r$1 : -1, c$1 = o$1.getSource(), h$1 = s$1.coveringZoomLevel({
						tileSize: c$1.tileSize,
						roundZoom: c$1.roundZoom
					}), d$1 = !i$1 || Math.abs(i$1.tileID.overscaledZ - h$1) > Math.abs(t$1.tileID.overscaledZ - h$1), u$1 = d$1 && t$1.refreshedUponExpiration ? 1 : e.aA(d$1 ? a$1 : 1 - l$1, 0, 1);
					return i$1 ? {
						opacity: 1,
						mix: 1 - u$1,
						isFading: a$1 < 1
					} : {
						opacity: u$1,
						mix: 0,
						isFading: a$1 < 1
					};
				}
				return {
					opacity: 1,
					mix: 0,
					isFading: !1
				};
			}
			class or extends Ft {
				constructor(e$1) {
					const t$1 = mt("mock-dem", {
						type: "raster-dem",
						maxzoom: e$1.transform.maxZoom
					}, e$1.style.dispatcher, e$1.style);
					super("mock-dem", t$1, !1), t$1.setEventedParent(this), this._sourceLoaded = !0;
				}
				_loadTile(e$1, t$1) {
					e$1.state = "loaded", t$1(null);
				}
			}
			class sr extends Ft {
				constructor(e$1) {
					const t$1 = mt("proxy", {
						type: "geojson",
						maxzoom: e$1.transform.maxZoom
					}, e$1.style.dispatcher, e$1.style);
					super("proxy", t$1, !1), t$1.setEventedParent(this), this.map = this.getSource().map = e$1, this.used = this._sourceLoaded = !0, this.renderCache = [], this.renderCachePool = [], this.proxyCachedFBO = {};
				}
				update(e$1, t$1, i$1) {
					if (e$1.freezeTileCoverage) return;
					this.transform = e$1;
					const o$1 = e$1.coveringTiles({
						tileSize: this._source.tileSize,
						minzoom: this._source.minzoom,
						maxzoom: this._source.maxzoom,
						roundZoom: this._source.roundZoom,
						reparseOverscaled: this._source.reparseOverscaled
					}).reduce(((t$2, i$2) => {
						if (t$2[i$2.key] = "", !this._tiles[i$2.key]) {
							const t$3 = new Pt(i$2, this._source.tileSize * i$2.overscaleFactor(), e$1.tileZoom, void 0, void 0, this._source.worldview);
							t$3.state = "loaded", this._tiles[i$2.key] = t$3;
						}
						return t$2;
					}), {});
					for (const e$2 in this._tiles) e$2 in o$1 || (this.freeFBO(e$2), this._tiles[e$2].unloadVectorData(), delete this._tiles[e$2]);
				}
				freeFBO(e$1) {
					const t$1 = this.proxyCachedFBO[e$1];
					if (void 0 !== t$1) {
						const i$1 = Object.values(t$1);
						this.renderCachePool.push(...i$1), delete this.proxyCachedFBO[e$1];
					}
				}
				deallocRenderCache() {
					this.renderCache.forEach(((e$1) => e$1.fb.destroy())), this.renderCache = [], this.renderCachePool = [], this.proxyCachedFBO = {};
				}
			}
			class rr extends e.aQ {
				constructor(e$1, t$1, i$1) {
					super(e$1.overscaledZ, e$1.wrap, e$1.canonical.z, e$1.canonical.x, e$1.canonical.y), this.proxyTileKey = t$1, this.projMatrix = i$1;
				}
			}
			class nr extends e.bV {
				constructor(t$1, i$1) {
					super(), this._debugParams = {
						sortTilesHiZFirst: !0,
						disableRenderCache: !1
					}, this.painter = t$1, this.terrainTileForTile = {}, this.prevTerrainTileForTile = {};
					const [o$1, s$1, r$1] = function(t$2) {
						const i$2 = new e.bd(), o$2 = new e.b0(), s$2 = 131;
						i$2.reserve(17161), o$2.reserve(33800);
						const r$2 = e.al / 128, n$2 = e.al + r$2 / 2, a$2 = n$2 + r$2;
						for (let t$3 = -r$2; t$3 < a$2; t$3 += r$2) for (let o$3 = -r$2; o$3 < a$2; o$3 += r$2) {
							const s$3 = o$3 < 0 || o$3 > n$2 || t$3 < 0 || t$3 > n$2 ? 24575 : 0, r$3 = e.aA(Math.round(o$3), 0, e.al), a$3 = e.aA(Math.round(t$3), 0, e.al);
							i$2.emplaceBack(r$3 + s$3, a$3);
						}
						const l$1 = (e$1, t$3) => {
							const i$3 = t$3 * s$2 + e$1;
							o$2.emplaceBack(i$3 + 1, i$3, i$3 + s$2), o$2.emplaceBack(i$3 + s$2, i$3 + s$2 + 1, i$3 + 1);
						};
						for (let e$1 = 1; e$1 < 129; e$1++) for (let t$3 = 1; t$3 < 129; t$3++) l$1(t$3, e$1);
						return [0, 129].forEach(((e$1) => {
							for (let t$3 = 0; t$3 < 130; t$3++) l$1(t$3, e$1), l$1(e$1, t$3);
						})), [
							i$2,
							o$2,
							32768
						];
					}(), n$1 = t$1.context;
					this.gridBuffer = n$1.createVertexBuffer(o$1, e.bf.members), this.gridIndexBuffer = n$1.createIndexBuffer(s$1), this.gridSegments = e.bg.simpleSegment(0, 0, o$1.length, s$1.length), this.gridNoSkirtSegments = e.bg.simpleSegment(0, 0, o$1.length, r$1), this.proxyCoords = [], this.proxiedCoords = {}, this._visibleDemTiles = [], this._drapedRenderBatches = [], this._sourceTilesOverlap = {}, this.proxySourceCache = new sr(i$1.map), this.orthoMatrix = e.bC(), e.ce(this.orthoMatrix, "globe" === this.painter.transform.projection.name ? .015 : 0, e.al, 0, e.al, 0, 1);
					const a$1 = n$1.gl;
					this._overlapStencilMode = new Ki({
						func: a$1.GEQUAL,
						mask: 255
					}, 0, 255, a$1.KEEP, a$1.KEEP, a$1.REPLACE), this._previousZoom = t$1.transform.zoom, this.pool = [], this._findCoveringTileCache = {}, this._tilesDirty = {}, this.style = i$1, this._useVertexMorphing = !0, this._exaggeration = 1, this._mockSourceCache = new or(i$1.map), this._pendingGroundEffectLayers = [], this._emissiveTexture = !1;
				}
				set style(e$1) {
					e$1.on("data", this._onStyleDataEvent.bind(this)), this._style = e$1, this._style.map.on("moveend", (() => {
						this._clearLineLayersFromRenderCache();
					}));
				}
				update(t$1, i$1, o$1) {
					if (t$1 && t$1.terrain) {
						this._style !== t$1 && (this.style = t$1, this._evaluationZoom = void 0);
						const s$1 = t$1.terrain.properties, r$1 = 0 === t$1.terrain.drapeRenderMode, n$1 = t$1.terrain.isZoomDependent();
						this._previousUpdateTimestamp = this.enabled ? this._updateTimestamp : void 0, this._updateTimestamp = e.o.now();
						const a$1 = t$1.terrain && t$1.terrain.scope, l$1 = s$1.get("source"), c$1 = r$1 ? this._mockSourceCache : t$1.getSourceCache(l$1, a$1);
						if (!c$1) return void e.w(`Couldn't find terrain source "${l$1}".`);
						if (this.sourceCache = c$1, this._attenuationRange = t$1.terrain.getAttenuationRange(), this._exaggeration = n$1 ? this.calculateExaggeration(i$1) : s$1.get("exaggeration"), !i$1.projection.requiresDraping && n$1 && 0 === this._exaggeration) return void this._disable();
						this.enabled = !0;
						const h$1 = () => {
							this.sourceCache.used && e.w(`Raster DEM source '${this.sourceCache.id}' is used both for terrain and as layer source.\nThis leads to lower resolution of hillshade. For full hillshade resolution but higher memory consumption, define another raster DEM source.`);
							const t$2 = this.getScaledDemTileSize();
							this.sourceCache.update(i$1, t$2, !0), this.resetTileLookupCache(this.sourceCache.id);
						};
						this.sourceCache.usedForTerrain || (this.resetTileLookupCache(this.sourceCache.id), this.sourceCache.usedForTerrain = !0, h$1(), this._initializing = !0), h$1(), i$1.updateElevation(!0, o$1), this.resetTileLookupCache(this.proxySourceCache.id), this.proxySourceCache.update(i$1), this._emptyDEMTextureDirty = !0, this._previousZoom = i$1.zoom;
					} else this._disable();
				}
				calculateExaggeration(t$1) {
					if (this._attenuationRange && t$1.zoom >= Math.ceil(this._attenuationRange[1])) return this._style.terrain.getExaggeration(t$1.zoom);
					const i$1 = this._previousCameraAltitude, o$1 = t$1.getFreeCameraOptions().position.z / t$1.pixelsPerMeter * t$1.worldSize;
					this._previousCameraAltitude = o$1;
					const s$1 = null != i$1 ? o$1 - i$1 : Number.MAX_VALUE;
					if (Math.abs(s$1) < 2) return this._exaggeration;
					const r$1 = t$1.zoom, n$1 = this._style.terrain;
					if (!this._previousUpdateTimestamp) return n$1.getExaggeration(r$1);
					let a$1 = r$1 - this._previousZoom;
					const l$1 = this._previousUpdateTimestamp;
					let c$1 = r$1;
					null != this._evaluationZoom && (c$1 = this._evaluationZoom, Math.abs(r$1 - c$1) > .5 && (a$1 = .5 * (r$1 - c$1 + a$1)), a$1 * s$1 < 0 && (c$1 += a$1)), this._evaluationZoom = c$1;
					const h$1 = n$1.getExaggeration(c$1), d$1 = h$1 === n$1.getExaggeration(Math.max(0, c$1 - .1));
					if (d$1 && Math.abs(h$1 - this._exaggeration) < .01) return h$1;
					let u$1 = Math.min(.1, .00375 * (this._updateTimestamp - l$1));
					return (d$1 || h$1 < .1 || Math.abs(a$1) < 1e-4) && (u$1 = Math.min(.2, 4 * u$1)), e.ak(this._exaggeration, h$1, u$1);
				}
				resetTileLookupCache(e$1) {
					this._findCoveringTileCache[e$1] = {};
				}
				attenuationRange() {
					return this._attenuationRange;
				}
				getDemUpscale() {
					return this.proxySourceCache.getSource().tileSize / 128;
				}
				getScaledDemTileSize() {
					return this.sourceCache.getSource().tileSize / 128 * this.proxySourceCache.getSource().tileSize;
				}
				_onStyleDataEvent(e$1) {
					"source" === e$1.dataType && e$1.coord ? this._clearRenderCacheForTile(e$1.sourceCacheId, e$1.coord) : "style" === e$1.dataType && (this.invalidateRenderCache = !0, this._evaluationZoom = void 0, this._previousUpdateTimestamp = void 0, this._previousCameraAltitude = void 0);
				}
				_disable() {
					if (this.enabled && (this.enabled = !1, this._emptyDEMTextureDirty = !0, this._sharedDepthStencil = void 0, this._evaluationZoom = void 0, this._previousUpdateTimestamp = void 0, this.proxySourceCache.deallocRenderCache(), this._style)) for (const e$1 in this._style._mergedSourceCaches) this._style._mergedSourceCaches[e$1].usedForTerrain = !1;
				}
				destroy() {
					this._disable(), this._emptyDEMTexture && this._emptyDEMTexture.destroy(), this.pool.forEach(((e$1) => e$1.fb.destroy())), this.pool = [], this.framebufferCopyTexture && this.framebufferCopyTexture.destroy();
				}
				_source() {
					return this.enabled ? this.sourceCache : null;
				}
				isUsingMockSource() {
					return this.sourceCache === this._mockSourceCache;
				}
				exaggeration() {
					return this.enabled ? this._exaggeration : 0;
				}
				get visibleDemTiles() {
					return this._visibleDemTiles;
				}
				get drapeBufferSize() {
					const e$1 = 2 * this.proxySourceCache.getSource().tileSize;
					return [e$1, e$1];
				}
				set useVertexMorphing(e$1) {
					this._useVertexMorphing = e$1;
				}
				updateTileBinding(t$1) {
					if (!this.enabled) return;
					this.prevTerrainTileForTile = this.terrainTileForTile;
					const i$1 = this.proxySourceCache, o$1 = this.painter.transform;
					this._initializing && (this._initializing = 0 === o$1._centerAltitude && -1 === this.getAtPointOrZero(e.ae.fromLngLat(o$1.center), -1), this._emptyDEMTextureDirty = !this._initializing);
					const s$1 = this.proxyCoords = i$1.getIds().map(((e$1) => {
						const t$2 = i$1.getTileByID(e$1).tileID;
						return t$2.projMatrix = o$1.calculateProjMatrix(t$2.toUnwrapped()), t$2;
					}));
					(function(t$2, i$2) {
						const o$2 = i$2.transform.pointCoordinate(i$2.transform.getCameraPoint()), s$2 = new e.P(o$2.x, o$2.y);
						t$2.sort(((t$3, i$3) => {
							if (i$3.overscaledZ - t$3.overscaledZ) return i$3.overscaledZ - t$3.overscaledZ;
							const o$3 = new e.P(t$3.canonical.x + (1 << t$3.canonical.z) * t$3.wrap, t$3.canonical.y), r$2 = new e.P(i$3.canonical.x + (1 << i$3.canonical.z) * i$3.wrap, i$3.canonical.y), n$2 = s$2.mult(1 << t$3.canonical.z);
							return n$2.x -= .5, n$2.y -= .5, n$2.distSqr(o$3) - n$2.distSqr(r$2);
						}));
					})(s$1, this.painter);
					const r$1 = this.proxyToSource || {};
					this.proxyToSource = {}, s$1.forEach(((e$1) => {
						this.proxyToSource[e$1.key] = {};
					})), this.terrainTileForTile = {};
					const n$1 = this._style._mergedSourceCaches;
					for (const e$1 in n$1) {
						const i$2 = n$1[e$1];
						if (!i$2.used) continue;
						if (i$2 !== this.sourceCache && this.resetTileLookupCache(i$2.id), this._setupProxiedCoordsForOrtho(i$2, t$1[e$1], r$1), i$2.usedForTerrain) continue;
						const o$2 = t$1[e$1];
						i$2.getSource().reparseOverscaled && this._assignTerrainTiles(o$2);
					}
					this.proxiedCoords[i$1.id] = s$1.map(((e$1) => new rr(e$1, e$1.key, this.orthoMatrix))), this._assignTerrainTiles(s$1), this._prepareDEMTextures(), this._setupDrapedRenderBatches(), this._initFBOPool(), this._setupRenderCache(r$1), this.renderingToTexture = !1;
					const a$1 = {};
					this._visibleDemTiles = [];
					for (const e$1 of this.proxyCoords) {
						const t$2 = this.terrainTileForTile[e$1.key];
						if (!t$2) continue;
						const i$2 = t$2.tileID.key;
						i$2 in a$1 || (this._visibleDemTiles.push(t$2), a$1[i$2] = i$2);
					}
				}
				_assignTerrainTiles(e$1) {
					this._initializing || e$1.forEach(((e$2) => {
						if (this.terrainTileForTile[e$2.key]) return;
						const t$1 = this._findTileCoveringTileID(e$2, this.sourceCache);
						t$1 && (this.terrainTileForTile[e$2.key] = t$1);
					}));
				}
				_prepareDEMTextures() {
					const e$1 = this.painter.context, t$1 = e$1.gl;
					for (const i$1 in this.terrainTileForTile) {
						const o$1 = this.terrainTileForTile[i$1], s$1 = o$1.dem;
						!s$1 || o$1.demTexture && !o$1.needsDEMTextureUpload || (e$1.activeTexture.set(t$1.TEXTURE1), ls(this.painter, o$1, s$1));
					}
				}
				_prepareDemTileUniforms(e$1, t$1, i$1, o$1) {
					if (!t$1 || null == t$1.demTexture) return !1;
					const s$1 = e$1.tileID.canonical, r$1 = Math.pow(2, t$1.tileID.canonical.z - s$1.z), n$1 = o$1 || "";
					return i$1[`u_dem_tl${n$1}`] = [s$1.x * r$1 % 1, s$1.y * r$1 % 1], i$1[`u_dem_scale${n$1}`] = r$1, !0;
				}
				get emptyDEMTexture() {
					return !this._emptyDEMTextureDirty && this._emptyDEMTexture ? this._emptyDEMTexture : this._updateEmptyDEMTexture();
				}
				_getLoadedAreaMinimum() {
					if (!this.enabled) return 0;
					let e$1 = 0;
					const t$1 = this._visibleDemTiles.reduce(((t$2, i$1) => {
						if (!i$1.dem) return t$2;
						const o$1 = i$1.dem.tree.minimums[0];
						return o$1 > 0 && e$1++, t$2 + o$1;
					}), 0);
					return e$1 ? t$1 / e$1 : 0;
				}
				_updateEmptyDEMTexture() {
					const t$1 = this.painter.context, i$1 = t$1.gl;
					t$1.activeTexture.set(i$1.TEXTURE2);
					const o$1 = this._getLoadedAreaMinimum(), s$1 = new e.dL({
						width: 1,
						height: 1
					}, new Float32Array([o$1]));
					this._emptyDEMTextureDirty = !1;
					let r$1 = this._emptyDEMTexture;
					return r$1 ? r$1.update(s$1, { premultiply: !1 }) : r$1 = this._emptyDEMTexture = new e.T(t$1, s$1, i$1.R32F, { premultiply: !1 }), r$1;
				}
				setupElevationDraw(t$1, i$1, o$1) {
					const s$1 = this.painter.context, r$1 = s$1.gl, n$1 = {
						u_dem: 2,
						u_dem_prev: 4,
						u_dem_tl: [0, 0],
						u_dem_tl_prev: [0, 0],
						u_dem_scale: 0,
						u_dem_scale_prev: 0,
						u_dem_size: 0,
						u_dem_lerp: 1,
						u_depth: 3,
						u_depth_size_inv: [0, 0],
						u_depth_range_unpack: [0, 1],
						u_occluder_half_size: 16,
						u_occlusion_depth_offset: -1e-4,
						u_exaggeration: 0
					};
					n$1.u_exaggeration = this.exaggeration();
					let a$1 = null, l$1 = null, c$1 = 1;
					if (o$1 && o$1.morphing && this._useVertexMorphing) {
						const e$1 = o$1.morphing.srcDemTile, i$2 = o$1.morphing.dstDemTile;
						c$1 = o$1.morphing.phase, e$1 && i$2 && (this._prepareDemTileUniforms(t$1, e$1, n$1, "_prev") && (l$1 = e$1), this._prepareDemTileUniforms(t$1, i$2, n$1) && (a$1 = i$2));
					}
					const h$1 = (e$1) => e$1 && e$1.demTexture && this.painter.linearFloatFilteringSupported() ? r$1.LINEAR : r$1.NEAREST;
					let d$1 = null;
					var u$1;
					if (this.enabled ? l$1 && a$1 ? (d$1 = a$1.demTexture, s$1.activeTexture.set(r$1.TEXTURE4), l$1.demTexture.bind(h$1(l$1), r$1.CLAMP_TO_EDGE), n$1.u_dem_lerp = c$1) : (a$1 = this.terrainTileForTile[t$1.tileID.key], d$1 = this._prepareDemTileUniforms(t$1, a$1, n$1) ? a$1.demTexture : this.emptyDEMTexture) : d$1 = this.emptyDEMTexture, s$1.activeTexture.set(r$1.TEXTURE2), d$1 && (n$1.u_dem_size = 1 === (u$1 = d$1).size[0] ? 1 : u$1.size[0] - 2, d$1.bind(h$1(a$1), r$1.CLAMP_TO_EDGE)), this.painter.setupDepthForOcclusion(o$1 && o$1.useDepthForOcclusion, i$1, n$1), o$1 && o$1.useMeterToDem && a$1) n$1.u_meter_to_dem = (1 << a$1.tileID.canonical.z) * e.cf(1, this.painter.transform.center.lat) * this.sourceCache.getSource().tileSize;
					if (o$1 && o$1.labelPlaneMatrixInv && (n$1.u_label_plane_matrix_inv = o$1.labelPlaneMatrixInv), i$1.setTerrainUniformValues(s$1, n$1), "globe" === this.painter.transform.projection.name) {
						const e$1 = this.globeUniformValues(this.painter.transform, t$1.tileID.canonical, o$1 && o$1.useDenormalizedUpVectorScale);
						i$1.setGlobeUniformValues(s$1, e$1);
					}
				}
				globeUniformValues(t$1, i$1, o$1) {
					const s$1 = t$1.projection;
					return {
						u_tile_tl_up: s$1.upVector(i$1, 0, 0),
						u_tile_tr_up: s$1.upVector(i$1, e.al, 0),
						u_tile_br_up: s$1.upVector(i$1, e.al, e.al),
						u_tile_bl_up: s$1.upVector(i$1, 0, e.al),
						u_tile_up_scale: o$1 ? e.dM(1) : s$1.upVectorScale(i$1, t$1.center.lat, t$1.worldSize).metersToTile
					};
				}
				renderToBackBuffer(t$1) {
					const i$1 = this.painter, o$1 = this.painter.context;
					0 !== t$1.length && (o$1.bindFramebuffer.set(null), o$1.viewport.set([
						0,
						0,
						i$1.width,
						i$1.height
					]), i$1.gpuTimingDeferredRenderStart(), this.renderingToTexture = !1, function(t$2, i$2, o$2, s$1, r$1) {
						if ("globe" === t$2.transform.projection.name) (function(t$3, i$3, o$3, s$2, r$2) {
							const n$1 = t$3.context, a$1 = n$1.gl;
							let l$1, c$1;
							const h$1 = t$3.transform, d$1 = e.dE(t$3, n$1, h$1), u$1 = (e$1, i$4) => {
								if (c$1 === i$4) return;
								const o$4 = [Ks[i$4], "PROJECTION_GLOBE_VIEW"];
								d$1 && o$4.push("CUSTOM_ANTIALIASING");
								const s$3 = t$3.isTileAffectedByFog(e$1);
								l$1 = t$3.getOrCreateProgram("globeRaster", {
									defines: o$4,
									overrideFog: s$3
								}), c$1 = i$4;
							}, _$1 = t$3.colorModeForRenderPass(), p$1 = new Xi(a$1.LEQUAL, Xi.ReadWrite, t$3.depthRangeFor3D);
							Ys.update(r$2);
							const f$1 = e.dF(h$1), m$1 = [e.aF(h$1.center.lng), e.aJ(h$1.center.lat)], g$1 = t$3.globeSharedBuffers, v$1 = [h$1.width * e.o.devicePixelRatio, h$1.height * e.o.devicePixelRatio], y$1 = Float32Array.from(h$1.globeMatrix), x$1 = { useDenormalizedUpVectorScale: !0 };
							{
								const h$2 = t$3.transform, d$2 = Js(h$2.zoom, i$3.exaggeration(), i$3.sourceCache._source.tileSize);
								c$1 = -1;
								const b$1 = a$1.TRIANGLES;
								for (const c$2 of s$2) {
									const s$3 = o$3.getTile(c$2), w$1 = Ki.disabled, T$1 = i$3.prevTerrainTileForTile[c$2.key], E$1 = i$3.terrainTileForTile[c$2.key];
									Xs(T$1, E$1) && Ys.newMorphing(c$2.key, T$1, E$1, r$2, 250), er(t$3, s$3.emissiveTexture), n$1.activeTexture.set(a$1.TEXTURE0), s$3.texture && s$3.texture.bind(a$1.LINEAR, a$1.CLAMP_TO_EDGE);
									const S$1 = Ys.getMorphValuesForProxy(c$2.key), I$1 = S$1 ? 1 : 0;
									S$1 && Object.assign(x$1, { morphing: {
										srcDemTile: S$1.from,
										dstDemTile: S$1.to,
										phase: e.dD(S$1.phase)
									} });
									const C$1 = e.dG(c$2.canonical), R$1 = e.dH(C$1.getCenter().lat), A$1 = e.dI(c$2.canonical, C$1, R$1, h$2.worldSize / h$2._pixelsPerMercatorPixel), L$1 = e.bk(e.dJ(c$2.canonical)), D$1 = "mrt-fallback" === t$3.emissiveMode ? 1 : 0, P$1 = $s(h$2.expandedFarZProjMatrix, y$1, f$1, L$1, e.aj(h$2.zoom), m$1, h$2.frustumCorners.TL, h$2.frustumCorners.TR, h$2.frustumCorners.BR, h$2.frustumCorners.BL, h$2.globeCenterInViewSpace, h$2.globeRadius, v$1, d$2, h$2._farZ, D$1, A$1);
									if (u$1(c$2, I$1), l$1 && (i$3.setupElevationDraw(s$3, l$1, x$1), t$3.uploadCommonUniforms(n$1, l$1, c$2.toUnwrapped()), g$1)) {
										const [e$1, i$4, o$4] = g$1.getGridBuffers(R$1, 0 !== d$2);
										l$1.draw(t$3, b$1, p$1, w$1, _$1, eo.backCCW, P$1, "globe_raster", e$1, i$4, o$4);
									}
								}
							}
							if (g$1 && (t$3.renderDefaultNorthPole || t$3.renderDefaultSouthPole)) {
								const r$3 = ["GLOBE_POLES", "PROJECTION_GLOBE_VIEW"];
								d$1 && r$3.push("CUSTOM_ANTIALIASING"), l$1 = t$3.getOrCreateProgram("globeRaster", { defines: r$3 });
								for (const r$4 of s$2) {
									const { x: s$3, y: c$2, z: d$2 } = r$4.canonical, u$2 = 0 === c$2, f$2 = c$2 === (1 << d$2) - 1, [y$2, b$1, w$1, T$1] = g$1.getPoleBuffers(d$2, !1);
									if (T$1 && (u$2 || f$2)) {
										const c$3 = o$3.getTile(r$4);
										er(t$3, c$3.emissiveTexture), n$1.activeTexture.set(a$1.TEXTURE0), c$3.texture && c$3.texture.bind(a$1.LINEAR, a$1.CLAMP_TO_EDGE);
										let g$2 = e.dK(d$2, s$3, h$1);
										const E$1 = e.bk(e.dJ(r$4.canonical)), S$1 = "mrt-fallback" === t$3.emissiveMode ? 1 : 0, I$1 = (e$1, i$4) => e$1.draw(t$3, a$1.TRIANGLES, p$1, Ki.disabled, _$1, eo.disabled, $s(h$1.expandedFarZProjMatrix, g$2, g$2, E$1, 0, m$1, h$1.frustumCorners.TL, h$1.frustumCorners.TR, h$1.frustumCorners.BR, h$1.frustumCorners.BL, h$1.globeCenterInViewSpace, h$1.globeRadius, v$1, 0, h$1._farZ, S$1), "globe_pole_raster", i$4, w$1, T$1);
										i$3.setupElevationDraw(c$3, l$1, x$1), t$3.uploadCommonUniforms(n$1, l$1, r$4.toUnwrapped()), u$2 && t$3.renderDefaultNorthPole && I$1(l$1, y$2), f$2 && t$3.renderDefaultSouthPole && (g$2 = e.cS(e.bC(), g$2, [
											1,
											-1,
											1
										]), I$1(l$1, b$1));
									}
								}
							}
						})(t$2, i$2, o$2, s$1, r$1);
						else {
							const n$1 = t$2.context, a$1 = n$1.gl;
							let l$1, c$1;
							const h$1 = t$2.shadowRenderer, d$1 = ho(t$2, t$2.longestCutoffRange), u$1 = (e$1) => {
								if (c$1 === e$1) return;
								const i$3 = [];
								i$3.push(Ks[e$1]), d$1.shouldRenderCutoff && i$3.push("RENDER_CUTOFF"), h$1 && (i$3.push("RENDER_SHADOWS", "DEPTH_TEXTURE"), h$1.useNormalOffset && i$3.push("NORMAL_OFFSET")), l$1 = t$2.getOrCreateProgram("terrainRaster", { defines: i$3 }), c$1 = e$1;
							}, _$1 = t$2.colorModeForRenderPass(), p$1 = new Xi(a$1.LEQUAL, Xi.ReadWrite, t$2.depthRangeFor3D);
							Ys.update(r$1);
							const f$1 = t$2.transform, m$1 = Js(f$1.zoom, i$2.exaggeration(), i$2.sourceCache._source.tileSize);
							let g$1 = [
								0,
								0,
								0
							];
							if (h$1) {
								const e$1 = t$2.style.directionalLight, i$3 = t$2.style.ambientLight;
								e$1 && i$3 && (g$1 = vo(t$2.style, e$1, i$3));
							}
							{
								c$1 = -1;
								const v$1 = a$1.TRIANGLES, [y$1, x$1] = [i$2.gridIndexBuffer, i$2.gridSegments];
								for (const c$2 of s$1) {
									const s$2 = o$2.getTile(c$2), b$1 = Ki.disabled, w$1 = i$2.prevTerrainTileForTile[c$2.key], T$1 = i$2.terrainTileForTile[c$2.key];
									Xs(w$1, T$1) && Ys.newMorphing(c$2.key, w$1, T$1, r$1, 250), er(t$2, s$2.emissiveTexture), n$1.activeTexture.set(a$1.TEXTURE0), s$2.texture && s$2.texture.bind(a$1.LINEAR, a$1.CLAMP_TO_EDGE);
									const E$1 = Ys.getMorphValuesForProxy(c$2.key), S$1 = E$1 ? 1 : 0;
									let I$1;
									E$1 && (I$1 = { morphing: {
										srcDemTile: E$1.from,
										dstDemTile: E$1.to,
										phase: e.dD(E$1.phase)
									} });
									const C$1 = "mrt-fallback" === t$2.emissiveMode ? 1 : 0, R$1 = Ws(c$2.projMatrix, Qs(c$2.canonical, f$1.renderWorldCopies) ? m$1 / 10 : m$1, g$1, C$1);
									if (u$1(S$1), !l$1) continue;
									i$2.setupElevationDraw(s$2, l$1, I$1);
									const A$1 = c$2.toUnwrapped();
									h$1 && h$1.setupShadows(A$1, l$1), t$2.uploadCommonUniforms(n$1, l$1, A$1, null, d$1), l$1.draw(t$2, v$1, p$1, b$1, _$1, eo.backCCW, R$1, "terrain_raster", i$2.gridBuffer, y$1, x$1);
								}
							}
						}
					}(i$1, this, this.proxySourceCache, t$1, this._updateTimestamp), this.renderingToTexture = !0, i$1.gpuTimingDeferredRenderEnd(), t$1.splice(0, t$1.length));
				}
				renderBatch(t$1) {
					if (0 === this._drapedRenderBatches.length) return t$1 + 1;
					this.renderingToTexture = !0;
					const i$1 = this.painter, o$1 = this.painter.context, s$1 = this.proxySourceCache, r$1 = this.proxiedCoords[s$1.id], n$1 = this._drapedRenderBatches.shift(), a$1 = i$1.style.order, l$1 = [];
					this._updateFBOs("mrt-fallback" === i$1.emissiveMode);
					let c$1 = 0;
					for (const h$1 of r$1) {
						const r$2 = s$1.getTileByID(h$1.proxyTileKey), d$1 = s$1.proxyCachedFBO[h$1.key] ? s$1.proxyCachedFBO[h$1.key][t$1] : void 0, u$1 = void 0 !== d$1 ? s$1.renderCache[d$1] : this.pool[c$1++], _$1 = void 0 !== d$1;
						if (r$2.texture = u$1.tex, r$2.emissiveTexture = u$1.emissiveTex, _$1 && !u$1.dirty) {
							l$1.push(r$2.tileID);
							continue;
						}
						o$1.bindFramebuffer.set(u$1.fb.framebuffer);
						const p$1 = o$1.gl;
						let f$1;
						p$1.drawBuffers("mrt-fallback" === i$1.emissiveMode ? [p$1.COLOR_ATTACHMENT0, p$1.COLOR_ATTACHMENT1] : [p$1.COLOR_ATTACHMENT0]), this.renderedToTile = !1, u$1.dirty && (o$1.clear({
							color: e.ao.transparent,
							stencil: 0
						}), u$1.dirty = !1);
						for (let e$1 = n$1.start; e$1 <= n$1.end; ++e$1) {
							const t$2 = i$1.style._mergedLayers[a$1[e$1]];
							if (t$2.isHidden(i$1.transform.zoom)) continue;
							const s$2 = i$1.style.getLayerSourceCache(t$2), r$3 = s$2 ? this.proxyToSource[h$1.key][s$2.id] : [h$1];
							if (!r$3) continue;
							const n$2 = r$3;
							o$1.viewport.set([
								0,
								0,
								u$1.fb.width,
								u$1.fb.height
							]), f$1 !== (s$2 ? s$2.id : null) && (this._setupStencil(u$1, r$3, t$2, s$2), f$1 = s$2 ? s$2.id : null), i$1.renderLayer(i$1, s$2, t$2, n$2);
						}
						if (p$1.drawBuffers([p$1.COLOR_ATTACHMENT0]), 0 === this._drapedRenderBatches.length) for (const e$1 of this._pendingGroundEffectLayers) {
							const t$2 = i$1.style._mergedLayers[a$1[e$1]];
							if (t$2.isHidden(i$1.transform.zoom)) continue;
							const s$2 = i$1.style.getLayerSourceCache(t$2), r$3 = s$2 ? this.proxyToSource[h$1.key][s$2.id] : [h$1];
							if (!r$3) continue;
							const n$2 = r$3;
							o$1.viewport.set([
								0,
								0,
								u$1.fb.width,
								u$1.fb.height
							]), f$1 !== (s$2 ? s$2.id : null) && (this._setupStencil(u$1, r$3, t$2, s$2), f$1 = s$2 ? s$2.id : null), i$1.renderLayer(i$1, s$2, t$2, n$2);
						}
						this.renderedToTile ? (u$1.dirty = !0, l$1.push(r$2.tileID)) : _$1 || --c$1, 5 === c$1 && (c$1 = 0, this.renderToBackBuffer(l$1));
					}
					return this.renderToBackBuffer(l$1), this.renderingToTexture = !1, o$1.bindFramebuffer.set(null), o$1.viewport.set([
						0,
						0,
						i$1.width,
						i$1.height
					]), n$1.end + 1;
				}
				postRender() {}
				isLayerOrderingCorrect(e$1) {
					const t$1 = e$1.order.length;
					let i$1 = -1, o$1 = t$1;
					for (let s$1 = 0; s$1 < t$1; ++s$1) this._style.isLayerDraped(e$1._mergedLayers[e$1.order[s$1]]) ? i$1 = Math.max(i$1, s$1) : o$1 = Math.min(o$1, s$1);
					return o$1 > i$1;
				}
				getMinElevationBelowMSL() {
					let e$1 = 0;
					return this._visibleDemTiles.filter(((e$2) => e$2.dem)).forEach(((t$1) => {
						e$1 = Math.min(e$1, t$1.dem.tree.minimums[0]);
					})), 0 === e$1 ? e$1 : (e$1 - 30) * this._exaggeration;
				}
				raycast(e$1, t$1, i$1) {
					if (!this._visibleDemTiles) return null;
					const o$1 = this._visibleDemTiles.filter(((e$2) => e$2.dem)).map(((o$2) => {
						const s$1 = o$2.tileID, r$1 = 1 << s$1.overscaledZ, { x: n$1, y: a$1 } = s$1.canonical, l$1 = n$1 / r$1, c$1 = (n$1 + 1) / r$1, h$1 = a$1 / r$1, d$1 = (a$1 + 1) / r$1;
						return {
							minx: l$1,
							miny: h$1,
							maxx: c$1,
							maxy: d$1,
							t: o$2.dem.tree.raycastRoot(l$1, h$1, c$1, d$1, e$1, t$1, i$1),
							tile: o$2
						};
					}));
					o$1.sort(((e$2, t$2) => (null !== e$2.t ? e$2.t : Number.MAX_VALUE) - (null !== t$2.t ? t$2.t : Number.MAX_VALUE)));
					for (const s$1 of o$1) {
						if (null == s$1.t) return null;
						const o$2 = s$1.tile.dem.tree.raycast(s$1.minx, s$1.miny, s$1.maxx, s$1.maxy, e$1, t$1, i$1);
						if (null != o$2) return o$2;
					}
					return null;
				}
				_createFBO() {
					const t$1 = this.painter.context, i$1 = t$1.gl, o$1 = this.drapeBufferSize;
					t$1.activeTexture.set(i$1.TEXTURE0);
					const s$1 = new e.T(t$1, {
						width: o$1[0],
						height: o$1[1],
						data: null
					}, i$1.RGBA8);
					s$1.bind(i$1.LINEAR, i$1.CLAMP_TO_EDGE);
					const r$1 = t$1.createFramebuffer(o$1[0], o$1[1], 1, null);
					let n$1;
					return r$1.colorAttachment0.set(s$1.texture), this._emissiveTexture && (n$1 = new e.T(t$1, {
						width: o$1[0],
						height: o$1[1],
						data: null
					}, i$1.R8), n$1.bind(i$1.LINEAR, i$1.CLAMP_TO_EDGE), r$1.createColorAttachment(t$1, 1), r$1.colorAttachment1.set(n$1.texture)), r$1.depthAttachment = new Zs(t$1, r$1.framebuffer), void 0 === this._sharedDepthStencil ? (this._sharedDepthStencil = t$1.createRenderbuffer(t$1.gl.DEPTH_STENCIL, o$1[0], o$1[1]), this._stencilRef = 0, r$1.depthAttachment.set(this._sharedDepthStencil), t$1.clear({ stencil: 0 })) : r$1.depthAttachment.set(this._sharedDepthStencil), t$1.extTextureFilterAnisotropic && i$1.texParameterf(i$1.TEXTURE_2D, t$1.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, t$1.extTextureFilterAnisotropicMax), {
						fb: r$1,
						tex: s$1,
						emissiveTex: n$1,
						dirty: !1
					};
				}
				_updateFBOs(e$1) {
					if (this._emissiveTexture !== e$1) {
						for (const t$1 of this.pool) this._updateFBO(t$1, e$1);
						for (const t$1 of this.proxySourceCache.renderCache) this._updateFBO(t$1, e$1);
						this._emissiveTexture = e$1;
					}
				}
				_updateFBO(t$1, i$1) {
					const o$1 = t$1.fb, s$1 = this.painter.context, r$1 = s$1.gl, n$1 = this.drapeBufferSize;
					if (i$1) {
						const i$2 = new e.T(s$1, {
							width: n$1[0],
							height: n$1[1],
							data: null
						}, r$1.R8);
						i$2.bind(r$1.LINEAR, r$1.CLAMP_TO_EDGE), t$1.emissiveTex = i$2, o$1.createColorAttachment(s$1, 1), o$1.colorAttachment1.set(i$2.texture);
					} else t$1.emissiveTex = void 0, o$1.removeColorAttachment(s$1, 1);
					t$1.dirty = !0;
				}
				_initFBOPool() {
					for (; this.pool.length < Math.min(5, this.proxyCoords.length);) this.pool.push(this._createFBO());
				}
				_shouldDisableRenderCache() {
					if (this._debugParams.disableRenderCache) return !0;
					if (this._style.hasLightTransitions()) return !0;
					for (const e$1 in this._style._mergedSourceCaches) if (this._style._mergedSourceCaches[e$1].hasTransition()) return !0;
					return this._style.order.some(((e$1) => {
						const t$1 = this._style._mergedLayers[e$1], i$1 = t$1.isHidden(this.painter.transform.zoom);
						return "hillshade" === t$1.type || "custom" === t$1.type ? !i$1 && t$1.shouldRedrape() : !i$1 && t$1.hasTransition();
					}));
				}
				_clearLineLayersFromRenderCache() {
					let t$1 = !1;
					for (const e$1 of this._style.getSources()) if (e$1 instanceof dt) {
						t$1 = !0;
						break;
					}
					if (!t$1) return;
					const i$1 = {};
					for (let t$2 = 0; t$2 < this._style.order.length; ++t$2) {
						const o$1 = this._style._mergedLayers[this._style.order[t$2]], s$1 = this._style.getLayerSourceCache(o$1);
						if (!s$1 || i$1[s$1.id]) continue;
						if (o$1.isHidden(this.painter.transform.zoom) || "line" !== o$1.type) continue;
						const r$1 = o$1.widthExpression(), n$1 = o$1.emissiveStrengthExpression();
						if (r$1 instanceof e.ad || n$1 instanceof e.ad) {
							i$1[s$1.id] = !0;
							for (const e$1 of this.proxyCoords) {
								const t$3 = this.proxyToSource[e$1.key][s$1.id];
								if (t$3) for (const e$2 of t$3) this._clearRenderCacheForTile(s$1.id, e$2);
							}
						}
					}
				}
				_clearRasterLayersFromRenderCache() {
					let e$1 = !1;
					for (const t$2 in this._style._mergedSourceCaches) if (this._style._mergedSourceCaches[t$2]._source instanceof ut) {
						e$1 = !0;
						break;
					}
					if (!e$1) return;
					const t$1 = {};
					for (let e$2 = 0; e$2 < this._style.order.length; ++e$2) {
						const i$1 = this._style._mergedLayers[this._style.order[e$2]], o$1 = this._style.getLayerSourceCache(i$1);
						if (!o$1 || t$1[o$1.id]) continue;
						if (i$1.isHidden(this.painter.transform.zoom) || "raster" !== i$1.type) continue;
						const s$1 = i$1.paint.get("raster-fade-duration");
						for (const e$3 of this.proxyCoords) {
							const t$2 = this.proxyToSource[e$3.key][o$1.id];
							if (t$2) for (const e$4 of t$2) {
								const t$3 = ir(o$1.getTile(e$4), o$1.findLoadedParent(e$4, 0), o$1, this.painter.transform, s$1);
								(1 !== t$3.opacity || 0 !== t$3.mix) && this._clearRenderCacheForTile(o$1.id, e$4);
							}
						}
					}
				}
				_setupDrapedRenderBatches() {
					this._style.updateDrapeFirstLayers();
					const t$1 = this._style.order, i$1 = t$1.length;
					if (0 === i$1) return;
					const o$1 = [];
					this._pendingGroundEffectLayers = [];
					let s$1, r$1 = 0, n$1 = this._style._mergedLayers[t$1[r$1]];
					for (; !this._style.isLayerDraped(n$1) && n$1.isHidden(this.painter.transform.zoom) && ++r$1 < i$1;) n$1 = this._style._mergedLayers[t$1[r$1]];
					for (; r$1 < i$1; ++r$1) {
						const e$1 = this._style._mergedLayers[t$1[r$1]];
						e$1.isHidden(this.painter.transform.zoom) || (this._style.isLayerDraped(e$1) ? void 0 === s$1 && (s$1 = r$1) : ("fill-extrusion" === e$1.type && this._pendingGroundEffectLayers.push(r$1), void 0 !== s$1 && (o$1.push({
							start: s$1,
							end: r$1 - 1
						}), s$1 = void 0)));
					}
					if (void 0 !== s$1 && o$1.push({
						start: s$1,
						end: r$1 - 1
					}), 0 !== o$1.length) {
						const t$2 = o$1[o$1.length - 1];
						this._pendingGroundEffectLayers.every(((e$1) => e$1 > t$2.end)) || e.w("fill-extrusion with flood lighting and/or ground ambient occlusion should be moved to be on top of all draped layers.");
					}
					this._drapedRenderBatches = o$1;
				}
				_setupRenderCache(e$1) {
					const t$1 = this.proxySourceCache;
					if (this._shouldDisableRenderCache() || this.invalidateRenderCache) {
						if (this.invalidateRenderCache = !1, t$1.renderCache.length > t$1.renderCachePool.length) {
							const e$2 = Object.values(t$1.proxyCachedFBO);
							t$1.proxyCachedFBO = {};
							for (let i$2 = 0; i$2 < e$2.length; ++i$2) {
								const o$2 = Object.values(e$2[i$2]);
								t$1.renderCachePool.push(...o$2);
							}
						}
						return;
					}
					this._clearRasterLayersFromRenderCache();
					const i$1 = this.proxyCoords, o$1 = this._tilesDirty;
					for (let s$2 = i$1.length - 1; s$2 >= 0; s$2--) {
						const r$1 = i$1[s$2];
						if (t$1.getTileByID(r$1.key), void 0 !== t$1.proxyCachedFBO[r$1.key]) {
							const i$2 = e$1[r$1.key], s$3 = this.proxyToSource[r$1.key];
							let n$1 = 0;
							for (const e$2 in s$3) {
								const t$2 = s$3[e$2], r$2 = i$2[e$2];
								if (!r$2 || r$2.length !== t$2.length || t$2.some(((t$3, i$3) => t$3 !== r$2[i$3] || o$1[e$2] && o$1[e$2].hasOwnProperty(t$3.key)))) {
									n$1 = -1;
									break;
								}
								++n$1;
							}
							for (const e$2 in t$1.proxyCachedFBO[r$1.key]) t$1.renderCache[t$1.proxyCachedFBO[r$1.key][e$2]].dirty = n$1 < 0 || n$1 !== Object.values(i$2).length;
						}
					}
					const s$1 = [...this._drapedRenderBatches];
					s$1.sort(((e$2, t$2) => t$2.end - t$2.start - (e$2.end - e$2.start)));
					for (const e$2 of s$1) for (const o$2 of i$1) {
						if (t$1.proxyCachedFBO[o$2.key]) continue;
						let i$2 = t$1.renderCachePool.pop();
						void 0 === i$2 && t$1.renderCache.length < 50 && (i$2 = t$1.renderCache.length, t$1.renderCache.push(this._createFBO())), void 0 !== i$2 && (t$1.proxyCachedFBO[o$2.key] = {}, t$1.proxyCachedFBO[o$2.key][e$2.start] = i$2, t$1.renderCache[i$2].dirty = !0);
					}
					this._tilesDirty = {};
				}
				_setupStencil(e$1, t$1, i$1, o$1) {
					if (!o$1 || !this._sourceTilesOverlap[o$1.id]) return void (this._overlapStencilType && (this._overlapStencilType = !1));
					const s$1 = this.painter.context, r$1 = s$1.gl;
					if (t$1.length <= 1) return void (this._overlapStencilType = !1);
					let n$1;
					if (i$1.isTileClipped()) n$1 = t$1.length, this._overlapStencilMode.test = {
						func: r$1.EQUAL,
						mask: 255
					}, this._overlapStencilType = "Clip";
					else {
						if (!(t$1[0].overscaledZ > t$1[t$1.length - 1].overscaledZ)) return void (this._overlapStencilType = !1);
						n$1 = 1, this._overlapStencilMode.test = {
							func: r$1.GREATER,
							mask: 255
						}, this._overlapStencilType = "Mask";
					}
					this._stencilRef + n$1 > 255 && (s$1.clear({ stencil: 0 }), this._stencilRef = 0), this._stencilRef += n$1, this._overlapStencilMode.ref = this._stencilRef, i$1.isTileClipped() && this._renderTileClippingMasks(t$1, this._overlapStencilMode.ref);
				}
				clipOrMaskOverlapStencilType() {
					return "Clip" === this._overlapStencilType || "Mask" === this._overlapStencilType;
				}
				stencilModeForRTTOverlap(e$1) {
					return this.renderingToTexture && this._overlapStencilType ? ("Clip" === this._overlapStencilType && (this._overlapStencilMode.ref = this.painter._tileClippingMaskIDs[e$1.key]), this._overlapStencilMode) : Ki.disabled;
				}
				_renderTileClippingMasks(e$1, t$1) {
					const i$1 = this.painter, o$1 = this.painter.context, s$1 = o$1.gl;
					i$1._tileClippingMaskIDs = {}, o$1.setColorMode($i.disabled), o$1.setDepthMode(Xi.disabled);
					const r$1 = i$1.getOrCreateProgram("clippingMask");
					for (const o$2 of e$1) {
						const e$2 = i$1._tileClippingMaskIDs[o$2.key] = --t$1;
						r$1.draw(i$1, s$1.TRIANGLES, Xi.disabled, new Ki({
							func: s$1.ALWAYS,
							mask: 0
						}, e$2, 255, s$1.KEEP, s$1.KEEP, s$1.REPLACE), $i.disabled, eo.disabled, tr(o$2.projMatrix), "$clipping", i$1.tileExtentBuffer, i$1.quadTriangleIndexBuffer, i$1.tileExtentSegments);
					}
				}
				pointCoordinate(t$1) {
					const i$1 = this.painter.transform;
					if (t$1.x < 0 || t$1.x > i$1.width || t$1.y < 0 || t$1.y > i$1.height) return null;
					const o$1 = [
						t$1.x,
						t$1.y,
						1,
						1
					];
					e.aC(o$1, o$1, i$1.pixelMatrixInverse), e.cK(o$1, o$1, 1 / o$1[3]), o$1[0] /= i$1.worldSize, o$1[1] /= i$1.worldSize;
					const s$1 = i$1._camera.position, r$1 = e.cf(1, i$1.center.lat), n$1 = [
						s$1[0],
						s$1[1],
						s$1[2] / r$1,
						0
					], a$1 = e.da([], o$1.slice(0, 3), n$1);
					e.aw(a$1, a$1);
					const l$1 = this.raycast(n$1, a$1, this._exaggeration);
					return null !== l$1 && l$1 ? (e.bH(n$1, n$1, a$1, l$1), n$1[3] = n$1[2], n$1[2] *= r$1, n$1) : null;
				}
				_setupProxiedCoordsForOrtho(t$1, i$1, o$1) {
					if (t$1.getSource() instanceof e.aU) return this._setupProxiedCoordsForImageSource(t$1, i$1, o$1);
					this._findCoveringTileCache[t$1.id] = this._findCoveringTileCache[t$1.id] || {};
					const s$1 = this.proxiedCoords[t$1.id] = [], r$1 = this.proxyCoords;
					for (let e$1 = 0; e$1 < r$1.length; e$1++) {
						const i$2 = r$1[e$1], n$2 = this._findTileCoveringTileID(i$2, t$1);
						if (n$2) {
							const e$2 = this._createProxiedId(i$2, n$2, o$1[i$2.key] && o$1[i$2.key][t$1.id]);
							s$1.push(e$2), this.proxyToSource[i$2.key][t$1.id] = [e$2];
						}
					}
					let n$1 = !1;
					const a$1 = /* @__PURE__ */ new Set();
					for (let e$1 = 0; e$1 < i$1.length; e$1++) {
						const r$2 = t$1.getTile(i$1[e$1]);
						if (!r$2 || !r$2.hasData()) continue;
						const l$1 = this._findTileCoveringTileID(r$2.tileID, this.proxySourceCache);
						if (l$1 && l$1.tileID.canonical.z !== r$2.tileID.canonical.z) {
							const e$2 = this.proxyToSource[l$1.tileID.key][t$1.id], i$2 = this._createProxiedId(l$1.tileID, r$2, o$1[l$1.tileID.key] && o$1[l$1.tileID.key][t$1.id]);
							e$2 ? e$2.splice(e$2.length - 1, 0, i$2) : this.proxyToSource[l$1.tileID.key][t$1.id] = [i$2];
							const c$1 = this.proxyToSource[l$1.tileID.key][t$1.id];
							a$1.has(c$1) || a$1.add(c$1), s$1.push(i$2), n$1 = !0;
						}
					}
					if (this._sourceTilesOverlap[t$1.id] = n$1, n$1 && this._debugParams.sortTilesHiZFirst) for (const e$1 of a$1) e$1.sort(((e$2, t$2) => t$2.overscaledZ - e$2.overscaledZ));
				}
				_setupProxiedCoordsForImageSource(t$1, i$1, o$1) {
					if (!t$1.getSource().loaded()) return;
					const s$1 = this.proxiedCoords[t$1.id] = [], r$1 = this.proxyCoords, n$1 = t$1.getSource(), a$1 = n$1.tileID;
					if (!a$1) return;
					const l$1 = new e.P(a$1.x, a$1.y)._div(1 << a$1.z), c$1 = n$1.coordinates.map(e.ae.fromLngLat).reduce(((e$1, t$2) => (e$1.min.x = Math.min(e$1.min.x, t$2.x - l$1.x), e$1.min.y = Math.min(e$1.min.y, t$2.y - l$1.y), e$1.max.x = Math.max(e$1.max.x, t$2.x - l$1.x), e$1.max.y = Math.max(e$1.max.y, t$2.y - l$1.y), e$1)), {
						min: new e.P(Number.MAX_VALUE, Number.MAX_VALUE),
						max: new e.P(-Number.MAX_VALUE, -Number.MAX_VALUE)
					}), h$1 = (t$2, i$2) => {
						const o$2 = t$2.wrap + t$2.canonical.x / (1 << t$2.canonical.z), s$2 = t$2.canonical.y / (1 << t$2.canonical.z), r$2 = e.al / (1 << t$2.canonical.z), n$2 = i$2.wrap + i$2.canonical.x / (1 << i$2.canonical.z), a$2 = i$2.canonical.y / (1 << i$2.canonical.z);
						return o$2 + r$2 < n$2 + c$1.min.x || o$2 > n$2 + c$1.max.x || s$2 + r$2 < a$2 + c$1.min.y || s$2 > a$2 + c$1.max.y;
					};
					for (let e$1 = 0; e$1 < r$1.length; e$1++) {
						const n$2 = r$1[e$1];
						for (let e$2 = 0; e$2 < i$1.length; e$2++) {
							const r$2 = t$1.getTile(i$1[e$2]);
							if (!r$2 || !r$2.hasData()) continue;
							if (h$1(n$2, r$2.tileID)) continue;
							const a$2 = this._createProxiedId(n$2, r$2, o$1[n$2.key] && o$1[n$2.key][t$1.id]), l$2 = this.proxyToSource[n$2.key][t$1.id];
							l$2 ? l$2.push(a$2) : this.proxyToSource[n$2.key][t$1.id] = [a$2], s$1.push(a$2);
						}
					}
				}
				_createProxiedId(t$1, i$1, o$1) {
					let s$1 = this.orthoMatrix;
					if (o$1) {
						const e$1 = o$1.find(((e$2) => e$2.key === i$1.tileID.key));
						if (e$1) return e$1;
					}
					if (i$1.tileID.key !== t$1.key) {
						const o$2 = t$1.canonical.z - i$1.tileID.canonical.z;
						let r$1, n$1, a$1;
						s$1 = e.bC();
						const l$1 = i$1.tileID.wrap - t$1.wrap << t$1.overscaledZ;
						o$2 > 0 ? (r$1 = e.al >> o$2, n$1 = r$1 * ((i$1.tileID.canonical.x << o$2) - t$1.canonical.x + l$1), a$1 = r$1 * ((i$1.tileID.canonical.y << o$2) - t$1.canonical.y)) : (r$1 = e.al << -o$2, n$1 = e.al * (i$1.tileID.canonical.x - (t$1.canonical.x + l$1 << -o$2)), a$1 = e.al * (i$1.tileID.canonical.y - (t$1.canonical.y << -o$2))), e.ce(s$1, 0, r$1, 0, r$1, 0, 1), e.br(s$1, s$1, [
							n$1,
							a$1,
							0
						]);
					}
					return new rr(i$1.tileID, t$1.key, s$1);
				}
				_findTileCoveringTileID(t$1, i$1) {
					let o$1 = i$1.getTile(t$1);
					if (o$1 && o$1.hasData()) return o$1;
					const s$1 = this._findCoveringTileCache[i$1.id], r$1 = s$1[t$1.key];
					if (o$1 = r$1 ? i$1.getTileByID(r$1) : null, o$1 && o$1.hasData() || null === r$1) return o$1;
					let n$1 = o$1 ? o$1.tileID : t$1, a$1 = n$1.overscaledZ;
					const l$1 = i$1.getSource().minzoom, c$1 = [];
					if (!r$1) {
						const s$2 = i$1.getSource().maxzoom;
						if (t$1.canonical.z >= s$2) {
							const o$2 = t$1.canonical.z - s$2;
							i$1.getSource().reparseOverscaled ? (a$1 = Math.max(t$1.canonical.z + 2, i$1.transform.tileZoom), n$1 = new e.aQ(a$1, t$1.wrap, s$2, t$1.canonical.x >> o$2, t$1.canonical.y >> o$2)) : 0 !== o$2 && (a$1 = s$2, n$1 = new e.aQ(a$1, t$1.wrap, s$2, t$1.canonical.x >> o$2, t$1.canonical.y >> o$2));
						}
						n$1.key !== t$1.key && (c$1.push(n$1.key), o$1 = i$1.getTile(n$1));
					}
					const h$1 = (e$1) => {
						c$1.forEach(((t$2) => {
							s$1[t$2] = e$1;
						})), c$1.length = 0;
					};
					for (a$1 -= 1; a$1 >= l$1 && (!o$1 || !o$1.hasData()); a$1--) {
						o$1 && h$1(o$1.tileID.key);
						const e$1 = n$1.calculateScaledKey(a$1);
						if (o$1 = i$1.getTileByID(e$1), o$1 && o$1.hasData()) break;
						const t$2 = s$1[e$1];
						if (null === t$2) break;
						void 0 === t$2 ? c$1.push(e$1) : o$1 = i$1.getTileByID(t$2);
					}
					return h$1(o$1 ? o$1.tileID.key : null), o$1 && o$1.hasData() ? o$1 : null;
				}
				findDEMTileFor(e$1) {
					return this.enabled ? this._findTileCoveringTileID(e$1, this.sourceCache) : null;
				}
				prepareDrawTile() {
					this.renderedToTile = !0;
				}
				_clearRenderCacheForTile(e$1, t$1) {
					let i$1 = this._tilesDirty[e$1];
					i$1 || (i$1 = this._tilesDirty[e$1] = {}), i$1[t$1.key] = !0;
				}
			}
			function ar(t$1, i$1, o$1) {
				const s$1 = function(t$2, i$2, o$2) {
					const s$2 = e.bJ(i$2, t$2), r$2 = e.bJ(o$2, [
						.2126,
						.7152,
						.0722
					]), n$2 = (e$1, t$3, i$3) => (1 - i$3) * e$1 + i$3 * t$3, a$2 = n$2(1 - .3 * Math.min(r$2, 1), 1, Math.min(s$2 + 1, 1));
					return n$2(.92, 1, Math.asin(e.aA(i$2[2], -1, 1)) / Math.PI + .5) * a$2;
				}(t$1, [
					0,
					0,
					1
				], i$1), r$1 = [
					0,
					0,
					0
				];
				e.c5(r$1, o$1.slice(0, 3), s$1);
				const n$1 = [
					0,
					0,
					0
				];
				e.c5(n$1, i$1.slice(0, 3), t$1[2]);
				const a$1 = [
					0,
					0,
					0
				];
				return e.d8(a$1, r$1, n$1), e.db(a$1);
			}
			const lr = [
				"fill",
				"fillOutline",
				"fillPattern",
				"line",
				"linePattern",
				"background",
				"backgroundPattern",
				"hillshade",
				"raster"
			], cr = [
				"stars",
				"rainParticle",
				"snowParticle",
				"fillExtrusion",
				"fillExtrusionGroundEffect",
				"building",
				"buildingBloom",
				"elevatedStructures",
				"model",
				"symbol"
			];
			class hr {
				static cacheKey(e$1, t$1, i$1, o$1) {
					const s$1 = [t$1];
					o$1 && s$1.push(o$1.cacheKey);
					for (const t$2 of i$1) e$1.usedDefines.has(t$2) && s$1.push(t$2);
					return s$1.join("/");
				}
				constructor(t$1, i$1, o$1, s$1, r$1, n$1) {
					const a$1 = t$1.gl;
					this.program = a$1.createProgram(), this.configuration = s$1, this.name = i$1, this.fixedDefines = [...n$1];
					const l$1 = `#version 300 es\n${(s$1 ? s$1.defines() : []).concat(n$1.map(((e$1) => `#define ${e$1}`))).join("\n")}`, c$1 = [l$1, es];
					for (const e$1 of o$1.fragmentIncludes) c$1.push(Yo[e$1]);
					c$1.push(o$1.fragmentSource);
					const h$1 = c$1.join("\n"), d$1 = [l$1, ts];
					for (const e$1 of o$1.vertexIncludes) d$1.push(Yo[e$1]);
					this.forceManualRenderingForInstanceIDShaders = t$1.forceManualRenderingForInstanceIDShaders && o$1.vertexSource.includes("gl_InstanceID"), this.forceManualRenderingForInstanceIDShaders && d$1.push("uniform int u_instanceID;"), d$1.push(o$1.vertexSource);
					let u$1 = d$1.join("\n");
					this.forceManualRenderingForInstanceIDShaders && (u$1 = u$1.replaceAll("gl_InstanceID", "u_instanceID"));
					const _$1 = a$1.createShader(a$1.FRAGMENT_SHADER);
					if (a$1.isContextLost()) return void (this.failedToCreate = !0);
					a$1.shaderSource(_$1, h$1), a$1.compileShader(_$1), a$1.attachShader(this.program, _$1);
					const p$1 = a$1.createShader(a$1.VERTEX_SHADER);
					a$1.isContextLost() ? this.failedToCreate = !0 : (a$1.shaderSource(p$1, u$1), a$1.compileShader(p$1), a$1.attachShader(this.program, p$1), this.attributes = {}, a$1.linkProgram(this.program), a$1.deleteShader(p$1), a$1.deleteShader(_$1), this.fixedUniforms = r$1(t$1), this.fixedUniformsEntries = Object.entries(this.fixedUniforms), this.binderUniforms = s$1 ? s$1.getUniforms(t$1) : [], this.forceManualRenderingForInstanceIDShaders && (this.instancingUniforms = ((t$2) => ({ u_instanceID: new e.ch(t$2) }))(t$1)), (n$1.includes("TERRAIN") || i$1.includes("symbol") || i$1.includes("circle")) && (this.terrainUniforms = ((t$2) => ({
						u_dem: new e.ch(t$2),
						u_dem_prev: new e.ch(t$2),
						u_dem_tl: new e.ck(t$2),
						u_dem_scale: new e.cj(t$2),
						u_dem_tl_prev: new e.ck(t$2),
						u_dem_scale_prev: new e.cj(t$2),
						u_dem_size: new e.cj(t$2),
						u_dem_lerp: new e.cj(t$2),
						u_exaggeration: new e.cj(t$2),
						u_depth: new e.ch(t$2),
						u_depth_size_inv: new e.ck(t$2),
						u_depth_range_unpack: new e.ck(t$2),
						u_occluder_half_size: new e.cj(t$2),
						u_occlusion_depth_offset: new e.cj(t$2),
						u_meter_to_dem: new e.cj(t$2),
						u_label_plane_matrix_inv: new e.cl(t$2)
					}))(t$1)), n$1.includes("GLOBE") && (this.globeUniforms = ((t$2) => ({
						u_tile_tl_up: new e.ci(t$2),
						u_tile_tr_up: new e.ci(t$2),
						u_tile_br_up: new e.ci(t$2),
						u_tile_bl_up: new e.ci(t$2),
						u_tile_up_scale: new e.cj(t$2)
					}))(t$1)), n$1.includes("FOG") && (this.fogUniforms = ((t$2) => ({
						u_fog_matrix: new e.cl(t$2),
						u_fog_range: new e.ck(t$2),
						u_fog_color: new e.d3(t$2),
						u_fog_horizon_blend: new e.cj(t$2),
						u_fog_vertical_limit: new e.ck(t$2),
						u_fog_temporal_offset: new e.cj(t$2),
						u_frustum_tl: new e.ci(t$2),
						u_frustum_tr: new e.ci(t$2),
						u_frustum_br: new e.ci(t$2),
						u_frustum_bl: new e.ci(t$2),
						u_globe_pos: new e.ci(t$2),
						u_globe_radius: new e.cj(t$2),
						u_globe_transition: new e.cj(t$2),
						u_is_globe: new e.ch(t$2),
						u_viewport: new e.ck(t$2)
					}))(t$1)), n$1.includes("RENDER_CUTOFF") && (this.cutoffUniforms = ((t$2) => ({ u_cutoff_params: new e.d3(t$2) }))(t$1)), n$1.includes("LIGHTING_3D_MODE") && (this.lightsUniforms = ((t$2) => ({
						u_lighting_ambient_color: new e.ci(t$2),
						u_lighting_directional_dir: new e.ci(t$2),
						u_lighting_directional_color: new e.ci(t$2),
						u_ground_radiance: new e.ci(t$2)
					}))(t$1)), n$1.includes("RENDER_SHADOWS") && (this.shadowUniforms = ((t$2) => ({
						u_light_matrix_0: new e.cl(t$2),
						u_light_matrix_1: new e.cl(t$2),
						u_fade_range: new e.ck(t$2),
						u_shadow_normal_offset: new e.ci(t$2),
						u_shadow_intensity: new e.cj(t$2),
						u_shadow_texel_size: new e.cj(t$2),
						u_shadow_map_resolution: new e.cj(t$2),
						u_shadow_direction: new e.ci(t$2),
						u_shadow_bias: new e.ci(t$2),
						u_shadowmap_0: new e.ch(t$2),
						u_shadowmap_1: new e.ch(t$2)
					}))(t$1)));
				}
				getAttributeLocation(e$1, t$1) {
					let i$1 = this.attributes[t$1];
					return void 0 === i$1 && (i$1 = this.attributes[t$1] = e$1.getAttribLocation(this.program, t$1)), i$1;
				}
				setTerrainUniformValues(e$1, t$1) {
					if (!this.terrainUniforms) return;
					const i$1 = this.terrainUniforms;
					if (!this.failedToCreate) {
						e$1.program.set(this.program);
						for (const e$2 in t$1) i$1[e$2] && i$1[e$2].set(this.program, e$2, t$1[e$2]);
					}
				}
				setGlobeUniformValues(e$1, t$1) {
					if (!this.globeUniforms) return;
					const i$1 = this.globeUniforms;
					if (!this.failedToCreate) {
						e$1.program.set(this.program);
						for (const e$2 in t$1) i$1[e$2] && i$1[e$2].set(this.program, e$2, t$1[e$2]);
					}
				}
				setFogUniformValues(e$1, t$1) {
					if (!this.fogUniforms) return;
					const i$1 = this.fogUniforms;
					if (!this.failedToCreate) {
						e$1.program.set(this.program);
						for (const e$2 in t$1) i$1[e$2].set(this.program, e$2, t$1[e$2]);
					}
				}
				setCutoffUniformValues(e$1, t$1) {
					if (!this.cutoffUniforms) return;
					const i$1 = this.cutoffUniforms;
					if (!this.failedToCreate) {
						e$1.program.set(this.program);
						for (const e$2 in t$1) i$1[e$2].set(this.program, e$2, t$1[e$2]);
					}
				}
				setLightsUniformValues(e$1, t$1) {
					if (!this.lightsUniforms) return;
					const i$1 = this.lightsUniforms;
					if (!this.failedToCreate) {
						e$1.program.set(this.program);
						for (const e$2 in t$1) i$1[e$2].set(this.program, e$2, t$1[e$2]);
					}
				}
				setShadowUniformValues(e$1, t$1) {
					if (this.failedToCreate || !this.shadowUniforms) return;
					const i$1 = this.shadowUniforms;
					e$1.program.set(this.program);
					for (const e$2 in t$1) i$1[e$2].set(this.program, e$2, t$1[e$2]);
				}
				_drawDebugWireframe(t$1, i$1, o$1, s$1, r$1, n$1, a$1, l$1, c$1, h$1) {
					const d$1 = t$1.options.wireframe;
					if (!1 === d$1.terrain && !1 === d$1.layers2D && !1 === d$1.layers3D) return;
					const u$1 = t$1.context;
					if (!(() => !(!d$1.terrain || "terrainRaster" !== this.name && "globeRaster" !== this.name) || !(!d$1.layers2D || t$1._terrain && t$1._terrain.renderingToTexture || !lr.includes(this.name)) || !(!d$1.layers3D || !cr.includes(this.name)))()) return;
					const _$1 = u$1.gl, p$1 = t$1.wireframeDebugCache.getLinesFromTrianglesBuffer(t$1.frameCounter, r$1, u$1);
					if (!p$1) return;
					const f$1 = [...this.fixedDefines, "DEBUG_WIREFRAME"], m$1 = t$1.getOrCreateProgram(this.name, {
						config: this.configuration,
						defines: f$1
					});
					u$1.program.set(m$1.program);
					const g$1 = (e$1, t$2, i$2) => {
						if (t$2[e$1] && i$2[e$1]) for (const o$2 in t$2[e$1]) i$2[e$1][o$2] && i$2[e$1][o$2].set(i$2.program, o$2, t$2[e$1][o$2].current);
					};
					c$1 && c$1.setUniforms(m$1.program, u$1, m$1.binderUniforms, a$1, { zoom: l$1 }), g$1("fixedUniforms", this, m$1), g$1("terrainUniforms", this, m$1), g$1("globeUniforms", this, m$1), g$1("fogUniforms", this, m$1), g$1("lightsUniforms", this, m$1), g$1("shadowUniforms", this, m$1), p$1.bind(), u$1.setColorMode(new $i([
						_$1.ONE,
						_$1.ONE_MINUS_SRC_ALPHA,
						_$1.ZERO,
						_$1.ONE
					], e.ao.transparent, [
						!0,
						!0,
						!0,
						!1
					])), u$1.setDepthMode(new Xi(i$1.func === _$1.LESS ? _$1.LEQUAL : i$1.func, Xi.ReadOnly, i$1.range)), u$1.setStencilMode(Ki.disabled);
					const v$1 = 3 * n$1.primitiveLength * 2, y$1 = 3 * n$1.primitiveOffset * 2 * 2;
					if (this.forceManualRenderingForInstanceIDShaders) {
						const e$1 = h$1 || 1;
						for (let t$2 = 0; t$2 < e$1; ++t$2) m$1.instancingUniforms.u_instanceID.set(this.program, "u_instanceID", t$2), _$1.drawElements(_$1.LINES, v$1, _$1.UNSIGNED_SHORT, y$1);
					} else h$1 && h$1 > 1 ? _$1.drawElementsInstanced(_$1.LINES, v$1, _$1.UNSIGNED_SHORT, y$1, h$1) : _$1.drawElements(_$1.LINES, v$1, _$1.UNSIGNED_SHORT, y$1);
					r$1.bind(), u$1.program.set(this.program), u$1.setDepthMode(i$1), u$1.setStencilMode(o$1), u$1.setColorMode(s$1);
				}
				checkUniforms(e$1, t$1, i$1) {
					if (this.fixedDefines.includes(t$1)) {
						for (const o$1 of Object.keys(i$1)) if (!i$1[o$1].initialized) throw new Error(`Program '${this.name}', from draw '${e$1}': uniform ${o$1} not set but required by ${t$1} being defined`);
					}
				}
				draw(e$1, t$1, i$1, o$1, s$1, r$1, n$1, a$1, l$1, c$1, h$1, d$1, u$1, _$1, p$1, f$1) {
					const m$1 = e$1.context, g$1 = m$1.gl;
					if (this.failedToCreate) return;
					m$1.program.set(this.program), m$1.setDepthMode(i$1), m$1.setStencilMode(o$1), m$1.setColorMode(s$1), m$1.setCullFace(r$1);
					for (const [e$2, t$2] of this.fixedUniformsEntries) t$2.set(this.program, e$2, n$1[e$2]);
					_$1 && _$1.setUniforms(this.program, m$1, this.binderUniforms, d$1, { zoom: u$1 });
					const v$1 = {
						[g$1.POINTS]: 1,
						[g$1.LINES]: 2,
						[g$1.TRIANGLES]: 3,
						[g$1.LINE_STRIP]: 1
					}[t$1];
					this.checkUniforms(a$1, "RENDER_SHADOWS", this.shadowUniforms);
					const y$1 = p$1 || [], x$1 = _$1 ? _$1.getPaintVertexBuffers() : [], b$1 = t$1 === g$1.TRIANGLES && c$1, w$1 = f$1 && f$1 > 0 ? 1 : void 0;
					for (const r$2 of h$1.get()) {
						const n$2 = r$2.vaos || (r$2.vaos = {});
						if ((n$2[a$1] || (n$2[a$1] = new rs())).bind(m$1, this, l$1, x$1, c$1, r$2.vertexOffset, y$1, w$1), this.forceManualRenderingForInstanceIDShaders) {
							const e$2 = f$1 || 1;
							for (let i$2 = 0; i$2 < e$2; ++i$2) this.instancingUniforms.u_instanceID.set(this.program, "u_instanceID", i$2), c$1 ? g$1.drawElements(t$1, r$2.primitiveLength * v$1, g$1.UNSIGNED_SHORT, r$2.primitiveOffset * v$1 * 2) : g$1.drawArrays(t$1, r$2.vertexOffset, r$2.vertexLength);
						} else f$1 && f$1 > 1 ? g$1.drawElementsInstanced(t$1, r$2.primitiveLength * v$1, g$1.UNSIGNED_SHORT, r$2.primitiveOffset * v$1 * 2, f$1) : c$1 ? g$1.drawElements(t$1, r$2.primitiveLength * v$1, g$1.UNSIGNED_SHORT, r$2.primitiveOffset * v$1 * 2) : g$1.drawArrays(t$1, r$2.vertexOffset, r$2.vertexLength);
						b$1 && this._drawDebugWireframe(e$1, i$1, o$1, s$1, c$1, r$2, d$1, u$1, _$1, f$1);
					}
				}
			}
			function dr(t$1, i$1, o$1 = 0) {
				const s$1 = Math.pow(2, i$1.tileID.overscaledZ), r$1 = i$1.tileSize * Math.pow(2, t$1.transform.tileZoom) / s$1, n$1 = r$1 * (i$1.tileID.canonical.x + i$1.tileID.wrap * s$1), a$1 = r$1 * i$1.tileID.canonical.y;
				return {
					u_image: 0,
					u_texsize: i$1.imageAtlasTexture ? i$1.imageAtlasTexture.size : [0, 0],
					u_tile_units_to_pixels: 1 / e.ay(i$1, 1, t$1.transform.tileZoom),
					u_pixel_coord_upper: [n$1 >> 16, a$1 >> 16],
					u_pixel_coord_lower: [65535 & n$1, 65535 & a$1],
					u_pattern_transition: o$1
				};
			}
			const ur = {
				terrain: 0,
				flat: 1
			}, _r = e.bC(), pr = (t$1, i$1, o$1, s$1, r$1, n$1, a$1, l$1, c$1, h$1, d$1, u$1, _$1, p$1, f$1, m$1, g$1, v$1) => {
				const y$1 = i$1.style.light, x$1 = y$1.properties.get("position"), b$1 = [
					x$1.x,
					x$1.y,
					x$1.z
				], w$1 = e.dO();
				"viewport" === y$1.properties.get("anchor") && (e.dP(w$1, -i$1.transform.angle), e.dQ(b$1, b$1, w$1));
				const T$1 = y$1.properties.get("color").toPremultipliedRenderColor(null), E$1 = i$1.transform, S$1 = {
					u_matrix: t$1,
					u_lightpos: b$1,
					u_lightintensity: y$1.properties.get("intensity"),
					u_lightcolor: [
						T$1.r,
						T$1.g,
						T$1.b
					],
					u_vertical_gradient: +o$1,
					u_opacity: s$1,
					u_tile_id: [
						0,
						0,
						0
					],
					u_zoom_transition: 0,
					u_inv_rot_matrix: _r,
					u_merc_center: [0, 0],
					u_up_dir: [
						0,
						0,
						0
					],
					u_height_lift: 0,
					u_height_type: ur[h$1],
					u_base_type: ur[d$1],
					u_ao: r$1,
					u_edge_radius: n$1,
					u_width_scale: a$1,
					u_flood_light_color: f$1,
					u_vertical_scale: m$1,
					u_flood_light_intensity: g$1,
					u_ground_shadow_factor: v$1
				};
				return "globe" === E$1.projection.name && (S$1.u_tile_id = [
					l$1.canonical.x,
					l$1.canonical.y,
					1 << l$1.canonical.z
				], S$1.u_zoom_transition = u$1, S$1.u_inv_rot_matrix = p$1, S$1.u_merc_center = _$1, S$1.u_up_dir = E$1.projection.upVector(new e.cD(0, 0, 0), _$1[0] * e.al, _$1[1] * e.al), S$1.u_height_lift = c$1), S$1;
			}, fr = (e$1, t$1, i$1, o$1, s$1, r$1) => ({
				u_matrix: e$1,
				u_edge_radius: t$1,
				u_width_scale: i$1,
				u_vertical_scale: o$1,
				u_height_type: ur[s$1],
				u_base_type: ur[r$1]
			}), mr = (e$1, t$1, i$1, o$1, s$1, r$1, n$1, a$1, l$1, c$1, h$1, d$1, u$1, _$1, p$1, f$1, m$1, g$1) => {
				const v$1 = pr(e$1, t$1, i$1, o$1, s$1, r$1, n$1, a$1, c$1, h$1, d$1, u$1, _$1, p$1, f$1, m$1, 1, [
					0,
					0,
					0
				]), y$1 = { u_height_factor: -Math.pow(2, a$1.overscaledZ) / l$1.tileSize / 8 };
				return Object.assign(v$1, dr(t$1, l$1, g$1), y$1);
			}, gr = (e$1, t$1, i$1, o$1, s$1, r$1, n$1, a$1, l$1, c$1, h$1) => ({
				u_matrix: t$1,
				u_opacity: i$1,
				u_ao_pass: o$1 ? 1 : 0,
				u_meter_to_tile: s$1,
				u_ao: r$1,
				u_flood_light_intensity: n$1,
				u_flood_light_color: a$1,
				u_attenuation: l$1,
				u_edge_radius: c$1,
				u_fb: 0,
				u_fb_size: h$1,
				u_dynamic_offset: 1
			}), vr = (e$1, t$1, i$1) => ({
				u_matrix: e$1,
				u_emissive_strength: t$1,
				u_ground_shadow_factor: i$1
			}), yr = (e$1, t$1, i$1, o$1, s$1, r$1 = 0) => Object.assign(vr(e$1, t$1, s$1), dr(i$1, o$1, r$1)), xr = (e$1, t$1, i$1, o$1) => ({
				u_matrix: e$1,
				u_world: i$1,
				u_emissive_strength: t$1,
				u_ground_shadow_factor: o$1
			}), br = (e$1, t$1, i$1, o$1, s$1, r$1, n$1 = 0) => Object.assign(yr(e$1, t$1, i$1, o$1, r$1, n$1), { u_world: s$1 }), wr = (e$1, t$1) => ({
				u_matrix: e$1,
				u_ground_shadow_factor: t$1
			}), Tr = (e$1, t$1, i$1, o$1, s$1) => ({
				u_matrix: e$1,
				u_camera_pos: [
					t$1[0],
					t$1[1],
					t$1[2]
				],
				u_depth_bias: i$1,
				u_height_scale: o$1,
				u_reset_depth: s$1
			}), Er = (e$1, t$1, i$1, o$1, s$1, r$1, n$1, a$1, l$1) => ({
				u_matrix: e$1,
				u_normal_matrix: t$1,
				u_opacity: i$1,
				u_faux_facade_ao_intensity: o$1,
				u_camera_pos: s$1,
				u_tile_to_meter: r$1,
				u_facade_emissive_chance: n$1,
				u_flood_light_color: a$1,
				u_flood_light_intensity: l$1
			}), Sr = (e$1) => ({ u_matrix: e$1 }), Ir = (e$1) => ({ u_matrix: e$1 }), Cr = (t$1, i$1, o$1, s$1, r$1, n$1, a$1, l$1) => {
				const c$1 = e.al / n$1.tileSize;
				return {
					u_matrix: t$1,
					u_inv_rot_matrix: i$1,
					u_camera_to_center_distance: o$1.getCameraToCenterDistance(l$1),
					u_extrude_scale: [o$1.pixelsToGLUnits[0] / c$1, o$1.pixelsToGLUnits[1] / c$1],
					u_zoom_transition: s$1,
					u_tile_id: a$1,
					u_merc_center: r$1
				};
			}, Rr = (e$1, t$1, i$1 = 1) => ({
				u_matrix: e$1,
				u_color: t$1,
				u_overlay: 0,
				u_overlay_scale: i$1
			}), Ar = e.bC(), Lr = (t$1, i$1, o$1, s$1, r$1, n$1, a$1) => {
				const l$1 = t$1.transform, c$1 = "globe" === l$1.projection.name, h$1 = c$1 ? e.dR(l$1.zoom, i$1.canonical) * l$1._pixelsPerMercatorPixel : e.ay(o$1, 1, n$1), d$1 = {
					u_matrix: i$1.projMatrix,
					u_extrude_scale: h$1,
					u_intensity: a$1,
					u_inv_rot_matrix: Ar,
					u_merc_center: [0, 0],
					u_tile_id: [
						0,
						0,
						0
					],
					u_zoom_transition: 0,
					u_up_dir: [
						0,
						0,
						0
					]
				};
				if (c$1) {
					d$1.u_inv_rot_matrix = s$1, d$1.u_merc_center = r$1, d$1.u_tile_id = [
						i$1.canonical.x,
						i$1.canonical.y,
						1 << i$1.canonical.z
					], d$1.u_zoom_transition = e.aj(l$1.zoom);
					const t$2 = r$1[0] * e.al, o$2 = r$1[1] * e.al;
					d$1.u_up_dir = l$1.projection.upVector(new e.cD(0, 0, 0), t$2, o$2);
				}
				return d$1;
			};
			function Dr(e$1, [t$1, i$1, o$1, s$1], [r$1, n$1]) {
				if (r$1 === n$1) return [
					0,
					0,
					0,
					0
				];
				const a$1 = 255 * (e$1 - 1) / (e$1 * (n$1 - r$1));
				return [
					t$1 * a$1,
					i$1 * a$1,
					o$1 * a$1,
					s$1 * a$1
				];
			}
			function Pr(e$1, t$1, [i$1, o$1]) {
				return i$1 === o$1 ? 0 : .5 / e$1 + (t$1 - i$1) * (e$1 - 1) / (e$1 * (o$1 - i$1));
			}
			const Or = (t$1, i$1, o$1, s$1, r$1, n$1, a$1, l$1, c$1, h$1, d$1, u$1, _$1, p$1, f$1, m$1, g$1, v$1, y$1, x$1, b$1) => ({
				u_matrix: t$1,
				u_normalize_matrix: i$1,
				u_globe_matrix: o$1,
				u_merc_matrix: s$1,
				u_grid_matrix: r$1,
				u_tl_parent: n$1,
				u_scale_parent: h$1,
				u_fade_t: d$1.mix,
				u_opacity: d$1.opacity * u$1.paint.get("raster-opacity"),
				u_image0: 0,
				u_image1: 1,
				u_brightness_low: u$1.paint.get("raster-brightness-min"),
				u_brightness_high: u$1.paint.get("raster-brightness-max"),
				u_saturation_factor: e.dT(u$1.paint.get("raster-saturation")),
				u_contrast_factor: e.dS(u$1.paint.get("raster-contrast")),
				u_spin_weights: zr(u$1.paint.get("raster-hue-rotate")),
				u_perspective_transform: _$1,
				u_raster_elevation: p$1,
				u_zoom_transition: a$1,
				u_merc_center: l$1,
				u_cutoff_params: c$1,
				u_colorization_mix: Dr(e.dU, m$1, v$1),
				u_colorization_offset: Pr(e.dU, g$1, v$1),
				u_color_ramp: f$1,
				u_texture_offset: [x$1 / (y$1 + 2 * x$1), y$1 / (y$1 + 2 * x$1)],
				u_texture_res: [y$1 + 2 * x$1, y$1 + 2 * x$1],
				u_emissive_strength: b$1
			});
			function zr(e$1) {
				e$1 *= Math.PI / 180;
				const t$1 = Math.sin(e$1), i$1 = Math.cos(e$1);
				return [
					(2 * i$1 + 1) / 3,
					(-Math.sqrt(3) * t$1 - i$1 + 1) / 3,
					(Math.sqrt(3) * t$1 - i$1 + 1) / 3
				];
			}
			const Mr = .05, Fr = (e$1, t$1, i$1, o$1, s$1, r$1, n$1, a$1, l$1, c$1, h$1, d$1) => ({
				u_matrix: e$1,
				u_normalize_matrix: t$1,
				u_globe_matrix: i$1,
				u_merc_matrix: o$1,
				u_grid_matrix: s$1,
				u_tl_parent: r$1,
				u_scale_parent: c$1,
				u_fade_t: h$1.mix,
				u_opacity: h$1.opacity,
				u_image0: 0,
				u_image1: 1,
				u_raster_elevation: d$1,
				u_zoom_transition: n$1,
				u_merc_center: a$1,
				u_cutoff_params: l$1
			}), Br = (e$1, t$1, i$1, o$1, s$1, r$1, n$1, a$1, l$1, c$1) => ({
				u_particle_texture: e$1,
				u_particle_texture_side_len: t$1,
				u_tile_offset: i$1,
				u_velocity: o$1,
				u_color_ramp: r$1,
				u_velocity_res: s$1,
				u_max_speed: n$1,
				u_uv_offset: a$1,
				u_data_scale: [255 * l$1[0], 255 * l$1[1]],
				u_data_offset: c$1,
				u_particle_pos_scale: 1.1,
				u_particle_pos_offset: [Mr, Mr]
			}), kr = (e$1, t$1, i$1, o$1, s$1, r$1, n$1, a$1, l$1, c$1) => ({
				u_particle_texture: e$1,
				u_particle_texture_side_len: t$1,
				u_velocity: i$1,
				u_velocity_res: o$1,
				u_max_speed: s$1,
				u_speed_factor: r$1,
				u_reset_rate: n$1,
				u_rand_seed: Math.random(),
				u_uv_offset: a$1,
				u_data_scale: [255 * l$1[0], 255 * l$1[1]],
				u_data_offset: c$1,
				u_particle_pos_scale: 1.1,
				u_particle_pos_offset: [Mr, Mr]
			}), Nr = e.bC(), Ur = (t$1, i$1, o$1, s$1, r$1, n$1, a$1, l$1, c$1, h$1, d$1, u$1, _$1, p$1, f$1, m$1, g$1, v$1, y$1, x$1, b$1, w$1, T$1, E$1) => {
				const S$1 = r$1.transform, I$1 = {
					u_is_size_zoom_constant: +("constant" === t$1 || "source" === t$1),
					u_is_size_feature_constant: +("constant" === t$1 || "camera" === t$1),
					u_size_t: i$1 ? i$1.uSizeT : 0,
					u_size: i$1 ? i$1.uSize : 0,
					u_camera_to_center_distance: S$1.getCameraToCenterDistance(y$1),
					u_rotate_symbol: +o$1,
					u_aspect_ratio: S$1.width / S$1.height,
					u_fade_change: r$1.options.fadeDuration ? r$1.symbolFadeChange : 1,
					u_matrix: n$1,
					u_label_plane_matrix: a$1,
					u_coord_matrix: l$1,
					u_is_text: +h$1,
					u_elevation_from_sea: c$1 ? 1 : 0,
					u_pitch_with_map: +s$1,
					u_texsize: d$1,
					u_texsize_icon: u$1,
					u_texture: 0,
					u_texture_icon: 1,
					u_tile_id: [
						0,
						0,
						0
					],
					u_zoom_transition: 0,
					u_inv_rot_matrix: Nr,
					u_merc_center: [0, 0],
					u_camera_forward: [
						0,
						0,
						0
					],
					u_ecef_origin: [
						0,
						0,
						0
					],
					u_tile_matrix: Nr,
					u_up_vector: [
						0,
						-1,
						0
					],
					u_color_adj_mat: w$1,
					u_icon_transition: T$1 || 0,
					u_gamma_scale: s$1 ? r$1.transform.getCameraToCenterDistance(y$1) * Math.cos(r$1.terrain ? 0 : r$1.transform._pitch) : 1,
					u_device_pixel_ratio: e.o.devicePixelRatio,
					u_is_halo: 1,
					u_scale_factor: E$1 || 1,
					u_ground_shadow_factor: x$1,
					u_inv_matrix: e.bl(e.bC(), a$1),
					u_normal_scale: b$1,
					u_lutTexture: no.LUT
				};
				return "globe" === y$1.name && (I$1.u_tile_id = [
					p$1.canonical.x,
					p$1.canonical.y,
					1 << p$1.canonical.z
				], I$1.u_zoom_transition = f$1, I$1.u_inv_rot_matrix = g$1, I$1.u_merc_center = m$1, I$1.u_camera_forward = S$1._camera.forward(), I$1.u_ecef_origin = e.dV(S$1.globeMatrix, p$1.toUnwrapped()), I$1.u_tile_matrix = Float32Array.from(S$1.globeMatrix), I$1.u_up_vector = v$1), I$1;
			}, jr = (e$1, t$1, i$1, o$1) => ({
				u_matrix: e$1,
				u_emissive_strength: t$1,
				u_opacity: i$1,
				u_color: o$1
			}), Gr = (t$1, i$1, o$1, s$1, r$1, n$1, a$1, l$1, c$1) => Object.assign(function(t$2, i$2, o$2, s$2, r$2, n$2) {
				const { width: a$2, height: l$2 } = s$2.imageManager.getPixelSize(i$2), c$2 = Math.pow(2, n$2.tileID.overscaledZ), h$1 = n$2.tileSize * Math.pow(2, s$2.transform.tileZoom) / c$2, d$1 = h$1 * (n$2.tileID.canonical.x + n$2.tileID.wrap * c$2), u$1 = h$1 * n$2.tileID.canonical.y;
				return {
					u_image: 0,
					u_pattern_tl: o$2.tl,
					u_pattern_br: o$2.br,
					u_texsize: [a$2, l$2],
					u_pattern_size: o$2.displaySize,
					u_pattern_units_to_pixels: r$2 ? [s$2.transform.width, -1 * s$2.transform.height] : [1 / e.ay(n$2, 1, s$2.transform.tileZoom), 1 / e.ay(n$2, 1, s$2.transform.tileZoom)],
					u_pixel_coord_upper: [d$1 >> 16, u$1 >> 16],
					u_pixel_coord_lower: [65535 & d$1, 65535 & u$1]
				};
			}(0, n$1, a$1, s$1, l$1, c$1), {
				u_matrix: t$1,
				u_emissive_strength: i$1,
				u_opacity: o$1
			}), Vr = new Float32Array(e.bA([])), Hr = (t$1, i$1, o$1, s$1, r$1, n$1, a$1, l$1, c$1, h$1, d$1, u$1, _$1, p$1 = [
				0,
				0,
				0
			], f$1, m$1, g$1) => {
				const v$1 = r$1.style.light, y$1 = v$1.properties.get("position"), x$1 = [
					-y$1.x,
					-y$1.y,
					y$1.z
				], b$1 = e.dO();
				"viewport" === v$1.properties.get("anchor") && (e.dP(b$1, -r$1.transform.angle), e.dQ(x$1, x$1, b$1));
				const w$1 = "MASK" === d$1.alphaMode, T$1 = v$1.properties.get("color").toNonPremultipliedRenderColor(null), E$1 = _$1.paint.get("model-ambient-occlusion-intensity"), S$1 = _$1.paint.get("model-color").constantOr(e.ao.white).toNonPremultipliedRenderColor(null);
				return S$1.a = _$1.paint.get("model-color-mix-intensity").constantOr(0), g$1 && (S$1.r = g$1[0], S$1.g = g$1[1], S$1.b = g$1[2], S$1.a = g$1[3]), m$1 && (S$1.r = m$1.color.r, S$1.g = m$1.color.g, S$1.b = m$1.color.b, S$1.a = m$1.colorMix, u$1 = m$1.emissionStrength, n$1 *= m$1.opacity), {
					u_matrix: t$1,
					u_lighting_matrix: i$1,
					u_normal_matrix: o$1,
					u_node_matrix: s$1 || Vr,
					u_lightpos: x$1,
					u_lightintensity: v$1.properties.get("intensity"),
					u_lightcolor: [
						T$1.r,
						T$1.g,
						T$1.b
					],
					u_camera_pos: p$1,
					u_opacity: n$1,
					u_baseTextureIsAlpha: 0,
					u_alphaMask: +w$1,
					u_alphaCutoff: d$1.alphaCutoff,
					u_baseColorFactor: a$1.toNonPremultipliedRenderColor(null).toArray01(),
					u_emissiveFactor: l$1.toNonPremultipliedRenderColor(null).toArray01(),
					u_metallicFactor: c$1,
					u_roughnessFactor: h$1,
					u_baseColorTexture: no.BaseColor,
					u_metallicRoughnessTexture: no.MetallicRoughness,
					u_normalTexture: no.Normal,
					u_occlusionTexture: no.Occlusion,
					u_emissionTexture: no.Emission,
					u_lutTexture: no.LUT,
					u_color_mix: S$1.toArray01(),
					u_aoIntensity: E$1,
					u_emissive_strength: u$1,
					u_occlusionTextureTransform: f$1 || [
						0,
						0,
						0,
						0
					]
				};
			}, qr = (e$1, t$1 = Vr, i$1 = Vr) => ({
				u_matrix: e$1,
				u_instance: t$1,
				u_node_matrix: i$1
			}), Zr = {
				fillExtrusion: (t$1) => ({
					u_matrix: new e.cl(t$1),
					u_lightpos: new e.ci(t$1),
					u_lightintensity: new e.cj(t$1),
					u_lightcolor: new e.ci(t$1),
					u_vertical_gradient: new e.cj(t$1),
					u_opacity: new e.cj(t$1),
					u_edge_radius: new e.cj(t$1),
					u_width_scale: new e.cj(t$1),
					u_ao: new e.ck(t$1),
					u_height_type: new e.ch(t$1),
					u_base_type: new e.ch(t$1),
					u_tile_id: new e.ci(t$1),
					u_zoom_transition: new e.cj(t$1),
					u_inv_rot_matrix: new e.cl(t$1),
					u_merc_center: new e.ck(t$1),
					u_up_dir: new e.ci(t$1),
					u_height_lift: new e.cj(t$1),
					u_flood_light_color: new e.ci(t$1),
					u_vertical_scale: new e.cj(t$1),
					u_flood_light_intensity: new e.cj(t$1),
					u_ground_shadow_factor: new e.ci(t$1)
				}),
				fillExtrusionDepth: (t$1) => ({
					u_matrix: new e.cl(t$1),
					u_edge_radius: new e.cj(t$1),
					u_width_scale: new e.cj(t$1),
					u_vertical_scale: new e.cj(t$1),
					u_height_type: new e.ch(t$1),
					u_base_type: new e.ch(t$1)
				}),
				fillExtrusionPattern: (t$1) => ({
					u_matrix: new e.cl(t$1),
					u_lightpos: new e.ci(t$1),
					u_lightintensity: new e.cj(t$1),
					u_lightcolor: new e.ci(t$1),
					u_vertical_gradient: new e.cj(t$1),
					u_height_factor: new e.cj(t$1),
					u_edge_radius: new e.cj(t$1),
					u_width_scale: new e.cj(t$1),
					u_ao: new e.ck(t$1),
					u_height_type: new e.ch(t$1),
					u_base_type: new e.ch(t$1),
					u_tile_id: new e.ci(t$1),
					u_zoom_transition: new e.cj(t$1),
					u_inv_rot_matrix: new e.cl(t$1),
					u_merc_center: new e.ck(t$1),
					u_up_dir: new e.ci(t$1),
					u_height_lift: new e.cj(t$1),
					u_image: new e.ch(t$1),
					u_texsize: new e.ck(t$1),
					u_pixel_coord_upper: new e.ck(t$1),
					u_pixel_coord_lower: new e.ck(t$1),
					u_tile_units_to_pixels: new e.cj(t$1),
					u_opacity: new e.cj(t$1),
					u_pattern_transition: new e.cj(t$1)
				}),
				fillExtrusionGroundEffect: (t$1) => ({
					u_matrix: new e.cl(t$1),
					u_opacity: new e.cj(t$1),
					u_ao_pass: new e.cj(t$1),
					u_meter_to_tile: new e.cj(t$1),
					u_ao: new e.ck(t$1),
					u_flood_light_intensity: new e.cj(t$1),
					u_flood_light_color: new e.ci(t$1),
					u_attenuation: new e.cj(t$1),
					u_edge_radius: new e.cj(t$1),
					u_fb: new e.ch(t$1),
					u_fb_size: new e.cj(t$1),
					u_dynamic_offset: new e.cj(t$1)
				}),
				fill: (t$1) => ({
					u_matrix: new e.cl(t$1),
					u_emissive_strength: new e.cj(t$1),
					u_ground_shadow_factor: new e.ci(t$1)
				}),
				fillPattern: (t$1) => ({
					u_matrix: new e.cl(t$1),
					u_emissive_strength: new e.cj(t$1),
					u_image: new e.ch(t$1),
					u_texsize: new e.ck(t$1),
					u_pixel_coord_upper: new e.ck(t$1),
					u_pixel_coord_lower: new e.ck(t$1),
					u_tile_units_to_pixels: new e.cj(t$1),
					u_ground_shadow_factor: new e.ci(t$1),
					u_pattern_transition: new e.cj(t$1)
				}),
				fillOutline: (t$1) => ({
					u_matrix: new e.cl(t$1),
					u_emissive_strength: new e.cj(t$1),
					u_world: new e.ck(t$1),
					u_ground_shadow_factor: new e.ci(t$1)
				}),
				fillOutlinePattern: (t$1) => ({
					u_matrix: new e.cl(t$1),
					u_emissive_strength: new e.cj(t$1),
					u_world: new e.ck(t$1),
					u_image: new e.ch(t$1),
					u_texsize: new e.ck(t$1),
					u_pixel_coord_upper: new e.ck(t$1),
					u_pixel_coord_lower: new e.ck(t$1),
					u_tile_units_to_pixels: new e.cj(t$1),
					u_ground_shadow_factor: new e.ci(t$1),
					u_pattern_transition: new e.cj(t$1)
				}),
				building: (t$1) => ({
					u_matrix: new e.cl(t$1),
					u_normal_matrix: new e.cl(t$1),
					u_opacity: new e.cj(t$1),
					u_faux_facade_ao_intensity: new e.cj(t$1),
					u_camera_pos: new e.ci(t$1),
					u_tile_to_meter: new e.cj(t$1),
					u_facade_emissive_chance: new e.cj(t$1),
					u_flood_light_color: new e.ci(t$1),
					u_flood_light_intensity: new e.cj(t$1)
				}),
				buildingBloom: (t$1) => ({ u_matrix: new e.cl(t$1) }),
				buildingDepth: (t$1) => ({ u_matrix: new e.cl(t$1) }),
				elevatedStructuresDepth: (t$1) => ({
					u_matrix: new e.cl(t$1),
					u_depth_bias: new e.cj(t$1)
				}),
				elevatedStructures: (t$1) => ({
					u_matrix: new e.cl(t$1),
					u_ground_shadow_factor: new e.ci(t$1)
				}),
				elevatedStructuresDepthReconstruct: (t$1) => ({
					u_matrix: new e.cl(t$1),
					u_camera_pos: new e.ci(t$1),
					u_depth_bias: new e.cj(t$1),
					u_height_scale: new e.cj(t$1),
					u_reset_depth: new e.cj(t$1)
				}),
				circle: e.dY,
				collisionBox: (t$1) => ({
					u_matrix: new e.cl(t$1),
					u_inv_rot_matrix: new e.cl(t$1),
					u_camera_to_center_distance: new e.cj(t$1),
					u_extrude_scale: new e.ck(t$1),
					u_zoom_transition: new e.cj(t$1),
					u_merc_center: new e.ck(t$1),
					u_tile_id: new e.ci(t$1)
				}),
				collisionCircle: (t$1) => ({
					u_matrix: new e.cl(t$1),
					u_inv_matrix: new e.cl(t$1),
					u_camera_to_center_distance: new e.cj(t$1),
					u_viewport_size: new e.ck(t$1)
				}),
				debug: (t$1) => ({
					u_color: new e.dB(t$1),
					u_matrix: new e.cl(t$1),
					u_overlay: new e.ch(t$1),
					u_overlay_scale: new e.cj(t$1)
				}),
				clippingMask: (t$1) => ({ u_matrix: new e.cl(t$1) }),
				heatmap: (t$1) => ({
					u_extrude_scale: new e.cj(t$1),
					u_intensity: new e.cj(t$1),
					u_matrix: new e.cl(t$1),
					u_inv_rot_matrix: new e.cl(t$1),
					u_merc_center: new e.ck(t$1),
					u_tile_id: new e.ci(t$1),
					u_zoom_transition: new e.cj(t$1),
					u_up_dir: new e.ci(t$1)
				}),
				heatmapTexture: (t$1) => ({
					u_image: new e.ch(t$1),
					u_color_ramp: new e.ch(t$1),
					u_opacity: new e.cj(t$1)
				}),
				hillshade: (t$1) => ({
					u_matrix: new e.cl(t$1),
					u_image: new e.ch(t$1),
					u_latrange: new e.ck(t$1),
					u_light: new e.ck(t$1),
					u_shadow: new e.dB(t$1),
					u_highlight: new e.dB(t$1),
					u_emissive_strength: new e.cj(t$1),
					u_accent: new e.dB(t$1)
				}),
				hillshadePrepare: (t$1) => ({
					u_matrix: new e.cl(t$1),
					u_image: new e.ch(t$1),
					u_dimension: new e.ck(t$1),
					u_zoom: new e.cj(t$1)
				}),
				line: e.dX,
				linePattern: e.dW,
				raster: (t$1) => ({
					u_matrix: new e.cl(t$1),
					u_normalize_matrix: new e.cl(t$1),
					u_globe_matrix: new e.cl(t$1),
					u_merc_matrix: new e.cl(t$1),
					u_grid_matrix: new e.dC(t$1),
					u_tl_parent: new e.ck(t$1),
					u_scale_parent: new e.cj(t$1),
					u_fade_t: new e.cj(t$1),
					u_opacity: new e.cj(t$1),
					u_image0: new e.ch(t$1),
					u_image1: new e.ch(t$1),
					u_brightness_low: new e.cj(t$1),
					u_brightness_high: new e.cj(t$1),
					u_saturation_factor: new e.cj(t$1),
					u_contrast_factor: new e.cj(t$1),
					u_spin_weights: new e.ci(t$1),
					u_perspective_transform: new e.ck(t$1),
					u_raster_elevation: new e.cj(t$1),
					u_zoom_transition: new e.cj(t$1),
					u_merc_center: new e.ck(t$1),
					u_cutoff_params: new e.d3(t$1),
					u_colorization_mix: new e.d3(t$1),
					u_colorization_offset: new e.cj(t$1),
					u_color_ramp: new e.ch(t$1),
					u_texture_offset: new e.ck(t$1),
					u_texture_res: new e.ck(t$1),
					u_emissive_strength: new e.cj(t$1)
				}),
				rasterParticle: (t$1) => ({
					u_matrix: new e.cl(t$1),
					u_normalize_matrix: new e.cl(t$1),
					u_globe_matrix: new e.cl(t$1),
					u_merc_matrix: new e.cl(t$1),
					u_grid_matrix: new e.dC(t$1),
					u_tl_parent: new e.ck(t$1),
					u_scale_parent: new e.cj(t$1),
					u_fade_t: new e.cj(t$1),
					u_opacity: new e.cj(t$1),
					u_image0: new e.ch(t$1),
					u_image1: new e.ch(t$1),
					u_raster_elevation: new e.cj(t$1),
					u_zoom_transition: new e.cj(t$1),
					u_merc_center: new e.ck(t$1),
					u_cutoff_params: new e.d3(t$1)
				}),
				rasterParticleTexture: (t$1) => ({
					u_texture: new e.ch(t$1),
					u_opacity: new e.cj(t$1)
				}),
				rasterParticleDraw: (t$1) => ({
					u_particle_texture: new e.ch(t$1),
					u_particle_texture_side_len: new e.cj(t$1),
					u_tile_offset: new e.ck(t$1),
					u_velocity: new e.ch(t$1),
					u_color_ramp: new e.ch(t$1),
					u_velocity_res: new e.ck(t$1),
					u_max_speed: new e.cj(t$1),
					u_uv_offset: new e.ck(t$1),
					u_data_scale: new e.ck(t$1),
					u_data_offset: new e.cj(t$1),
					u_particle_pos_scale: new e.cj(t$1),
					u_particle_pos_offset: new e.ck(t$1)
				}),
				rasterParticleUpdate: (t$1) => ({
					u_particle_texture: new e.ch(t$1),
					u_particle_texture_side_len: new e.cj(t$1),
					u_velocity: new e.ch(t$1),
					u_velocity_res: new e.ck(t$1),
					u_max_speed: new e.cj(t$1),
					u_speed_factor: new e.cj(t$1),
					u_reset_rate: new e.cj(t$1),
					u_rand_seed: new e.cj(t$1),
					u_uv_offset: new e.ck(t$1),
					u_data_scale: new e.ck(t$1),
					u_data_offset: new e.cj(t$1),
					u_particle_pos_scale: new e.cj(t$1),
					u_particle_pos_offset: new e.ck(t$1)
				}),
				symbol: (t$1) => ({
					u_is_size_zoom_constant: new e.ch(t$1),
					u_is_size_feature_constant: new e.ch(t$1),
					u_size_t: new e.cj(t$1),
					u_size: new e.cj(t$1),
					u_camera_to_center_distance: new e.cj(t$1),
					u_rotate_symbol: new e.ch(t$1),
					u_aspect_ratio: new e.cj(t$1),
					u_fade_change: new e.cj(t$1),
					u_matrix: new e.cl(t$1),
					u_label_plane_matrix: new e.cl(t$1),
					u_coord_matrix: new e.cl(t$1),
					u_is_text: new e.ch(t$1),
					u_elevation_from_sea: new e.ch(t$1),
					u_pitch_with_map: new e.ch(t$1),
					u_texsize: new e.ck(t$1),
					u_texsize_icon: new e.ck(t$1),
					u_texture: new e.ch(t$1),
					u_texture_icon: new e.ch(t$1),
					u_gamma_scale: new e.cj(t$1),
					u_device_pixel_ratio: new e.cj(t$1),
					u_tile_id: new e.ci(t$1),
					u_zoom_transition: new e.cj(t$1),
					u_inv_rot_matrix: new e.cl(t$1),
					u_merc_center: new e.ck(t$1),
					u_camera_forward: new e.ci(t$1),
					u_tile_matrix: new e.cl(t$1),
					u_up_vector: new e.ci(t$1),
					u_ecef_origin: new e.ci(t$1),
					u_is_halo: new e.ch(t$1),
					u_icon_transition: new e.cj(t$1),
					u_color_adj_mat: new e.cl(t$1),
					u_scale_factor: new e.cj(t$1),
					u_ground_shadow_factor: new e.ci(t$1),
					u_inv_matrix: new e.cl(t$1),
					u_normal_scale: new e.cj(t$1),
					u_lutTexture: new e.ch(t$1)
				}),
				background: (t$1) => ({
					u_matrix: new e.cl(t$1),
					u_emissive_strength: new e.cj(t$1),
					u_opacity: new e.cj(t$1),
					u_color: new e.dB(t$1)
				}),
				backgroundPattern: (t$1) => ({
					u_matrix: new e.cl(t$1),
					u_emissive_strength: new e.cj(t$1),
					u_opacity: new e.cj(t$1),
					u_image: new e.ch(t$1),
					u_pattern_tl: new e.ck(t$1),
					u_pattern_br: new e.ck(t$1),
					u_texsize: new e.ck(t$1),
					u_pattern_size: new e.ck(t$1),
					u_pixel_coord_upper: new e.ck(t$1),
					u_pixel_coord_lower: new e.ck(t$1),
					u_pattern_units_to_pixels: new e.ck(t$1)
				}),
				terrainRaster: (t$1) => ({
					u_matrix: new e.cl(t$1),
					u_image0: new e.ch(t$1),
					u_image1: new e.ch(t$1),
					u_skirt_height: new e.cj(t$1),
					u_ground_shadow_factor: new e.ci(t$1),
					u_emissive_texture_available: new e.cj(t$1)
				}),
				skybox: (t$1) => ({
					u_matrix: new e.cl(t$1),
					u_sun_direction: new e.ci(t$1),
					u_cubemap: new e.ch(t$1),
					u_opacity: new e.cj(t$1),
					u_temporal_offset: new e.cj(t$1)
				}),
				skyboxGradient: (t$1) => ({
					u_matrix: new e.cl(t$1),
					u_color_ramp: new e.ch(t$1),
					u_center_direction: new e.ci(t$1),
					u_radius: new e.cj(t$1),
					u_opacity: new e.cj(t$1),
					u_temporal_offset: new e.cj(t$1)
				}),
				skyboxCapture: (t$1) => ({
					u_matrix_3f: new e.dC(t$1),
					u_sun_direction: new e.ci(t$1),
					u_sun_intensity: new e.cj(t$1),
					u_color_tint_r: new e.d3(t$1),
					u_color_tint_m: new e.d3(t$1),
					u_luminance: new e.cj(t$1)
				}),
				globeRaster: (t$1) => ({
					u_proj_matrix: new e.cl(t$1),
					u_globe_matrix: new e.cl(t$1),
					u_normalize_matrix: new e.cl(t$1),
					u_merc_matrix: new e.cl(t$1),
					u_zoom_transition: new e.cj(t$1),
					u_merc_center: new e.ck(t$1),
					u_image0: new e.ch(t$1),
					u_image1: new e.ch(t$1),
					u_grid_matrix: new e.dC(t$1),
					u_skirt_height: new e.cj(t$1),
					u_far_z_cutoff: new e.cj(t$1),
					u_frustum_tl: new e.ci(t$1),
					u_frustum_tr: new e.ci(t$1),
					u_frustum_br: new e.ci(t$1),
					u_frustum_bl: new e.ci(t$1),
					u_globe_pos: new e.ci(t$1),
					u_globe_radius: new e.cj(t$1),
					u_viewport: new e.ck(t$1),
					u_emissive_texture_available: new e.cj(t$1)
				}),
				globeAtmosphere: (t$1) => ({
					u_frustum_tl: new e.ci(t$1),
					u_frustum_tr: new e.ci(t$1),
					u_frustum_br: new e.ci(t$1),
					u_frustum_bl: new e.ci(t$1),
					u_horizon: new e.cj(t$1),
					u_transition: new e.cj(t$1),
					u_fadeout_range: new e.cj(t$1),
					u_atmosphere_fog_color: new e.d3(t$1),
					u_high_color: new e.d3(t$1),
					u_space_color: new e.d3(t$1),
					u_temporal_offset: new e.cj(t$1),
					u_horizon_angle: new e.cj(t$1)
				}),
				model: (t$1) => ({
					u_matrix: new e.cl(t$1),
					u_lighting_matrix: new e.cl(t$1),
					u_normal_matrix: new e.cl(t$1),
					u_node_matrix: new e.cl(t$1),
					u_lightpos: new e.ci(t$1),
					u_lightintensity: new e.cj(t$1),
					u_lightcolor: new e.ci(t$1),
					u_camera_pos: new e.ci(t$1),
					u_opacity: new e.cj(t$1),
					u_baseColorFactor: new e.d3(t$1),
					u_emissiveFactor: new e.d3(t$1),
					u_metallicFactor: new e.cj(t$1),
					u_roughnessFactor: new e.cj(t$1),
					u_baseTextureIsAlpha: new e.ch(t$1),
					u_alphaMask: new e.ch(t$1),
					u_alphaCutoff: new e.cj(t$1),
					u_baseColorTexture: new e.ch(t$1),
					u_metallicRoughnessTexture: new e.ch(t$1),
					u_normalTexture: new e.ch(t$1),
					u_occlusionTexture: new e.ch(t$1),
					u_emissionTexture: new e.ch(t$1),
					u_lutTexture: new e.ch(t$1),
					u_color_mix: new e.d3(t$1),
					u_aoIntensity: new e.cj(t$1),
					u_emissive_strength: new e.cj(t$1),
					u_occlusionTextureTransform: new e.d3(t$1)
				}),
				modelDepth: (t$1) => ({
					u_matrix: new e.cl(t$1),
					u_instance: new e.cl(t$1),
					u_node_matrix: new e.cl(t$1)
				}),
				groundShadow: (t$1) => ({
					u_matrix: new e.cl(t$1),
					u_ground_shadow_factor: new e.ci(t$1)
				}),
				stars: (t$1) => ({
					u_matrix: new e.cl(t$1),
					u_up: new e.ci(t$1),
					u_right: new e.ci(t$1),
					u_intensity_multiplier: new e.cj(t$1)
				}),
				snowParticle: (t$1) => ({
					u_modelview: new e.cl(t$1),
					u_projection: new e.cl(t$1),
					u_time: new e.cj(t$1),
					u_cam_pos: new e.ci(t$1),
					u_velocityConeAperture: new e.cj(t$1),
					u_velocity: new e.cj(t$1),
					u_horizontalOscillationRadius: new e.cj(t$1),
					u_horizontalOscillationRate: new e.cj(t$1),
					u_boxSize: new e.cj(t$1),
					u_billboardSize: new e.cj(t$1),
					u_simpleShapeParameters: new e.ck(t$1),
					u_screenSize: new e.ck(t$1),
					u_thinningCenterPos: new e.ck(t$1),
					u_thinningShape: new e.ci(t$1),
					u_thinningAffectedRatio: new e.cj(t$1),
					u_thinningParticleOffset: new e.cj(t$1),
					u_particleColor: new e.d3(t$1),
					u_direction: new e.ci(t$1)
				}),
				rainParticle: (t$1) => ({
					u_modelview: new e.cl(t$1),
					u_projection: new e.cl(t$1),
					u_time: new e.cj(t$1),
					u_cam_pos: new e.ci(t$1),
					u_texScreen: new e.ch(t$1),
					u_velocityConeAperture: new e.cj(t$1),
					u_velocity: new e.cj(t$1),
					u_boxSize: new e.cj(t$1),
					u_rainDropletSize: new e.ck(t$1),
					u_distortionStrength: new e.cj(t$1),
					u_rainDirection: new e.ci(t$1),
					u_color: new e.d3(t$1),
					u_screenSize: new e.ck(t$1),
					u_thinningCenterPos: new e.ck(t$1),
					u_thinningShape: new e.ci(t$1),
					u_thinningAffectedRatio: new e.cj(t$1),
					u_thinningParticleOffset: new e.cj(t$1),
					u_shapeDirectionalPower: new e.cj(t$1),
					u_shapeNormalPower: new e.cj(t$1),
					u_mode: new e.cj(t$1)
				}),
				vignette: (t$1) => ({
					u_vignetteShape: new e.ci(t$1),
					u_vignetteColor: new e.d3(t$1)
				}),
				occlusion: (t$1) => ({
					u_matrix: new e.cl(t$1),
					u_anchorPos: new e.ci(t$1),
					u_screenSizePx: new e.ck(t$1),
					u_occluderSizePx: new e.ck(t$1),
					u_color: new e.d3(t$1)
				})
			};
			class Wr {
				constructor(e$1, t$1, i$1, o$1) {
					this.id = Wr.uniqueIdxCounter, Wr.uniqueIdxCounter++, this.context = e$1;
					const s$1 = e$1.gl;
					this.buffer = s$1.createBuffer(), this.dynamicDraw = Boolean(i$1), this.context.unbindVAO(), e$1.bindElementBuffer.set(this.buffer), s$1.bufferData(s$1.ELEMENT_ARRAY_BUFFER, t$1.arrayBuffer, this.dynamicDraw ? s$1.DYNAMIC_DRAW : s$1.STATIC_DRAW), this.dynamicDraw || o$1 || t$1.destroy();
				}
				bind() {
					this.context.bindElementBuffer.set(this.buffer);
				}
				updateData(e$1) {
					this.id = Wr.uniqueIdxCounter, Wr.uniqueIdxCounter++;
					const t$1 = this.context.gl;
					this.context.unbindVAO(), this.bind(), t$1.bufferSubData(t$1.ELEMENT_ARRAY_BUFFER, 0, e$1.arrayBuffer);
				}
				destroy() {
					this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
				}
			}
			Wr.uniqueIdxCounter = 0;
			const $r = {
				Int8: "BYTE",
				Uint8: "UNSIGNED_BYTE",
				Int16: "SHORT",
				Uint16: "UNSIGNED_SHORT",
				Int32: "INT",
				Uint32: "UNSIGNED_INT",
				Float32: "FLOAT"
			};
			class Xr {
				constructor(e$1, t$1, i$1, o$1, s$1, r$1) {
					this.length = t$1.length, this.attributes = i$1, this.itemSize = t$1.bytesPerElement, this.dynamicDraw = o$1, this.instanceCount = r$1, this.context = e$1;
					const n$1 = e$1.gl;
					this.buffer = n$1.createBuffer(), e$1.bindVertexBuffer.set(this.buffer), n$1.bufferData(n$1.ARRAY_BUFFER, t$1.arrayBuffer, this.dynamicDraw ? n$1.DYNAMIC_DRAW : n$1.STATIC_DRAW), this.dynamicDraw || s$1 || t$1.destroy();
				}
				bind() {
					this.context.bindVertexBuffer.set(this.buffer);
				}
				updateData(e$1) {
					const t$1 = this.context.gl;
					this.bind(), t$1.bufferSubData(t$1.ARRAY_BUFFER, 0, e$1.arrayBuffer);
				}
				enableAttributes(e$1, t$1) {
					for (let i$1 = 0; i$1 < this.attributes.length; i$1++) {
						const o$1 = t$1.getAttributeLocation(e$1, this.attributes[i$1].name);
						-1 !== o$1 && e$1.enableVertexAttribArray(o$1);
					}
				}
				setVertexAttribPointers(e$1, t$1, i$1) {
					for (let o$1 = 0; o$1 < this.attributes.length; o$1++) {
						const s$1 = this.attributes[o$1], r$1 = t$1.getAttributeLocation(e$1, s$1.name);
						-1 !== r$1 && e$1.vertexAttribPointer(r$1, s$1.components, e$1[$r[s$1.type]], !1, this.itemSize, s$1.offset + this.itemSize * (i$1 || 0));
					}
				}
				setVertexAttribDivisor(e$1, t$1, i$1) {
					for (let o$1 = 0; o$1 < this.attributes.length; o$1++) {
						const s$1 = t$1.getAttributeLocation(e$1, this.attributes[o$1].name);
						-1 !== s$1 && this.instanceCount && this.instanceCount > 0 && e$1.vertexAttribDivisor(s$1, i$1);
					}
				}
				destroy() {
					this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
				}
			}
			class Yr {
				constructor(e$1, t$1, i$1, o$1, s$1) {
					this.context = e$1, this.width = t$1, this.height = i$1;
					const r$1 = this.framebuffer = e$1.gl.createFramebuffer();
					o$1 > 0 && (this.colorAttachment0 = new Vs(e$1, r$1, 0)), o$1 > 1 && (this.colorAttachment1 = new Vs(e$1, r$1, 1)), s$1 && (this.depthAttachmentType = s$1, this.depthAttachment = "renderbuffer" === s$1 ? new Hs(e$1, r$1) : new qs(e$1, r$1));
				}
				createColorAttachment(e$1, t$1) {
					0 === t$1 ? this.colorAttachment0 = new Vs(e$1, this.framebuffer, 0) : 1 === t$1 && (this.colorAttachment1 = new Vs(e$1, this.framebuffer, 1));
				}
				removeColorAttachment(e$1, t$1) {
					const i$1 = this.context.gl;
					let o$1;
					0 === t$1 ? (o$1 = this.colorAttachment0.get(), this.colorAttachment0 = void 0) : 1 === t$1 && (o$1 = this.colorAttachment1.get(), this.colorAttachment1 = void 0), o$1 && i$1.deleteTexture(o$1);
				}
				destroy() {
					const e$1 = this.context.gl;
					if (this.colorAttachment0) {
						const t$1 = this.colorAttachment0.get();
						t$1 && e$1.deleteTexture(t$1);
					}
					if (this.colorAttachment1) {
						const t$1 = this.colorAttachment1.get();
						t$1 && e$1.deleteTexture(t$1);
					}
					if (this.depthAttachment && this.depthAttachmentType) if ("renderbuffer" === this.depthAttachmentType) {
						const t$1 = this.depthAttachment.get();
						t$1 && e$1.deleteRenderbuffer(t$1);
					} else {
						const t$1 = this.depthAttachment.get();
						t$1 && e$1.deleteTexture(t$1);
					}
					e$1.deleteFramebuffer(this.framebuffer);
				}
			}
			class Kr {
				constructor(e$1, t$1) {
					this.gl = e$1, this.clearColor = new ds(this), this.clearDepth = new us(this), this.clearStencil = new _s(this), this.colorMask = new ps(this), this.depthMask = new fs(this), this.stencilMask = new ms(this), this.stencilFunc = new gs(this), this.stencilOp = new vs(this), this.stencilTest = new ys(this), this.depthRange = new xs(this), this.depthTest = new bs(this), this.depthFunc = new ws(this), this.blend = new Ts(this), this.blendFunc = new Es(this), this.blendColor = new Ss(this), this.blendEquation = new Is(this), this.cullFace = new Cs(this), this.cullFaceSide = new Rs(this), this.frontFace = new As(this), this.program = new Ls(this), this.activeTexture = new Ds(this), this.viewport = new Ps(this), this.bindFramebuffer = new Os(this), this.bindRenderbuffer = new zs(this), this.bindTexture = new Ms(this), this.bindVertexBuffer = new Fs(this), this.bindElementBuffer = new Bs(this), this.bindVertexArrayOES = new ks(this), this.pixelStoreUnpack = new Ns(this), this.pixelStoreUnpackPremultiplyAlpha = new Us(this), this.pixelStoreUnpackFlipY = new js(this), this.options = t$1 ? Object.assign({}, t$1) : {}, this.options.extTextureFilterAnisotropicForceOff || (this.extTextureFilterAnisotropic = e$1.getExtension("EXT_texture_filter_anisotropic") || e$1.getExtension("MOZ_EXT_texture_filter_anisotropic") || e$1.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = e$1.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT))), this.extDebugRendererInfo = e$1.getExtension("WEBGL_debug_renderer_info"), this.extDebugRendererInfo && (this.renderer = e$1.getParameter(this.extDebugRendererInfo.UNMASKED_RENDERER_WEBGL), this.vendor = e$1.getParameter(this.extDebugRendererInfo.UNMASKED_VENDOR_WEBGL)), this.forceManualRenderingForInstanceIDShaders = t$1 && !!t$1.forceManualRenderingForInstanceIDShaders || this.renderer && -1 !== this.renderer.indexOf("PowerVR"), this.options.extTextureFloatLinearForceOff || (this.extTextureFloatLinear = e$1.getExtension("OES_texture_float_linear")), this.extRenderToTextureHalfFloat = e$1.getExtension("EXT_color_buffer_half_float"), this.extTimerQuery = e$1.getExtension("EXT_disjoint_timer_query_webgl2"), this.maxTextureSize = e$1.getParameter(e$1.MAX_TEXTURE_SIZE), this.extBlendFuncExtended = e$1.getExtension("WEBGL_blend_func_extended");
				}
				setDefault() {
					this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();
				}
				setDirty() {
					this.clearColor.dirty = !0, this.clearDepth.dirty = !0, this.clearStencil.dirty = !0, this.colorMask.dirty = !0, this.depthMask.dirty = !0, this.stencilMask.dirty = !0, this.stencilFunc.dirty = !0, this.stencilOp.dirty = !0, this.stencilTest.dirty = !0, this.depthRange.dirty = !0, this.depthTest.dirty = !0, this.depthFunc.dirty = !0, this.blend.dirty = !0, this.blendFunc.dirty = !0, this.blendColor.dirty = !0, this.blendEquation.dirty = !0, this.cullFace.dirty = !0, this.cullFaceSide.dirty = !0, this.frontFace.dirty = !0, this.program.dirty = !0, this.activeTexture.dirty = !0, this.viewport.dirty = !0, this.bindFramebuffer.dirty = !0, this.bindRenderbuffer.dirty = !0, this.bindTexture.dirty = !0, this.bindVertexBuffer.dirty = !0, this.bindElementBuffer.dirty = !0, this.bindVertexArrayOES.dirty = !0, this.pixelStoreUnpack.dirty = !0, this.pixelStoreUnpackPremultiplyAlpha.dirty = !0, this.pixelStoreUnpackFlipY.dirty = !0;
				}
				createIndexBuffer(e$1, t$1, i$1) {
					return new Wr(this, e$1, t$1, i$1);
				}
				createVertexBuffer(e$1, t$1, i$1, o$1, s$1) {
					return new Xr(this, e$1, t$1, i$1, o$1, s$1);
				}
				createRenderbuffer(e$1, t$1, i$1) {
					const o$1 = this.gl, s$1 = o$1.createRenderbuffer();
					return this.bindRenderbuffer.set(s$1), o$1.renderbufferStorage(o$1.RENDERBUFFER, e$1, t$1, i$1), this.bindRenderbuffer.set(null), s$1;
				}
				createFramebuffer(e$1, t$1, i$1, o$1) {
					return new Yr(this, e$1, t$1, i$1, o$1);
				}
				clear({ color: e$1, depth: t$1, stencil: i$1, colorMask: o$1 }) {
					const s$1 = this.gl;
					let r$1 = 0;
					e$1 && (r$1 |= s$1.COLOR_BUFFER_BIT, this.clearColor.set(e$1.toNonPremultipliedRenderColor(null)), this.colorMask.set(o$1 || [
						!0,
						!0,
						!0,
						!0
					])), void 0 !== t$1 && (r$1 |= s$1.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(t$1), this.depthMask.set(!0)), void 0 !== i$1 && (r$1 |= s$1.STENCIL_BUFFER_BIT, this.clearStencil.set(i$1), this.stencilMask.set(255)), s$1.clear(r$1);
				}
				setCullFace(e$1) {
					!1 === e$1.enable ? this.cullFace.set(!1) : (this.cullFace.set(!0), this.cullFaceSide.set(e$1.mode), this.frontFace.set(e$1.frontFace));
				}
				setDepthMode(e$1) {
					e$1.func !== this.gl.ALWAYS || e$1.mask ? (this.depthTest.set(!0), this.depthFunc.set(e$1.func), this.depthMask.set(e$1.mask), this.depthRange.set(e$1.range)) : this.depthTest.set(!1);
				}
				setStencilMode(e$1) {
					e$1.test.func !== this.gl.ALWAYS || e$1.mask ? (this.stencilTest.set(!0), this.stencilMask.set(e$1.mask), this.stencilOp.set([
						e$1.fail,
						e$1.depthFail,
						e$1.pass
					]), this.stencilFunc.set({
						func: e$1.test.func,
						ref: e$1.ref,
						mask: e$1.test.mask
					})) : this.stencilTest.set(!1);
				}
				setColorMode(t$1) {
					e.by(t$1.blendFunction, $i.Replace) ? this.blend.set(!1) : (this.blend.set(!0), this.blendFunc.set(t$1.blendFunction), this.blendColor.set(t$1.blendColor), t$1.blendEquation ? this.blendEquation.set(t$1.blendEquation) : this.blendEquation.setDefault()), this.colorMask.set(t$1.mask);
				}
				unbindVAO() {
					this.bindVertexArrayOES.set(null);
				}
			}
			let Jr;
			function Qr(t$1, i$1, o$1, s$1, r$1, n$1, a$1) {
				const l$1 = t$1.context, c$1 = l$1.gl, h$1 = t$1.transform, d$1 = [e.aF(h$1.center.lng), e.aJ(h$1.center.lat)], u$1 = o$1.layout.get("symbol-placement"), _$1 = o$1.layout.get("text-variable-anchor"), p$1 = "map" === o$1.layout.get("icon-rotation-alignment"), f$1 = "map" === o$1.layout.get("text-rotation-alignment"), m$1 = "point" !== u$1, g$1 = [];
				let v$1 = 0, y$1 = 0;
				for (let l$2 = 0; l$2 < s$1.length; l$2++) {
					const u$2 = s$1[l$2], x$2 = i$1.getTile(u$2), b$2 = x$2.getBucket(o$1);
					if (!b$2) continue;
					const w$2 = b$2.getProjection().createInversionMatrix(h$1, u$2.canonical), T$2 = [], E$2 = Jt(u$2, b$2, h$1), S$2 = !a$1 && p$1 && m$1, I$1 = a$1 && f$1 && m$1, C$1 = _$1 && b$2.hasTextData(), R$1 = b$2.hasIconTextFit() && C$1 && b$2.hasIconData(), A$1 = S$2 || I$1 || a$1 && C$1 || R$1, L$1 = "globe" === b$2.projection.name, D$1 = L$1 ? e.aj(h$1.zoom) : 0;
					L$1 && (T$2.push("PROJECTION_GLOBE_VIEW"), A$1 && T$2.push("PROJECTED_POS_ON_VIEWPORT"));
					const P$1 = t$1.getOrCreateProgram("collisionBox", { defines: T$2 });
					let O$1 = E$2;
					0 === r$1[0] && 0 === r$1[1] || (O$1 = t$1.translatePosMatrix(E$2, x$2, r$1, n$1));
					const z$1 = a$1 ? b$2.textCollisionBox : b$2.iconCollisionBox, M$1 = b$2.collisionCircleArray;
					if (M$1.length > 0) {
						const t$2 = e.bC(), i$2 = O$1;
						e.cP(t$2, b$2.placementInvProjMatrix, h$1.glCoordMatrix), e.cP(t$2, t$2, b$2.placementViewportMatrix), g$1.push({
							circleArray: M$1,
							circleOffset: y$1,
							transform: i$2,
							invTransform: t$2,
							projection: b$2.getProjection()
						}), v$1 += M$1.length / 4, y$1 = v$1;
					}
					if (!z$1) continue;
					t$1.terrain && t$1.terrain.setupElevationDraw(x$2, P$1);
					const F$1 = L$1 ? [
						u$2.canonical.x,
						u$2.canonical.y,
						1 << u$2.canonical.z
					] : [
						0,
						0,
						0
					];
					P$1.draw(t$1, c$1.LINES, Xi.disabled, Ki.disabled, t$1.colorModeForRenderPass(), eo.disabled, Cr(O$1, w$2, h$1, D$1, d$1, x$2, F$1, b$2.getProjection()), o$1.id, z$1.layoutVertexBuffer, z$1.indexBuffer, z$1.segments, null, h$1.zoom, null, [z$1.collisionVertexBuffer, z$1.collisionVertexBufferExt]);
				}
				if (!a$1 || !g$1.length) return;
				const x$1 = t$1.getOrCreateProgram("collisionCircle"), b$1 = new e.dZ();
				b$1.resize(4 * v$1), b$1._trim();
				let w$1 = 0;
				for (const e$1 of g$1) for (let t$2 = 0; t$2 < e$1.circleArray.length / 4; t$2++) {
					const i$2 = 4 * t$2, o$2 = e$1.circleArray[i$2 + 0], s$2 = e$1.circleArray[i$2 + 1], r$2 = e$1.circleArray[i$2 + 2], n$2 = e$1.circleArray[i$2 + 3];
					b$1.emplace(w$1++, o$2, s$2, r$2, n$2, 0), b$1.emplace(w$1++, o$2, s$2, r$2, n$2, 1), b$1.emplace(w$1++, o$2, s$2, r$2, n$2, 2), b$1.emplace(w$1++, o$2, s$2, r$2, n$2, 3);
				}
				(!Jr || Jr.length < 2 * v$1) && (Jr = function(t$2) {
					const i$2 = 2 * t$2, o$2 = new e.b0();
					o$2.resize(i$2), o$2._trim();
					for (let e$1 = 0; e$1 < i$2; e$1++) {
						const t$3 = 6 * e$1;
						o$2.uint16[t$3 + 0] = 4 * e$1 + 0, o$2.uint16[t$3 + 1] = 4 * e$1 + 1, o$2.uint16[t$3 + 2] = 4 * e$1 + 2, o$2.uint16[t$3 + 3] = 4 * e$1 + 2, o$2.uint16[t$3 + 4] = 4 * e$1 + 3, o$2.uint16[t$3 + 5] = 4 * e$1 + 0;
					}
					return o$2;
				}(v$1));
				const T$1 = l$1.createIndexBuffer(Jr, !0), E$1 = l$1.createVertexBuffer(b$1, e.d_.members, !0);
				for (const i$2 of g$1) {
					const s$2 = {
						u_matrix: i$2.transform,
						u_inv_matrix: i$2.invTransform,
						u_camera_to_center_distance: (S$1 = h$1).getCameraToCenterDistance(i$2.projection),
						u_viewport_size: [S$1.width, S$1.height]
					};
					x$1.draw(t$1, c$1.TRIANGLES, Xi.disabled, Ki.disabled, t$1.colorModeForRenderPass(), eo.disabled, s$2, o$1.id, E$1, T$1, e.bg.simpleSegment(0, 2 * i$2.circleOffset, i$2.circleArray.length, i$2.circleArray.length / 2), null, h$1.zoom);
				}
				var S$1;
				E$1.destroy(), T$1.destroy();
			}
			const en = e.bC();
			function tn(t$1) {
				const i$1 = t$1._camera.getWorldToCamera(t$1.worldSize, 1), o$1 = e.aB([], i$1, t$1.globeMatrix);
				e.bl(o$1, o$1);
				const s$1 = [
					0,
					0,
					0
				], r$1 = [
					0,
					1,
					0,
					0
				];
				return e.aC(r$1, r$1, o$1), s$1[0] = r$1[0], s$1[1] = r$1[1], s$1[2] = r$1[2], e.aw(s$1, s$1), s$1;
			}
			function on({ width: t$1, height: i$1, anchor: o$1, textOffset: s$1, textScale: r$1 }, n$1) {
				const { horizontalAlign: a$1, verticalAlign: l$1 } = e.c1(o$1), c$1 = -(a$1 - .5) * t$1, h$1 = -(l$1 - .5) * i$1, d$1 = e.c2(o$1, s$1);
				return new e.P((c$1 / r$1 + d$1[0]) * n$1, (h$1 / r$1 + d$1[1]) * n$1);
			}
			function sn(t$1, i$1, o$1, s$1, r$1, n$1, a$1, l$1, c$1, h$1) {
				const d$1 = t$1.text.placedSymbolArray, u$1 = t$1.text.dynamicLayoutVertexArray, _$1 = t$1.icon.dynamicLayoutVertexArray, p$1 = {}, f$1 = t$1.getProjection(), m$1 = Qt(a$1, f$1, r$1), g$1 = r$1.elevation, v$1 = f$1.upVectorScale(a$1.canonical, r$1.center.lat, r$1.worldSize).metersToTile;
				u$1.clear();
				for (let _$2 = 0; _$2 < d$1.length; _$2++) {
					const y$1 = d$1.get(_$2), { tileAnchorX: x$1, tileAnchorY: b$1, numGlyphs: w$1 } = y$1, T$1 = y$1.hidden || !y$1.crossTileID || t$1.allowVerticalPlacement && !y$1.placedOrientation ? null : s$1[y$1.crossTileID];
					if (T$1) {
						let s$2 = 0, d$2 = 0, E$1 = 0;
						const S$1 = "road" === t$1.elevationType;
						if (g$1 || S$1) {
							const i$2 = S$1 ? t$1.getElevationFeatureForText(_$2) : null, o$2 = e.bV.getAtTileOffset(a$1, new e.P(x$1, b$1), g$1, i$2), [r$2, n$2, l$2] = f$1.upVector(a$1.canonical, x$1, b$1);
							s$2 = o$2 * r$2 * v$1, d$2 = o$2 * n$2 * v$1, E$1 = o$2 * l$2 * v$1;
						}
						let [I$1, C$1, R$1, A$1] = ai(y$1.projectedAnchorX + s$2, y$1.projectedAnchorY + d$2, y$1.projectedAnchorZ + E$1, o$1 ? m$1 : n$1);
						const L$1 = li(r$1.getCameraToCenterDistance(f$1), A$1);
						let D$1 = e.bM(t$1.textSizeData, c$1, y$1) * L$1 / e.bY;
						o$1 && (D$1 *= t$1.tilePixelRatio / l$1);
						const P$1 = on(T$1, D$1);
						o$1 ? ({x: I$1, y: C$1, z: R$1} = f$1.projectTilePoint(x$1 + P$1.x, b$1 + P$1.y, a$1.canonical), [I$1, C$1, R$1] = ai(I$1 + s$2, C$1 + d$2, R$1 + E$1, n$1)) : (i$1 && P$1._rotate(-r$1.angle), I$1 += P$1.x, C$1 += P$1.y, R$1 = 0);
						const O$1 = t$1.allowVerticalPlacement && y$1.placedOrientation === e.bL.vertical ? Math.PI / 2 : 0;
						for (let t$2 = 0; t$2 < w$1; t$2++) e.bO(u$1, I$1, C$1, R$1, O$1);
						h$1 && y$1.associatedIconIndex >= 0 && (p$1[y$1.associatedIconIndex] = {
							x: I$1,
							y: C$1,
							z: R$1,
							angle: O$1
						});
					} else gi(w$1, u$1);
				}
				if (h$1) {
					_$1.clear();
					const i$2 = t$1.icon.placedSymbolArray;
					for (let t$2 = 0; t$2 < i$2.length; t$2++) {
						const o$2 = i$2.get(t$2), { numGlyphs: s$2 } = o$2, r$2 = p$1[t$2];
						if (o$2.hidden || !r$2) gi(s$2, _$1);
						else {
							const { x: t$3, y: i$3, z: o$3, angle: n$2 } = r$2;
							for (let r$3 = 0; r$3 < s$2; r$3++) e.bO(_$1, t$3, i$3, o$3, n$2);
						}
					}
					t$1.icon.dynamicLayoutVertexBuffer.updateData(_$1);
				}
				t$1.text.dynamicLayoutVertexBuffer.updateData(u$1);
			}
			function rn(t$1, i$1, o$1, s$1, r$1, n$1, a$1 = {}) {
				const l$1 = o$1.paint.get("icon-translate"), c$1 = o$1.paint.get("text-translate"), h$1 = o$1.paint.get("icon-translate-anchor"), d$1 = o$1.paint.get("text-translate-anchor"), u$1 = o$1.layout.get("icon-rotation-alignment"), _$1 = o$1.layout.get("text-rotation-alignment"), p$1 = o$1.layout.get("icon-pitch-alignment"), f$1 = o$1.layout.get("text-pitch-alignment"), m$1 = o$1.layout.get("icon-keep-upright"), g$1 = o$1.layout.get("text-keep-upright"), v$1 = o$1.paint.get("icon-color-saturation"), y$1 = o$1.paint.get("icon-color-contrast"), x$1 = o$1.paint.get("icon-color-brightness-min"), b$1 = o$1.paint.get("icon-color-brightness-max"), w$1 = "sea" === o$1.layout.get("symbol-elevation-reference"), T$1 = "none" === o$1.layout.get("icon-image-use-theme"), E$1 = t$1.context, S$1 = E$1.gl, I$1 = t$1.transform, C$1 = "map" === u$1, R$1 = "map" === _$1, A$1 = "map" === p$1, L$1 = "map" === f$1, D$1 = void 0 !== o$1.layout.get("symbol-sort-key").constantOr(1);
				let P$1 = !1;
				const O$1 = t$1.depthModeForSublayer(0, Xi.ReadOnly), z$1 = new Xi(t$1.context.gl.LEQUAL, Xi.ReadOnly, t$1.depthRangeFor3D), M$1 = [e.aF(I$1.center.lng), e.aJ(I$1.center.lat)], F$1 = o$1.layout.get("text-variable-anchor"), B$1 = "globe" === I$1.projection.name, k$1 = [], N$1 = [
					0,
					-1,
					0
				];
				for (const r$2 of s$1) {
					const s$2 = i$1.getTile(r$2), n$2 = s$2.getBucket(o$1);
					if (!n$2) continue;
					if ("mercator" === n$2.projection.name && B$1) continue;
					if (n$2.fullyClipped) continue;
					const u$2 = "globe" === n$2.projection.name, _$2 = u$2 ? e.aj(I$1.zoom) : 0, p$2 = Qt(r$2, n$2.getProjection(), I$1), f$2 = I$1.calculatePixelsToTileUnitsMatrix(s$2), U$1 = F$1 && n$2.hasTextData(), j$1 = n$2.hasIconTextFit() && U$1 && n$2.hasIconData(), G$1 = n$2.getProjection().createInversionMatrix(I$1, r$2.canonical), V$1 = (1 << s$2.tileID.canonical.z) * e.al / t$1.transform.worldSize, H$1 = (e$1) => {
						let i$2 = [
							0,
							0,
							0
						];
						if (e$1) {
							const e$2 = t$1.style.directionalLight, o$2 = t$1.style.ambientLight;
							e$2 && o$2 && (i$2 = vo(t$1.style, e$2, o$2));
						}
						return i$2;
					}, q$1 = (e$1) => {
						I$1.depthOcclusionForSymbolsAndCircles && (o$1.hasOcclusionOpacityProperties || t$1.terrain) && (e$1.push("DEPTH_D24"), e$1.push("DEPTH_OCCLUSION"));
					}, Z$1 = (i$2) => {
						o$1.lut && !T$1 && (o$1.lut.texture || (o$1.lut.texture = new e.d$(t$1.context, o$1.lut.image, [
							o$1.lut.image.height,
							o$1.lut.image.height,
							o$1.lut.image.height
						], E$1.gl.RGBA8)), E$1.activeTexture.set(E$1.gl.TEXTURE0 + no.LUT), o$1.lut.texture && o$1.lut.texture.bind(E$1.gl.LINEAR, E$1.gl.CLAMP_TO_EDGE), i$2.push("APPLY_LUT_ON_GPU"));
					}, W$1 = () => {
						const i$2 = C$1 && "point" !== o$1.layout.get("symbol-placement"), a$2 = [];
						q$1(a$2), Z$1(a$2);
						const c$2 = i$2 || j$1, d$2 = "road" === n$2.elevationType, g$2 = t$1.shadowRenderer, T$2 = d$2 && A$1 && !!g$2 && g$2.enabled, E$2 = H$1(T$2), R$2 = d$2 && A$1 && !t$1.terrain ? z$1 : O$1, L$2 = o$1.paint.get("icon-image-cross-fade");
						t$1.terrainRenderModeElevated() && A$1 && a$2.push("PITCH_WITH_MAP_TERRAIN"), u$2 && (a$2.push("PROJECTION_GLOBE_VIEW"), c$2 && a$2.push("PROJECTED_POS_ON_VIEWPORT")), L$2 > 0 && n$2.hasAnySecondaryIcon && a$2.push("ICON_TRANSITION"), !n$2.icon.zOffsetVertexBuffer || d$2 && t$1.terrain || a$2.push("Z_OFFSET"), 0 === v$1 && 0 === y$1 && 0 === x$1 && 1 === b$1 || a$2.push("COLOR_ADJUSTMENT"), n$2.sdfIcons && a$2.push("RENDER_SDF"), T$2 && a$2.push("RENDER_SHADOWS", "DEPTH_TEXTURE", "NORMAL_OFFSET"), d$2 && A$1 && !t$1.terrain && n$2.icon.orientationVertexBuffer && a$2.push("ELEVATED_ROADS");
						const D$2 = n$2.icon.programConfigurations.get(o$1.id), P$2 = t$1.getOrCreateProgram("symbol", {
							config: D$2,
							defines: a$2
						}), F$2 = s$2.imageAtlasTexture ? s$2.imageAtlasTexture.size : [0, 0], k$2 = n$2.iconSizeData, U$2 = e.bK(k$2, I$1.zoom), W$2 = A$1 || !I$1.isOrthographic, $$2 = si(p$2, s$2.tileID.canonical, A$1, C$1, I$1, n$2.getProjection(), f$2), X$2 = ni(p$2, s$2.tileID.canonical, A$1, C$1, I$1, n$2.getProjection(), f$2), Y$2 = t$1.translatePosMatrix(X$2, s$2, l$1, h$1, !0), K$2 = t$1.translatePosMatrix(p$2, s$2, l$1, h$1), J$2 = c$2 ? en : $$2, Q$2 = C$1 && !A$1 && !i$2;
						let ee$2 = N$1;
						!B$1 && !I$1.mercatorFromTransition || C$1 || (ee$2 = tn(I$1));
						const te$1 = u$2 ? ee$2 : N$1, ie$1 = o$1.getColorAdjustmentMatrix(v$1, y$1, x$1, b$1), oe$1 = Ur(k$2.kind, U$2, Q$2, A$1, t$1, K$2, J$2, Y$2, w$1, !1, F$2, [0, 0], 0, r$2, _$2, M$1, G$1, te$1, n$2.getProjection(), E$2, V$1, ie$1, L$2, null), se$1 = s$2.imageAtlasTexture ? s$2.imageAtlasTexture : null, re$1 = 1 !== o$1.layout.get("icon-size").constantOr(0) || n$2.iconsNeedLinear, ne$1 = n$2.sdfIcons || t$1.options.rotating || t$1.options.zooming || re$1 || W$2 ? S$1.LINEAR : S$1.NEAREST, ae$1 = n$2.sdfIcons && 0 !== o$1.paint.get("icon-halo-width").constantOr(1), le$1 = t$1.terrain && A$1 && i$2 ? e.bl(e.bC(), $$2) : en;
						if (i$2 && n$2.icon) {
							const i$3 = e.bV.getAtTileOffsetFunc(r$2, I$1.center.lat, I$1.worldSize, n$2.getProjection()), a$3 = ri(p$2, s$2.tileID.canonical, A$1, C$1, I$1, n$2.getProjection(), f$2), l$2 = o$1.layout.get("icon-size-scale-range");
							hi(n$2, p$2, t$1, !1, a$3, X$2, A$1, m$1, i$3, r$2, e.aA(t$1.scaleFactor, l$2[0], l$2[1]));
						}
						return {
							program: P$2,
							buffers: n$2.icon,
							uniformValues: oe$1,
							atlasTexture: se$1,
							atlasTextureIcon: null,
							atlasInterpolation: ne$1,
							atlasInterpolationIcon: null,
							isSDF: n$2.sdfIcons,
							hasHalo: ae$1,
							depthMode: R$2,
							tile: s$2,
							renderWithShadows: T$2,
							labelPlaneMatrixInv: le$1
						};
					}, $$1 = () => {
						const i$2 = R$1 && "point" !== o$1.layout.get("symbol-placement"), a$2 = [], l$2 = i$2 || F$1 || j$1, h$2 = "road" === n$2.elevationType, m$2 = t$1.shadowRenderer, v$2 = h$2 && L$1 && !!m$2 && m$2.enabled, y$2 = H$1(v$2), x$2 = h$2 && L$1 && !t$1.terrain ? z$1 : O$1;
						t$1.terrainRenderModeElevated() && L$1 && a$2.push("PITCH_WITH_MAP_TERRAIN"), u$2 && (a$2.push("PROJECTION_GLOBE_VIEW"), l$2 && a$2.push("PROJECTED_POS_ON_VIEWPORT")), !n$2.text.zOffsetVertexBuffer || h$2 && t$1.terrain || a$2.push("Z_OFFSET"), n$2.iconsInText && a$2.push("RENDER_TEXT_AND_SYMBOL"), a$2.push("RENDER_SDF"), v$2 && a$2.push("RENDER_SHADOWS", "DEPTH_TEXTURE", "NORMAL_OFFSET"), h$2 && L$1 && !t$1.terrain && n$2.text.orientationVertexBuffer && a$2.push("ELEVATED_ROADS"), q$1(a$2);
						const b$2 = n$2.text.programConfigurations.get(o$1.id), T$2 = t$1.getOrCreateProgram("symbol", {
							config: b$2,
							defines: a$2
						});
						let E$2, C$2 = [0, 0], A$2 = null;
						const D$2 = n$2.textSizeData;
						n$2.iconsInText && (C$2 = s$2.imageAtlasTexture ? s$2.imageAtlasTexture.size : [0, 0], A$2 = s$2.imageAtlasTexture ? s$2.imageAtlasTexture : null, E$2 = L$1 || !I$1.isOrthographic || t$1.options.rotating || t$1.options.zooming || "composite" === D$2.kind || "camera" === D$2.kind ? S$1.LINEAR : S$1.NEAREST);
						const P$2 = s$2.glyphAtlasTexture ? s$2.glyphAtlasTexture.size : [0, 0], k$2 = o$1.layout.get("text-size-scale-range"), U$2 = e.aA(t$1.scaleFactor, k$2[0], k$2[1]), Z$2 = e.bK(D$2, I$1.zoom, U$2), W$2 = si(p$2, s$2.tileID.canonical, L$1, R$1, I$1, n$2.getProjection(), f$2), $$2 = ni(p$2, s$2.tileID.canonical, L$1, R$1, I$1, n$2.getProjection(), f$2), X$2 = t$1.translatePosMatrix($$2, s$2, c$1, d$1, !0), Y$2 = t$1.translatePosMatrix(p$2, s$2, c$1, d$1), K$2 = l$2 ? en : W$2, J$2 = R$1 && !L$1 && !i$2;
						let Q$2 = N$1;
						!B$1 && !I$1.mercatorFromTransition || R$1 || (Q$2 = tn(I$1));
						const ee$2 = Ur(D$2.kind, Z$2, J$2, L$1, t$1, Y$2, K$2, X$2, w$1, !0, P$2, C$2, 0, r$2, _$2, M$1, G$1, u$2 ? Q$2 : N$1, n$2.getProjection(), y$2, V$1, null, null, U$2), te$1 = s$2.glyphAtlasTexture ? s$2.glyphAtlasTexture : null, ie$1 = S$1.LINEAR, oe$1 = 0 !== o$1.paint.get("text-halo-width").constantOr(1), se$1 = t$1.terrain && L$1 && i$2 ? e.bl(e.bC(), W$2) : en;
						if (i$2 && n$2.text) {
							const i$3 = e.bV.getAtTileOffsetFunc(r$2, I$1.center.lat, I$1.worldSize, n$2.getProjection());
							hi(n$2, p$2, t$1, !0, ri(p$2, s$2.tileID.canonical, L$1, R$1, I$1, n$2.getProjection(), f$2), $$2, L$1, g$1, i$3, r$2, U$2);
						}
						return {
							program: T$2,
							buffers: n$2.text,
							uniformValues: ee$2,
							atlasTexture: te$1,
							atlasTextureIcon: A$2,
							atlasInterpolation: ie$1,
							atlasInterpolationIcon: E$2,
							isSDF: !0,
							hasHalo: oe$1,
							depthMode: x$2,
							tile: s$2,
							renderWithShadows: v$2,
							labelPlaneMatrixInv: se$1
						};
					}, X$1 = n$2.icon.segments.get().length, Y$1 = n$2.text.segments.get().length, K$1 = X$1 && !a$1.onlyText ? W$1() : null, J$1 = Y$1 && !a$1.onlyIcons ? $$1() : null, Q$1 = o$1.paint.get("icon-opacity").constantOr(1), ee$1 = o$1.paint.get("text-opacity").constantOr(1);
					if (D$1 && n$2.canOverlap) {
						P$1 = !0;
						const t$2 = Q$1 && !a$1.onlyText ? n$2.icon.segments.get() : [], i$2 = ee$1 && !a$1.onlyIcons ? n$2.text.segments.get() : [];
						for (const i$3 of t$2) k$1.push({
							segments: new e.bg([i$3]),
							sortKey: i$3.sortKey,
							state: K$1
						});
						for (const t$3 of i$2) k$1.push({
							segments: new e.bg([t$3]),
							sortKey: t$3.sortKey,
							state: J$1
						});
					} else a$1.onlyText || k$1.push({
						segments: Q$1 ? n$2.icon.segments : new e.bg([]),
						sortKey: 0,
						state: K$1
					}), a$1.onlyIcons || k$1.push({
						segments: ee$1 ? n$2.text.segments : new e.bg([]),
						sortKey: 0,
						state: J$1
					});
				}
				P$1 && k$1.sort(((e$1, t$2) => e$1.sortKey - t$2.sortKey));
				for (const e$1 of k$1) {
					const i$2 = e$1.state;
					if (i$2) if (t$1.terrain ? t$1.terrain.setupElevationDraw(i$2.tile, i$2.program, {
						useDepthForOcclusion: I$1.depthOcclusionForSymbolsAndCircles,
						labelPlaneMatrixInv: i$2.labelPlaneMatrixInv
					}) : t$1.setupDepthForOcclusion(I$1.depthOcclusionForSymbolsAndCircles, i$2.program), E$1.activeTexture.set(S$1.TEXTURE0), i$2.atlasTexture && i$2.atlasTexture.bind(i$2.atlasInterpolation, S$1.CLAMP_TO_EDGE, !0), i$2.atlasTextureIcon && (E$1.activeTexture.set(S$1.TEXTURE1), i$2.atlasTextureIcon && i$2.atlasTextureIcon.bind(i$2.atlasInterpolationIcon, S$1.CLAMP_TO_EDGE, !0)), i$2.renderWithShadows && t$1.shadowRenderer.setupShadows(i$2.tile.tileID.toUnwrapped(), i$2.program, "vector-tile"), t$1.uploadCommonLightUniforms(t$1.context, i$2.program), i$2.hasHalo) {
						const s$2 = i$2.uniformValues;
						s$2.u_is_halo = 1, nn(i$2.buffers, e$1.segments, o$1, t$1, i$2.program, i$2.depthMode, r$1, n$1, s$2, 2), s$2.u_is_halo = 0;
					} else {
						if (i$2.isSDF) {
							const s$2 = i$2.uniformValues;
							i$2.hasHalo && (s$2.u_is_halo = 1, nn(i$2.buffers, e$1.segments, o$1, t$1, i$2.program, i$2.depthMode, r$1, n$1, s$2, 1)), s$2.u_is_halo = 0;
						}
						nn(i$2.buffers, e$1.segments, o$1, t$1, i$2.program, i$2.depthMode, r$1, n$1, i$2.uniformValues, 1);
					}
				}
			}
			function nn(e$1, t$1, i$1, o$1, s$1, r$1, n$1, a$1, l$1, c$1) {
				const h$1 = [
					e$1.dynamicLayoutVertexBuffer,
					e$1.opacityVertexBuffer,
					e$1.iconTransitioningVertexBuffer,
					e$1.globeExtVertexBuffer,
					e$1.zOffsetVertexBuffer,
					e$1.orientationVertexBuffer
				];
				s$1.draw(o$1, o$1.context.gl.TRIANGLES, r$1, n$1, a$1, eo.disabled, l$1, i$1.id, e$1.layoutVertexBuffer, e$1.indexBuffer, t$1, i$1.paint, o$1.transform.zoom, e$1.programConfigurations.get(i$1.id), h$1, c$1);
			}
			function an(t$1, i$1) {
				const o$1 = 1 << t$1.canonical.z, s$1 = (i$1.x * o$1 - t$1.canonical.x - t$1.wrap * o$1) * e.al, r$1 = (i$1.y * o$1 - t$1.canonical.y) * e.al, n$1 = e.e8(i$1.z, i$1.y);
				return e.d5(s$1, r$1, n$1);
			}
			function ln(t$1, i$1, o$1, s$1, r$1) {
				if (!o$1.layout || "none" === o$1.layout.get("fill-elevation-reference") || 0 === o$1.paint.get("fill-opacity").constantOr(1)) return;
				const n$1 = t$1.context.gl, a$1 = new Xi(t$1.context.gl.LEQUAL, Xi.ReadWrite, t$1.depthRangeFor3D), l$1 = new Xi(t$1.context.gl.GREATER, Xi.ReadWrite, t$1.depthRangeFor3D), c$1 = function(t$2) {
					let i$2 = .01;
					return t$2.isOrthographic && (i$2 = e.ak(1e-4, i$2, e.d0(t$2.pitch >= lo ? 1 : t$2.pitch / lo))), 2 * i$2;
				}(t$1.transform), h$1 = t$1.transform.getFreeCameraOptions().position, d$1 = "elevatedStructuresDepthReconstruct", u$1 = t$1.getOrCreateProgram(d$1, { defines: ["DEPTH_RECONSTRUCTION"] }), _$1 = t$1.getOrCreateProgram(d$1);
				for (const e$1 of s$1) {
					const s$2 = i$1.getTile(e$1), d$2 = s$2.getBucket(o$1);
					if (!d$2) continue;
					const p$1 = d$2.elevatedStructures;
					if (!p$1) continue;
					const f$1 = d$2.elevationBufferData.heightRange, m$1 = an(e$1.toUnwrapped(), h$1), g$1 = t$1.translatePosMatrix(e$1.projMatrix, s$2, o$1.paint.get("fill-translate"), o$1.paint.get("fill-translate-anchor"));
					let v$1, y$1, x$1, b$1;
					if ("initialize" === r$1) {
						if (!f$1 || f$1.min >= 1 || 0 === p$1.depthSegments.segments[0].primitiveLength) continue;
						v$1 = Tr(g$1, m$1, c$1, 1, 0), y$1 = a$1, x$1 = p$1.depthSegments, b$1 = u$1;
					} else if ("reset" === r$1) {
						if (!f$1 || f$1.min >= 0 || 0 === p$1.maskSegments.segments[0].primitiveLength) continue;
						v$1 = Tr(g$1, m$1, 0, 0, 1), y$1 = l$1, x$1 = p$1.maskSegments, b$1 = u$1;
					} else if ("geometry" === r$1) {
						if (0 === p$1.depthSegments.segments[0].primitiveLength) continue;
						v$1 = Tr(g$1, m$1, c$1, 1, 0), y$1 = a$1, x$1 = p$1.depthSegments, b$1 = _$1;
					}
					b$1.draw(t$1, n$1.TRIANGLES, y$1, Ki.disabled, $i.disabled, eo.disabled, v$1, o$1.id, p$1.vertexBuffer, p$1.indexBuffer, x$1, o$1.paint, t$1.transform.zoom);
				}
			}
			function cn(t$1, i$1, o$1, s$1) {
				const { painter: r$1, sourceCache: n$1, layer: a$1, coords: l$1, colorMode: c$1, elevationType: h$1, terrainEnabled: d$1, pass: u$1 } = t$1, _$1 = r$1.context.gl, p$1 = a$1.paint.get("fill-pattern"), f$1 = a$1.paint.get("fill-pattern-cross-fade"), m$1 = p$1.constantOr(null);
				let g$1 = h$1;
				"road" !== h$1 || i$1 && !d$1 || (g$1 = "none");
				const v$1 = "road" === g$1, y$1 = t$1.painter.shadowRenderer, x$1 = v$1 && !!y$1 && y$1.enabled, b$1 = new Xi(r$1.context.gl.LEQUAL, Xi.ReadOnly, r$1.depthRangeFor3D);
				let w$1 = [
					0,
					0,
					0
				];
				if (x$1) {
					const e$1 = r$1.style.directionalLight, t$2 = r$1.style.ambientLight;
					e$1 && t$2 && (w$1 = vo(r$1.style, e$1, t$2));
				}
				const T$1 = p$1 && p$1.constantOr(1), E$1 = r$1.terrain && r$1.terrain.renderingToTexture, S$1 = (t$2, u$2) => {
					let p$2, g$2, S$2, I$1, C$1;
					u$2 ? (p$2 = T$1 && !a$1.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", S$2 = _$1.LINES) : (p$2 = T$1 ? "fillPattern" : "fill", S$2 = _$1.TRIANGLES);
					for (const R$1 of l$1) {
						const l$2 = n$1.getTile(R$1);
						if (T$1 && !l$2.patternsLoaded()) continue;
						const A$1 = l$2.getBucket(a$1);
						if (!A$1) continue;
						const L$1 = i$1 ? A$1.elevationBufferData : A$1.bufferData;
						if (L$1.isEmpty()) continue;
						r$1.prepareDrawTile();
						const D$1 = L$1.programConfigurations.get(a$1.id), P$1 = r$1.isTileAffectedByFog(R$1), O$1 = [], z$1 = [];
						v$1 && (O$1.push("ELEVATED_ROADS"), z$1.push(L$1.elevatedLayoutVertexBuffer)), x$1 && O$1.push("RENDER_SHADOWS", "DEPTH_TEXTURE", "NORMAL_OFFSET"), E$1 && o$1 && O$1.push("USE_MRT1"), T$1 && (r$1.context.activeTexture.set(_$1.TEXTURE0), l$2.imageAtlasTexture && l$2.imageAtlasTexture.bind(_$1.LINEAR, _$1.CLAMP_TO_EDGE), D$1.updatePaintBuffers());
						let M$1 = !1;
						if (m$1 && l$2.imageAtlas) {
							const t$3 = l$2.imageAtlas, i$2 = e.e3.from(m$1), o$2 = i$2.getPrimary().scaleSelf(e.o.devicePixelRatio).toString(), s$2 = i$2.getSecondary(), r$2 = t$3.patternPositions.get(o$2), n$2 = s$2 ? t$3.patternPositions.get(s$2.scaleSelf(e.o.devicePixelRatio).toString()) : null;
							M$1 = !!r$2 && !!n$2, r$2 && D$1.setConstantPatternPositions(r$2, n$2);
						}
						f$1 > 0 && (M$1 || D$1.getPatternTransitionVertexBuffer("fill-pattern")) && O$1.push("FILL_PATTERN_TRANSITION");
						const F$1 = r$1.getOrCreateProgram(p$2, {
							config: D$1,
							overrideFog: P$1,
							defines: O$1
						}), B$1 = r$1.translatePosMatrix(R$1.projMatrix, l$2, a$1.paint.get("fill-translate"), a$1.paint.get("fill-translate-anchor"));
						x$1 && y$1.setupShadows(l$2.tileID.toUnwrapped(), F$1, "vector-tile");
						const k$1 = a$1.paint.get("fill-emissive-strength");
						if (u$2) {
							I$1 = L$1.lineIndexBuffer, C$1 = L$1.lineSegments;
							const e$1 = r$1.terrain && r$1.terrain.renderingToTexture ? r$1.terrain.drapeBufferSize : [_$1.drawingBufferWidth, _$1.drawingBufferHeight];
							g$2 = "fillOutlinePattern" === p$2 && T$1 ? br(B$1, k$1, r$1, l$2, e$1, w$1, f$1) : xr(B$1, k$1, e$1, w$1);
						} else I$1 = L$1.indexBuffer, C$1 = L$1.triangleSegments, g$2 = T$1 ? yr(B$1, k$1, r$1, l$2, w$1, f$1) : vr(B$1, k$1, w$1);
						r$1.uploadCommonUniforms(r$1.context, F$1, R$1.toUnwrapped());
						let N$1 = t$2;
						("road" === h$1 && !d$1 || "offset" === h$1) && (N$1 = b$1), F$1.draw(r$1, S$2, N$1, s$1 || r$1.stencilModeForClipping(R$1), c$1, eo.disabled, g$2, a$1.id, L$1.layoutVertexBuffer, I$1, C$1, a$1.paint, r$1.transform.zoom, D$1, z$1);
					}
				};
				r$1.renderPass === u$1 && S$1(r$1.depthModeForSublayer(1, "opaque" === r$1.renderPass ? Xi.ReadWrite : Xi.ReadOnly), !1), "none" === g$1 && "translucent" === r$1.renderPass && a$1.paint.get("fill-antialias") && S$1(r$1.depthModeForSublayer(a$1.getPaintProperty("fill-outline-color") ? 2 : 0, Xi.ReadOnly), !0);
			}
			function hn(t$1, i$1, o$1, s$1, r$1, n$1, a$1, l$1) {
				o$1.resetLayerRenderingStats(t$1);
				const c$1 = t$1.context, h$1 = c$1.gl, d$1 = t$1.transform, u$1 = o$1.paint.get("fill-extrusion-pattern"), _$1 = o$1.paint.get("fill-extrusion-pattern-cross-fade"), p$1 = u$1.constantOr(null), f$1 = u$1.constantOr(1), m$1 = o$1.paint.get("fill-extrusion-opacity"), g$1 = t$1.style.enable3dLights(), v$1 = o$1.paint.get(g$1 && !f$1 ? "fill-extrusion-ambient-occlusion-wall-radius" : "fill-extrusion-ambient-occlusion-radius"), y$1 = [o$1.paint.get("fill-extrusion-ambient-occlusion-intensity"), v$1], x$1 = o$1.layout.get("fill-extrusion-edge-radius"), b$1 = x$1 > 0 && !o$1.paint.get("fill-extrusion-rounded-roof"), w$1 = b$1 ? 0 : x$1, T$1 = "globe" === d$1.projection.name ? e.eb() : 0, E$1 = "globe" === d$1.projection.name, S$1 = E$1 ? e.aj(d$1.zoom) : 0, I$1 = [e.aF(d$1.center.lng), e.aJ(d$1.center.lat)], C$1 = "none" === o$1.paint.get("fill-extrusion-flood-light-color-use-theme").constantOr("default"), R$1 = o$1.paint.get("fill-extrusion-flood-light-color").toNonPremultipliedRenderColor(C$1 ? null : o$1.lut).toArray01().slice(0, 3), A$1 = o$1.paint.get("fill-extrusion-flood-light-intensity"), L$1 = o$1.paint.get("fill-extrusion-vertical-scale"), D$1 = 0 !== o$1.paint.get("fill-extrusion-line-width").constantOr(1), P$1 = o$1.paint.get("fill-extrusion-height-alignment"), O$1 = o$1.paint.get("fill-extrusion-base-alignment"), z$1 = ho(t$1, o$1.paint.get("fill-extrusion-cutoff-fade-range")), M$1 = [];
				let F$1;
				E$1 && M$1.push("PROJECTION_GLOBE_VIEW"), y$1[0] > 0 && M$1.push("FAUX_AO"), b$1 && M$1.push("ZERO_ROOF_RADIUS"), l$1 && M$1.push("HAS_CENTROID"), A$1 > 0 && M$1.push("FLOOD_LIGHT"), z$1.shouldRenderCutoff && M$1.push("RENDER_CUTOFF"), D$1 && M$1.push("RENDER_WALL_MODE");
				const B$1 = "shadow" === t$1.renderPass, k$1 = t$1.shadowRenderer, N$1 = B$1 && !!k$1, U$1 = B$1 ? eo.disabled : eo.backCCW;
				t$1.shadowRenderer && (t$1.shadowRenderer.useNormalOffset = !0);
				let j$1 = [
					0,
					0,
					0
				];
				if (k$1) {
					const e$1 = t$1.style.directionalLight, i$2 = t$1.style.ambientLight;
					e$1 && i$2 && (j$1 = vo(t$1.style, e$1, i$2)), B$1 || (M$1.push("RENDER_SHADOWS", "DEPTH_TEXTURE"), k$1.useNormalOffset && M$1.push("NORMAL_OFFSET")), F$1 = M$1.concat(["SHADOWS_SINGLE_CASCADE"]);
				}
				const G$1 = N$1 ? "fillExtrusionDepth" : f$1 ? "fillExtrusionPattern" : "fillExtrusion", V$1 = o$1.getLayerRenderingStats();
				for (const u$2 of s$1) {
					const s$2 = i$1.getTile(u$2), g$2 = s$2.getBucket(o$1);
					if (!g$2 || g$2.projection.name !== d$1.projection.name) continue;
					let v$2 = !1;
					k$1 && (v$2 = 0 === k$1.getMaxCascadeForTile(u$2.toUnwrapped()));
					const x$2 = t$1.isTileAffectedByFog(u$2), b$2 = g$2.programConfigurations.get(o$1.id);
					let C$2 = !1;
					if (p$1 && s$2.imageAtlas) {
						const t$2 = s$2.imageAtlas, i$2 = e.e3.from(p$1), o$2 = i$2.getPrimary().scaleSelf(e.o.devicePixelRatio).toString(), r$2 = i$2.getSecondary(), n$2 = t$2.patternPositions.get(o$2), a$2 = r$2 ? t$2.patternPositions.get(r$2.scaleSelf(e.o.devicePixelRatio).toString()) : null;
						C$2 = !!n$2 && !!a$2, n$2 && b$2.setConstantPatternPositions(n$2, a$2);
					}
					_$1 > 0 && (C$2 || b$2.getPatternTransitionVertexBuffer("fill-extrusion-pattern")) && M$1.push("FILL_EXTRUSION_PATTERN_TRANSITION");
					const N$2 = t$1.getOrCreateProgram(G$1, {
						config: b$2,
						defines: v$2 ? F$1 : M$1,
						overrideFog: x$2
					});
					if (t$1.terrain && t$1.terrain.setupElevationDraw(s$2, N$2, { useMeterToDem: !0 }), !g$2.centroidVertexBuffer) {
						const e$1 = N$2.getAttributeLocation(h$1, "a_centroid_pos");
						-1 !== e$1 && h$1.vertexAttrib2f(e$1, 0, 0);
					}
					!B$1 && k$1 && k$1.setupShadows(s$2.tileID.toUnwrapped(), N$2, "vector-tile"), f$1 && (t$1.context.activeTexture.set(h$1.TEXTURE0), s$2.imageAtlasTexture && s$2.imageAtlasTexture.bind(h$1.LINEAR, h$1.CLAMP_TO_EDGE), b$2.updatePaintBuffers());
					const H$1 = o$1.paint.get("fill-extrusion-vertical-gradient"), q$1 = 1 / g$2.tileToMeter;
					let Z$1;
					if (B$1 && k$1) {
						if (gn(s$2.tileID, g$2.maxHeight, t$1)) continue;
						Z$1 = fr(k$1.calculateShadowPassMatrixFromTile(s$2.tileID.toUnwrapped()), w$1, q$1, L$1, P$1, O$1);
					} else {
						const e$1 = t$1.translatePosMatrix(u$2.expandedProjMatrix, s$2, o$1.paint.get("fill-extrusion-translate"), o$1.paint.get("fill-extrusion-translate-anchor")), i$2 = d$1.projection.createInversionMatrix(d$1, u$2.canonical);
						Z$1 = f$1 ? mr(e$1, t$1, H$1, m$1, y$1, w$1, q$1, u$2, s$2, T$1, P$1, O$1, S$1, I$1, i$2, R$1, L$1, _$1) : pr(e$1, t$1, H$1, m$1, y$1, w$1, q$1, u$2, T$1, P$1, O$1, S$1, I$1, i$2, R$1, L$1, A$1, j$1);
					}
					t$1.uploadCommonUniforms(c$1, N$2, u$2.toUnwrapped(), null, z$1);
					let W$1 = g$2.segments;
					if ("mercator" === d$1.projection.name && !B$1 && (W$1 = g$2.getVisibleSegments(s$2.tileID, t$1.terrain, t$1.transform.getFrustum(0)), !W$1.get().length)) continue;
					if (V$1) if (B$1) for (const e$1 of W$1.get()) V$1.numRenderedVerticesInShadowPass += e$1.primitiveLength;
					else for (const e$1 of W$1.get()) V$1.numRenderedVerticesInTransparentPass += e$1.primitiveLength;
					const $$1 = [];
					(t$1.terrain || l$1) && $$1.push(g$2.centroidVertexBuffer), E$1 && $$1.push(g$2.layoutVertexExtBuffer), D$1 && $$1.push(g$2.wallVertexBuffer), N$2.draw(t$1, c$1.gl.TRIANGLES, r$1, n$1, a$1, U$1, Z$1, o$1.id, g$2.layoutVertexBuffer, g$2.indexBuffer, W$1, o$1.paint, t$1.transform.zoom, b$2, $$1);
				}
				t$1.shadowRenderer && (t$1.shadowRenderer.useNormalOffset = !1);
			}
			class dn {
				constructor() {
					this.translate = [0, 0], this.translateAnchor = "map", this.edgeRadius = 0, this.cutoffFadeRange = 0;
				}
			}
			function un(t$1, i$1, o$1, s$1, r$1, n$1, a$1, l$1, c$1, h$1, d$1, u$1, _$1, p$1, f$1, m$1, g$1, v$1, y$1, x$1) {
				const b$1 = i$1.context, w$1 = b$1.gl, T$1 = i$1.transform, E$1 = i$1.transform.zoom, S$1 = [], I$1 = t$1.translate, C$1 = t$1.translateAnchor, R$1 = t$1.edgeRadius, A$1 = ho(i$1, t$1.cutoffFadeRange);
				"clear" === d$1 ? (S$1.push("CLEAR_SUBPASS"), x$1 && (S$1.push("CLEAR_FROM_TEXTURE"), b$1.activeTexture.set(w$1.TEXTURE0), x$1.bind(w$1.LINEAR, w$1.CLAMP_TO_EDGE))) : "sdf" === d$1 ? S$1.push("SDF_SUBPASS") : "emissive" === d$1 && (S$1.push("USE_MRT1"), b$1.activeTexture.set(w$1.TEXTURE0), x$1.bind(w$1.LINEAR, w$1.CLAMP_TO_EDGE)), v$1 && S$1.push("HAS_CENTROID"), A$1.shouldRenderCutoff && S$1.push("RENDER_CUTOFF");
				const L$1 = (e$1, t$2, o$2, r$2, d$2) => {
					let y$2 = S$1;
					null != t$2.groundRadiusBuffer && (y$2 = S$1.concat("HAS_ATTRIBUTE_a_flood_light_ground_radius"));
					const w$2 = t$2.programConfigurations.get(s$1.id), T$2 = i$1.isTileAffectedByFog(e$1), I$2 = i$1.getOrCreateProgram("fillExtrusionGroundEffect", {
						config: w$2,
						defines: y$2,
						overrideFog: T$2
					}), C$2 = gr(i$1, r$2, u$1, h$1, d$2, [_$1, p$1 * d$2], f$1, m$1, g$1, E$1 >= 17 ? 0 : R$1 * d$2, x$1 ? x$1.size[0] : 0), L$2 = [];
					v$1 && L$2.push(t$2.hiddenByLandmarkVertexBuffer), null != t$2.groundRadiusBuffer && L$2.push(t$2.groundRadiusBuffer), i$1.uploadCommonUniforms(b$1, I$2, e$1.toUnwrapped(), null, A$1), I$2.draw(i$1, b$1.gl.TRIANGLES, n$1, a$1, l$1, c$1, C$2, s$1.id, t$2.vertexBuffer, t$2.indexBuffer, o$2, s$1.paint, E$1, w$2, L$2);
				};
				for (const t$2 of r$1) {
					const r$2 = o$1.getTile(t$2), n$2 = r$2.getBucket(s$1);
					if (!n$2 || n$2.projection.name !== T$1.projection.name || !n$2.groundEffect || n$2.groundEffect && !n$2.groundEffect.hasData()) continue;
					const a$2 = n$2.groundEffect, l$2 = 1 / n$2.tileToMeter;
					{
						const e$1 = i$1.translatePosMatrix(t$2.projMatrix, r$2, I$1, C$1);
						L$1(t$2, a$2, a$2.getDefaultSegment(), e$1, l$2);
					}
					if (y$1) for (let n$3 = 0; n$3 < 4; n$3++) {
						const a$3 = e.e9[n$3](t$2), c$2 = o$1.getTile(a$3);
						if (!c$2) continue;
						const h$2 = c$2.getBucket(s$1);
						if (!h$2 || h$2.projection.name !== T$1.projection.name || !h$2.groundEffect || h$2.groundEffect && !h$2.groundEffect.hasData()) continue;
						const d$2 = h$2.groundEffect;
						let u$2, _$2;
						0 === n$3 ? (u$2 = [
							-e.al,
							0,
							0
						], _$2 = 1) : 1 === n$3 ? (u$2 = [
							e.al,
							0,
							0
						], _$2 = 0) : 2 === n$3 ? (u$2 = [
							0,
							-e.al,
							0
						], _$2 = 3) : (u$2 = [
							0,
							e.al,
							0
						], _$2 = 2);
						const p$2 = d$2.regionSegments[_$2];
						if (!p$2) continue;
						const f$2 = new Float32Array(16);
						e.br(f$2, t$2.projMatrix, u$2), L$1(t$2, d$2, p$2, i$1.translatePosMatrix(f$2, r$2, I$1, C$1), l$2);
					}
				}
			}
			function _n(t$1, i$1, o$1, s$1, r$1, n$1, a$1) {
				0 === s$1.centroidVertexArray.length && s$1.createCentroidsBuffer();
				const l$1 = n$1 ? n$1.findDEMTileFor(o$1) : null;
				if (!(l$1 && l$1.dem || a$1)) return;
				n$1 && l$1 && l$1.dem && s$1.selfDEMTileTimestamp !== l$1.dem._timestamp && (s$1.borderDoneWithNeighborZ = [
					-1,
					-1,
					-1,
					-1
				], s$1.selfDEMTileTimestamp = l$1.dem._timestamp);
				const c$1 = (t$2) => new e.P(Math.ceil((t$2 + e.ed) * e.ee), 0), h$1 = (e$1) => {
					const t$2 = i$1.getSource().minzoom, o$2 = (e$2) => {
						const t$3 = i$1.getTileByID(e$2);
						if (t$3 && t$3.hasData()) return t$3.getBucket(r$1);
					};
					for (const i$2 of [
						0,
						-1,
						1
					]) {
						if (e$1.overscaledZ + i$2 < t$2) continue;
						const s$2 = o$2(e$1.calculateScaledKey(e$1.overscaledZ + i$2));
						if (s$2) return s$2;
					}
				}, d$1 = [
					0,
					0,
					0
				], u$1 = (t$2, i$2) => (d$1[0] = Math.min(t$2.min.y, i$2.min.y), d$1[1] = Math.max(t$2.max.y, i$2.max.y), d$1[2] = e.al - i$2.min.x > t$2.max.x ? i$2.min.x - e.al : t$2.max.x, d$1), _$1 = (t$2, i$2) => (d$1[0] = Math.min(t$2.min.x, i$2.min.x), d$1[1] = Math.max(t$2.max.x, i$2.max.x), d$1[2] = e.al - i$2.min.y > t$2.max.y ? i$2.min.y - e.al : t$2.max.y, d$1), p$1 = [
					(e$1, t$2) => u$1(e$1, t$2),
					(e$1, t$2) => u$1(t$2, e$1),
					(e$1, t$2) => _$1(e$1, t$2),
					(e$1, t$2) => _$1(t$2, e$1)
				], f$1 = (t$2, i$2, s$2, r$2, a$2, c$2, h$2) => {
					if (!n$1) return 0;
					const d$2 = [[
						c$2 ? s$2 : t$2,
						c$2 ? t$2 : s$2,
						0
					], [
						c$2 ? s$2 : i$2,
						c$2 ? i$2 : s$2,
						0
					]], u$2 = h$2 < 0 ? e.al + h$2 : h$2, _$2 = [
						c$2 ? u$2 : (t$2 + i$2) / 2,
						c$2 ? (t$2 + i$2) / 2 : u$2,
						0
					];
					return 0 === s$2 && h$2 < 0 || 0 !== s$2 && h$2 > 0 ? n$1.getForTilePoints(a$2, [_$2], !0, r$2) : d$2.push(_$2), n$1.getForTilePoints(o$1, d$2, !0, l$1), Math.max(d$2[0][2], d$2[1][2], _$2[2]) / n$1.exaggeration();
				};
				for (let t$2 = 0; t$2 < 4; t$2++) {
					const i$2 = s$1.borderFeatureIndices[t$2];
					if (0 === i$2.length) continue;
					const r$2 = e.e9[t$2](o$1), l$2 = h$1(r$2);
					if (!(l$2 && l$2 instanceof e.ea)) continue;
					const d$2 = n$1 ? n$1.findDEMTileFor(r$2) : null;
					if (!(d$2 && d$2.dem || a$1)) continue;
					if (n$1 && d$2 && d$2.dem && s$1.borderDEMTileTimestamp[t$2] !== d$2.dem._timestamp && (s$1.borderDoneWithNeighborZ[t$2] = -1, s$1.borderDEMTileTimestamp[t$2] = d$2.dem._timestamp), s$1.borderDoneWithNeighborZ[t$2] === l$2.canonical.z) continue;
					0 === l$2.centroidVertexArray.length && l$2.createCentroidsBuffer();
					const u$2 = (t$2 < 2 ? 1 : 5) - t$2, _$2 = l$2.borderDoneWithNeighborZ[u$2] !== s$1.canonical.z, v$1 = l$2.borderFeatureIndices[u$2];
					let y$1 = 0;
					if (s$1.canonical.z !== l$2.canonical.z) {
						for (const e$1 of i$2) s$1.showCentroid(s$1.featuresOnBorder[e$1]);
						if (_$2) for (const e$1 of v$1) l$2.showCentroid(l$2.featuresOnBorder[e$1]);
						s$1.borderDoneWithNeighborZ[t$2] = l$2.canonical.z, l$2.borderDoneWithNeighborZ[u$2] = s$1.canonical.z;
					}
					for (const o$2 of i$2) {
						const i$3 = s$1.featuresOnBorder[o$2], n$2 = s$1.centroidData[i$3.centroidDataIndex], h$2 = i$3.borders[t$2];
						let _$3;
						for (; y$1 < v$1.length;) {
							_$3 = l$2.featuresOnBorder[v$1[y$1]];
							const e$1 = _$3.borders[u$2];
							if (e$1[1] > h$2[0] + 3 || e$1[0] > h$2[0] - 3) break;
							l$2.showCentroid(_$3), y$1++;
						}
						if (_$3 && y$1 < v$1.length) {
							const o$3 = y$1;
							let x$1 = 0;
							for (; !(_$3.borders[u$2][0] > h$2[1] - 3) && (x$1++, ++y$1 !== v$1.length);) _$3 = l$2.featuresOnBorder[v$1[y$1]];
							_$3 = l$2.featuresOnBorder[v$1[o$3]];
							let b$1 = !1;
							if (x$1 >= 1) {
								const e$1 = _$3.borders[u$2];
								Math.abs(h$2[0] - e$1[0]) < 3 && Math.abs(h$2[1] - e$1[1]) < 3 && (x$1 = 1, b$1 = !0, y$1 = o$3 + 1);
							} else if (0 === x$1) {
								s$1.showCentroid(i$3);
								continue;
							}
							const w$1 = l$2.centroidData[_$3.centroidDataIndex];
							a$1 && b$1 && (((m$1 = n$2).flags | (g$1 = w$1).flags) & e.ec ? (m$1.flags |= e.ec, g$1.flags |= e.ec) : (m$1.flags &= ~e.ec, g$1.flags &= ~e.ec));
							const T$1 = i$3.intersectsCount() > 1 || _$3.intersectsCount() > 1;
							if (x$1 > 1) y$1 = o$3, n$2.centroidXY = w$1.centroidXY = new e.P(0, 0);
							else if (d$2 && d$2.dem && !T$1) {
								const i$4 = p$1[t$2](n$2, w$1), o$4 = t$2 % 2 ? e.al - 1 : 0;
								n$2.centroidXY = w$1.centroidXY = c$1(f$1(i$4[0], Math.min(e.al - 1, i$4[1]), o$4, d$2, r$2, t$2 < 2, i$4[2]));
							} else T$1 ? n$2.centroidXY = w$1.centroidXY = new e.P(0, 0) : (n$2.centroidXY = s$1.encodeBorderCentroid(i$3), w$1.centroidXY = l$2.encodeBorderCentroid(_$3));
							s$1.writeCentroidToBuffer(n$2), l$2.writeCentroidToBuffer(w$1);
						} else s$1.showCentroid(i$3);
					}
					s$1.borderDoneWithNeighborZ[t$2] = l$2.canonical.z, l$2.borderDoneWithNeighborZ[u$2] = s$1.canonical.z;
				}
				var m$1, g$1;
				(s$1.needsCentroidUpdate || !s$1.centroidVertexBuffer && 0 !== s$1.centroidVertexArray.length) && s$1.uploadCentroid(t$1);
			}
			const pn = [
				1,
				0,
				0
			], fn = [
				0,
				1,
				0
			], mn = [
				0,
				0,
				1
			];
			function gn(t$1, i$1, o$1) {
				const s$1 = o$1.transform, r$1 = o$1.shadowRenderer;
				if (!r$1) return !0;
				const n$1 = t$1.toUnwrapped(), a$1 = s$1.tileSize * r$1._cascades[o$1.currentShadowCascade].scale;
				let l$1 = i$1;
				if (s$1.elevation) {
					const e$1 = s$1.elevation.getMinMaxForTile(t$1);
					e$1 && (l$1 += e$1.max);
				}
				const c$1 = [...r$1.shadowDirection];
				c$1[2] = -c$1[2];
				const h$1 = r$1.computeSimplifiedTileShadowVolume(n$1, l$1, a$1, c$1);
				if (!h$1) return !1;
				const d$1 = [
					pn,
					fn,
					mn,
					c$1,
					[
						c$1[0],
						0,
						c$1[2]
					],
					[
						0,
						c$1[1],
						c$1[2]
					]
				], u$1 = "globe" === s$1.projection.name, _$1 = s$1.scaleZoom(a$1), p$1 = e.cB.fromInvProjectionMatrix(s$1.invProjMatrix, s$1.worldSize, _$1, !u$1), f$1 = r$1.getCurrentCascadeFrustum();
				return 0 === p$1.intersectsPrecise(h$1.vertices, h$1.planes, d$1) || 0 === f$1.intersectsPrecise(h$1.vertices, h$1.planes, d$1);
			}
			function vn(t$1) {
				const { painter: i$1, source: o$1, layer: s$1, coords: r$1 } = t$1;
				let n$1 = t$1.defines;
				const a$1 = i$1.context, l$1 = "shadow" === i$1.renderPass, c$1 = "light-beam" === i$1.renderPass, h$1 = i$1.shadowRenderer, d$1 = e.ef(i$1.transform.center.lat, i$1.transform.zoom), u$1 = ho(i$1, s$1.paint.get("building-cutoff-fade-range"));
				u$1.shouldRenderCutoff && (n$1 = n$1.concat("RENDER_CUTOFF")), t$1.floodLightIntensity > 0 && (n$1 = n$1.concat("FLOOD_LIGHT"));
				for (const _$1 of r$1) {
					const r$2 = o$1.getTile(_$1), p$1 = r$2.getBucket(s$1);
					if (!p$1) continue;
					h$1 && 0 === h$1.getMaxCascadeForTile(_$1.toUnwrapped()) && (n$1 = n$1.concat("SHADOWS_SINGLE_CASCADE"));
					const f$1 = p$1.programConfigurations.get(s$1.id);
					let m$1, g$1, v$1, y$1 = i$1.translatePosMatrix(_$1.expandedProjMatrix, r$2, [0, 0], "map");
					if (y$1 = e.cS(e.bC(), y$1, [
						1,
						1,
						t$1.verticalScale
					]), l$1 && h$1) {
						if (gn(r$2.tileID, p$1.maxHeight * d$1, i$1)) continue;
						let o$2 = h$1.calculateShadowPassMatrixFromTile(r$2.tileID.toUnwrapped());
						o$2 = e.cS(e.bC(), o$2, [
							1,
							1,
							t$1.verticalScale
						]), v$1 = Ir(o$2), m$1 = g$1 = i$1.getOrCreateProgram("buildingDepth", {
							config: f$1,
							defines: n$1,
							overrideFog: !1
						});
					} else if (c$1) m$1 = g$1 = i$1.getOrCreateProgram("buildingBloom", {
						config: f$1,
						defines: n$1,
						overrideFog: !1
					}), v$1 = Sr(y$1);
					else {
						const o$2 = i$1.transform.calculatePosMatrix(_$1.toUnwrapped(), i$1.transform.worldSize);
						e.cS(o$2, o$2, [
							1,
							1,
							t$1.verticalScale
						]);
						const s$2 = e.bC();
						e.cS(s$2, o$2, [
							1,
							-1,
							1 / d$1
						]), e.bl(s$2, s$2), e.eg(s$2, s$2);
						const r$3 = i$1.transform.getFreeCameraOptions().position, a$2 = 1 << _$1.canonical.z;
						if (v$1 = Er(y$1, s$2, t$1.opacity, t$1.facadeAOIntensity, [
							((r$3.x - _$1.wrap) * a$2 - _$1.canonical.x) * e.al,
							(r$3.y * a$2 - _$1.canonical.y) * e.al,
							r$3.z * a$2 * e.al
						], p$1.tileToMeter, t$1.facadeEmissiveChance, t$1.floodLightColor, t$1.floodLightIntensity), g$1 = i$1.getOrCreateProgram("building", {
							config: f$1,
							defines: n$1,
							overrideFog: !1
						}), !0 === t$1.depthOnly) m$1 = g$1;
						else {
							const e$1 = n$1.concat(["BUILDING_FAUX_FACADE", "HAS_ATTRIBUTE_a_faux_facade_color_emissive"]);
							m$1 = i$1.getOrCreateProgram("building", {
								config: f$1,
								defines: e$1,
								overrideFog: !1
							});
						}
						h$1 && (h$1.setupShadowsFromMatrix(o$2, g$1, !0), m$1 !== g$1 && h$1.setupShadowsFromMatrix(o$2, m$1, !0));
					}
					const x$1 = (e$1, o$2) => {
						if (c$1) {
							const r$3 = e$1.entranceBloom;
							o$2.draw(i$1, a$1.gl.TRIANGLES, t$1.depthMode, Ki.disabled, t$1.blendMode, eo.disabled, v$1, s$1.id, r$3.layoutVertexBuffer, r$3.indexBuffer, r$3.segmentsBucket, s$1.paint, i$1.transform.zoom, f$1, [r$3.layoutAttenuationBuffer, r$3.layoutColorBuffer]);
						} else {
							const r$3 = e$1.segmentsBucket;
							let n$2 = [
								e$1.layoutNormalBuffer,
								e$1.layoutCentroidBuffer,
								e$1.layoutColorBuffer,
								e$1.layoutFloodLightDataBuffer
							];
							e$1.layoutFacadePaintBuffer && (n$2 = n$2.concat([
								e$1.layoutFacadeDataBuffer,
								e$1.layoutFacadeVerticalRangeBuffer,
								e$1.layoutFacadePaintBuffer
							])), o$2.draw(i$1, a$1.gl.TRIANGLES, t$1.depthMode, Ki.disabled, t$1.blendMode, l$1 ? eo.disabled : eo.backCW, v$1, s$1.id, e$1.layoutVertexBuffer, e$1.indexBuffer, r$3, s$1.paint, i$1.transform.zoom, f$1, n$2);
						}
					};
					i$1.uploadCommonUniforms(a$1, g$1, _$1.toUnwrapped(), null, u$1), p$1.buildingWithoutFacade && x$1(p$1.buildingWithoutFacade, g$1), p$1.buildingWithFacade && (m$1 !== g$1 && i$1.uploadCommonUniforms(a$1, m$1, _$1.toUnwrapped(), null, u$1), x$1(p$1.buildingWithFacade, m$1));
				}
			}
			function yn(t$1, i$1, o$1, s$1, r$1, n$1, a$1, l$1, c$1, h$1, d$1, u$1, _$1) {
				const p$1 = t$1.context.gl, f$1 = t$1.depthModeForSublayer(1, Xi.ReadOnly, p$1.LEQUAL, !0), m$1 = .1 * (1 - (g$1 = d$1)) + 3 * g$1;
				var g$1;
				const v$1 = t$1._showOverdrawInspector, y$1 = u$1, x$1 = new dn();
				v$1 || un(x$1, t$1, i$1, o$1, s$1, f$1, new Ki({
					func: p$1.ALWAYS,
					mask: 255
				}, 255, 255, p$1.KEEP, p$1.KEEP, p$1.REPLACE), new $i([
					p$1.ONE,
					p$1.ONE,
					p$1.ONE,
					p$1.ONE
				], e.ao.transparent, [
					!1,
					!1,
					!1,
					!0
				], p$1.MIN), eo.disabled, r$1, "sdf", n$1, a$1, l$1, c$1, h$1, m$1, y$1, !1);
				un(x$1, t$1, i$1, o$1, s$1, f$1, v$1 ? Ki.disabled : new Ki({
					func: p$1.EQUAL,
					mask: 255
				}, 255, 255, p$1.KEEP, p$1.DECR, p$1.DECR), v$1 ? t$1.colorModeForRenderPass() : new $i([
					p$1.ONE_MINUS_DST_ALPHA,
					p$1.DST_ALPHA,
					p$1.ONE,
					p$1.ONE
				], e.ao.transparent, [
					!0,
					!0,
					!0,
					!0
				]), eo.disabled, r$1, "color", n$1, a$1, l$1, c$1, h$1, m$1, y$1, !1);
			}
			function xn(t$1) {
				return [
					t$1[0] * e.eh,
					t$1[1] * e.eh,
					t$1[2] * e.eh,
					0
				];
			}
			function bn(t$1, i$1, o$1, s$1, r$1, n$1, a$1, l$1, c$1) {
				const h$1 = s$1.getSource(), d$1 = o$1.globeSharedBuffers;
				if (!d$1) return;
				let u$1, _$1, p$1;
				if (i$1 && (u$1 = s$1.getTile(i$1)), h$1 instanceof e.aU ? (_$1 = h$1.texture, p$1 = e.dK(0, 0, o$1.transform)) : u$1 && i$1 && (_$1 = u$1.texture, p$1 = e.dK(i$1.canonical.z, i$1.canonical.x, o$1.transform)), !_$1 || !p$1) return;
				t$1 || (p$1 = e.cS(e.bC(), p$1, [
					1,
					-1,
					1
				]));
				const f$1 = o$1.context, m$1 = f$1.gl, g$1 = "nearest" === r$1.paint.get("raster-resampling") ? m$1.NEAREST : m$1.LINEAR, v$1 = o$1.colorModeForDrapableLayerRenderPass(n$1), y$1 = a$1.defines;
				y$1.push("GLOBE_POLES");
				const x$1 = new Xi(m$1.LEQUAL, Xi.ReadWrite, o$1.depthRangeFor3D), b$1 = Float32Array.from(o$1.transform.expandedFarZProjMatrix), w$1 = Float32Array.from(e.bk(e.dJ(new e.cD(0, 0, 0))));
				o$1.terrain && o$1.terrain.prepareDrawTile(), f$1.activeTexture.set(m$1.TEXTURE0), _$1.bind(g$1, m$1.CLAMP_TO_EDGE), f$1.activeTexture.set(m$1.TEXTURE1), _$1.bind(g$1, m$1.CLAMP_TO_EDGE), "useMipmap" in _$1 && f$1.extTextureFilterAnisotropic && o$1.transform.pitch > 20 && m$1.texParameterf(m$1.TEXTURE_2D, f$1.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, f$1.extTextureFilterAnisotropicMax);
				const [T$1, E$1, S$1, I$1] = i$1 ? d$1.getPoleBuffers(i$1.canonical.z, !1) : d$1.getPoleBuffers(0, !0), C$1 = r$1.paint.get("raster-elevation");
				let R$1;
				t$1 ? (R$1 = T$1, o$1.renderDefaultNorthPole = 0 !== C$1) : (R$1 = E$1, o$1.renderDefaultSouthPole = 0 !== C$1);
				const A$1 = xn(a$1.mix), L$1 = ((e$1, t$2, i$2, o$2, s$2, r$2, n$2, a$2, l$2, c$2, h$2, d$2, u$2) => Or(e$1, t$2, i$2, new Float32Array(16), new Float32Array(9), [0, 0], o$2, [0, 0], [
					0,
					0,
					0,
					0
				], 1, {
					opacity: 1,
					mix: 0
				}, r$2, [0, 0], a$2, 2, c$2, h$2, d$2, 1, 0, u$2))(b$1, w$1, p$1, e.aj(o$1.transform.zoom), 0, r$1, 0, C$1, 0, A$1, a$1.offset, a$1.range, n$1), D$1 = o$1.getOrCreateProgram("raster", { defines: y$1 });
				o$1.uploadCommonUniforms(f$1, D$1, null), D$1.draw(o$1, m$1.TRIANGLES, x$1, c$1, v$1, l$1, L$1, r$1.id, R$1, S$1, I$1);
			}
			function wn(e$1) {
				const t$1 = e$1._nearZ, i$1 = e$1.projection.farthestPixelDistance(e$1), o$1 = i$1 - t$1, s$1 = .2 * e$1.height, r$1 = t$1 + s$1;
				return [
					t$1,
					i$1,
					(r$1 - s$1 - t$1) / o$1,
					(r$1 - t$1) / o$1
				];
			}
			function Tn(e$1, t$1, i$1, o$1) {
				if (e$1) return t$1 instanceof pt && e$1 instanceof Ot ? t$1.getTextureDescriptor(e$1, i$1, !0) : {
					texture: e$1.texture,
					mix: xn(o$1.mix),
					offset: o$1.offset,
					buffer: 0,
					tileSize: 1
				};
			}
			var En = e.ei([{
				name: "a_index",
				type: "Int16",
				components: 1
			}]);
			class Sn {
				constructor(t$1, i$1, o$1, s$1) {
					const r$1 = {
						width: o$1[0],
						height: o$1[1],
						data: null
					}, n$1 = t$1.gl;
					this.targetColorTexture = new e.T(t$1, r$1, n$1.RGBA8, { useMipmap: !1 }), this.backgroundColorTexture = new e.T(t$1, r$1, n$1.RGBA8, { useMipmap: !1 }), this.context = t$1, this.updateParticleTexture(i$1, s$1), this.lastInvalidatedAt = 0;
				}
				updateParticleTexture(t$1, i$1) {
					if (this.particleTextureDimension === i$1.width) return;
					(this.particleTexture0 || this.particleTexture1 || this.particleIndexBuffer || this.particleSegment) && (this.particleTexture0.destroy(), this.particleTexture1.destroy(), this.particleIndexBuffer.destroy(), this.particleSegment.destroy());
					const o$1 = this.context.gl, s$1 = i$1.width * i$1.height;
					this.particleTexture0 = new e.T(this.context, i$1, o$1.RGBA8, {
						premultiply: !1,
						useMipmap: !1
					}), this.particleTexture1 = new e.T(this.context, i$1, o$1.RGBA8, {
						premultiply: !1,
						useMipmap: !1
					});
					const r$1 = new e.ej();
					r$1.reserve(s$1);
					for (let e$1 = 0; e$1 < s$1; e$1++) r$1.emplaceBack(e$1);
					this.particleIndexBuffer = this.context.createVertexBuffer(r$1, En.members, !0), this.particleSegment = e.bg.simpleSegment(0, 0, this.particleIndexBuffer.length, 0), this.particleTextureDimension = i$1.width;
				}
				update(t$1) {
					return !(this.lastInvalidatedAt < t$1 && (this.lastInvalidatedAt = e.o.now(), 1));
				}
				destroy() {
					this.targetColorTexture.destroy(), this.backgroundColorTexture.destroy(), this.particleIndexBuffer.destroy(), this.particleTexture0.destroy(), this.particleTexture1.destroy(), this.particleSegment.destroy();
				}
			}
			function In(t$1, i$1, o$1) {
				if (!t$1) return null;
				const s$1 = i$1.getTextureDescriptor(t$1, o$1, !0);
				if (!s$1) return null;
				let { texture: r$1, mix: n$1, offset: a$1, tileSize: l$1, buffer: c$1, format: h$1 } = s$1;
				if (!r$1 || !h$1) return null;
				let d$1 = !1;
				return "uint32" === h$1 && (d$1 = !0, n$1[3] = 0, n$1 = Dr(e.ek, n$1, [0, o$1.paint.get("raster-particle-max-speed")]), a$1 = Pr(e.ek, a$1, [0, o$1.paint.get("raster-particle-max-speed")])), {
					texture: r$1,
					textureOffset: [c$1 / (l$1 + 2 * c$1), l$1 / (l$1 + 2 * c$1)],
					tileSize: l$1,
					scalarData: d$1,
					scale: n$1,
					offset: a$1,
					defines: ["RASTER_ARRAY", {
						uint8: "DATA_FORMAT_UINT8",
						uint16: "DATA_FORMAT_UINT16",
						uint32: "DATA_FORMAT_UINT32"
					}[h$1]]
				};
			}
			function Cn(e$1) {
				const t$1 = e$1._nearZ, i$1 = e$1.projection.farthestPixelDistance(e$1), o$1 = i$1 - t$1, s$1 = .2 * e$1.height, r$1 = t$1 + s$1;
				return [
					t$1,
					i$1,
					(r$1 - s$1 - t$1) / o$1,
					(r$1 - t$1) / o$1
				];
			}
			const Rn = new e.ao(1, 0, 0, 1), An = new e.ao(0, 1, 0, 1), Ln = new e.ao(0, 0, 1, 1), Dn = new e.ao(1, 0, 1, 1), Pn = new e.ao(0, 1, 1, 1);
			function On(t$1, i$1, o$1, s$1, r$1, n$1) {
				for (let a$1 = 0; a$1 < o$1.length; a$1++) if (r$1) {
					const r$2 = 1, l$1 = .8, c$1 = new e.ao(s$1.r * l$1, s$1.g * l$1, s$1.b * l$1, 1);
					zn(t$1, i$1, o$1[a$1], s$1, -r$2, -r$2, n$1), zn(t$1, i$1, o$1[a$1], s$1, -r$2, r$2, n$1), zn(t$1, i$1, o$1[a$1], s$1, r$2, r$2, n$1), zn(t$1, i$1, o$1[a$1], s$1, r$2, -r$2, n$1), zn(t$1, i$1, o$1[a$1], c$1, 0, 0, n$1);
				} else zn(t$1, i$1, o$1[a$1], s$1, 0, 0, n$1);
			}
			function zn(t$1, i$1, o$1, s$1, r$1, n$1, a$1) {
				const l$1 = t$1.context, c$1 = t$1.transform, h$1 = l$1.gl, d$1 = "globe" === c$1.projection.name, u$1 = d$1 ? ["PROJECTION_GLOBE_VIEW"] : [];
				let _$1 = e.bz(o$1.projMatrix);
				if (d$1 && e.aj(c$1.zoom) > 0) {
					const t$2 = e.bj(o$1.canonical, c$1), i$2 = e.el(t$2);
					_$1 = e.aB(new Float32Array(16), c$1.globeMatrix, i$2), e.aB(_$1, c$1.projMatrix, _$1);
				}
				const p$1 = e.bC();
				p$1[12] += 2 * r$1 / (e.o.devicePixelRatio * c$1.width), p$1[13] += 2 * n$1 / (e.o.devicePixelRatio * c$1.height), e.aB(_$1, p$1, _$1);
				const f$1 = t$1.getOrCreateProgram("debug", { defines: u$1 }), m$1 = i$1.getTileByID(o$1.key);
				t$1.terrain && t$1.terrain.setupElevationDraw(m$1, f$1);
				const g$1 = Xi.disabled, v$1 = Ki.disabled, y$1 = t$1.colorModeForRenderPass(), x$1 = "$debug";
				l$1.activeTexture.set(h$1.TEXTURE0), t$1.emptyTexture.bind(h$1.LINEAR, h$1.CLAMP_TO_EDGE), d$1 ? m$1._makeGlobeTileDebugBuffers(t$1.context, c$1) : m$1._makeDebugTileBoundsBuffers(t$1.context, c$1.projection);
				const b$1 = m$1._tileDebugBuffer || t$1.debugBuffer, w$1 = m$1._tileDebugIndexBuffer || t$1.debugIndexBuffer, T$1 = m$1._tileDebugSegments || t$1.debugSegments;
				if (f$1.draw(t$1, h$1.LINE_STRIP, g$1, v$1, y$1, eo.disabled, Rr(_$1, s$1.toPremultipliedRenderColor(null)), x$1, b$1, w$1, T$1, null, null, null, [m$1._globeTileDebugBorderBuffer]), a$1) {
					const e$1 = m$1.latestRawTileData, i$2 = Math.floor((e$1 && e$1.byteLength || 0) / 1024);
					let s$2 = o$1.canonical.toString();
					o$1.overscaledZ !== o$1.canonical.z && (s$2 += ` => ${o$1.overscaledZ}`), s$2 += ` ${m$1.state}`, s$2 += ` ${i$2}kb`, function(e$2, t$2) {
						e$2.initDebugOverlayCanvas();
						const i$3 = e$2.debugOverlayCanvas, o$2 = e$2.context.gl, s$3 = e$2.debugOverlayCanvas.getContext("2d");
						s$3.clearRect(0, 0, i$3.width, i$3.height), s$3.shadowColor = "white", s$3.shadowBlur = 2, s$3.lineWidth = 1.5, s$3.strokeStyle = "white", s$3.textBaseline = "top", s$3.font = "bold 36px Open Sans, sans-serif", s$3.fillText(t$2, 5, 5), s$3.strokeText(t$2, 5, 5), e$2.debugOverlayTexture.update(i$3), e$2.debugOverlayTexture.bind(o$2.LINEAR, o$2.CLAMP_TO_EDGE);
					}(t$1, s$2);
				}
				const E$1 = i$1.getTile(o$1).tileSize, S$1 = 512 / Math.min(E$1, 512) * (o$1.overscaledZ / c$1.zoom) * .5, I$1 = m$1._tileDebugTextBuffer || t$1.debugBuffer, C$1 = m$1._tileDebugTextIndexBuffer || t$1.quadTriangleIndexBuffer, R$1 = m$1._tileDebugTextSegments || t$1.debugSegments;
				f$1.draw(t$1, h$1.TRIANGLES, g$1, v$1, $i.alphaBlended, eo.disabled, Rr(_$1, e.ao.transparent.toPremultipliedRenderColor(null), S$1), x$1, I$1, C$1, R$1, null, null, null, [m$1._globeTileDebugTextBuffer]);
			}
			function Mn(e$1, t$1, i$1, o$1) {
				Bn(e$1, 0, t$1 + i$1 / 2, e$1.transform.width, i$1, o$1);
			}
			function Fn(e$1, t$1, i$1, o$1) {
				Bn(e$1, t$1 - i$1 / 2, 0, i$1, e$1.transform.height, o$1);
			}
			function Bn(t$1, i$1, o$1, s$1, r$1, n$1) {
				const a$1 = t$1.context, l$1 = a$1.gl;
				l$1.enable(l$1.SCISSOR_TEST), l$1.scissor(i$1 * e.o.devicePixelRatio, o$1 * e.o.devicePixelRatio, s$1 * e.o.devicePixelRatio, r$1 * e.o.devicePixelRatio), a$1.clear({ color: n$1 }), l$1.disable(l$1.SCISSOR_TEST);
			}
			const { members: Nn } = e.ei([{
				name: "a_pos_3f",
				components: 3,
				type: "Float32"
			}]);
			function Un(e$1, t$1, i$1, o$1) {
				e$1.emplaceBack(t$1, i$1, o$1);
			}
			class jn {
				constructor(t$1) {
					this.vertexArray = new e.em(), this.indices = new e.b0(), Un(this.vertexArray, -1, -1, 1), Un(this.vertexArray, 1, -1, 1), Un(this.vertexArray, -1, 1, 1), Un(this.vertexArray, 1, 1, 1), Un(this.vertexArray, -1, -1, -1), Un(this.vertexArray, 1, -1, -1), Un(this.vertexArray, -1, 1, -1), Un(this.vertexArray, 1, 1, -1), this.indices.emplaceBack(5, 1, 3), this.indices.emplaceBack(3, 7, 5), this.indices.emplaceBack(6, 2, 0), this.indices.emplaceBack(0, 4, 6), this.indices.emplaceBack(2, 6, 7), this.indices.emplaceBack(7, 3, 2), this.indices.emplaceBack(5, 4, 0), this.indices.emplaceBack(0, 1, 5), this.indices.emplaceBack(0, 2, 3), this.indices.emplaceBack(3, 1, 0), this.indices.emplaceBack(7, 6, 4), this.indices.emplaceBack(4, 5, 7), this.vertexBuffer = t$1.createVertexBuffer(this.vertexArray, Nn), this.indexBuffer = t$1.createIndexBuffer(this.indices), this.segment = e.bg.simpleSegment(0, 0, 36, 12);
				}
			}
			function Gn(t$1, i$1, o$1, s$1, r$1, n$1) {
				const a$1 = t$1.context.gl, l$1 = i$1.paint.get("sky-atmosphere-color"), c$1 = i$1.paint.get("sky-atmosphere-halo-color"), h$1 = i$1.paint.get("sky-atmosphere-sun-intensity"), d$1 = ((e$1, t$2, i$2, o$2, s$2) => ({
					u_matrix_3f: e$1,
					u_sun_direction: t$2,
					u_sun_intensity: i$2,
					u_color_tint_r: [
						o$2.r,
						o$2.g,
						o$2.b,
						o$2.a
					],
					u_color_tint_m: [
						s$2.r,
						s$2.g,
						s$2.b,
						s$2.a
					],
					u_luminance: 5e-5
				}))(e.eo(e.dO(), s$1), r$1, h$1, l$1.toPremultipliedRenderColor(null), c$1.toPremultipliedRenderColor(null));
				a$1.framebufferTexture2D(a$1.FRAMEBUFFER, a$1.COLOR_ATTACHMENT0, a$1.TEXTURE_CUBE_MAP_POSITIVE_X + n$1, i$1.skyboxTexture, 0), o$1.draw(t$1, a$1.TRIANGLES, Xi.disabled, Ki.disabled, $i.unblended, eo.frontCW, d$1, "skyboxCapture", i$1.skyboxGeometry.vertexBuffer, i$1.skyboxGeometry.indexBuffer, i$1.skyboxGeometry.segment);
			}
			const Vn = e.ei([{
				type: "Float32",
				name: "a_pos",
				components: 3
			}, {
				type: "Float32",
				name: "a_uv",
				components: 2
			}]);
			class Hn {
				constructor(t$1) {
					const i$1 = new e.ep();
					i$1.emplaceBack(-1, 1, 1, 0, 0), i$1.emplaceBack(1, 1, 1, 1, 0), i$1.emplaceBack(1, -1, 1, 1, 1), i$1.emplaceBack(-1, -1, 1, 0, 1);
					const o$1 = new e.b0();
					o$1.emplaceBack(0, 1, 2), o$1.emplaceBack(2, 3, 0), this.vertexBuffer = t$1.createVertexBuffer(i$1, Vn.members), this.indexBuffer = t$1.createIndexBuffer(o$1), this.segments = e.bg.simpleSegment(0, 0, 4, 2);
				}
				destroy() {
					this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy();
				}
			}
			const qn = e.ei([
				{
					type: "Float32",
					name: "a_pos_3f",
					components: 3
				},
				{
					type: "Float32",
					name: "a_uv",
					components: 2
				},
				{
					type: "Float32",
					name: "a_size_scale",
					components: 1
				},
				{
					type: "Float32",
					name: "a_fade_opacity",
					components: 1
				}
			]);
			class Zn {
				constructor() {
					this.starsCount = 16e3, this.sizeMultiplier = .15, this.sizeRange = 100, this.intensityRange = 200;
				}
			}
			class Wn {
				constructor(t$1) {
					this.colorModeAlphaBlendedWriteRGB = new $i([
						1,
						Wi,
						1,
						Wi
					], e.ao.transparent, [
						!0,
						!0,
						!0,
						!1
					]), this.colorModeWriteAlpha = new $i([
						1,
						0,
						1,
						0
					], e.ao.transparent, [
						!1,
						!1,
						!1,
						!0
					]), this.params = new Zn(), this.updateNeeded = !0;
				}
				update(t$1) {
					const i$1 = t$1.context;
					if (!this.atmosphereBuffer || this.updateNeeded) {
						this.updateNeeded = !1, this.atmosphereBuffer = new Hn(i$1);
						const t$2 = this.params.sizeRange, o$1 = this.params.intensityRange, s$1 = function(t$3) {
							const i$2 = e.eq(30), o$2 = [];
							for (let s$2 = 0; s$2 < t$3; ++s$2) {
								const t$4 = 2 * Math.PI * i$2(), s$3 = Math.acos(1 - 2 * i$2()) - .5 * Math.PI;
								o$2.push(e.d5(Math.cos(s$3) * Math.cos(t$4), Math.cos(s$3) * Math.sin(t$4), Math.sin(s$3)));
							}
							return o$2;
						}(this.params.starsCount), r$1 = e.eq(300), n$1 = new e.er(), a$1 = new e.b0();
						let l$1 = 0;
						for (let i$2 = 0; i$2 < s$1.length; ++i$2) {
							const c$1 = e.c5([], s$1[i$2], 200), h$1 = Math.max(0, 1 + .01 * t$2 * (1 * r$1() - .5)), d$1 = Math.max(0, 1 + .01 * o$1 * (1 * r$1() - .5));
							n$1.emplaceBack(c$1[0], c$1[1], c$1[2], -1, -1, h$1, d$1), n$1.emplaceBack(c$1[0], c$1[1], c$1[2], 1, -1, h$1, d$1), n$1.emplaceBack(c$1[0], c$1[1], c$1[2], 1, 1, h$1, d$1), n$1.emplaceBack(c$1[0], c$1[1], c$1[2], -1, 1, h$1, d$1), a$1.emplaceBack(l$1 + 0, l$1 + 1, l$1 + 2), a$1.emplaceBack(l$1 + 0, l$1 + 2, l$1 + 3), l$1 += 4;
						}
						this.starsVx = i$1.createVertexBuffer(n$1, qn.members), this.starsIdx = i$1.createIndexBuffer(a$1), this.starsSegments = e.bg.simpleSegment(0, 0, n$1.length, a$1.length);
					}
				}
				destroy() {
					this.atmosphereBuffer && this.atmosphereBuffer.destroy(), this.starsVx && this.starsVx.destroy(), this.starsIdx && this.starsIdx.destroy();
				}
				drawAtmosphereGlow(t$1, i$1) {
					const o$1 = t$1.context, s$1 = o$1.gl, r$1 = t$1.transform, n$1 = new Xi(s$1.LEQUAL, Xi.ReadOnly, [0, 1]), a$1 = e.aj(r$1.zoom), l$1 = t$1.style.getLut(i$1.scope), c$1 = "none" === i$1.properties.get("color-use-theme"), h$1 = i$1.properties.get("color").toNonPremultipliedRenderColor(c$1 ? null : l$1), d$1 = "none" === i$1.properties.get("high-color-use-theme"), u$1 = i$1.properties.get("high-color").toNonPremultipliedRenderColor(d$1 ? null : l$1), _$1 = "none" === i$1.properties.get("space-color-use-theme"), p$1 = i$1.properties.get("space-color").toNonPremultipliedRenderColor(_$1 ? null : l$1), f$1 = 5e-4, m$1 = e.es(i$1.properties.get("horizon-blend"), 0, 1, f$1, .25), g$1 = e.dE(t$1, o$1, r$1) && m$1 === f$1 ? r$1.worldSize / (2 * Math.PI * 1.025) - 1 : r$1.globeRadius, v$1 = t$1.frameCounter / 1e3 % 1, y$1 = e.ag(r$1.globeCenterInViewSpace), x$1 = Math.sqrt(Math.pow(y$1, 2) - Math.pow(g$1, 2)), b$1 = Math.acos(x$1 / y$1), w$1 = (e$1) => {
						const i$2 = "globe" === r$1.projection.name ? ["PROJECTION_GLOBE_VIEW", "FOG"] : ["FOG"];
						e$1 && i$2.push("ALPHA_PASS");
						const l$2 = t$1.getOrCreateProgram("globeAtmosphere", { defines: i$2 }), c$2 = ((e$2, t$2, i$3, o$2, s$2, r$2, n$2, a$2, l$3, c$3, h$2, d$3) => ({
							u_frustum_tl: e$2,
							u_frustum_tr: t$2,
							u_frustum_br: i$3,
							u_frustum_bl: o$2,
							u_horizon: s$2,
							u_transition: r$2,
							u_fadeout_range: n$2,
							u_atmosphere_fog_color: a$2.toArray01(),
							u_high_color: l$3.toArray01(),
							u_space_color: c$3.toArray01(),
							u_temporal_offset: h$2,
							u_horizon_angle: d$3
						}))(r$1.frustumCorners.TL, r$1.frustumCorners.TR, r$1.frustumCorners.BR, r$1.frustumCorners.BL, r$1.frustumCorners.horizon, a$1, m$1, h$1, u$1, p$1, v$1, b$1);
						t$1.uploadCommonUniforms(o$1, l$2);
						const d$2 = this.atmosphereBuffer;
						d$2 && l$2.draw(t$1, s$1.TRIANGLES, n$1, Ki.disabled, e$1 ? this.colorModeWriteAlpha : this.colorModeAlphaBlendedWriteRGB, eo.backCW, c$2, e$1 ? "atmosphere_glow_alpha" : "atmosphere_glow", d$2.vertexBuffer, d$2.indexBuffer, d$2.segments);
					};
					w$1(!1), w$1(!0);
				}
				drawStars(t$1, i$1) {
					const o$1 = e.aA(i$1.properties.get("star-intensity"), 0, 1);
					if (0 === o$1) return;
					const s$1 = t$1.context, r$1 = s$1.gl, n$1 = t$1.transform, a$1 = t$1.getOrCreateProgram("stars"), l$1 = e.c7([]);
					e.c9(l$1, l$1, -n$1._pitch), e.c8(l$1, l$1, -n$1.angle), e.c9(l$1, l$1, e.an(n$1._center.lat)), e.et(l$1, l$1, -e.an(n$1._center.lng));
					const c$1 = e.cc(new Float32Array(16), l$1), h$1 = e.aB([], n$1.starsProjMatrix, c$1), d$1 = e.eo([], c$1), u$1 = e.eu([], d$1), _$1 = [
						0,
						1,
						0
					];
					e.dQ(_$1, _$1, u$1), e.c5(_$1, _$1, this.params.sizeMultiplier);
					const p$1 = [
						1,
						0,
						0
					];
					e.dQ(p$1, p$1, u$1), e.c5(p$1, p$1, this.params.sizeMultiplier);
					const f$1 = (m$1 = _$1, g$1 = p$1, v$1 = o$1, {
						u_matrix: Float32Array.from(h$1),
						u_up: m$1,
						u_right: g$1,
						u_intensity_multiplier: v$1
					});
					var m$1, g$1, v$1;
					t$1.uploadCommonUniforms(s$1, a$1), this.starsVx && this.starsIdx && a$1.draw(t$1, r$1.TRIANGLES, Xi.disabled, Ki.disabled, this.colorModeAlphaBlendedWriteRGB, eo.disabled, f$1, "atmosphere_stars", this.starsVx, this.starsIdx, this.starsSegments);
				}
			}
			class $n {
				constructor() {
					this.visibleTiles = [];
				}
				updateBorders(t$1, i$1) {
					const o$1 = [], s$1 = [], r$1 = t$1._getRenderableCoordinates(!1, !0);
					for (const e$1 of r$1) {
						const r$2 = t$1.getTile(e$1);
						if (!r$2.hasData()) continue;
						const n$2 = r$2.getBucket(i$1);
						n$2 && (n$2.isEmpty() || (o$1.push(e$1.key), s$1.push({
							bucket: n$2,
							tileID: e$1.canonical
						})));
					}
					let n$1 = o$1.length !== this.visibleTiles.length;
					if (!n$1) {
						o$1.sort();
						for (let e$1 = 0; e$1 < o$1.length; e$1++) if (o$1[e$1] !== this.visibleTiles[e$1]) {
							n$1 = !0;
							break;
						}
					}
					if (!n$1) return;
					const a$1 = /* @__PURE__ */ new Set();
					this.visibleTiles = o$1, s$1.sort(((e$1, t$2) => e$1.tileID.z - t$2.tileID.z || e$1.tileID.x - t$2.tileID.x || e$1.tileID.y - t$2.tileID.y));
					for (const t$2 of s$1) {
						const i$2 = new Array(), o$2 = new Array(), s$2 = t$2.bucket;
						for (const e$1 of s$2.featuresOnBorder) a$1.has(e$1.featureId) ? o$2.push(e$1.footprintIndex) : (a$1.add(e$1.featureId), i$2.push(e$1.footprintIndex));
						s$2.updateFootprintHiddenFlags(i$2, e.ev, !1), s$2.updateFootprintHiddenFlags(o$2, e.ev, !0);
					}
				}
			}
			function Xn(t$1, i$1) {
				const o$1 = [...t$1], s$1 = i$1.cameraWorldSizeForFog / i$1.worldSize, r$1 = e.bA([]);
				return e.cS(r$1, r$1, [
					s$1,
					s$1,
					1
				]), e.aB(o$1, r$1, o$1), e.aB(o$1, i$1.worldToFogMatrix, o$1), o$1;
			}
			function Yn(t$1, i$1, o$1, s$1, r$1) {
				const n$1 = o$1.material, a$1 = s$1.context, { baseColorTexture: l$1, metallicRoughnessTexture: c$1 } = n$1.pbrMetallicRoughness, { normalTexture: h$1, occlusionTexture: d$1, emissionTexture: u$1 } = n$1;
				function _$1(e$1, i$2, o$2) {
					if (e$1 && (t$1.push(i$2), a$1.activeTexture.set(a$1.gl.TEXTURE0 + o$2), e$1.gfxTexture)) {
						const { minFilter: t$2, magFilter: i$3, wrapS: o$3, wrapT: s$2 } = e$1.sampler;
						e$1.gfxTexture.bindExtraParam(t$2, i$3, o$3, s$2);
					}
				}
				_$1(l$1, "HAS_TEXTURE_u_baseColorTexture", no.BaseColor), _$1(c$1, "HAS_TEXTURE_u_metallicRoughnessTexture", no.MetallicRoughness), _$1(h$1, "HAS_TEXTURE_u_normalTexture", no.Normal), _$1(d$1, "HAS_TEXTURE_u_occlusionTexture", no.Occlusion), _$1(u$1, "HAS_TEXTURE_u_emissionTexture", no.Emission), r$1 && (r$1.texture || (r$1.texture = new e.d$(s$1.context, r$1.image, [
					r$1.image.height,
					r$1.image.height,
					r$1.image.height
				], a$1.gl.RGBA8)), a$1.activeTexture.set(a$1.gl.TEXTURE0 + no.LUT), r$1.texture && r$1.texture.bind(a$1.gl.LINEAR, a$1.gl.CLAMP_TO_EDGE), t$1.push("APPLY_LUT_ON_GPU")), o$1.texcoordBuffer && (t$1.push("HAS_ATTRIBUTE_a_uv_2f"), i$1.push(o$1.texcoordBuffer)), o$1.colorBuffer && (t$1.push(12 === o$1.colorBuffer.itemSize ? "HAS_ATTRIBUTE_a_color_3f" : "HAS_ATTRIBUTE_a_color_4f"), i$1.push(o$1.colorBuffer)), o$1.normalBuffer && (t$1.push("HAS_ATTRIBUTE_a_normal_3f"), i$1.push(o$1.normalBuffer)), o$1.pbrBuffer && (t$1.push("HAS_ATTRIBUTE_a_pbr"), t$1.push("HAS_ATTRIBUTE_a_heightBasedEmissiveStrength"), i$1.push(o$1.pbrBuffer)), "OPAQUE" !== n$1.alphaMode && "MASK" !== n$1.alphaMode || t$1.push("UNPREMULT_TEXTURE_IN_SHADER"), n$1.defined || t$1.push("DIFFUSE_SHADED");
				const p$1 = s$1.shadowRenderer;
				p$1 && (t$1.push("RENDER_SHADOWS", "DEPTH_TEXTURE"), p$1.useNormalOffset && t$1.push("NORMAL_OFFSET"));
			}
			function Kn(t$1, i$1, o$1, s$1, r$1, n$1) {
				const a$1 = t$1.modelOpacity, l$1 = i$1.context, c$1 = new Xi(i$1.context.gl.LEQUAL, t$1.isLightMesh ? Xi.ReadOnly : Xi.ReadWrite, i$1.depthRangeFor3D), h$1 = i$1.transform, d$1 = t$1.mesh, u$1 = d$1.material, _$1 = u$1.pbrMetallicRoughness, p$1 = i$1.style.fog;
				let f$1;
				f$1 = "pixels" === i$1.transform.projection.zAxisUnit ? [...t$1.nodeModelMatrix] : e.aB([], s$1.zScaleMatrix, t$1.nodeModelMatrix), e.aB(f$1, s$1.negCameraPosMatrix, f$1);
				const m$1 = e.bl([], f$1);
				e.eg(m$1, m$1);
				const g$1 = "none" === o$1.paint.get("model-color-use-theme").constantOr("default"), v$1 = o$1.paint.get("model-emissive-strength").constantOr(0), y$1 = Hr(new Float32Array(t$1.worldViewProjection), new Float32Array(f$1), new Float32Array(m$1), null, i$1, a$1, _$1.baseColorFactor, u$1.emissiveFactor, _$1.metallicFactor, _$1.roughnessFactor, u$1, v$1, o$1, void 0, void 0, t$1.materialOverride, t$1.modelColor), x$1 = { defines: [] }, b$1 = [], w$1 = i$1.shadowRenderer;
				w$1 && (w$1.useNormalOffset = !1), Yn(x$1.defines, b$1, d$1, i$1, g$1 ? null : o$1.lut);
				let T$1 = null;
				if (p$1) {
					const e$1 = Xn(t$1.nodeModelMatrix, i$1.transform);
					if (T$1 = new Float32Array(e$1), "globe" !== h$1.projection.name) {
						const t$2 = d$1.aabb.min, i$2 = d$1.aabb.max, [o$2, s$2] = p$1.getOpacityForBounds(e$1, t$2[0], t$2[1], i$2[0], i$2[1]);
						x$1.overrideFog = o$2 >= He || s$2 >= He;
					}
				}
				const E$1 = ho(i$1, o$1.paint.get("model-cutoff-fade-range"));
				E$1.shouldRenderCutoff && x$1.defines.push("RENDER_CUTOFF");
				const S$1 = i$1.getOrCreateProgram("model", x$1);
				i$1.uploadCommonUniforms(l$1, S$1, null, T$1, E$1), "shadow" !== i$1.renderPass && w$1 && w$1.setupShadowsFromMatrix(t$1.nodeModelMatrix, S$1), S$1.draw(i$1, l$1.gl.TRIANGLES, c$1, r$1, n$1, d$1.material.doubleSided ? eo.disabled : eo.backCCW, y$1, o$1.id, d$1.vertexBuffer, d$1.indexBuffer, d$1.segments, o$1.paint, i$1.transform.zoom, void 0, b$1);
			}
			function Jn(e$1, t$1) {
				return e$1.style._importedAsBasemap ? "basemap" : t$1.scope;
			}
			function Qn(t$1, i$1, o$1, s$1, r$1, n$1, a$1, l$1, c$1, h$1) {
				const d$1 = t$1.transform, u$1 = !!i$1.isGeometryBloom && i$1.isGeometryBloom;
				if (u$1 && "shadow" === t$1.renderPass) return;
				const _$1 = "globe" === d$1.projection.name ? e.eD(o$1, d$1) : [...o$1];
				e.aB(_$1, _$1, i$1.globalMatrix);
				const p$1 = e.aB([], s$1, _$1);
				if (i$1.meshes) for (const t$2 of i$1.meshes) {
					const i$2 = l$1.get(t$2.material.name);
					if (i$2 && i$2.opacity <= 0) continue;
					if ("BLEND" !== t$2.material.alphaMode) {
						a$1.push({
							mesh: t$2,
							depth: 0,
							modelIndex: r$1,
							worldViewProjection: p$1,
							nodeModelMatrix: _$1,
							isLightMesh: u$1,
							materialOverride: i$2,
							modelOpacity: c$1,
							modelColor: h$1
						});
						continue;
					}
					const o$2 = e.af([], t$2.centroid, p$1);
					!d$1.isOrthographic && o$2[2] <= 0 || n$1.push({
						mesh: t$2,
						depth: o$2[2],
						modelIndex: r$1,
						worldViewProjection: p$1,
						nodeModelMatrix: _$1,
						isLightMesh: u$1,
						materialOverride: i$2,
						modelOpacity: c$1,
						modelColor: h$1
					});
				}
				if (i$1.children) for (const e$1 of i$1.children) Qn(t$1, e$1, o$1, s$1, r$1, n$1, a$1, l$1, c$1, h$1);
			}
			function ea(e$1, t$1, i$1, o$1) {
				const s$1 = i$1.shadowRenderer;
				if (!s$1) return;
				const r$1 = s$1.getShadowPassDepthMode(), n$1 = s$1.getShadowPassColorMode(), l$1 = qr(s$1.calculateShadowPassMatrixFromMatrix(t$1));
				i$1.getOrCreateProgram("modelDepth", { defines: i$1._shadowMapDebug ? [] : ["DEPTH_TEXTURE"] }).draw(i$1, i$1.context.gl.TRIANGLES, r$1, Ki.disabled, n$1, eo.disabled, l$1, o$1.id, e$1.vertexBuffer, e$1.indexBuffer, e$1.segments, o$1.paint, i$1.transform.zoom, void 0, void 0);
			}
			function ta(e$1, t$1, i$1, o$1, s$1, r$1) {
				for (const n$1 of s$1) {
					const s$2 = Object.assign({}, o$1);
					s$2.part = n$1;
					const a$1 = {
						type: "Unknown",
						id: t$1,
						properties: s$2
					}, l$1 = { orientation: e$1.paint.get("model-rotation").evaluate(a$1, i$1) };
					r$1.set(n$1, l$1);
				}
			}
			function ia(e$1, t$1, i$1, o$1, s$1, r$1) {
				for (const n$1 of s$1) {
					const s$2 = Object.assign({}, o$1);
					s$2.part = n$1;
					const a$1 = {
						type: "Unknown",
						id: t$1,
						properties: s$2
					}, l$1 = {
						color: e$1.paint.get("model-color").evaluate(a$1, i$1),
						colorMix: e$1.paint.get("model-color-mix-intensity").evaluate(a$1, i$1),
						opacity: e$1.paint.get("model-opacity").evaluate(a$1, i$1),
						emissionStrength: e$1.paint.get("model-emissive-strength").evaluate(a$1, i$1)
					};
					r$1.set(n$1, l$1);
				}
			}
			function oa(e$1, t$1, i$1, o$1, s$1) {
				let r$1 = !1;
				for (const i$2 of o$1) 1 !== i$2.modelOpacity && (Kn(i$2, e$1, t$1, s$1[i$2.modelIndex], Ki.disabled, $i.disabled), r$1 = !0);
				for (const i$2 of o$1) Kn(i$2, e$1, t$1, s$1[i$2.modelIndex], 1 !== i$2.modelOpacity ? e$1.stencilModeFor3D() : Ki.disabled, e$1.colorModeForRenderPass());
				r$1 && e$1.resetStencilClippingMasks();
				const n$1 = $i.additive;
				for (const o$2 of i$1) Kn(o$2, e$1, t$1, s$1[o$2.modelIndex], Ki.disabled, o$2.isLightMesh ? n$1 : e$1.colorModeForRenderPass());
			}
			function sa(t$1, i$1, o$1) {
				const s$1 = i$1.updateZoomBasedPaintProperties(), r$1 = function(t$2, i$2, o$2) {
					let s$2, r$2, n$1, a$1 = t$2.terrain ? t$2.terrain.exaggeration() : 0;
					if (t$2.terrain && a$1 > 0) {
						const i$3 = t$2.terrain, r$3 = i$3.findDEMTileFor(o$2);
						r$3 && r$3.dem ? s$2 = e.eF.create(i$3, o$2, r$3) : a$1 = 0;
					}
					if (0 === a$1 && (i$2.terrainElevationMin = 0, i$2.terrainElevationMax = 0), a$1 === i$2.validForExaggeration && (0 === a$1 || s$2 && s$2._demTile && s$2._demTile.tileID === i$2.validForDEMTile.id && s$2._dem._timestamp === i$2.validForDEMTile.timestamp)) return !1;
					for (const e$1 in i$2.instancesPerModel) {
						const t$3 = i$2.instancesPerModel[e$1];
						for (let e$2 = 0; e$2 < t$3.instancedDataArray.length; ++e$2) {
							const o$3 = (s$2 ? a$1 * s$2.getElevationAt(0 | t$3.instancedDataArray.float32[16 * e$2], 0 | t$3.instancedDataArray.float32[16 * e$2 + 1], !0, !0) : 0) + t$3.instancesEvaluatedElevation[e$2];
							t$3.instancedDataArray.float32[16 * e$2 + 6] = o$3, r$2 = r$2 ? Math.min(i$2.terrainElevationMin, o$3) : o$3, n$1 = n$1 ? Math.max(i$2.terrainElevationMax, o$3) : o$3;
						}
					}
					return i$2.terrainElevationMin = r$2 || 0, i$2.terrainElevationMax = n$1 || 0, i$2.validForExaggeration = a$1, i$2.validForDEMTile = s$2 && s$2._demTile ? {
						id: s$2._demTile.tileID,
						timestamp: s$2._dem._timestamp
					} : {
						id: void 0,
						timestamp: 0
					}, !0;
				}(t$1, i$1, o$1);
				(s$1 || r$1) && (i$1.uploaded = !1, i$1.upload(t$1.context));
			}
			const ra = {
				shadowUniformsInitialized: !1,
				useSingleShadowCascade: !1,
				tileMatrix: new Float64Array(16),
				shadowTileMatrix: new Float32Array(16),
				aabb: new e.d9([
					0,
					0,
					0
				], [
					e.al,
					e.al,
					0
				])
			};
			function na(t$1, i$1) {
				const o$1 = 1 << t$1.canonical.z, s$1 = i$1.getFreeCameraOptions().position, r$1 = i$1.elevation, n$1 = t$1.canonical.x / o$1, a$1 = (t$1.canonical.x + 1) / o$1, l$1 = t$1.canonical.y / o$1, c$1 = (t$1.canonical.y + 1) / o$1;
				let h$1 = i$1._centerAltitude;
				if (r$1) {
					const e$1 = r$1.getMinMaxForTile(t$1);
					e$1 && e$1.max > h$1 && (h$1 = e$1.max);
				}
				const d$1 = e.aA(s$1.x, n$1, a$1) - s$1.x, u$1 = e.aA(s$1.y, l$1, c$1) - s$1.y, _$1 = e.cf(h$1, i$1.center.lat) - s$1.z;
				return i$1._zoomFromMercatorZ(Math.sqrt(d$1 * d$1 + u$1 * u$1 + _$1 * _$1));
			}
			function aa(e$1, t$1, i$1, o$1, s$1, r$1, n$1) {
				const a$1 = e$1.context, l$1 = "shadow" === e$1.renderPass, c$1 = e$1.shadowRenderer, h$1 = l$1 && c$1 ? c$1.getShadowPassDepthMode() : new Xi(a$1.gl.LEQUAL, Xi.ReadWrite, e$1.depthRangeFor3D), d$1 = e$1.isTileAffectedByFog(r$1), u$1 = "globe" === e$1.transform.projection.name;
				if (i$1.meshes) for (const _$1 of i$1.meshes) {
					const p$1 = u$1 ? [] : ["MODEL_POSITION_ON_GPU"], f$1 = [];
					let m$1, g$1, v$1;
					const y$1 = !u$1 && o$1.instancedDataArray.length > 20;
					y$1 && p$1.push("INSTANCED_ARRAYS");
					const x$1 = ho(e$1, t$1.paint.get("model-cutoff-fade-range"));
					if (x$1.shouldRenderCutoff && p$1.push("RENDER_CUTOFF"), l$1 && c$1) m$1 = e$1.getOrCreateProgram("modelDepth", { defines: p$1 }), g$1 = qr(n$1.shadowTileMatrix, n$1.shadowTileMatrix, Float32Array.from(i$1.globalMatrix)), v$1 = c$1.getShadowPassColorMode();
					else {
						Yn(p$1, f$1, _$1, e$1, "none" === t$1.paint.get("model-color-use-theme").constantOr("default") ? null : t$1.lut), m$1 = e$1.getOrCreateProgram("model", {
							defines: p$1,
							overrideFog: d$1
						});
						const o$2 = _$1.material, l$2 = o$2.pbrMetallicRoughness, h$2 = t$1.paint.get("model-opacity").constantOr(1), u$2 = t$1.paint.get("model-emissive-strength").constantOr(0);
						g$1 = Hr(r$1.expandedProjMatrix, Float32Array.from(i$1.globalMatrix), new Float32Array(16), null, e$1, h$2, l$2.baseColorFactor, o$2.emissiveFactor, l$2.metallicFactor, l$2.roughnessFactor, o$2, u$2, t$1, s$1), c$1 && (n$1.shadowUniformsInitialized ? m$1.setShadowUniformValues(a$1, c$1.getShadowUniformValues()) : (c$1.setupShadows(r$1.toUnwrapped(), m$1, "model-tile"), n$1.shadowUniformsInitialized = !0)), v$1 = x$1.shouldRenderCutoff || h$2 < 1 || "OPAQUE" !== o$2.alphaMode ? $i.alphaBlended : $i.unblended;
					}
					e$1.uploadCommonUniforms(a$1, m$1, r$1.toUnwrapped(), null, x$1);
					const b$1 = _$1.material.doubleSided ? eo.disabled : eo.backCCW;
					if (y$1) f$1.push(o$1.instancedDataBuffer), m$1.draw(e$1, a$1.gl.TRIANGLES, h$1, Ki.disabled, v$1, b$1, g$1, t$1.id, _$1.vertexBuffer, _$1.indexBuffer, _$1.segments, t$1.paint, e$1.transform.zoom, void 0, f$1, o$1.instancedDataArray.length);
					else {
						const i$2 = l$1 ? "u_instance" : "u_normal_matrix";
						for (let s$2 = 0; s$2 < o$1.instancedDataArray.length; ++s$2) g$1[i$2] = new Float32Array(o$1.instancedDataArray.arrayBuffer, 64 * s$2, 16), m$1.draw(e$1, a$1.gl.TRIANGLES, h$1, Ki.disabled, v$1, b$1, g$1, t$1.id, _$1.vertexBuffer, _$1.indexBuffer, _$1.segments, t$1.paint, e$1.transform.zoom, void 0, f$1);
					}
				}
				if (i$1.children) for (const a$2 of i$1.children) aa(e$1, t$1, a$2, o$1, s$1, r$1, n$1);
			}
			const la = [
				1,
				-1,
				1
			];
			function ca(t$1, i$1, o$1, s$1) {
				if (!o$1.modelManager) return !0;
				const r$1 = o$1.modelManager;
				if (!o$1.shadowRenderer) return !0;
				const n$1 = o$1.shadowRenderer, a$1 = i$1.aabb;
				let l$1 = !0, c$1 = t$1.maxHeight;
				if (0 === c$1) {
					let e$1 = 0;
					for (const i$2 in t$1.instancesPerModel) {
						const t$2 = r$1.getModel(i$2, s$1);
						t$2 ? e$1 = Math.max(e$1, Math.max(Math.max(t$2.aabb.max[0], t$2.aabb.max[1]), t$2.aabb.max[2])) : l$1 = !1;
					}
					c$1 = t$1.maxScale * e$1 * 1.41 + t$1.maxVerticalOffset, l$1 && (t$1.maxHeight = c$1);
				}
				a$1.max[2] = c$1, a$1.min[2] += t$1.terrainElevationMin, a$1.max[2] += t$1.terrainElevationMax, e.af(a$1.min, a$1.min, i$1.tileMatrix), e.af(a$1.max, a$1.max, i$1.tileMatrix);
				const h$1 = a$1.intersects(n$1.getCurrentCascadeFrustum());
				return 0 === o$1.currentShadowCascade && (t$1.isInsideFirstShadowMapFrustum = 2 === h$1), 0 === h$1;
			}
			function ha(t$1, i$1) {
				const o$1 = t$1.uniformValues.u_cutoff_params[0], s$1 = t$1.uniformValues.u_cutoff_params[1], r$1 = t$1.uniformValues.u_cutoff_params[2], n$1 = t$1.uniformValues.u_cutoff_params[3];
				return s$1 === o$1 || n$1 === r$1 ? 1 : e.aA(((i$1 - o$1) / (s$1 - o$1) - r$1) / (n$1 - r$1), 0, 1);
			}
			function da(t$1, i$1, o$1, s$1) {
				if (i$1.pitch < 20) return 1;
				const r$1 = i$1.getWorldToCameraMatrix();
				e.aB(r$1, r$1, t$1);
				const n$1 = e.bU(o$1.min[0], o$1.min[1], o$1.min[2], 1);
				let a$1 = e.aC(e.eG(), n$1, r$1), l$1 = a$1, c$1 = a$1;
				n$1[1] = o$1.max[1], a$1 = e.aC(e.eG(), n$1, r$1), l$1 = a$1[1] < l$1[1] ? a$1 : l$1, c$1 = a$1[1] > c$1[1] ? a$1 : c$1, n$1[0] = o$1.max[0], a$1 = e.aC(e.eG(), n$1, r$1), l$1 = a$1[1] < l$1[1] ? a$1 : l$1, c$1 = a$1[1] > c$1[1] ? a$1 : c$1, n$1[1] = o$1.min[1], a$1 = e.aC(e.eG(), n$1, r$1), l$1 = a$1[1] < l$1[1] ? a$1 : l$1, c$1 = a$1[1] > c$1[1] ? a$1 : c$1;
				const h$1 = e.aA(s$1[0], 0, 1), d$1 = 100 * i$1.pixelsPerMeter * e.aA(s$1[1], 0, 1), u$1 = e.aA(s$1[2], 0, 1), _$1 = e.eH(e.eG(), l$1, c$1, h$1), p$1 = Math.tan(.5 * i$1.fovX), f$1 = -_$1[2] * p$1;
				if (0 === d$1) return _$1[1] < -Math.abs(f$1) ? u$1 : 1;
				const m$1 = (-Math.abs(f$1) - _$1[1]) / d$1, g$1 = (e$1, t$2, i$2) => (1 - i$2) * e$1 + i$2 * t$2;
				return g$1(1, e.aA(g$1(1, u$1, m$1), u$1, 1), e.aA((i$1.pitch - 20) / 20, 0, 1));
			}
			class ua {}
			class _a {
				constructor() {
					this._storage = /* @__PURE__ */ new Map();
				}
				getLinesFromTrianglesBuffer(t$1, i$1, o$1) {
					{
						const e$1 = this._storage.get(i$1.id);
						if (e$1) return e$1.lastUsedFrameIdx = t$1, e$1.buf;
					}
					const s$1 = o$1.gl, r$1 = s$1.getBufferParameter(s$1.ELEMENT_ARRAY_BUFFER, s$1.BUFFER_SIZE), n$1 = new ArrayBuffer(r$1), a$1 = new Int16Array(n$1);
					s$1.getBufferSubData(s$1.ELEMENT_ARRAY_BUFFER, 0, new Int16Array(n$1));
					const l$1 = new e.eJ();
					for (let e$1 = 0; e$1 < r$1 / 2; e$1 += 3) {
						const t$2 = a$1[e$1], i$2 = a$1[e$1 + 1], o$2 = a$1[e$1 + 2];
						l$1.emplaceBack(t$2, i$2), l$1.emplaceBack(i$2, o$2), l$1.emplaceBack(o$2, t$2);
					}
					const c$1 = o$1.bindVertexArrayOES.current, h$1 = new ua();
					return h$1.buf = new Wr(o$1, l$1), h$1.lastUsedFrameIdx = t$1, this._storage.set(i$1.id, h$1), o$1.bindVertexArrayOES.set(c$1), h$1.buf;
				}
				update(e$1) {
					for (const [t$1, i$1] of this._storage) e$1 - i$1.lastUsedFrameIdx > 30 && (i$1.buf.destroy(), this._storage.delete(t$1));
				}
				destroy() {
					for (const [e$1, t$1] of this._storage) t$1.buf.destroy(), this._storage.delete(e$1);
				}
			}
			class pa {
				constructor() {
					this.occluderSize = 30, this.depthOffset = -1e-4;
				}
			}
			const fa = e.ei([
				{
					type: "Float32",
					name: "a_pos_3f",
					components: 3
				},
				{
					type: "Float32",
					name: "a_uv",
					components: 2
				},
				{
					type: "Float32",
					name: "a_rainParticleData",
					components: 4
				}
			]);
			class ma {
				constructor(e$1) {
					this.revealStart = 11, this.revealRange = 2;
				}
			}
			const ga = e.ei([{
				type: "Float32",
				name: "a_pos_2f",
				components: 2
			}]);
			class va {
				destroy() {
					this.vignetteVx && this.vignetteVx.destroy(), this.vignetteIdx && this.vignetteIdx.destroy();
				}
				draw(t$1, i$1) {
					const o$1 = t$1.getOrCreateProgram("vignette");
					if (!this.vignetteVx || !this.vignetteIdx) {
						const i$2 = new e.eK(), o$2 = new e.b0();
						i$2.emplaceBack(-1, -1), i$2.emplaceBack(1, -1), i$2.emplaceBack(1, 1), i$2.emplaceBack(-1, 1), o$2.emplaceBack(0, 1, 2), o$2.emplaceBack(0, 2, 3), this.vignetteVx = t$1.context.createVertexBuffer(i$2, ga.members), this.vignetteIdx = t$1.context.createIndexBuffer(o$2);
					}
					const s$1 = e.bg.simpleSegment(0, 0, 4, 6);
					if (this.vignetteVx && this.vignetteIdx) {
						t$1.uploadCommonUniforms(t$1.context, o$1);
						const e$1 = {
							u_vignetteShape: (r$1 = {
								vignetteShape: [
									i$1.start,
									i$1.range,
									Math.pow(10, i$1.fadePower)
								],
								vignetteColor: [
									i$1.color.r,
									i$1.color.g,
									i$1.color.b,
									i$1.color.a * i$1.strength
								]
							}).vignetteShape,
							u_vignetteColor: r$1.vignetteColor
						};
						o$1.draw(t$1, t$1.context.gl.TRIANGLES, Xi.disabled, Ki.disabled, $i.alphaBlended, eo.disabled, e$1, "vignette", this.vignetteVx, this.vignetteIdx, s$1);
					}
					var r$1;
				}
			}
			class ya {
				constructor() {
					this._accumulatedOffsetX = 0, this._accumulatedOffsetY = 0, this._accumulatedElevation = 0;
				}
				update(t$1, i$1) {
					const o$1 = t$1.getFreeCameraOptions().position, s$1 = o$1.toAltitude(), r$1 = o$1.toLngLat(), n$1 = e.an(r$1.lng), a$1 = e.an(r$1.lat), l$1 = t$1.pixelsPerMeter / i$1, c$1 = n$1 * e.eM, h$1 = e.eM * Math.log(Math.tan(Math.PI / 4 + a$1 / 2));
					if (void 0 === this._offsetXPrev) this._offsetXPrev = 0, this._offsetYPrev = 0, this._elevationPrev = 0, this._accumulatedOffsetX = 0, this._accumulatedOffsetY = 0, this._accumulatedElevation = 0;
					else {
						const e$1 = -this._offsetYPrev + h$1, t$2 = -this._elevationPrev + s$1;
						this._accumulatedOffsetX += (-this._offsetXPrev + c$1) * l$1, this._accumulatedOffsetY += e$1 * l$1, this._accumulatedElevation += t$2 * l$1, this._offsetXPrev = c$1, this._offsetYPrev = h$1, this._elevationPrev = s$1;
					}
				}
				getPosition() {
					return [
						this._accumulatedOffsetX,
						this._accumulatedOffsetY,
						this._accumulatedElevation
					];
				}
			}
			function xa(e$1, t$1) {
				return [
					-(e$1[0] - Math.floor(e$1[0] / t$1) * t$1),
					-(e$1[1] - Math.floor(e$1[1] / t$1) * t$1),
					-(e$1[2] - Math.floor(e$1[2] / t$1) * t$1)
				];
			}
			function ba(t$1) {
				const i$1 = e.eq(1323123451230), o$1 = [];
				for (let s$1 = 0; s$1 < t$1; ++s$1) {
					const t$2 = 2 * i$1() - 1, s$2 = 2 * i$1() - 1, r$1 = 2 * i$1() - 1;
					o$1.push(e.d5(t$2, s$2, r$1));
				}
				return o$1;
			}
			function wa(t$1, i$1, o$1, s$1, r$1) {
				const n$1 = e.aA((r$1 - o$1) / (s$1 - o$1), 0, 1);
				return (1 - n$1) * t$1 + n$1 * i$1;
			}
			class Ta {
				constructor(e$1) {
					this._movement = new ya(), this._accumulatedTimeFromStart = 0, this._prevTime = Date.now() / 1e3, this._vignette = new va(), this._ppmScaleFactor = e$1;
				}
				destroy() {
					this.particlesVx && this.particlesVx.destroy(), this.particlesIdx && this.particlesIdx.destroy(), this._vignette && this._vignette.destroy();
				}
				updateOnRender(t$1, i$1) {
					const o$1 = t$1.transform;
					this._movement.update(o$1, this._ppmScaleFactor);
					const s$1 = o$1.starsProjMatrix, r$1 = e.c7([]);
					e.c9(r$1, r$1, e.an(90) - o$1._pitch), e.c8(r$1, r$1, -o$1.angle);
					const n$1 = e.cc(new Float32Array(16), r$1), a$1 = e.eL(1, 0, 0, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 0, 0, 1), l$1 = e.eg([], a$1), c$1 = e.aB([], l$1, n$1), h$1 = Date.now() / 1e3;
					return this._accumulatedTimeFromStart += (h$1 - this._prevTime) * i$1, this._prevTime = h$1, {
						projectionMatrix: s$1,
						modelviewMatrix: c$1
					};
				}
			}
			class Ea extends Ta {
				constructor(e$1) {
					super(4.25), this._params = {
						overrideStyleParameters: !1,
						intensity: .5,
						timeFactor: 1,
						velocityConeAperture: 0,
						velocity: 300,
						boxSize: 2500,
						dropletSizeX: 1,
						dropletSizeYScale: 10,
						distortionStrength: 70,
						screenThinning: {
							intensity: .57,
							start: .46,
							range: 1.17,
							fadePower: .17,
							affectedRatio: 1,
							particleOffset: -.2
						},
						color: {
							r: .66,
							g: .68,
							b: .74,
							a: .7
						},
						direction: {
							x: -50,
							y: -35
						},
						shapeDirPower: 2,
						shapeNormalPower: 1
					}, this._revealParams = new ma("Precipitation > Rain"), this._vignetteParams = {
						strength: 1,
						start: .7,
						range: 1,
						fadePower: .4,
						color: {
							r: .27,
							g: .27,
							b: .27,
							a: 1
						}
					}, this.particlesCount = 16e3;
				}
				update(t$1) {
					const i$1 = t$1.context;
					if (!this.particlesVx) {
						const t$2 = ba(this.particlesCount), o$1 = new e.eN(), s$1 = new e.b0();
						let r$1 = 0;
						const n$1 = e.eq(1323123451230);
						for (let e$1 = 0; e$1 < t$2.length; ++e$1) {
							const i$2 = t$2[e$1], a$1 = [
								2 * n$1() - 1,
								n$1(),
								n$1(),
								n$1()
							];
							o$1.emplaceBack(i$2[0], i$2[1], i$2[2], -1, -1, ...a$1), o$1.emplaceBack(i$2[0], i$2[1], i$2[2], 1, -1, ...a$1), o$1.emplaceBack(i$2[0], i$2[1], i$2[2], 1, 1, ...a$1), o$1.emplaceBack(i$2[0], i$2[1], i$2[2], -1, 1, ...a$1), s$1.emplaceBack(r$1 + 0, r$1 + 1, r$1 + 2), s$1.emplaceBack(r$1 + 0, r$1 + 2, r$1 + 3), r$1 += 4;
						}
						this.particlesVx = i$1.createVertexBuffer(o$1, fa.members), this.particlesIdx = i$1.createIndexBuffer(s$1);
					}
				}
				draw(t$1) {
					if (!this._params.overrideStyleParameters && !t$1.style.rain) return;
					const i$1 = this._params.overrideStyleParameters ? this._revealParams : {
						revealStart: 0,
						revealRange: .01
					}, o$1 = t$1.transform.zoom;
					if (i$1.revealStart > o$1) return;
					const s$1 = wa(0, 1, i$1.revealStart, i$1.revealStart + i$1.revealRange, o$1);
					if (!this.particlesVx || !this.particlesIdx) return;
					const r$1 = structuredClone(this._params);
					let n$1 = [
						-r$1.direction.x,
						r$1.direction.y,
						-100
					];
					e.aw(n$1, n$1);
					const a$1 = structuredClone(this._vignetteParams);
					a$1.strength *= s$1, r$1.overrideStyleParameters || (r$1.intensity = t$1.style.rain.state.density, r$1.timeFactor = t$1.style.rain.state.intensity, r$1.color = structuredClone(t$1.style.rain.state.color), n$1 = structuredClone(t$1.style.rain.state.direction), r$1.screenThinning.intensity = t$1.style.rain.state.centerThinning, r$1.dropletSizeX = t$1.style.rain.state.dropletSize[0], r$1.dropletSizeYScale = t$1.style.rain.state.dropletSize[1] / t$1.style.rain.state.dropletSize[0], r$1.distortionStrength = 100 * t$1.style.rain.state.distortionStrength, a$1.strength = 1, a$1.color = structuredClone(t$1.style.rain.state.vignetteColor));
					const l$1 = this.updateOnRender(t$1, r$1.timeFactor), c$1 = t$1.context, h$1 = c$1.gl, d$1 = t$1.transform;
					this.screenTexture && this.screenTexture.size[0] === t$1.width && this.screenTexture.size[1] === t$1.height || (this.screenTexture = new e.T(c$1, {
						width: t$1.width,
						height: t$1.height,
						data: null
					}, h$1.RGBA8)), r$1.distortionStrength > 0 && (c$1.activeTexture.set(h$1.TEXTURE0), this.screenTexture.bind(h$1.LINEAR, h$1.CLAMP_TO_EDGE), h$1.copyTexSubImage2D(h$1.TEXTURE_2D, 0, 0, 0, 0, 0, t$1.width, t$1.height));
					const u$1 = t$1.getOrCreateProgram("rainParticle");
					t$1.uploadCommonUniforms(c$1, u$1), c$1.activeTexture.set(h$1.TEXTURE0), this.screenTexture.bind(h$1.LINEAR, h$1.CLAMP_TO_EDGE);
					const _$1 = [
						r$1.color.r,
						r$1.color.g,
						r$1.color.b,
						r$1.color.a
					], p$1 = (i$2, o$2) => {
						const s$2 = xa(this._movement.getPosition(), i$2), a$2 = r$1.dropletSizeX, c$2 = r$1.dropletSizeX * r$1.dropletSizeYScale, p$2 = t$1.width / 2, f$1 = t$1.height / 2, m$1 = wa(0, r$1.screenThinning.start, 0, 1, r$1.screenThinning.intensity), g$1 = wa(.001, r$1.screenThinning.range, 0, 1, r$1.screenThinning.intensity), v$1 = wa(0, r$1.screenThinning.particleOffset, 0, 1, r$1.screenThinning.intensity), y$1 = (x$1 = {
							modelview: l$1.modelviewMatrix,
							projection: l$1.projectionMatrix,
							time: this._accumulatedTimeFromStart,
							camPos: s$2,
							velocityConeAperture: r$1.velocityConeAperture,
							velocity: r$1.velocity,
							boxSize: i$2,
							rainDropletSize: [a$2, c$2],
							distortionStrength: r$1.distortionStrength,
							rainDirection: n$1,
							color: _$1,
							screenSize: [d$1.width, d$1.height],
							thinningCenterPos: [p$2, f$1],
							thinningShape: [
								m$1,
								g$1,
								Math.pow(10, r$1.screenThinning.fadePower)
							],
							thinningAffectedRatio: r$1.screenThinning.affectedRatio,
							thinningParticleOffset: v$1,
							shapeDirectionalPower: r$1.shapeDirPower,
							shapeNormalPower: r$1.shapeNormalPower,
							mode: o$2 ? 0 : 1
						}, {
							u_modelview: Float32Array.from(x$1.modelview),
							u_projection: Float32Array.from(x$1.projection),
							u_time: x$1.time,
							u_cam_pos: x$1.camPos,
							u_texScreen: 0,
							u_velocityConeAperture: x$1.velocityConeAperture,
							u_velocity: x$1.velocity,
							u_boxSize: x$1.boxSize,
							u_rainDropletSize: x$1.rainDropletSize,
							u_distortionStrength: x$1.distortionStrength,
							u_rainDirection: x$1.rainDirection,
							u_color: x$1.color,
							u_screenSize: x$1.screenSize,
							u_thinningCenterPos: x$1.thinningCenterPos,
							u_thinningShape: x$1.thinningShape,
							u_thinningAffectedRatio: x$1.thinningAffectedRatio,
							u_thinningParticleOffset: x$1.thinningParticleOffset,
							u_shapeDirectionalPower: x$1.shapeDirectionalPower,
							u_shapeNormalPower: x$1.shapeNormalPower,
							u_mode: x$1.mode
						});
						var x$1;
						const b$1 = Math.round(r$1.intensity * this.particlesCount), w$1 = e.bg.simpleSegment(0, 0, 4 * b$1, 2 * b$1);
						u$1.draw(t$1, h$1.TRIANGLES, Xi.disabled, Ki.disabled, $i.alphaBlended, eo.disabled, y$1, "rain_particles", this.particlesVx, this.particlesIdx, w$1);
					};
					r$1.distortionStrength > 0 && p$1(r$1.boxSize, !0), p$1(r$1.boxSize, !1), this._vignette.draw(t$1, a$1);
				}
			}
			const Sa = e.ei([
				{
					type: "Float32",
					name: "a_pos_3f",
					components: 3
				},
				{
					type: "Float32",
					name: "a_uv",
					components: 2
				},
				{
					type: "Float32",
					name: "a_snowParticleData",
					components: 4
				},
				{
					type: "Float32",
					name: "a_snowParticleDataHorizontalOscillation",
					components: 2
				}
			]);
			class Ia extends Ta {
				constructor(e$1) {
					super(2.25), this._params = {
						overrideStyleParameters: !1,
						intensity: .85,
						timeFactor: .75,
						velocityConeAperture: 70,
						velocity: 40,
						horizontalOscillationRadius: 4,
						horizontalOscillationRate: 1.5,
						boxSize: 2e3,
						billboardSize: 2,
						shapeFadeStart: .27,
						shapeFadePower: .21,
						screenThinning: {
							intensity: .4,
							start: .15,
							range: 1.4,
							fadePower: .24,
							affectedRatio: 1,
							particleOffset: -.2
						},
						color: {
							r: 1,
							g: 1,
							b: 1,
							a: 1
						},
						direction: {
							x: -50,
							y: -35
						}
					}, this._revealParams = new ma("Precipitation > Snow"), this._vignetteParams = {
						strength: .3,
						start: .78,
						range: .46,
						fadePower: .2,
						color: {
							r: 1,
							g: 1,
							b: 1,
							a: 1
						}
					}, this.particlesCount = 16e3;
				}
				update(t$1) {
					const i$1 = t$1.context;
					if (!this.particlesVx) {
						const t$2 = ba(this.particlesCount), o$1 = new e.eO(), s$1 = new e.b0();
						let r$1 = 0;
						const n$1 = e.eq(1323123451230);
						for (let e$1 = 0; e$1 < t$2.length; ++e$1) {
							const i$2 = t$2[e$1], a$1 = n$1(), l$1 = n$1(), c$1 = n$1(), h$1 = [
								e$1 / t$2.length,
								a$1,
								l$1,
								c$1
							], d$1 = [n$1(), n$1()];
							o$1.emplaceBack(i$2[0], i$2[1], i$2[2], -1, -1, ...h$1, ...d$1), o$1.emplaceBack(i$2[0], i$2[1], i$2[2], 1, -1, ...h$1, ...d$1), o$1.emplaceBack(i$2[0], i$2[1], i$2[2], 1, 1, ...h$1, ...d$1), o$1.emplaceBack(i$2[0], i$2[1], i$2[2], -1, 1, ...h$1, ...d$1), s$1.emplaceBack(r$1 + 0, r$1 + 1, r$1 + 2), s$1.emplaceBack(r$1 + 0, r$1 + 2, r$1 + 3), r$1 += 4;
						}
						this.particlesVx = i$1.createVertexBuffer(o$1, Sa.members), this.particlesIdx = i$1.createIndexBuffer(s$1);
					}
				}
				draw(t$1) {
					if (!this._params.overrideStyleParameters && !t$1.style.snow) return;
					const i$1 = structuredClone(this._params);
					let o$1 = [
						-i$1.direction.x,
						i$1.direction.y,
						-100
					];
					e.aw(o$1, o$1);
					const s$1 = structuredClone(this._vignetteParams), r$1 = i$1.overrideStyleParameters ? this._revealParams : {
						revealStart: 0,
						revealRange: .01
					}, n$1 = t$1.transform.zoom;
					if (r$1.revealStart > n$1) return;
					const a$1 = wa(0, 1, r$1.revealStart, r$1.revealStart + r$1.revealRange, n$1);
					s$1.strength *= a$1, i$1.overrideStyleParameters || (i$1.intensity = t$1.style.snow.state.density, i$1.timeFactor = t$1.style.snow.state.intensity, i$1.color = structuredClone(t$1.style.snow.state.color), o$1 = structuredClone(t$1.style.snow.state.direction), i$1.screenThinning.intensity = t$1.style.snow.state.centerThinning, i$1.billboardSize = 2.79 * t$1.style.snow.state.flakeSize, s$1.strength = 1, s$1.color = structuredClone(t$1.style.snow.state.vignetteColor));
					const l$1 = this.updateOnRender(t$1, i$1.timeFactor);
					if (!this.particlesVx || !this.particlesIdx) return;
					const c$1 = t$1.context, h$1 = c$1.gl, d$1 = t$1.transform, u$1 = t$1.getOrCreateProgram("snowParticle");
					t$1.uploadCommonUniforms(c$1, u$1), ((i$2, s$2, r$2) => {
						const n$2 = xa(this._movement.getPosition(), i$2), a$2 = d$1.width / 2, c$2 = d$1.height / 2, _$1 = wa(0, r$2.screenThinning.start, 0, 1, r$2.screenThinning.intensity), p$1 = wa(.001, r$2.screenThinning.range, 0, 1, r$2.screenThinning.intensity), f$1 = wa(0, r$2.screenThinning.particleOffset, 0, 1, r$2.screenThinning.intensity), m$1 = (g$1 = {
							modelview: l$1.modelviewMatrix,
							projection: l$1.projectionMatrix,
							time: this._accumulatedTimeFromStart,
							camPos: n$2,
							velocityConeAperture: r$2.velocityConeAperture,
							velocity: r$2.velocity,
							horizontalOscillationRadius: r$2.horizontalOscillationRadius,
							horizontalOscillationRate: r$2.horizontalOscillationRate,
							boxSize: i$2,
							billboardSize: 1 * r$2.billboardSize,
							simpleShapeParameters: [r$2.shapeFadeStart, r$2.shapeFadePower],
							screenSize: [d$1.width, d$1.height],
							thinningCenterPos: [a$2, c$2],
							thinningShape: [
								_$1,
								p$1,
								Math.pow(10, r$2.screenThinning.fadePower)
							],
							thinningAffectedRatio: r$2.screenThinning.affectedRatio,
							thinningParticleOffset: f$1,
							color: [
								r$2.color.r,
								r$2.color.g,
								r$2.color.b,
								r$2.color.a
							],
							direction: o$1
						}, {
							u_modelview: Float32Array.from(g$1.modelview),
							u_projection: Float32Array.from(g$1.projection),
							u_time: g$1.time,
							u_cam_pos: g$1.camPos,
							u_velocityConeAperture: g$1.velocityConeAperture,
							u_velocity: g$1.velocity,
							u_horizontalOscillationRadius: g$1.horizontalOscillationRadius,
							u_horizontalOscillationRate: g$1.horizontalOscillationRate,
							u_boxSize: g$1.boxSize,
							u_billboardSize: g$1.billboardSize,
							u_simpleShapeParameters: g$1.simpleShapeParameters,
							u_screenSize: g$1.screenSize,
							u_thinningCenterPos: g$1.thinningCenterPos,
							u_thinningShape: g$1.thinningShape,
							u_thinningAffectedRatio: g$1.thinningAffectedRatio,
							u_thinningParticleOffset: g$1.thinningParticleOffset,
							u_particleColor: g$1.color,
							u_direction: g$1.direction
						});
						var g$1;
						const v$1 = Math.round(r$2.intensity * this.particlesCount), y$1 = e.bg.simpleSegment(0, 0, 4 * v$1, 2 * v$1);
						this.particlesVx && this.particlesIdx && u$1.draw(t$1, h$1.TRIANGLES, Xi.disabled, Ki.disabled, $i.alphaBlended, eo.disabled, m$1, "snow_particles", this.particlesVx, this.particlesIdx, y$1);
					})(i$1.boxSize, 0, i$1), this._vignette.draw(t$1, s$1);
				}
			}
			const Ca = {
				symbol: function(t$1, i$1, o$1, s$1, r$1) {
					if ("translucent" !== t$1.renderPass) return;
					const n$1 = Ki.disabled, a$1 = t$1.colorModeForRenderPass(), l$1 = o$1.layout.get("text-variable-anchor"), c$1 = o$1.layout.get("text-size-scale-range"), h$1 = e.aA(t$1.scaleFactor, c$1[0], c$1[1]);
					l$1 && function(t$2, i$2, o$2, s$2, r$2, n$2, a$2, l$2) {
						const c$2 = i$2.transform, h$2 = "map" === r$2, d$2 = "map" === n$2;
						for (const i$3 of t$2) {
							const t$3 = s$2.getTile(i$3), r$3 = t$3.getBucket(o$2);
							if (!r$3 || !r$3.text || !r$3.text.segments.get().length) continue;
							const n$3 = e.bK(r$3.textSizeData, c$2.zoom, l$2), u$2 = Qt(i$3, r$3.getProjection(), c$2), _$1 = c$2.calculatePixelsToTileUnitsMatrix(t$3), p$1 = si(u$2, t$3.tileID.canonical, d$2, h$2, c$2, r$3.getProjection(), _$1), f$1 = r$3.hasIconTextFit() && r$3.hasIconData();
							n$3 && sn(r$3, h$2, d$2, a$2, c$2, p$1, i$3, Math.pow(2, c$2.zoom - t$3.tileID.overscaledZ), n$3, f$1);
						}
					}(s$1, t$1, o$1, i$1, o$1.layout.get("text-rotation-alignment"), o$1.layout.get("text-pitch-alignment"), r$1, h$1);
					const d$1 = 0 !== o$1.paint.get("icon-opacity").constantOr(1), u$1 = 0 !== o$1.paint.get("text-opacity").constantOr(1);
					void 0 !== o$1.layout.get("symbol-sort-key").constantOr(1) && (d$1 || u$1) ? rn(t$1, i$1, o$1, s$1, n$1, a$1) : (d$1 && rn(t$1, i$1, o$1, s$1, n$1, a$1, { onlyIcons: !0 }), u$1 && rn(t$1, i$1, o$1, s$1, n$1, a$1, { onlyText: !0 })), i$1.map.showCollisionBoxes && (Qr(t$1, i$1, o$1, s$1, o$1.paint.get("text-translate"), o$1.paint.get("text-translate-anchor"), !0), Qr(t$1, i$1, o$1, s$1, o$1.paint.get("icon-translate"), o$1.paint.get("icon-translate-anchor"), !1));
				},
				circle: function(t$1, i$1, o$1, s$1) {
					if ("translucent" !== t$1.renderPass) return;
					const r$1 = o$1.paint.get("circle-opacity"), n$1 = o$1.paint.get("circle-stroke-width"), a$1 = o$1.paint.get("circle-stroke-opacity"), l$1 = void 0 !== o$1.layout.get("circle-sort-key").constantOr(1), c$1 = o$1.paint.get("circle-emissive-strength");
					if (0 === r$1.constantOr(1) && (0 === n$1.constantOr(1) || 0 === a$1.constantOr(1))) return;
					const h$1 = t$1.context, d$1 = h$1.gl, u$1 = t$1.transform, _$1 = !(!t$1.terrain || !t$1.terrain.enabled), p$1 = o$1.layout.get("circle-elevation-reference"), f$1 = t$1.depthModeForSublayer(0, Xi.ReadOnly), m$1 = new Xi(t$1.context.gl.LEQUAL, Xi.ReadOnly, t$1.depthRangeFor3D), g$1 = "none" === p$1 || _$1 ? f$1 : m$1, v$1 = Ki.disabled, y$1 = t$1.colorModeForDrapableLayerRenderPass(c$1), x$1 = "globe" === u$1.projection.name, b$1 = [e.aF(u$1.center.lng), e.aJ(u$1.center.lat)], w$1 = [];
					for (let r$2 = 0; r$2 < s$1.length; r$2++) {
						const n$2 = s$1[r$2], a$2 = i$1.getTile(n$2), c$2 = a$2.getBucket(o$1);
						if (!c$2 || c$2.projection.name !== u$1.projection.name) continue;
						const h$2 = c$2.programConfigurations.get(o$1.id), d$2 = c$2.layoutVertexBuffer, _$2 = c$2.globeExtVertexBuffer, p$2 = c$2.indexBuffer, f$2 = e.e0(o$1), m$2 = [_$2], g$2 = t$1.isTileAffectedByFog(n$2);
						x$1 && f$2.push("PROJECTION_GLOBE_VIEW"), f$2.push("DEPTH_D24"), t$1.terrain && u$1.depthOcclusionForSymbolsAndCircles && f$2.push("DEPTH_OCCLUSION"), c$2.hasElevation && !t$1.terrain && (f$2.push("ELEVATED_ROADS"), m$2.push(c$2.elevatedLayoutVertexBuffer));
						const v$2 = t$1.getOrCreateProgram("circle", {
							config: h$2,
							defines: f$2,
							overrideFog: g$2
						}), y$2 = u$1.projection.createInversionMatrix(u$1, n$2.canonical), T$2 = {
							programConfiguration: h$2,
							program: v$2,
							layoutVertexBuffer: d$2,
							dynamicBuffers: m$2,
							indexBuffer: p$2,
							uniformValues: e.e1(t$1, n$2, a$2, y$2, b$1, o$1),
							tile: a$2
						};
						if (l$1) {
							const t$2 = c$2.segments.get();
							for (const i$2 of t$2) w$1.push({
								segments: new e.bg([i$2]),
								sortKey: i$2.sortKey,
								state: T$2
							});
						} else w$1.push({
							segments: c$2.segments,
							sortKey: 0,
							state: T$2
						});
					}
					l$1 && w$1.sort(((e$1, t$2) => e$1.sortKey - t$2.sortKey));
					const T$1 = { useDepthForOcclusion: u$1.depthOcclusionForSymbolsAndCircles };
					for (const e$1 of w$1) {
						const { programConfiguration: i$2, program: s$2, layoutVertexBuffer: r$2, dynamicBuffers: n$2, indexBuffer: a$2, uniformValues: l$2, tile: c$2 } = e$1.state, _$2 = e$1.segments;
						t$1.terrain && t$1.terrain.setupElevationDraw(c$2, s$2, T$1), t$1.uploadCommonUniforms(h$1, s$2, c$2.tileID.toUnwrapped()), s$2.draw(t$1, d$1.TRIANGLES, g$1, v$1, y$1, eo.disabled, l$2, o$1.id, r$2, a$2, _$2, o$1.paint, u$1.zoom, i$2, n$2);
					}
				},
				heatmap: function(t$1, i$1, o$1, s$1) {
					if (0 !== o$1.paint.get("heatmap-opacity")) if ("offscreen" === t$1.renderPass) {
						const r$1 = t$1.context, n$1 = r$1.gl, a$1 = Ki.disabled, l$1 = new $i([
							n$1.ONE,
							n$1.ONE,
							n$1.ONE,
							n$1.ONE
						], e.ao.transparent, [
							!0,
							!0,
							!0,
							!0
						]);
						(function(e$1, t$2, i$2, o$2) {
							const s$2 = e$1.gl, r$2 = t$2.width * o$2, n$2 = t$2.height * o$2;
							e$1.activeTexture.set(s$2.TEXTURE1), e$1.viewport.set([
								0,
								0,
								r$2,
								n$2
							]);
							let a$2 = i$2.heatmapFbo;
							if (!a$2 || a$2 && (a$2.width !== r$2 || a$2.height !== n$2)) {
								a$2 && a$2.destroy();
								const t$3 = s$2.createTexture();
								s$2.bindTexture(s$2.TEXTURE_2D, t$3), s$2.texParameteri(s$2.TEXTURE_2D, s$2.TEXTURE_WRAP_S, s$2.CLAMP_TO_EDGE), s$2.texParameteri(s$2.TEXTURE_2D, s$2.TEXTURE_WRAP_T, s$2.CLAMP_TO_EDGE), s$2.texParameteri(s$2.TEXTURE_2D, s$2.TEXTURE_MIN_FILTER, s$2.LINEAR), s$2.texParameteri(s$2.TEXTURE_2D, s$2.TEXTURE_MAG_FILTER, s$2.LINEAR), a$2 = i$2.heatmapFbo = e$1.createFramebuffer(r$2, n$2, 1, null), function(e$2, t$4, i$3, o$3, s$3, r$3) {
									const n$3 = e$2.gl;
									n$3.texImage2D(n$3.TEXTURE_2D, 0, e$2.extRenderToTextureHalfFloat ? n$3.RGBA16F : n$3.RGBA, s$3, r$3, 0, n$3.RGBA, e$2.extRenderToTextureHalfFloat ? n$3.HALF_FLOAT : n$3.UNSIGNED_BYTE, null), o$3.colorAttachment0.set(i$3);
								}(e$1, 0, t$3, a$2, r$2, n$2);
							} else s$2.bindTexture(s$2.TEXTURE_2D, a$2.colorAttachment0.get()), e$1.bindFramebuffer.set(a$2.framebuffer);
						})(r$1, t$1, o$1, "globe" === t$1.transform.projection.name ? .5 : .25), r$1.clear({ color: e.ao.transparent });
						const c$1 = t$1.transform, h$1 = "globe" === c$1.projection.name, d$1 = h$1 ? ["PROJECTION_GLOBE_VIEW"] : [], u$1 = h$1 ? eo.frontCCW : eo.disabled, _$1 = [e.aF(c$1.center.lng), e.aJ(c$1.center.lat)];
						for (let e$1 = 0; e$1 < s$1.length; e$1++) {
							const p$1 = s$1[e$1];
							if (i$1.hasRenderableParent(p$1)) continue;
							const f$1 = i$1.getTile(p$1), m$1 = f$1.getBucket(o$1);
							if (!m$1 || m$1.projection.name !== c$1.projection.name) continue;
							const g$1 = t$1.isTileAffectedByFog(p$1), v$1 = m$1.programConfigurations.get(o$1.id), y$1 = t$1.getOrCreateProgram("heatmap", {
								config: v$1,
								defines: d$1,
								overrideFog: g$1
							}), { zoom: x$1 } = t$1.transform;
							t$1.terrain && t$1.terrain.setupElevationDraw(f$1, y$1), t$1.uploadCommonUniforms(r$1, y$1, p$1.toUnwrapped());
							const b$1 = c$1.projection.createInversionMatrix(c$1, p$1.canonical);
							y$1.draw(t$1, n$1.TRIANGLES, Xi.disabled, a$1, l$1, u$1, Lr(t$1, p$1, f$1, b$1, _$1, x$1, o$1.paint.get("heatmap-intensity")), o$1.id, m$1.layoutVertexBuffer, m$1.indexBuffer, m$1.segments, o$1.paint, t$1.transform.zoom, v$1, h$1 ? [m$1.globeExtVertexBuffer] : null);
						}
						r$1.viewport.set([
							0,
							0,
							t$1.width,
							t$1.height
						]);
					} else "translucent" === t$1.renderPass && (t$1.context.setColorMode(t$1.colorModeForRenderPass()), function(t$2, i$2) {
						const o$2 = t$2.context, s$2 = o$2.gl, r$1 = i$2.heatmapFbo;
						if (!r$1) return;
						o$2.activeTexture.set(s$2.TEXTURE0), s$2.bindTexture(s$2.TEXTURE_2D, r$1.colorAttachment0.get()), o$2.activeTexture.set(s$2.TEXTURE1);
						let n$1 = i$2.colorRampTexture;
						n$1 || (n$1 = i$2.colorRampTexture = new e.T(o$2, i$2.colorRamp, s$2.RGBA8)), n$1.bind(s$2.LINEAR, s$2.CLAMP_TO_EDGE), t$2.getOrCreateProgram("heatmapTexture").draw(t$2, s$2.TRIANGLES, Xi.disabled, Ki.disabled, t$2.colorModeForRenderPass(), eo.disabled, ((e$1, t$3, i$3, o$3) => ({
							u_image: 0,
							u_color_ramp: 1,
							u_opacity: t$3.paint.get("heatmap-opacity")
						}))(0, i$2), i$2.id, t$2.viewportBuffer, t$2.quadTriangleIndexBuffer, t$2.viewportSegments, i$2.paint, t$2.transform.zoom);
					}(t$1, o$1));
				},
				line: function(t$1, i$1, o$1, s$1) {
					if ("translucent" !== t$1.renderPass) return;
					const r$1 = o$1.paint.get("line-opacity"), n$1 = o$1.paint.get("line-width");
					if (0 === r$1.constantOr(1) || 0 === n$1.constantOr(1)) return;
					const a$1 = o$1.paint.get("line-emissive-strength").isConstant(), l$1 = o$1.paint.get("line-emissive-strength").constantOr(0), c$1 = o$1.paint.get("line-occlusion-opacity"), h$1 = o$1.layout.get("line-elevation-reference"), d$1 = "meters" === o$1.layout.get("line-width-unit"), u$1 = "sea" === h$1, _$1 = !(!t$1.terrain || !t$1.terrain.enabled), p$1 = t$1.context, f$1 = p$1.gl;
					if (o$1.hasElevatedBuckets && "globe" === t$1.transform.projection.name) return;
					const m$1 = o$1.layout.get("line-cross-slope"), g$1 = void 0 !== m$1, v$1 = m$1 < 1, y$1 = t$1.colorModeForDrapableLayerRenderPass(a$1 ? l$1 : null), x$1 = t$1.terrain && t$1.terrain.renderingToTexture, b$1 = x$1 ? 1 : e.o.devicePixelRatio, w$1 = o$1.paint.get("line-dasharray"), T$1 = w$1.constantOr(1), E$1 = o$1.layout.get("line-cap"), S$1 = w$1.constantOr(null), I$1 = E$1.constantOr(null), C$1 = o$1.paint.get("line-pattern"), R$1 = C$1.constantOr(1), A$1 = o$1.paint.get("line-pattern-cross-fade"), L$1 = C$1.constantOr(null), D$1 = o$1.paint.get("line-opacity").constantOr(1);
					let P$1 = !R$1 && 1 !== D$1 || t$1.depthOcclusion && c$1 > 0 && c$1 < 1;
					const O$1 = o$1.paint.get("line-gradient"), z$1 = R$1 ? "linePattern" : "line", M$1 = e.e2(o$1);
					let F$1;
					if (x$1 && t$1.terrain && t$1.terrain.clipOrMaskOverlapStencilType() && (P$1 = !1), 0 !== c$1 && t$1.depthOcclusion) {
						const t$2 = o$1.paint._values["line-opacity"];
						t$2 && t$2.value && "constant" === t$2.value.kind ? F$1 = t$2.value : e.w(`Occlusion opacity for layer ${o$1.id} is supported only when line-opacity isn't data-driven.`);
					}
					"constant" !== n$1.value.kind && !1 === n$1.value.isLineProgressConstant && M$1.push("VARIABLE_LINE_WIDTH"), x$1 && ("dual-source-blending" !== t$1.emissiveMode || a$1 ? "mrt-fallback" === t$1.emissiveMode && M$1.push("USE_MRT1") : M$1.push("DUAL_SOURCE_BLENDING"));
					const B$1 = (s$2, r$2, n$2, a$2, l$2, h$2) => {
						for (const _$2 of s$2) {
							const s$3 = i$1.getTile(_$2);
							if (R$1 && !s$3.patternsLoaded()) continue;
							const m$2 = s$3.getBucket(o$1);
							if (!m$2) continue;
							if ("none" !== m$2.elevationType && !l$2 || "none" === m$2.elevationType && l$2) continue;
							t$1.prepareDrawTile();
							const g$2 = [...r$2], v$2 = t$1.shadowRenderer, w$2 = "road" === m$2.elevationType && !!v$2 && v$2.enabled;
							let E$2 = [
								0,
								0,
								0
							];
							if (w$2) {
								const e$1 = t$1.style.directionalLight, i$2 = t$1.style.ambientLight;
								e$1 && i$2 && (E$2 = vo(t$1.style, e$1, i$2)), g$2.push("RENDER_SHADOWS", "DEPTH_TEXTURE", "NORMAL_OFFSET");
							}
							const C$2 = m$2.programConfigurations.get(o$1.id);
							let M$2 = !1;
							if (L$1 && s$3.imageAtlas) {
								const t$2 = e.e3.from(L$1), i$2 = t$2.getPrimary().scaleSelf(b$1).toString(), o$2 = s$3.imageAtlas.patternPositions.get(i$2), r$3 = t$2.getSecondary(), n$3 = r$3 ? s$3.imageAtlas.patternPositions.get(r$3.scaleSelf(b$1).toString()) : null;
								M$2 = !!o$2 && !!n$3, o$2 && C$2.setConstantPatternPositions(o$2, n$3);
							}
							A$1 > 0 && (M$2 || C$2.getPatternTransitionVertexBuffer("line-pattern")) && g$2.push("LINE_PATTERN_TRANSITION");
							const B$2 = t$1.isTileAffectedByFog(_$2), k$2 = t$1.getOrCreateProgram(z$1, {
								config: C$2,
								defines: g$2,
								overrideFog: B$2
							});
							if (!R$1 && S$1 && I$1 && s$3.lineAtlas) {
								const e$1 = s$3.lineAtlas.getDash(S$1, I$1);
								e$1 && C$2.setConstantPatternPositions(e$1);
							}
							w$2 && v$2.setupShadows(s$3.tileID.toUnwrapped(), k$2, "vector-tile");
							let [N$2, U$1] = o$1.paint.get("line-trim-offset");
							if ("round" === I$1 || "square" === I$1) {
								const e$1 = 1;
								N$2 !== U$1 && (0 === N$2 && (N$2 -= e$1), 1 === U$1 && (U$1 += e$1));
							}
							const j$1 = x$1 ? _$2.projMatrix : null, G$1 = d$1 ? 1 / m$2.tileToMeter / e.ay(s$3, 1, t$1.transform.zoom) : 1, V$1 = d$1 ? 1 / m$2.tileToMeter / e.ay(s$3, 1, Math.floor(t$1.transform.zoom)) : 1, H$1 = R$1 ? e.e4(t$1, s$3, o$1, j$1, b$1, G$1, V$1, [N$2, U$1], E$2, A$1) : e.e5(t$1, s$3, o$1, j$1, m$2.lineClipsArray.length, b$1, G$1, V$1, [N$2, U$1], E$2);
							if (O$1) {
								const s$4 = m$2.gradients[o$1.id];
								let r$3 = s$4.texture;
								if (o$1.gradientVersion !== s$4.version) {
									let n$3 = 256;
									if (o$1.stepInterpolant) {
										const o$2 = i$1.getSource().maxzoom, s$5 = _$2.canonical.z === o$2 ? Math.ceil(1 << t$1.transform.maxZoom - _$2.canonical.z) : 1;
										n$3 = e.aA(e.e6(m$2.maxLineLength / e.al * 1024 * s$5), 256, p$1.maxTextureSize);
									}
									s$4.gradient = e.e7({
										expression: o$1.gradientExpression(),
										evaluationKey: "lineProgress",
										resolution: n$3,
										image: s$4.gradient || void 0,
										clips: m$2.lineClipsArray
									}), s$4.texture ? s$4.texture.update(s$4.gradient) : s$4.texture = new e.T(p$1, s$4.gradient, f$1.RGBA8), s$4.version = o$1.gradientVersion, r$3 = s$4.texture;
								}
								p$1.activeTexture.set(f$1.TEXTURE1), r$3.bind(o$1.stepInterpolant ? f$1.NEAREST : f$1.LINEAR, f$1.CLAMP_TO_EDGE);
							}
							T$1 && (p$1.activeTexture.set(f$1.TEXTURE0), s$3.lineAtlasTexture && s$3.lineAtlasTexture.bind(f$1.LINEAR, f$1.REPEAT), C$2.updatePaintBuffers()), R$1 && (p$1.activeTexture.set(f$1.TEXTURE0), s$3.imageAtlasTexture && s$3.imageAtlasTexture.bind(f$1.LINEAR, f$1.CLAMP_TO_EDGE), C$2.updatePaintBuffers()), l$2 && !u$1 && t$1.terrain.setupElevationDraw(s$3, k$2), t$1.uploadCommonUniforms(p$1, k$2, _$2.toUnwrapped());
							const q$1 = (e$1) => {
								null != F$1 && (F$1.value = D$1 * c$1), k$2.draw(t$1, f$1.TRIANGLES, n$2, e$1, y$1, eo.disabled, H$1, o$1.id, m$2.layoutVertexBuffer, m$2.indexBuffer, m$2.segments, o$1.paint, t$1.transform.zoom, C$2, [
									m$2.layoutVertexBuffer2,
									m$2.patternVertexBuffer,
									m$2.zOffsetVertexBuffer
								]), null != F$1 && (F$1.value = D$1);
							};
							if (P$1 && !l$2) {
								const e$1 = t$1.stencilModeForClipping(_$2).ref;
								0 === e$1 && x$1 && p$1.clear({ stencil: 0 });
								const i$2 = {
									func: f$1.EQUAL,
									mask: 255
								};
								H$1.u_alpha_discard_threshold = .8, q$1(new Ki(i$2, e$1, 255, f$1.KEEP, f$1.KEEP, f$1.INVERT)), H$1.u_alpha_discard_threshold = 0, q$1(new Ki(i$2, e$1, 255, f$1.KEEP, f$1.KEEP, f$1.KEEP));
							} else H$1.u_alpha_discard_threshold = P$1 && l$2 && h$2 ? .8 : 0, q$1(l$2 ? a$2 : t$1.stencilModeForClipping(_$2));
						}
					};
					let k$1 = t$1.depthModeForSublayer(0, Xi.ReadOnly);
					const N$1 = new Xi(t$1.depthOcclusion ? f$1.GREATER : f$1.LEQUAL, Xi.ReadOnly, t$1.depthRangeFor3D);
					if (o$1.hasNonElevatedBuckets) {
						const i$2 = !x$1 && t$1.terrain;
						0 !== c$1 && i$2 ? e.w(`Occlusion opacity for layer ${o$1.id} is supported on terrain only if the layer has line-z-offset enabled.`) : i$2 ? e.w(`Cannot render non-elevated lines in immediate mode when terrain is enabled. Layer: ${o$1.id}.`) : B$1(s$1, M$1, k$1, Ki.disabled, !1, !0);
					}
					if (o$1.hasElevatedBuckets) {
						"hd-road-markup" === h$1 ? _$1 || (k$1 = N$1, M$1.push("ELEVATED_ROADS")) : (M$1.push("ELEVATED"), k$1 = N$1, g$1 && M$1.push(v$1 ? "CROSS_SLOPE_HORIZONTAL" : "CROSS_SLOPE_VERTICAL"), u$1 && M$1.push("ELEVATION_REFERENCE_SEA"));
						const e$1 = P$1 ? t$1.stencilModeFor3D() : Ki.disabled;
						t$1.forceTerrainMode = !0, B$1(s$1, M$1, k$1, e$1, !0, !0), P$1 && B$1(s$1, M$1, k$1, e$1, !0, !1), t$1.forceTerrainMode = !1;
					}
					P$1 && (t$1.resetStencilClippingMasks(), x$1 && p$1.clear({ stencil: 0 })), 0 === c$1 || t$1.depthOcclusion || x$1 || t$1.layersWithOcclusionOpacity.push(t$1.currentLayer);
				},
				fill: function(t$1, i$1, o$1, s$1) {
					const r$1 = o$1.paint.get("fill-color"), n$1 = o$1.paint.get("fill-opacity");
					if (0 === n$1.constantOr(1)) return;
					const a$1 = o$1.paint.get("fill-emissive-strength"), l$1 = t$1.colorModeForDrapableLayerRenderPass(a$1), c$1 = o$1.paint.get("fill-pattern"), h$1 = t$1.opaquePassEnabledForLayer() && !c$1.constantOr(1) && 1 === r$1.constantOr(e.ao.transparent).a && 1 === n$1.constantOr(0) ? "opaque" : "translucent";
					let d$1 = "none";
					"none" !== o$1.layout.get("fill-elevation-reference") ? d$1 = "road" : 0 !== o$1.paint.get("fill-z-offset").constantOr(1) && (d$1 = "offset");
					const u$1 = !(!t$1.terrain || !t$1.terrain.enabled), _$1 = {
						painter: t$1,
						sourceCache: i$1,
						layer: o$1,
						coords: s$1,
						colorMode: l$1,
						elevationType: d$1,
						terrainEnabled: u$1,
						pass: h$1
					};
					if ("shadow" === t$1.renderPass) return void (t$1.shadowRenderer && "road" === d$1 && !u$1 && function(e$1) {
						const { painter: t$2, sourceCache: i$2, layer: o$2, coords: s$2 } = e$1, r$2 = t$2.context.gl, n$2 = e$1.painter.shadowRenderer;
						for (const e$2 of s$2) {
							const s$3 = i$2.getTile(e$2), a$2 = s$3.getBucket(o$2);
							if (!a$2) continue;
							const l$2 = a$2.elevatedStructures;
							if (!l$2) continue;
							if (!l$2.shadowCasterSegments || 0 === l$2.shadowCasterSegments.segments[0].primitiveLength) continue;
							t$2.prepareDrawTile();
							const c$2 = a$2.bufferData.programConfigurations.get(o$2.id), h$2 = t$2.isTileAffectedByFog(e$2), d$2 = t$2.getOrCreateProgram("elevatedStructuresDepth", {
								config: c$2,
								overrideFog: h$2
							}), u$2 = n$2.calculateShadowPassMatrixFromTile(s$3.tileID.toUnwrapped());
							t$2.uploadCommonUniforms(t$2.context, d$2, e$2.toUnwrapped());
							const _$2 = {
								u_matrix: u$2,
								u_depth_bias: 0
							};
							d$2.draw(t$2, r$2.TRIANGLES, n$2.getShadowPassDepthMode(), Ki.disabled, n$2.getShadowPassColorMode(), eo.disabled, _$2, o$2.id, l$2.vertexBuffer, l$2.indexBuffer, l$2.shadowCasterSegments, o$2.paint, t$2.transform.zoom, c$2);
						}
					}(_$1));
					const p$1 = "mrt-fallback" === t$1.emissiveMode;
					if ("offset" !== d$1) {
						if (cn(_$1, !1, p$1), "road" === d$1) {
							const e$1 = !u$1 && "translucent" === t$1.renderPass;
							e$1 && ln(t$1, i$1, o$1, s$1, "geometry"), cn(_$1, !0, p$1, Ki.disabled), e$1 && function(e$2) {
								const { painter: t$2, sourceCache: i$2, layer: o$2, coords: s$2, colorMode: r$2 } = e$2, n$2 = t$2.context.gl, a$2 = e$2.painter.shadowRenderer, l$2 = !!a$2 && a$2.enabled, c$2 = new Xi(t$2.context.gl.LEQUAL, Xi.ReadOnly, t$2.depthRangeFor3D);
								let h$2 = [
									0,
									0,
									0
								];
								if (l$2) {
									const e$3 = t$2.style.directionalLight, i$3 = t$2.style.ambientLight;
									e$3 && i$3 && (h$2 = vo(t$2.style, e$3, i$3));
								}
								const d$2 = (e$3) => {
									for (const d$3 of s$2) {
										const s$3 = i$2.getTile(d$3), u$2 = s$3.getBucket(o$2);
										if (!u$2) continue;
										const _$2 = u$2.elevatedStructures;
										if (!_$2) continue;
										let p$2, f$1;
										if (e$3 ? (p$2 = _$2.renderableBridgeSegments, f$1 = _$2.bridgeProgramConfigurations.get(o$2.id)) : (p$2 = _$2.renderableTunnelSegments, f$1 = _$2.tunnelProgramConfigurations.get(o$2.id)), !p$2 || 0 === p$2.segments[0].primitiveLength) continue;
										f$1.updatePaintBuffers(), t$2.prepareDrawTile();
										const m$1 = t$2.isTileAffectedByFog(d$3), g$1 = [];
										l$2 && g$1.push("RENDER_SHADOWS", "DEPTH_TEXTURE", "NORMAL_OFFSET");
										const v$1 = t$2.getOrCreateProgram("elevatedStructures", {
											config: f$1,
											overrideFog: m$1,
											defines: g$1
										}), y$1 = t$2.translatePosMatrix(d$3.projMatrix, s$3, o$2.paint.get("fill-translate"), o$2.paint.get("fill-translate-anchor"));
										l$2 && a$2.setupShadows(s$3.tileID.toUnwrapped(), v$1, "vector-tile");
										const x$1 = wr(y$1, h$2);
										t$2.uploadCommonUniforms(t$2.context, v$1, d$3.toUnwrapped()), v$1.draw(t$2, n$2.TRIANGLES, c$2, Ki.disabled, r$2, eo.backCCW, x$1, o$2.id, _$2.vertexBuffer, _$2.indexBuffer, p$2, o$2.paint, t$2.transform.zoom, f$1, [_$2.vertexBufferNormal]);
									}
								};
								d$2(!0), d$2(!1);
							}(_$1);
						}
					} else cn(_$1, !1, p$1, t$1.stencilModeFor3D());
				},
				"fill-extrusion": function(t$1, i$1, o$1, s$1) {
					const r$1 = o$1.paint.get("fill-extrusion-opacity"), n$1 = t$1.context, a$1 = n$1.gl, l$1 = t$1.terrain, c$1 = l$1 && l$1.renderingToTexture;
					if (0 === r$1) return;
					const h$1 = "mrt-fallback" === t$1.emissiveMode, d$1 = t$1.conflationActive && t$1.style.isLayerClipped(o$1, i$1.getSource()), u$1 = t$1.style.order.indexOf(o$1.fqid);
					if (d$1 && function(e$1, t$2, i$2, o$2, s$2) {
						for (const r$2 of o$2) {
							const o$3 = t$2.getTile(r$2).getBucket(i$2);
							o$3 && (o$3.updateReplacement(r$2, e$1.replacementSource, s$2), o$3.uploadCentroid(e$1.context));
						}
					}(t$1, i$1, o$1, s$1, u$1), l$1 || d$1) for (const e$1 of s$1) {
						const s$2 = i$1.getTile(e$1).getBucket(o$1);
						s$2 && _n(t$1.context, i$1, e$1, s$2, o$1, l$1, d$1);
					}
					if ("shadow" === t$1.renderPass && t$1.shadowRenderer) {
						const n$2 = t$1.shadowRenderer;
						if (l$1 && r$1 < .65 && o$1._transitionablePaint._values["fill-extrusion-opacity"].value.expression instanceof e.ad) return;
						const a$2 = n$2.getShadowPassDepthMode(), c$2 = n$2.getShadowPassColorMode();
						hn(t$1, i$1, o$1, s$1, a$2, Ki.disabled, c$2, d$1);
					} else if ("translucent" === t$1.renderPass) {
						const u$2 = !o$1.paint.get("fill-extrusion-pattern").constantOr(1), _$1 = o$1.paint.get("fill-extrusion-color").constantOr(e.ao.white);
						if (!c$1 && 0 !== _$1.a) {
							const e$1 = new Xi(t$1.context.gl.LEQUAL, Xi.ReadWrite, t$1.depthRangeFor3D);
							1 === r$1 && u$2 ? hn(t$1, i$1, o$1, s$1, e$1, Ki.disabled, $i.unblended, d$1) : (hn(t$1, i$1, o$1, s$1, e$1, Ki.disabled, $i.disabled, d$1), hn(t$1, i$1, o$1, s$1, e$1, t$1.stencilModeFor3D(), t$1.colorModeForRenderPass(), d$1), t$1.resetStencilClippingMasks());
						}
						if (t$1.style.enable3dLights() && u$2 && (!l$1 && "globe" !== t$1.transform.projection.name || c$1)) {
							const r$2 = o$1.paint.get("fill-extrusion-opacity"), u$3 = o$1.paint.get("fill-extrusion-ambient-occlusion-intensity"), _$2 = o$1.paint.get("fill-extrusion-ambient-occlusion-ground-radius"), p$1 = o$1.paint.get("fill-extrusion-flood-light-intensity"), f$1 = "none" === o$1.paint.get("fill-extrusion-flood-light-color-use-theme").constantOr("default"), m$1 = o$1.paint.get("fill-extrusion-flood-light-color").toNonPremultipliedRenderColor(f$1 ? null : o$1.lut).toArray01().slice(0, 3), g$1 = u$3 > 0 && _$2 > 0, v$1 = p$1 > 0, y$1 = (e$1, t$2, i$2) => (1 - i$2) * e$1 + i$2 * t$2, x$1 = new dn();
							x$1.translate = o$1.paint.get("fill-extrusion-translate"), x$1.translateAnchor = o$1.paint.get("fill-extrusion-translate-anchor"), x$1.edgeRadius = o$1.layout.get("fill-extrusion-edge-radius"), x$1.cutoffFadeRange = o$1.paint.get("fill-extrusion-cutoff-fade-range");
							const b$1 = (n$2) => {
								const l$2 = t$1.depthModeForSublayer(1, Xi.ReadOnly, a$1.LEQUAL, !0), h$2 = y$1(.1, 3, o$1.paint.get(n$2 ? "fill-extrusion-ambient-occlusion-ground-attenuation" : "fill-extrusion-flood-light-ground-attenuation")), f$2 = t$1._showOverdrawInspector;
								if (!f$2) un(x$1, t$1, i$1, o$1, s$1, l$2, new Ki({
									func: a$1.ALWAYS,
									mask: 255
								}, 255, 255, a$1.KEEP, a$1.KEEP, a$1.REPLACE), new $i([
									a$1.ONE,
									a$1.ONE,
									a$1.ONE,
									a$1.ONE
								], e.ao.transparent, [
									!1,
									!1,
									!1,
									!0
								], a$1.MIN), eo.disabled, n$2, "sdf", r$2, u$3, _$2, p$1, m$1, h$2, d$1, !1);
								un(x$1, t$1, i$1, o$1, s$1, l$2, f$2 ? Ki.disabled : new Ki({
									func: a$1.EQUAL,
									mask: 255
								}, 255, 255, a$1.KEEP, a$1.DECR, a$1.DECR), f$2 ? t$1.colorModeForRenderPass() : new $i([
									a$1.ONE_MINUS_DST_ALPHA,
									a$1.DST_ALPHA,
									a$1.ONE,
									a$1.ONE
								], e.ao.transparent, [
									!0,
									!0,
									!0,
									!0
								]), eo.disabled, n$2, "color", r$2, u$3, _$2, p$1, m$1, h$2, d$1, !1);
							};
							if (c$1) {
								const c$2 = () => {
									const t$2 = l$1.drapeBufferSize[0], i$2 = l$1.drapeBufferSize[1];
									let o$2 = l$1.framebufferCopyTexture;
									return o$2 && (!o$2 || o$2.size[0] === t$2 && o$2.size[1] === i$2) || (o$2 && o$2.destroy(), o$2 = l$1.framebufferCopyTexture = new e.T(n$1, new e.q({
										width: t$2,
										height: i$2
									}), a$1.RGBA8)), o$2.bind(a$1.LINEAR, a$1.CLAMP_TO_EDGE), a$1.copyTexSubImage2D(a$1.TEXTURE_2D, 0, 0, 0, 0, 0, t$2, i$2), o$2;
								}, f$2 = (n$2, l$2, f$3) => {
									const g$2 = t$1.depthModeForSublayer(1, Xi.ReadOnly, a$1.LEQUAL, !1), b$2 = y$1(.1, 3, o$1.paint.get(n$2 ? "fill-extrusion-ambient-occlusion-ground-attenuation" : "fill-extrusion-flood-light-ground-attenuation"));
									{
										const c$3 = new $i([
											a$1.ONE,
											a$1.ONE,
											a$1.ONE,
											a$1.ONE
										], e.ao.transparent, [
											!1,
											!1,
											!1,
											!0
										]);
										un(x$1, t$1, i$1, o$1, s$1, g$2, Ki.disabled, c$3, eo.disabled, n$2, "clear", r$2, u$3, _$2, p$1, m$1, b$2, d$1, l$2);
									}
									un(x$1, t$1, i$1, o$1, s$1, g$2, new Ki({
										func: a$1.ALWAYS,
										mask: 255
									}, 255, 255, a$1.KEEP, a$1.KEEP, a$1.REPLACE), new $i([
										a$1.ONE,
										a$1.ONE,
										a$1.ONE,
										a$1.ONE
									], e.ao.transparent, [
										!1,
										!1,
										!1,
										!0
									], a$1.MIN), eo.disabled, n$2, "sdf", r$2, u$3, _$2, p$1, m$1, b$2, d$1, l$2);
									h$1 && !n$2 && (f$3 = c$2());
									{
										const c$3 = n$2 ? a$1.ZERO : a$1.ONE_MINUS_DST_ALPHA;
										un(x$1, t$1, i$1, o$1, s$1, g$2, new Ki({
											func: a$1.EQUAL,
											mask: 255
										}, 255, 255, a$1.KEEP, a$1.DECR, a$1.DECR), new $i([
											c$3,
											a$1.DST_ALPHA,
											a$1.ONE_MINUS_DST_ALPHA,
											a$1.ZERO
										], e.ao.transparent, [
											!0,
											!0,
											!0,
											!0
										]), eo.disabled, n$2, "color", r$2, u$3, _$2, p$1, m$1, b$2, d$1, l$2);
									}
									if (!h$1 || n$2) {
										const c$3 = new $i([
											a$1.ONE,
											a$1.ONE,
											a$1.ONE,
											n$2 ? a$1.ZERO : a$1.ONE
										], e.ao.transparent, [
											!1,
											!1,
											!1,
											!0
										], n$2 ? a$1.FUNC_ADD : a$1.MAX);
										un(x$1, t$1, i$1, o$1, s$1, g$2, Ki.disabled, c$3, eo.disabled, n$2, "clear", r$2, u$3, _$2, p$1, m$1, b$2, d$1, l$2, f$3);
									} else {
										a$1.drawBuffers([a$1.NONE, a$1.COLOR_ATTACHMENT1]);
										un(x$1, t$1, i$1, o$1, s$1, g$2, new Ki({
											func: a$1.EQUAL,
											mask: 255
										}, 254, 255, a$1.KEEP, a$1.DECR, a$1.DECR), new $i([
											a$1.ONE,
											a$1.ONE,
											a$1.ONE,
											a$1.ONE
										], e.ao.transparent, [
											!0,
											!1,
											!1,
											!1
										], a$1.MAX), eo.disabled, n$2, "emissive", r$2, u$3, _$2, p$1, m$1, b$2, d$1, l$2, f$3), a$1.drawBuffers([a$1.COLOR_ATTACHMENT0]);
									}
								};
								if (g$1 || v$1) {
									let e$1;
									t$1.prepareDrawTile(), h$1 && !g$1 || (e$1 = c$2()), g$1 && f$2(!0, !1, e$1), v$1 && f$2(!1, !0, e$1);
								}
							} else g$1 && b$1(!0), v$1 && b$1(!1), (g$1 || v$1) && t$1.resetStencilClippingMasks();
						}
					}
				},
				building: function(e$1, t$1, i$1, o$1) {
					e$1.currentLayer < e$1.firstLightBeamLayer && (e$1.firstLightBeamLayer = e$1.currentLayer);
					const s$1 = i$1.paint.get("building-ambient-occlusion-ground-intensity"), r$1 = i$1.paint.get("building-ambient-occlusion-ground-radius"), n$1 = i$1.paint.get("building-ambient-occlusion-ground-attenuation"), a$1 = i$1.paint.get("building-opacity");
					if (a$1 <= 0) return;
					let l$1 = s$1 > 0 && r$1 > 0, c$1 = !0;
					const h$1 = i$1.paint.get("building-vertical-scale");
					if (h$1 <= 0) return;
					e$1.shadowRenderer || (c$1 = !1);
					const d$1 = e$1.conflationActive && e$1.style.isLayerClipped(i$1, t$1.getSource());
					if (function(e$2, t$2, i$2, o$2, s$2, r$2) {
						for (const n$2 of r$2) {
							const r$3 = t$2.getTile(n$2).getBucket(i$2);
							r$3 && (s$2 && r$3.updateReplacement(n$2, e$2.replacementSource, o$2), r$3.uploadUpdatedIndexBuffer(e$2.context));
						}
					}(e$1, t$1, i$1, e$1.style.order.indexOf(i$1.fqid), d$1, o$1), function(e$2, t$2, i$2, o$2) {
						for (const s$2 of o$2) {
							const o$3 = t$2.getTile(s$2).getBucket(i$2);
							o$3 && o$3.needsEvaluation() && o$3.uploadUpdatedColorBuffer(e$2.context);
						}
					}(e$1, t$1, i$1, o$1), i$1.resetLayerRenderingStats(e$1), e$1.shadowRenderer && (e$1.shadowRenderer.useNormalOffset = !0), "shadow" === e$1.renderPass && e$1.shadowRenderer) {
						const s$2 = e$1.shadowRenderer, r$2 = [], n$2 = s$2.getShadowPassDepthMode();
						vn({
							painter: e$1,
							source: t$1,
							layer: i$1,
							coords: o$1,
							defines: r$2,
							blendMode: s$2.getShadowPassColorMode(),
							depthMode: n$2,
							opacity: a$1,
							verticalScale: h$1,
							facadeEmissiveChance: 0,
							facadeAOIntensity: 0,
							floodLightIntensity: 0,
							floodLightColor: [
								0,
								0,
								0
							]
						});
					} else if ("translucent" === e$1.renderPass) {
						let u$1 = ["HAS_ATTRIBUTE_a_part_color_emissive", "LIGHTING_3D_MODE"];
						c$1 && (u$1 = u$1.concat("RENDER_SHADOWS", "DEPTH_TEXTURE")), e$1.shadowRenderer && e$1.shadowRenderer.useNormalOffset && (u$1 = u$1.concat("NORMAL_OFFSET"));
						const _$1 = i$1.paint.get("building-facade-emissive-chance"), p$1 = i$1.paint.get("building-ambient-occlusion-intensity"), f$1 = i$1.paint.get("building-flood-light-intensity"), m$1 = "none" === i$1.paint.get("building-flood-light-color-use-theme").constantOr("default"), g$1 = i$1.paint.get("building-flood-light-color").toNonPremultipliedRenderColor(m$1 ? null : i$1.lut).toArray01().slice(0, 3), v$1 = i$1.paint.get("building-flood-light-ground-attenuation"), y$1 = f$1 > 0, x$1 = new Xi(e$1.context.gl.LEQUAL, Xi.ReadWrite, e$1.depthRangeFor3D);
						a$1 < 1 && vn({
							painter: e$1,
							source: t$1,
							layer: i$1,
							coords: o$1,
							defines: u$1,
							blendMode: $i.disabled,
							depthMode: x$1,
							opacity: a$1,
							verticalScale: h$1,
							facadeEmissiveChance: _$1,
							facadeAOIntensity: p$1,
							floodLightIntensity: f$1,
							floodLightColor: g$1,
							depthOnly: !0
						});
						const b$1 = e$1.colorModeForRenderPass();
						vn({
							painter: e$1,
							source: t$1,
							layer: i$1,
							coords: o$1,
							defines: u$1,
							blendMode: b$1,
							depthMode: x$1,
							opacity: a$1,
							verticalScale: h$1,
							facadeEmissiveChance: _$1,
							facadeAOIntensity: p$1,
							floodLightIntensity: f$1,
							floodLightColor: g$1
						}), l$1 && yn(e$1, t$1, i$1, o$1, !0, a$1, s$1, r$1, f$1, g$1, n$1, d$1), y$1 && yn(e$1, t$1, i$1, o$1, !1, a$1, s$1, r$1, f$1, g$1, v$1, d$1);
					} else if ("light-beam" === e$1.renderPass) {
						const s$2 = ["HAS_ATTRIBUTE_a_part_color_emissive", "HAS_ATTRIBUTE_a_bloom_attenuation"], r$2 = new Xi(e$1.context.gl.LEQUAL, Xi.ReadOnly, e$1.depthRangeFor3D);
						vn({
							painter: e$1,
							source: t$1,
							layer: i$1,
							coords: o$1,
							defines: s$2,
							blendMode: $i.alphaBlended,
							depthMode: r$2,
							opacity: a$1,
							verticalScale: h$1,
							facadeEmissiveChance: 0,
							facadeAOIntensity: 0,
							floodLightIntensity: 0,
							floodLightColor: [
								0,
								0,
								0
							]
						});
					}
					e$1.shadowRenderer && (e$1.shadowRenderer.useNormalOffset = !1), e$1.resetStencilClippingMasks();
				},
				hillshade: function(e$1, t$1, i$1, o$1) {
					if ("offscreen" !== e$1.renderPass && "translucent" !== e$1.renderPass) return;
					if (e$1.style.disableElevatedTerrain) return;
					const s$1 = e$1.context, r$1 = e$1.terrain && e$1.terrain.renderingToTexture, [n$1, a$1] = "translucent" !== e$1.renderPass || r$1 ? [{}, o$1] : e$1.stencilConfigForOverlap(o$1);
					for (const o$2 of a$1) {
						const s$2 = t$1.getTile(o$2);
						if (s$2.needsHillshadePrepare && "offscreen" === e$1.renderPass) cs(e$1, s$2, i$1);
						else if ("translucent" === e$1.renderPass) {
							const t$2 = e$1.depthModeForSublayer(0, Xi.ReadOnly), a$2 = i$1.paint.get("hillshade-emissive-strength"), l$1 = e$1.colorModeForDrapableLayerRenderPass(a$2);
							as(e$1, o$2, s$2, i$1, t$2, r$1 && e$1.terrain ? e$1.terrain.stencilModeForRTTOverlap(o$2) : n$1[o$2.overscaledZ], l$1);
						}
					}
					s$1.viewport.set([
						0,
						0,
						e$1.width,
						e$1.height
					]), e$1.resetStencilClippingMasks();
				},
				raster: function(t$1, i$1, o$1, s$1, r$1, n$1) {
					if ("translucent" !== t$1.renderPass) return;
					if (0 === o$1.paint.get("raster-opacity")) return;
					const a$1 = "globe" === t$1.transform.projection.name, l$1 = 0 !== o$1.paint.get("raster-elevation"), c$1 = l$1 && a$1;
					if (t$1.renderElevatedRasterBackface && !c$1) return;
					const h$1 = t$1.context, d$1 = h$1.gl, u$1 = i$1.getSource(), _$1 = function(t$2, i$2, o$2, s$2, r$2) {
						const n$2 = i$2.paint.get("raster-color"), a$2 = "raster-array" === t$2.type, l$2 = [], c$2 = i$2.paint.get("raster-resampling"), h$2 = i$2.paint.get("raster-color-mix");
						let d$2 = i$2.paint.get("raster-color-range");
						const u$2 = [
							h$2[0],
							h$2[1],
							h$2[2],
							0
						], _$2 = h$2[3];
						let p$2 = "nearest" === c$2 ? s$2.NEAREST : s$2.LINEAR;
						if (a$2 && (l$2.push("RASTER_ARRAY"), n$2 || l$2.push("RASTER_COLOR"), "linear" === c$2 && l$2.push("RASTER_ARRAY_LINEAR"), p$2 = s$2.NEAREST, !d$2 && t$2.rasterLayers)) {
							const e$1 = t$2.rasterLayers.find((({ id: e$2 }) => e$2 === i$2.sourceLayer));
							e$1 && e$1.fields && e$1.fields.range && (d$2 = e$1.fields.range);
						}
						if (d$2 = d$2 || [0, 1], n$2) {
							l$2.push("RASTER_COLOR"), o$2.activeTexture.set(s$2.TEXTURE2), i$2.updateColorRamp(d$2);
							let t$3 = i$2.colorRampTexture;
							t$3 || (t$3 = i$2.colorRampTexture = new e.T(o$2, i$2.colorRamp, s$2.RGBA8)), t$3.bind(s$2.LINEAR, s$2.CLAMP_TO_EDGE);
						}
						return r$2 && l$2.push("USE_MRT1"), {
							mix: u$2,
							range: d$2,
							offset: _$2,
							defines: l$2,
							resampling: p$2
						};
					}(u$1, o$1, h$1, d$1, t$1.terrain && t$1.terrain.renderingToTexture && "mrt-fallback" === t$1.emissiveMode);
					if (u$1 instanceof e.aU && !s$1.length && !a$1) return;
					const p$1 = o$1.paint.get("raster-emissive-strength"), f$1 = t$1.colorModeForDrapableLayerRenderPass(p$1), m$1 = t$1.terrain && t$1.terrain.renderingToTexture, g$1 = !t$1.options.moving, v$1 = "nearest" === o$1.paint.get("raster-resampling") ? d$1.NEAREST : d$1.LINEAR;
					if (u$1 instanceof e.aU && !s$1.length && (u$1.onNorthPole || u$1.onSouthPole)) {
						const e$1 = l$1 ? t$1.stencilModeFor3D() : Ki.disabled;
						bn(!!u$1.onNorthPole, null, t$1, i$1, o$1, p$1, _$1, eo.disabled, e$1);
						return;
					}
					if (!s$1.length) return;
					const [y$1, x$1] = u$1 instanceof e.aU || m$1 ? [{}, s$1] : t$1.stencilConfigForOverlap(s$1), b$1 = x$1[x$1.length - 1].overscaledZ;
					c$1 && _$1.defines.push("PROJECTION_GLOBE_VIEW"), l$1 && _$1.defines.push("RENDER_CUTOFF");
					const w$1 = (s$2, r$2, x$2) => {
						for (const w$2 of s$2) {
							const s$3 = w$2.toUnwrapped(), T$1 = i$1.getTile(w$2);
							if (m$1 && (!T$1 || !T$1.hasData())) continue;
							h$1.activeTexture.set(d$1.TEXTURE0);
							const E$1 = Tn(T$1, u$1, o$1, _$1);
							if (!E$1 || !E$1.texture) continue;
							const { texture: S$1, mix: I$1, offset: C$1, tileSize: R$1, buffer: A$1 } = E$1;
							let L$1, D$1;
							m$1 ? (L$1 = Xi.disabled, D$1 = w$2.projMatrix) : l$1 ? (L$1 = new Xi(d$1.LEQUAL, Xi.ReadWrite, t$1.depthRangeFor3D), D$1 = a$1 ? Float32Array.from(t$1.transform.expandedFarZProjMatrix) : t$1.transform.calculateProjMatrix(s$3, g$1)) : (L$1 = t$1.depthModeForSublayer(w$2.overscaledZ - b$1, 1 === o$1.paint.get("raster-opacity") ? Xi.ReadWrite : Xi.ReadOnly, d$1.LESS), D$1 = t$1.transform.calculateProjMatrix(s$3, g$1));
							const P$1 = t$1.terrain && m$1 ? t$1.terrain.stencilModeForRTTOverlap(w$2) : y$1[w$2.overscaledZ], O$1 = n$1 ? 0 : o$1.paint.get("raster-fade-duration");
							T$1.registerFadeDuration(O$1);
							const z$1 = i$1.findLoadedParent(w$2, 0), M$1 = ir(T$1, z$1, i$1, t$1.transform, O$1);
							let F$1, B$1;
							!M$1.isFading && T$1.refreshedUponExpiration && (T$1.refreshedUponExpiration = !1), t$1.terrain && t$1.terrain.prepareDrawTile(), h$1.activeTexture.set(d$1.TEXTURE0), S$1.bind(v$1, d$1.CLAMP_TO_EDGE), h$1.activeTexture.set(d$1.TEXTURE1), z$1 ? (z$1.texture && z$1.texture.bind(v$1, d$1.CLAMP_TO_EDGE), F$1 = Math.pow(2, z$1.tileID.overscaledZ - T$1.tileID.overscaledZ), B$1 = [T$1.tileID.canonical.x * F$1 % 1, T$1.tileID.canonical.y * F$1 % 1]) : S$1.bind(v$1, d$1.CLAMP_TO_EDGE), "useMipmap" in S$1 && h$1.extTextureFilterAnisotropic && t$1.transform.pitch > 20 && d$1.texParameterf(d$1.TEXTURE_2D, h$1.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, h$1.extTextureFilterAnisotropicMax);
							const k$1 = t$1.transform;
							let N$1;
							const U$1 = l$1 ? wn(k$1) : [
								0,
								0,
								0,
								0
							];
							let j$1, G$1, V$1, H$1, q$1, Z$1 = 0;
							if (c$1 && u$1 instanceof e.aU && u$1.coordinates.length > 3) j$1 = Float32Array.from(e.bk(e.dJ(new e.cD(0, 0, 0)))), G$1 = Float32Array.from(k$1.globeMatrix), V$1 = Float32Array.from(e.dF(k$1)), H$1 = [e.aF(k$1.center.lng), e.aJ(k$1.center.lat)], N$1 = u$1.elevatedGlobePerspectiveTransform, q$1 = u$1.elevatedGlobeGridMatrix || new Float32Array(9);
							else if (c$1) {
								const t$2 = e.dG(w$2.canonical);
								Z$1 = e.dH(t$2.getCenter().lat), j$1 = Float32Array.from(e.bk(e.dJ(w$2.canonical))), G$1 = Float32Array.from(k$1.globeMatrix), V$1 = Float32Array.from(e.dF(k$1)), H$1 = [e.aF(k$1.center.lng), e.aJ(k$1.center.lat)], N$1 = [0, 0], q$1 = Float32Array.from(e.dI(w$2.canonical, t$2, Z$1, k$1.worldSize / k$1._pixelsPerMercatorPixel));
							} else N$1 = u$1 instanceof e.aU ? u$1.perspectiveTransform : [0, 0], j$1 = new Float32Array(16), G$1 = new Float32Array(9), V$1 = new Float32Array(16), H$1 = [0, 0], q$1 = new Float32Array(9);
							const W$1 = Or(D$1, j$1, G$1, V$1, q$1, B$1 || [0, 0], e.aj(t$1.transform.zoom), H$1, U$1, F$1 || 1, M$1, o$1, N$1, l$1 ? o$1.paint.get("raster-elevation") : 0, 2, I$1, C$1, _$1.range, R$1, A$1, p$1), $$1 = t$1.isTileAffectedByFog(w$2), X$1 = t$1.getOrCreateProgram("raster", {
								defines: _$1.defines,
								overrideFog: $$1
							});
							if (t$1.uploadCommonUniforms(h$1, X$1, s$3), u$1 instanceof e.aU) {
								const i$2 = u$1.elevatedGlobeVertexBuffer, s$4 = u$1.elevatedGlobeIndexBuffer;
								if (m$1 || !a$1) u$1.boundsBuffer && u$1.boundsSegments && X$1.draw(t$1, d$1.TRIANGLES, L$1, Ki.disabled, f$1, eo.disabled, W$1, o$1.id, u$1.boundsBuffer, t$1.quadTriangleIndexBuffer, u$1.boundsSegments);
								else if (i$2 && s$4) {
									const n$2 = k$1.zoom <= e.c_ ? u$1.elevatedGlobeSegments : u$1.getSegmentsForLongitude(k$1.center.lng);
									n$2 && X$1.draw(t$1, d$1.TRIANGLES, L$1, Ki.disabled, f$1, r$2, W$1, o$1.id, i$2, s$4, n$2);
								}
							} else if (c$1) {
								L$1 = new Xi(d$1.LEQUAL, Xi.ReadOnly, t$1.depthRangeFor3D);
								const e$1 = t$1.globeSharedBuffers;
								if (e$1) {
									const [i$2, s$4, n$2] = e$1.getGridBuffers(Z$1, !1);
									X$1.draw(t$1, d$1.TRIANGLES, L$1, x$2 || P$1, t$1.colorModeForRenderPass(), r$2, W$1, o$1.id, i$2, s$4, n$2);
								}
							} else {
								const { tileBoundsBuffer: e$1, tileBoundsIndexBuffer: i$2, tileBoundsSegments: s$4 } = t$1.getTileBoundsBuffers(T$1);
								X$1.draw(t$1, d$1.TRIANGLES, L$1, P$1, f$1, eo.disabled, W$1, o$1.id, e$1, i$2, s$4);
							}
						}
						if (!(u$1 instanceof e.aU) && c$1) for (const e$1 of s$2) {
							const s$3 = e$1.canonical.y === (1 << e$1.canonical.z) - 1;
							0 === e$1.canonical.y && bn(!0, e$1, t$1, i$1, o$1, p$1, _$1, r$2, x$2 || Ki.disabled), s$3 && bn(!1, e$1, t$1, i$1, o$1, p$1, _$1, r$2 === eo.frontCW ? eo.backCW : eo.frontCW, x$2 || Ki.disabled);
						}
					};
					c$1 ? w$1(x$1, t$1.renderElevatedRasterBackface ? eo.backCW : eo.frontCW, t$1.stencilModeFor3D()) : w$1(x$1, eo.disabled, void 0), t$1.resetStencilClippingMasks();
				},
				"raster-particle": function(t$1, i$1, o$1, s$1, r$1, n$1) {
					"offscreen" === t$1.renderPass && function(t$2, i$2, o$2, s$2) {
						if (!s$2.length) return;
						const r$2 = t$2.context, n$2 = r$2.gl, a$1 = i$2.getSource();
						if (!(a$1 instanceof pt)) return;
						const l$1 = Math.ceil(Math.sqrt(o$2.paint.get("raster-particle-count")));
						let c$1 = o$2.particlePositionRGBAImage;
						if (!c$1 || c$1.width !== l$1) {
							const t$3 = function(e$1) {
								const t$4 = e$1 * e$1, i$3 = new Uint8Array(4 * t$4), o$3 = function(e$2) {
									return e$2 |= 0, e$2 = Math.imul(2747636419 ^ e$2, 2654435769), e$2 = Math.imul(e$2 ^ e$2 >>> 16, 2654435769), ((e$2 = Math.imul(e$2 ^ e$2 >>> 16, 2654435769)) >>> 0) / 4294967296;
								}, s$3 = 1 / 1.1;
								for (let e$2 = 0; e$2 < t$4; e$2++) {
									const t$5 = s$3 * (o$3(2 * e$2 + 0) + Mr), r$3 = s$3 * (o$3(2 * e$2 + 1) + Mr), n$3 = 255 * t$5 % 1, a$2 = 255 * r$3 % 1, l$2 = n$3, c$2 = r$3 - a$2 / 255, h$2 = a$2;
									i$3[4 * e$2 + 0] = 255 * (t$5 - n$3 / 255), i$3[4 * e$2 + 1] = 255 * l$2, i$3[4 * e$2 + 2] = 255 * c$2, i$3[4 * e$2 + 3] = 255 * h$2;
								}
								return i$3;
							}(l$1);
							c$1 = o$2.particlePositionRGBAImage = new e.q({
								width: l$1,
								height: l$1
							}, t$3);
						}
						let h$1 = o$2.particleFramebuffer;
						h$1 ? h$1.width !== l$1 && (h$1.destroy(), h$1 = o$2.particleFramebuffer = r$2.createFramebuffer(l$1, l$1, 1, null)) : h$1 = o$2.particleFramebuffer = r$2.createFramebuffer(l$1, l$1, 1, null);
						const d$1 = [];
						for (const e$1 of s$2) {
							const t$3 = i$2.getTile(e$1);
							if (!(t$3 instanceof Ot)) continue;
							const s$3 = In(t$3, a$1, o$2);
							if (!s$3) continue;
							const n$3 = [t$3.tileSize, t$3.tileSize];
							let h$2 = o$2.tileFramebuffer;
							h$2 || (h$2 = o$2.tileFramebuffer = r$2.createFramebuffer(n$3[0], n$3[1], 1, null));
							let u$2 = t$3.rasterParticleState;
							u$2 || (u$2 = t$3.rasterParticleState = new Sn(r$2, e$1, n$3, c$1));
							const _$2 = u$2.update(o$2.lastInvalidatedAt);
							u$2.particleTextureDimension !== l$1 && u$2.updateParticleTexture(e$1, c$1);
							const p$1 = u$2.targetColorTexture;
							u$2.targetColorTexture = u$2.backgroundColorTexture, u$2.backgroundColorTexture = p$1;
							const f$1 = u$2.particleTexture0;
							u$2.particleTexture0 = u$2.particleTexture1, u$2.particleTexture1 = f$1, d$1.push([
								e$1,
								s$3,
								u$2,
								_$2
							]);
						}
						if (0 === d$1.length) return;
						const u$1 = e.o.now(), _$1 = o$2.previousDrawTimestamp ? .001 * (u$1 - o$2.previousDrawTimestamp) : .0167;
						if (o$2.previousDrawTimestamp = u$1, o$2.hasColorMap()) {
							r$2.activeTexture.set(n$2.TEXTURE0 + 2);
							let t$3 = o$2.colorRampTexture;
							t$3 || (t$3 = o$2.colorRampTexture = new e.T(r$2, o$2.colorRamp, n$2.RGBA8)), t$3.bind(n$2.LINEAR, n$2.CLAMP_TO_EDGE);
						}
						r$2.bindFramebuffer.set(o$2.tileFramebuffer.framebuffer), function(t$3, i$3, o$3) {
							const s$3 = t$3.context, r$3 = s$3.gl, n$3 = i$3.tileFramebuffer;
							s$3.activeTexture.set(r$3.TEXTURE0);
							const a$2 = {
								u_texture: 0,
								u_opacity: 1.05 * (c$2 = i$3.paint.get("raster-particle-fade-opacity-factor")) / (c$2 + .05)
							}, l$2 = t$3.getOrCreateProgram("rasterParticleTexture", {
								defines: [],
								overrideFog: !1
							});
							var c$2;
							for (const c$3 of o$3) {
								const [, , o$4, h$2] = c$3;
								n$3.colorAttachment0.set(o$4.targetColorTexture.texture), s$3.viewport.set([
									0,
									0,
									n$3.width,
									n$3.height
								]), s$3.clear({ color: e.ao.transparent }), h$2 && (o$4.backgroundColorTexture.bind(r$3.NEAREST, r$3.CLAMP_TO_EDGE), l$2.draw(t$3, r$3.TRIANGLES, Xi.disabled, Ki.disabled, $i.alphaBlended, eo.disabled, a$2, i$3.id, t$3.viewportBuffer, t$3.quadTriangleIndexBuffer, t$3.viewportSegments));
							}
						}(t$2, o$2, d$1), function(t$3, i$3, o$3, s$3) {
							const r$3 = t$3.context, n$3 = r$3.gl, a$2 = o$3.tileFramebuffer, l$2 = "globe" === t$3.transform.projection.name, c$2 = o$3.paint.get("raster-particle-max-speed");
							for (const h$2 of s$3) {
								const [s$4, d$2, u$2] = h$2;
								r$3.activeTexture.set(n$3.TEXTURE0 + 0), d$2.texture.bind(n$3.LINEAR, n$3.CLAMP_TO_EDGE), a$2.colorAttachment0.set(u$2.targetColorTexture.texture);
								const _$2 = t$3.getOrCreateProgram("rasterParticleDraw", {
									defines: d$2.defines,
									overrideFog: !1
								});
								r$3.activeTexture.set(n$3.TEXTURE0 + 1);
								const p$1 = d$2.scalarData ? [] : [
									0,
									1,
									2,
									3
								].map(((t$4) => e.e9[t$4](s$4)));
								p$1.push(s$4);
								const f$1 = s$4.canonical.x, m$1 = s$4.canonical.y;
								for (const e$1 of p$1) {
									const r$4 = i$3.getTile(l$2 ? e$1.wrapped() : e$1);
									if (!r$4) continue;
									const a$3 = r$4.rasterParticleState;
									if (!a$3) continue;
									const h$3 = e$1.canonical.x + (1 << e$1.canonical.z) * (e$1.wrap - s$4.wrap), u$3 = e$1.canonical.y;
									a$3.particleTexture0.bind(n$3.NEAREST, n$3.CLAMP_TO_EDGE);
									const p$2 = Br(1, a$3.particleTexture0.size[0], [h$3 - f$1, u$3 - m$1], 0, d$2.texture.size, 2, c$2, d$2.textureOffset, d$2.scale, d$2.offset);
									_$2.draw(t$3, n$3.POINTS, Xi.disabled, Ki.disabled, $i.alphaBlended, eo.disabled, p$2, o$3.id, a$3.particleIndexBuffer, void 0, a$3.particleSegment);
								}
							}
						}(t$2, i$2, o$2, d$1), r$2.bindFramebuffer.set(o$2.particleFramebuffer.framebuffer), function(t$3, i$3, o$3, s$3) {
							const r$3 = t$3.context, n$3 = r$3.gl, a$2 = i$3.paint.get("raster-particle-max-speed"), l$2 = s$3 * i$3.paint.get("raster-particle-speed-factor") * .15, c$2 = function(e$1) {
								return Math.pow(e$1, 6);
							}(.01 + 1 * i$3.paint.get("raster-particle-reset-rate-factor")), h$2 = i$3.particleFramebuffer;
							r$3.viewport.set([
								0,
								0,
								h$2.width,
								h$2.height
							]);
							for (const s$4 of o$3) {
								const [, o$4, d$2] = s$4;
								r$3.activeTexture.set(n$3.TEXTURE0 + 0), o$4.texture.bind(n$3.LINEAR, n$3.CLAMP_TO_EDGE), r$3.activeTexture.set(n$3.TEXTURE0 + 1);
								const u$2 = d$2.particleTexture0;
								u$2.bind(n$3.NEAREST, n$3.CLAMP_TO_EDGE);
								const _$2 = kr(1, u$2.size[0], 0, o$4.texture.size, a$2, l$2, c$2, o$4.textureOffset, o$4.scale, o$4.offset);
								h$2.colorAttachment0.set(d$2.particleTexture1.texture), r$3.clear({ color: e.ao.transparent }), t$3.getOrCreateProgram("rasterParticleUpdate", { defines: o$4.defines }).draw(t$3, n$3.TRIANGLES, Xi.disabled, Ki.disabled, $i.unblended, eo.disabled, _$2, i$3.id, t$3.viewportBuffer, t$3.quadTriangleIndexBuffer, t$3.viewportSegments);
							}
						}(t$2, o$2, d$1, _$1);
					}(t$1, i$1, o$1, s$1), "translucent" === t$1.renderPass && (function(t$2, i$2, o$2, s$2, r$2) {
						const n$2 = t$2.context, a$1 = n$2.gl, l$1 = i$2.getSource().tileSize, c$1 = 5 * (1 - e.ah(e.cL, e.cL + 1, t$2.transform.zoom)) * l$1 + o$2.paint.get("raster-particle-elevation"), h$1 = !t$2.options.moving, d$1 = "globe" === t$2.transform.projection.name;
						if (!s$2.length) return;
						const [u$1, _$1] = t$2.stencilConfigForOverlap(s$2), p$1 = [];
						d$1 && p$1.push("PROJECTION_GLOBE_VIEW");
						const f$1 = t$2.stencilModeFor3D();
						for (const s$3 of _$1) {
							const r$3 = s$3.toUnwrapped(), l$2 = i$2.getTile(s$3);
							if (!l$2.rasterParticleState) continue;
							const _$2 = l$2.rasterParticleState, m$1 = 100;
							l$2.registerFadeDuration(m$1);
							const g$1 = i$2.findLoadedParent(s$3, 0), v$1 = ir(l$2, g$1, i$2, t$2.transform, m$1);
							let y$1, x$1;
							t$2.terrain && t$2.terrain.prepareDrawTile(), n$2.activeTexture.set(a$1.TEXTURE0), _$2.targetColorTexture.bind(a$1.LINEAR, a$1.CLAMP_TO_EDGE), n$2.activeTexture.set(a$1.TEXTURE1), g$1 && g$1.rasterParticleState ? (g$1.rasterParticleState.targetColorTexture.bind(a$1.LINEAR, a$1.CLAMP_TO_EDGE), y$1 = Math.pow(2, g$1.tileID.overscaledZ - l$2.tileID.overscaledZ), x$1 = [l$2.tileID.canonical.x * y$1 % 1, l$2.tileID.canonical.y * y$1 % 1]) : _$2.targetColorTexture.bind(a$1.LINEAR, a$1.CLAMP_TO_EDGE);
							const b$1 = d$1 ? Float32Array.from(t$2.transform.expandedFarZProjMatrix) : t$2.transform.calculateProjMatrix(r$3, h$1), w$1 = t$2.transform, T$1 = Cn(w$1), E$1 = e.dG(s$3.canonical), S$1 = e.dH(E$1.getCenter().lat);
							let I$1, C$1, R$1, A$1, L$1;
							d$1 ? (I$1 = Float32Array.from(e.bk(e.dJ(s$3.canonical))), C$1 = Float32Array.from(w$1.globeMatrix), R$1 = Float32Array.from(e.dF(w$1)), A$1 = [e.aF(w$1.center.lng), e.aJ(w$1.center.lat)], L$1 = Float32Array.from(e.dI(s$3.canonical, E$1, S$1, w$1.worldSize / w$1._pixelsPerMercatorPixel))) : (I$1 = new Float32Array(16), C$1 = new Float32Array(9), R$1 = new Float32Array(16), A$1 = [0, 0], L$1 = new Float32Array(9));
							const D$1 = Fr(b$1, I$1, C$1, R$1, L$1, x$1 || [0, 0], e.aj(t$2.transform.zoom), A$1, T$1, y$1 || 1, v$1, c$1), P$1 = t$2.isTileAffectedByFog(s$3), O$1 = t$2.getOrCreateProgram("rasterParticle", {
								defines: p$1,
								overrideFog: P$1
							});
							if (t$2.uploadCommonUniforms(n$2, O$1, r$3), d$1) {
								const e$1 = new Xi(a$1.LEQUAL, Xi.ReadOnly, t$2.depthRangeFor3D), i$3 = 0, s$4 = t$2.globeSharedBuffers;
								if (s$4) {
									const [r$4, n$3, l$3] = s$4.getGridBuffers(S$1, 0 !== i$3);
									O$1.draw(t$2, a$1.TRIANGLES, e$1, f$1, $i.alphaBlended, t$2.renderElevatedRasterBackface ? eo.frontCCW : eo.backCCW, D$1, o$2.id, r$4, n$3, l$3);
								}
							} else {
								const e$1 = t$2.depthModeForSublayer(0, Xi.ReadOnly), i$3 = u$1[s$3.overscaledZ], { tileBoundsBuffer: r$4, tileBoundsIndexBuffer: n$3, tileBoundsSegments: c$2 } = t$2.getTileBoundsBuffers(l$2);
								O$1.draw(t$2, a$1.TRIANGLES, e$1, i$3, $i.alphaBlended, eo.disabled, D$1, o$2.id, r$4, n$3, c$2);
							}
						}
						t$2.resetStencilClippingMasks();
					}(t$1, i$1, o$1, s$1), t$1.style.map.triggerRepaint());
				},
				background: function(t$1, i$1, o$1, s$1) {
					const r$1 = o$1.paint.get("background-color"), n$1 = "none" === o$1.paint.get("background-color-use-theme").constantOr("default"), a$1 = o$1.paint.get("background-opacity"), l$1 = o$1.paint.get("background-emissive-strength"), c$1 = "viewport" === o$1.paint.get("background-pitch-alignment");
					if (0 === a$1) return;
					const h$1 = t$1.context, d$1 = h$1.gl, u$1 = t$1.transform, _$1 = u$1.tileSize, p$1 = o$1.paint.get("background-pattern");
					let f$1;
					if (void 0 !== p$1) {
						if (null === p$1) return;
						if (f$1 = t$1.imageManager.getPattern(e.I.from(p$1.toString()), o$1.scope, t$1.style.getLut(o$1.scope)), !f$1) return;
					}
					const m$1 = !p$1 && 1 === r$1.a && 1 === a$1 && t$1.opaquePassEnabledForLayer() ? "opaque" : "translucent";
					if (t$1.renderPass !== m$1) return;
					const g$1 = Ki.disabled, v$1 = t$1.depthModeForSublayer(0, "opaque" === m$1 ? Xi.ReadWrite : Xi.ReadOnly), y$1 = t$1.colorModeForDrapableLayerRenderPass(l$1), x$1 = p$1 ? "backgroundPattern" : "background";
					let b$1, w$1 = s$1;
					w$1 || (b$1 = t$1.getBackgroundTiles(), w$1 = Object.values(b$1).map(((e$1) => e$1.tileID))), p$1 && (h$1.activeTexture.set(d$1.TEXTURE0), t$1.imageManager.bind(t$1.context, o$1.scope));
					const T$1 = [];
					if (t$1.terrain && t$1.terrain.renderingToTexture && "mrt-fallback" === t$1.emissiveMode && T$1.push("USE_MRT1"), c$1) {
						const i$2 = t$1.getOrCreateProgram(x$1, {
							overrideFog: !1,
							overrideRtt: !0,
							defines: T$1
						}), s$2 = new Float32Array(e.bA([])), h$2 = new e.aQ(0, 0, 0, 0, 0), u$2 = p$1 ? Gr(s$2, l$1, a$1, t$1, 0, o$1.scope, f$1, c$1, {
							tileID: h$2,
							tileSize: _$1
						}) : jr(s$2, l$1, a$1, r$1.toPremultipliedRenderColor(n$1 ? null : o$1.lut));
						i$2.draw(t$1, d$1.TRIANGLES, v$1, g$1, y$1, eo.disabled, u$2, o$1.id, t$1.viewportBuffer, t$1.quadTriangleIndexBuffer, t$1.viewportSegments);
					} else for (const e$1 of w$1) {
						const m$2 = t$1.isTileAffectedByFog(e$1), w$2 = t$1.getOrCreateProgram(x$1, {
							overrideFog: m$2,
							defines: T$1
						}), E$1 = e$1.toUnwrapped(), S$1 = s$1 ? e$1.projMatrix : t$1.transform.calculateProjMatrix(E$1);
						t$1.prepareDrawTile();
						const I$1 = i$1 ? i$1.getTile(e$1) : b$1 ? b$1[e$1.key] : new Pt(e$1, _$1, u$1.zoom, t$1), C$1 = p$1 ? Gr(S$1, l$1, a$1, t$1, 0, o$1.scope, f$1, c$1, {
							tileID: e$1,
							tileSize: _$1
						}) : jr(S$1, l$1, a$1, r$1.toPremultipliedRenderColor(n$1 ? null : o$1.lut));
						t$1.uploadCommonUniforms(h$1, w$2, E$1);
						const { tileBoundsBuffer: R$1, tileBoundsIndexBuffer: A$1, tileBoundsSegments: L$1 } = t$1.getTileBoundsBuffers(I$1);
						w$2.draw(t$1, d$1.TRIANGLES, v$1, g$1, y$1, eo.disabled, C$1, o$1.id, R$1, A$1, L$1);
					}
				},
				sky: function(t$1, i$1, o$1) {
					const s$1 = t$1._atmosphere ? e.aj(t$1.transform.zoom) : 1, r$1 = o$1.paint.get("sky-opacity") * s$1;
					if (0 === r$1) return;
					const n$1 = t$1.context, a$1 = o$1.paint.get("sky-type"), l$1 = new Xi(n$1.gl.LEQUAL, Xi.ReadOnly, [0, 1]), c$1 = t$1.frameCounter / 1e3 % 1;
					"atmosphere" === a$1 ? "offscreen" === t$1.renderPass ? o$1.needsSkyboxCapture(t$1) && (function(t$2, i$2, o$2, s$2) {
						const r$2 = t$2.context, n$2 = r$2.gl;
						let a$2 = i$2.skyboxFbo;
						if (!a$2) {
							a$2 = i$2.skyboxFbo = r$2.createFramebuffer(32, 32, 1, null), i$2.skyboxGeometry = new jn(r$2), i$2.skyboxTexture = r$2.gl.createTexture(), n$2.bindTexture(n$2.TEXTURE_CUBE_MAP, i$2.skyboxTexture), n$2.texParameteri(n$2.TEXTURE_CUBE_MAP, n$2.TEXTURE_WRAP_S, n$2.CLAMP_TO_EDGE), n$2.texParameteri(n$2.TEXTURE_CUBE_MAP, n$2.TEXTURE_WRAP_T, n$2.CLAMP_TO_EDGE), n$2.texParameteri(n$2.TEXTURE_CUBE_MAP, n$2.TEXTURE_MIN_FILTER, n$2.LINEAR), n$2.texParameteri(n$2.TEXTURE_CUBE_MAP, n$2.TEXTURE_MAG_FILTER, n$2.LINEAR);
							for (let e$1 = 0; e$1 < 6; ++e$1) n$2.texImage2D(n$2.TEXTURE_CUBE_MAP_POSITIVE_X + e$1, 0, n$2.RGBA, 32, 32, 0, n$2.RGBA, n$2.UNSIGNED_BYTE, null);
						}
						r$2.bindFramebuffer.set(a$2.framebuffer), r$2.viewport.set([
							0,
							0,
							32,
							32
						]);
						const l$2 = i$2.getCenter(t$2, !0), c$2 = t$2.getOrCreateProgram("skyboxCapture"), h$1 = new Float64Array(16);
						e.bA(h$1), e.en(h$1, h$1, .5 * -Math.PI), Gn(t$2, i$2, c$2, h$1, l$2, 0), e.bA(h$1), e.en(h$1, h$1, .5 * Math.PI), Gn(t$2, i$2, c$2, h$1, l$2, 1), e.bA(h$1), e.cU(h$1, h$1, .5 * -Math.PI), Gn(t$2, i$2, c$2, h$1, l$2, 2), e.bA(h$1), e.cU(h$1, h$1, .5 * Math.PI), Gn(t$2, i$2, c$2, h$1, l$2, 3), e.bA(h$1), Gn(t$2, i$2, c$2, h$1, l$2, 4), e.bA(h$1), e.en(h$1, h$1, Math.PI), Gn(t$2, i$2, c$2, h$1, l$2, 5), r$2.viewport.set([
							0,
							0,
							t$2.width,
							t$2.height
						]);
					}(t$1, o$1), o$1.markSkyboxValid(t$1)) : "sky" === t$1.renderPass && function(e$1, t$2, i$2, o$2, s$2) {
						const r$2 = e$1.context, n$2 = r$2.gl, a$2 = e$1.transform, l$2 = e$1.getOrCreateProgram("skybox");
						r$2.activeTexture.set(n$2.TEXTURE0), n$2.bindTexture(n$2.TEXTURE_CUBE_MAP, t$2.skyboxTexture);
						const c$2 = ((e$2, t$3, i$3, o$3, s$3) => ({
							u_matrix: e$2,
							u_sun_direction: t$3,
							u_cubemap: 0,
							u_opacity: o$3,
							u_temporal_offset: s$3
						}))(a$2.skyboxMatrix, t$2.getCenter(e$1, !1), 0, o$2, s$2);
						e$1.uploadCommonUniforms(r$2, l$2), l$2.draw(e$1, n$2.TRIANGLES, i$2, Ki.disabled, e$1.colorModeForRenderPass(), eo.backCW, c$2, "skybox", t$2.skyboxGeometry.vertexBuffer, t$2.skyboxGeometry.indexBuffer, t$2.skyboxGeometry.segment);
					}(t$1, o$1, l$1, r$1, c$1) : "gradient" === a$1 && "sky" === t$1.renderPass && function(t$2, i$2, o$2, s$2, r$2) {
						const n$2 = t$2.context, a$2 = n$2.gl, l$2 = t$2.transform, c$2 = t$2.getOrCreateProgram("skyboxGradient");
						i$2.skyboxGeometry || (i$2.skyboxGeometry = new jn(n$2)), n$2.activeTexture.set(a$2.TEXTURE0);
						let h$1 = i$2.colorRampTexture;
						h$1 || (h$1 = i$2.colorRampTexture = new e.T(n$2, i$2.colorRamp, a$2.RGBA8)), h$1.bind(a$2.LINEAR, a$2.CLAMP_TO_EDGE);
						const d$1 = ((t$3, i$3, o$3, s$3, r$3) => ({
							u_matrix: t$3,
							u_color_ramp: 0,
							u_center_direction: i$3,
							u_radius: e.an(o$3),
							u_opacity: s$3,
							u_temporal_offset: r$3
						}))(l$2.skyboxMatrix, i$2.getCenter(t$2, !1), i$2.paint.get("sky-gradient-radius"), s$2, r$2);
						t$2.uploadCommonUniforms(n$2, c$2), c$2.draw(t$2, a$2.TRIANGLES, o$2, Ki.disabled, t$2.colorModeForRenderPass(), eo.backCW, d$1, "skyboxGradient", i$2.skyboxGeometry.vertexBuffer, i$2.skyboxGeometry.indexBuffer, i$2.skyboxGeometry.segment);
					}(t$1, o$1, l$1, r$1, c$1);
				},
				custom: function(t$1, i$1, o$1, s$1) {
					const r$1 = t$1.context, n$1 = o$1.implementation;
					if (!t$1.transform.projection.unsupportedLayers || !t$1.transform.projection.unsupportedLayers.includes("custom") || t$1.terrain && (t$1.terrain.renderingToTexture || "offscreen" === t$1.renderPass) && o$1.isDraped(i$1)) {
						if ("offscreen" === t$1.renderPass) {
							const i$2 = n$1.prerender;
							if (i$2) {
								if (t$1.setCustomLayerDefaults(), r$1.setColorMode(t$1.colorModeForRenderPass()), "globe" === t$1.transform.projection.name) {
									const o$2 = t$1.transform.pointMerc;
									i$2.call(n$1, r$1.gl, t$1.transform.customLayerMatrix(), t$1.transform.getProjection(), t$1.transform.globeToMercatorMatrix(), e.aj(t$1.transform.zoom), [o$2.x, o$2.y], t$1.transform.pixelsPerMeterRatio);
								} else i$2.call(n$1, r$1.gl, t$1.transform.customLayerMatrix());
								r$1.setDirty(), t$1.setBaseState();
							}
						} else if ("translucent" === t$1.renderPass) {
							if (t$1.terrain && t$1.terrain.renderingToTexture) {
								const e$1 = n$1.renderToTile;
								if (e$1) {
									const i$3 = s$1[0].canonical, o$2 = {
										x: i$3.x + s$1[0].wrap * (n$1.wrapTileId ? 0 : 1 << i$3.z),
										y: i$3.y,
										z: i$3.z
									};
									r$1.setDepthMode(Xi.disabled), r$1.setStencilMode(Ki.disabled), r$1.setColorMode(t$1.colorModeForRenderPass()), t$1.setCustomLayerDefaults(), e$1.call(n$1, r$1.gl, o$2), r$1.setDirty(), t$1.setBaseState();
								}
								return;
							}
							t$1.setCustomLayerDefaults(), r$1.setColorMode(t$1.colorModeForRenderPass()), r$1.setStencilMode(Ki.disabled);
							const i$2 = "3d" === n$1.renderingMode ? new Xi(t$1.context.gl.LEQUAL, Xi.ReadWrite, t$1.depthRangeFor3D) : t$1.depthModeForSublayer(0, Xi.ReadOnly);
							if (r$1.setDepthMode(i$2), "globe" === t$1.transform.projection.name) {
								const i$3 = t$1.transform.pointMerc;
								n$1.render(r$1.gl, t$1.transform.customLayerMatrix(), t$1.transform.getProjection(), t$1.transform.globeToMercatorMatrix(), e.aj(t$1.transform.zoom), [i$3.x, i$3.y], t$1.transform.pixelsPerMeterRatio);
							} else n$1.render(r$1.gl, t$1.transform.customLayerMatrix());
							r$1.setDirty(), t$1.setBaseState(), r$1.bindFramebuffer.set(null);
						}
					} else e.w("Custom layers are not yet supported with this projection. Use mercator or globe to enable usage of custom layers.");
				},
				model: function(t$1, i$1, o$1, s$1) {
					if ("opaque" === t$1.renderPass) return;
					const r$1 = o$1.paint.get("model-opacity").constantOr(1), n$1 = o$1.paint.get("model-elevation-reference"), a$1 = "ground" === n$1, l$1 = "ground" === n$1;
					if (0 === r$1) return;
					const c$1 = o$1.paint.get("model-cast-shadows");
					if ("shadow" === t$1.renderPass) {
						if (!c$1) return;
						if (t$1.terrain && r$1 < .65 && o$1._transitionablePaint._values["model-opacity"].value.expression instanceof e.ad) return;
					}
					const h$1 = t$1.shadowRenderer, d$1 = o$1.paint.get("model-receive-shadows");
					h$1 && (h$1.useNormalOffset = !0, d$1 || (h$1.enabled = !1));
					const u$1 = () => {
						h$1 && (h$1.useNormalOffset = !0, d$1 || (h$1.enabled = !0));
					}, _$1 = i$1.getSource();
					if ("light-beam" === t$1.renderPass && "batched-model" !== _$1.type) return;
					if ("vector" === _$1.type || "geojson" === _$1.type) return function(t$2, i$2, o$2, s$2, r$2) {
						const n$2 = t$2.transform, a$2 = "globe" === n$2.projection.name, l$2 = n$2.getFreeCameraOptions().position;
						if (!t$2.modelManager) return;
						const c$2 = t$2.modelManager;
						o$2.modelManager = c$2;
						const h$2 = t$2.shadowRenderer;
						if (!o$2._unevaluatedLayout._values.hasOwnProperty("model-id")) return;
						const d$2 = o$2._unevaluatedLayout._values["model-id"], u$2 = Object.assign({}, o$2.layout.get("model-id").parameters), _$2 = t$2.style.order.indexOf(o$2.fqid), p$2 = o$2.paint.get("model-opacity").constantOr(1);
						for (const f$2 of s$2) {
							const s$3 = i$2.getTile(f$2).getBucket(o$2);
							if (!s$3 || s$3.projection.name !== n$2.projection.name) continue;
							const m$2 = s$3.getModelUris();
							if (m$2 && !s$3.modelsRequested && (c$2.addModelsFromBucket(m$2, r$2), s$3.modelsRequested = !0), a$2) u$2.zoom = f$2.overscaledZ;
							else u$2.zoom = na(f$2, n$2);
							const g$2 = d$2.possiblyEvaluate(u$2);
							if (sa(t$2, s$3, f$2), ra.shadowUniformsInitialized = !1, ra.useSingleShadowCascade = !!h$2 && 0 === h$2.getMaxCascadeForTile(f$2.toUnwrapped()), "shadow" === t$2.renderPass && h$2) {
								if (1 === t$2.currentShadowCascade && s$3.isInsideFirstShadowMapFrustum) continue;
								const i$3 = n$2.calculatePosMatrix(f$2.toUnwrapped(), n$2.worldSize);
								if (ra.tileMatrix.set(i$3), ra.shadowTileMatrix = Float32Array.from(h$2.calculateShadowPassMatrixFromMatrix(i$3)), ra.aabb.min = [
									0,
									0,
									0
								], ra.aabb.max[0] = ra.aabb.max[1] = e.al, ra.aabb.max[2] = 0, ca(s$3, ra, t$2, o$2.scope)) continue;
							}
							const v$2 = 1 << f$2.canonical.z, y$2 = [
								((l$2.x - f$2.wrap) * v$2 - f$2.canonical.x) * e.al,
								(l$2.y * v$2 - f$2.canonical.y) * e.al,
								l$2.z * v$2 * e.al
							];
							t$2.conflationActive && Object.keys(s$3.instancesPerModel).length > 0 && t$2.style.isLayerClipped(o$2, i$2.getSource()) && s$3.updateReplacement(f$2, t$2.replacementSource, _$2, o$2.scope) && (s$3.uploaded = !1, s$3.upload(t$2.context));
							let x$2 = 0;
							const b$1 = new Array(), w$1 = new Array(), T$1 = new Array();
							for (let i$3 in s$3.instancesPerModel) {
								const n$3 = s$3.instancesPerModel[i$3];
								n$3.features.length > 0 && !a$2 && (i$3 = g$2.evaluate(n$3.features[0].feature, {}));
								const h$3 = c$2.getModel(i$3, r$2);
								if (h$3 || c$2.hasURLBeenRequested(i$3) || s$3.modelUris.includes(i$3) || (s$3.modelUris.push(i$3), s$3.modelsRequested = !1), h$3 && h$3.uploaded) if (a$2) {
									const i$4 = e.c5([], [
										l$2.x,
										l$2.y,
										l$2.z
									], t$2.transform.worldSize);
									e.ew(i$4, i$4);
									for (let o$3 = 0; o$3 < n$3.instancedDataArray.length; ++o$3) {
										const r$3 = [
											0,
											0,
											0
										], a$3 = [
											1,
											1,
											1
										], l$3 = e.ex(), c$3 = n$3.tileCoordinatesForInstance(o$3), d$3 = n$3.transformForInstance(o$3);
										e.ey(a$3, d$3), e.ez(l$3, d$3), e.eA(r$3, l$3);
										const u$3 = n$3.translationForInstance(o$3), _$3 = new e.aT(0, 0);
										e.eB(s$3.canonical, _$3, c$3.x, c$3.y);
										const f$3 = e.bC();
										e.eC(f$3, h$3, t$2.transform, _$3, r$3, a$3, u$3, !0, !1, !1);
										const m$3 = n$3.colorForInstance(o$3), g$3 = e.bA([]), v$3 = e.ef(_$3.lat, t$2.transform.zoom), y$3 = e.bq([], [
											1,
											1,
											1 / v$3
										]);
										e.br(g$3, g$3, i$4), T$1.push({
											zScaleMatrix: y$3,
											negCameraPosMatrix: g$3
										});
										for (const e$1 of h$3.nodes) Qn(t$2, e$1, f$3, t$2.transform.expandedFarZProjMatrix, x$2, b$1, w$1, h$3.materialOverrides, p$2, m$3);
										++x$2;
									}
								} else for (const e$1 of h$3.nodes) aa(t$2, o$2, e$1, n$3, y$2, f$2, ra);
							}
							if (a$2) if ("shadow" === t$2.renderPass) {
								for (const e$1 of w$1) ea(e$1.mesh, e$1.nodeModelMatrix, t$2, o$2);
								for (const e$1 of b$1) ea(e$1.mesh, e$1.nodeModelMatrix, t$2, o$2);
							} else oa(t$2, o$2, b$1, w$1, T$1);
						}
					}(t$1, i$1, o$1, s$1, Jn(t$1, o$1)), void u$1();
					if (!_$1.loaded()) return;
					if ("batched-model" === _$1.type) return function(t$2, i$2, o$2, s$2) {
						o$2.resetLayerRenderingStats(t$2);
						const r$2 = t$2.context, n$2 = t$2.transform, a$2 = t$2.style.fog, l$2 = t$2.shadowRenderer;
						if ("mercator" !== n$2.projection.name) return void e.w(`Drawing 3D landmark models for ${n$2.projection.name} projection is not yet implemented`);
						const c$2 = t$2.transform.getFreeCameraOptions().position, h$2 = e.c5([], [
							c$2.x,
							c$2.y,
							c$2.z
						], t$2.transform.worldSize), d$2 = e.ew([], h$2), u$2 = e.bA([]), _$2 = e.ef(n$2.center.lat, n$2.zoom), p$2 = e.bq([], [
							1,
							1,
							1 / _$2
						]);
						e.br(u$2, u$2, d$2);
						const f$2 = o$2.paint.get("model-opacity").constantOr(1), m$2 = new Xi(r$2.gl.LEQUAL, Xi.ReadWrite, t$2.depthRangeFor3D), g$2 = new Xi(r$2.gl.LEQUAL, Xi.ReadOnly, t$2.depthRangeFor3D), v$2 = new e.d9([
							Infinity,
							Infinity,
							Infinity
						], [
							-Infinity,
							-Infinity,
							-Infinity
						]), y$2 = "shadow" === t$2.renderPass, x$2 = y$2 && l$2 ? l$2.getCurrentCascadeFrustum() : n$2.getFrustum(n$2.scaleZoom(n$2.worldSize)), b$1 = o$2.paint.get("model-front-cutoff"), w$1 = b$1[2] < 1, T$1 = ho(t$2, o$2.paint.get("model-cutoff-fade-range")), E$1 = o$2.getLayerRenderingStats();
						(function(e$1, t$3, i$3, o$3) {
							const s$3 = e$1.terrain ? e$1.terrain.exaggeration() : 0, r$3 = e$1.transform.zoom;
							for (const n$3 of o$3) {
								const o$4 = t$3.getTile(n$3).getBucket(i$3);
								o$4 && (o$4.setFilter(i$3.filter), e$1.conflationActive && o$4.updateReplacement(n$3, e$1.replacementSource), o$4.evaluateTransform(e$1, i$3), e$1.terrain && s$3 > 0 && o$4.elevationUpdate(e$1.terrain, s$3, n$3, i$3.source), o$4.needsReEvaluation(e$1, r$3, i$3) && o$4.evaluate(i$3));
							}
						})(t$2, i$2, o$2, s$2), function() {
							let c$3, d$3, S$1;
							w$1 ? (c$3 = s$2.length - 1, d$3 = -1, S$1 = -1) : (c$3 = 0, d$3 = s$2.length, S$1 = 1);
							const I$1 = new Float64Array(16), C$1 = e.cA(), R$1 = new e.P(0, 0);
							for (let A$1 = c$3; A$1 !== d$3; A$1 += S$1) {
								const c$4 = s$2[A$1], d$4 = i$2.getTile(c$4).getBucket(o$2);
								if (!d$4 || !d$4.uploaded) continue;
								let S$2 = !1;
								l$2 && (S$2 = 0 === l$2.getMaxCascadeForTile(c$4.toUnwrapped()));
								const L$1 = n$2.calculatePosMatrix(c$4.toUnwrapped(), n$2.worldSize), D$1 = d$4.modelTraits;
								!y$2 && w$1 && (e.bl(I$1, L$1), e.af(C$1, h$2, I$1), R$1.x = C$1[0], R$1.y = C$1[1]);
								const P$1 = [];
								d$4.setFilter(o$2.filter);
								for (const i$3 of d$4.getNodesInfo()) {
									if (i$3.hiddenByReplacement) continue;
									if (!i$3.node.meshes) continue;
									const o$3 = i$3.node;
									let s$3 = 0;
									t$2.terrain && o$3.elevation && (s$3 = o$3.elevation * t$2.terrain.exaggeration());
									const r$3 = (() => {
										const t$3 = i$3.aabb;
										return v$2.min = [...t$3.min], v$2.max = [...t$3.max], v$2.min[2] += s$3, v$2.max[2] += s$3, e.af(v$2.min, v$2.min, L$1), e.af(v$2.max, v$2.max, L$1), v$2;
									})(), a$3 = i$3.evaluatedScale;
									if (a$3[0] <= 1 && a$3[1] <= 1 && a$3[2] <= 1 && 0 === r$3.intersects(x$2)) continue;
									if (!y$2 && w$1) {
										const t$3 = 1 / 6;
										i$3.cameraCollisionOpacity = h$2[0] > r$3.min[0] && h$2[0] < r$3.max[0] && h$2[1] > r$3.min[1] && h$2[1] < r$3.max[1] && h$2[2] * _$2 < r$3.max[2] && o$3.footprint && e.c0(R$1, o$3.footprint) ? Math.max(i$3.cameraCollisionOpacity - t$3, 0) : Math.min(1, i$3.cameraCollisionOpacity + t$3);
									}
									const l$3 = [...L$1], d$5 = 1 / e.d7(c$4.canonical), u$3 = o$3.anchor ? o$3.anchor[0] : 0, p$3 = o$3.anchor ? o$3.anchor[1] : 0;
									e.br(l$3, l$3, [
										u$3 * (a$3[0] - 1) + i$3.evaluatedTranslation[0] * d$5,
										p$3 * (a$3[1] - 1) + i$3.evaluatedTranslation[1] * d$5,
										s$3 + i$3.evaluatedTranslation[2]
									]), e.cq(a$3, e.eE) || e.cS(l$3, l$3, a$3);
									const m$3 = e.aB([], l$3, o$3.globalMatrix), g$3 = e.aB([], n$2.expandedFarZProjMatrix, m$3), E$2 = e.aB([], n$2.expandedFarZProjMatrix, l$3), S$3 = e.aC([], [
										u$3,
										p$3,
										s$3,
										1
									], g$3)[2];
									o$3.hidden = !1;
									let I$2 = f$2;
									y$2 || (w$1 && (I$2 *= i$3.cameraCollisionOpacity, I$2 *= da(l$3, n$2, i$3.aabb, b$1)), I$2 *= ha(T$1, S$3)), 0 !== I$2 ? P$1.push({
										nodeInfo: i$3,
										depth: S$3,
										opacity: I$2,
										wvpForNode: g$3,
										wvpForTile: E$2,
										nodeModelMatrix: m$3,
										tileModelMatrix: l$3
									}) : o$3.hidden = !0;
								}
								y$2 || P$1.sort(((e$1, t$3) => !w$1 || 1 === e$1.opacity && 1 === t$3.opacity ? e$1.depth < t$3.depth ? -1 : 1 : 1 === e$1.opacity ? -1 : 1 === t$3.opacity ? 1 : e$1.depth > t$3.depth ? -1 : 1));
								for (const i$3 of P$1) {
									const s$3 = i$3.nodeInfo, c$5 = s$3.node;
									let h$3 = e.aB([], p$2, i$3.tileModelMatrix);
									e.aB(h$3, u$2, h$3);
									const d$5 = e.bl([], h$3);
									e.eg(d$5, d$5), e.cS(d$5, d$5, la), h$3 = e.aB(h$3, h$3, c$5.globalMatrix);
									const _$3 = "light-beam" === t$2.renderPass, f$3 = "none" === o$2.paint.get("model-color-use-theme").constantOr("default"), v$3 = D$1 & e.eI.HasMapboxMeshFeatures, x$3 = v$3 ? 0 : s$3.evaluatedRMEA[0][2];
									for (let e$1 = 0; e$1 < c$5.meshes.length; ++e$1) {
										const u$3 = c$5.meshes[e$1], p$3 = e$1 === c$5.lightMeshIndex;
										let b$2 = i$3.wvpForNode;
										if (p$3) {
											if (!_$3 && !t$2.terrain && t$2.shadowRenderer) {
												t$2.currentLayer < t$2.firstLightBeamLayer && (t$2.firstLightBeamLayer = t$2.currentLayer);
												continue;
											}
											b$2 = i$3.wvpForTile;
										} else if (_$3) continue;
										const w$2 = { defines: [] }, T$2 = [];
										if (!y$2 && l$2 && (l$2.useNormalOffset = !!u$3.normalBuffer), Yn(w$2.defines, T$2, u$3, t$2, f$3 ? null : o$2.lut), v$3 || w$2.defines.push("DIFFUSE_SHADED"), S$2 && w$2.defines.push("SHADOWS_SINGLE_CASCADE"), E$1 && (y$2 ? E$1.numRenderedVerticesInShadowPass += u$3.vertexArray.length : E$1.numRenderedVerticesInTransparentPass += u$3.vertexArray.length), y$2) {
											ea(u$3, i$3.nodeModelMatrix, t$2, o$2);
											continue;
										}
										let I$2 = null;
										if (a$2) {
											const e$2 = Xn(i$3.nodeModelMatrix, t$2.transform);
											if (I$2 = new Float32Array(e$2), "globe" !== n$2.projection.name) {
												const t$3 = u$3.aabb.min, i$4 = u$3.aabb.max, [o$3, s$4] = a$2.getOpacityForBounds(e$2, t$3[0], t$3[1], i$4[0], i$4[1]);
												w$2.overrideFog = o$3 >= He || s$4 >= He;
											}
										}
										const C$2 = u$3.material;
										let R$2;
										C$2.occlusionTexture && C$2.occlusionTexture.offsetScale && (R$2 = C$2.occlusionTexture.offsetScale, w$2.defines.push("OCCLUSION_TEXTURE_TRANSFORM"));
										const A$2 = t$2.getOrCreateProgram("model", w$2);
										!y$2 && l$2 && l$2.setupShadowsFromMatrix(i$3.tileModelMatrix, A$2, l$2.useNormalOffset), t$2.uploadCommonUniforms(r$2, A$2, null, I$2);
										const L$2 = C$2.pbrMetallicRoughness;
										L$2.metallicFactor = .9, L$2.roughnessFactor = .5;
										const D$2 = Hr(new Float32Array(b$2), new Float32Array(h$3), new Float32Array(d$5), new Float32Array(c$5.globalMatrix), t$2, i$3.opacity, L$2.baseColorFactor, C$2.emissiveFactor, L$2.metallicFactor, L$2.roughnessFactor, C$2, x$3, o$2, [
											0,
											0,
											0
										], R$2);
										!p$3 && (s$3.hasTranslucentParts || i$3.opacity < 1) && A$2.draw(t$2, r$2.gl.TRIANGLES, m$2, Ki.disabled, $i.disabled, eo.backCCW, D$2, o$2.id, u$3.vertexBuffer, u$3.indexBuffer, u$3.segments, o$2.paint, t$2.transform.zoom, void 0, T$2), A$2.draw(t$2, r$2.gl.TRIANGLES, p$3 ? g$2 : m$2, Ki.disabled, p$3 || i$3.opacity < 1 || s$3.hasTranslucentParts ? $i.alphaBlended : $i.unblended, eo.backCCW, D$2, o$2.id, u$3.vertexBuffer, u$3.indexBuffer, u$3.segments, o$2.paint, t$2.transform.zoom, void 0, T$2);
									}
								}
							}
						}();
					}(t$1, i$1, o$1, s$1), void u$1();
					if ("model" !== _$1.type) return;
					const p$1 = _$1.getModels(), f$1 = [], m$1 = t$1.transform.getFreeCameraOptions().position, g$1 = e.c5([], [
						m$1.x,
						m$1.y,
						m$1.z
					], t$1.transform.worldSize);
					e.ew(g$1, g$1);
					const v$1 = [], y$1 = [];
					let x$1 = 0;
					for (const s$2 of p$1) {
						const r$2 = i$1.getFeatureState("", s$2.id), n$2 = {
							type: "Unknown",
							id: s$2.id,
							properties: s$2.featureProperties
						}, c$2 = o$1.paint.get("model-rotation").evaluate(n$2, r$2), h$2 = o$1.paint.get("model-scale").evaluate(n$2, r$2), d$2 = o$1.paint.get("model-translation").evaluate(n$2, r$2), u$2 = o$1.paint.get("model-opacity").evaluate(n$2, r$2);
						ta(o$1, s$2.id, r$2, s$2.featureProperties, s$2.nodeOverrideNames, s$2.nodeOverrides), ia(o$1, s$2.id, r$2, s$2.featureProperties, s$2.materialOverrideNames, s$2.materialOverrides), s$2.nodeOverrides.size > 0 && s$2.computeBoundsAndApplyParent(), s$2.computeModelMatrix(t$1, c$2, h$2, d$2, l$1, a$1, !1);
						const _$2 = e.bA([]), p$2 = e.ef(s$2.position.lat, t$1.transform.zoom), m$2 = e.bq([], [
							1,
							1,
							1 / p$2
						]);
						e.br(_$2, _$2, g$1), f$1.push({
							zScaleMatrix: m$2,
							negCameraPosMatrix: _$2
						});
						for (const e$1 of s$2.nodes) Qn(t$1, e$1, s$2.matrix, t$1.transform.expandedFarZProjMatrix, x$1, v$1, y$1, s$2.materialOverrides, u$2);
						x$1++;
					}
					if (v$1.sort(((e$1, t$2) => t$2.depth - e$1.depth)), "shadow" !== t$1.renderPass) oa(t$1, o$1, v$1, y$1, f$1), u$1();
					else {
						for (const e$1 of y$1) ea(e$1.mesh, e$1.nodeModelMatrix, t$1, o$1);
						for (const e$1 of v$1) ea(e$1.mesh, e$1.nodeModelMatrix, t$1, o$1);
						u$1();
					}
				}
			}, Ra = {
				line: function(e$1, t$1, i$1) {
					if (e$1.hasElevatedBuckets = !1, e$1.hasNonElevatedBuckets = !1, void 0 !== e$1._unevaluatedLayout.getValue("line-elevation-reference") || void 0 !== e$1._unevaluatedLayout.getValue("line-z-offset")) {
						if (t$1) {
							const i$2 = t$1.getVisibleCoordinates();
							for (const o$1 of i$2) {
								const i$3 = t$1.getTile(o$1).getBucket(e$1);
								if (i$3 && ("none" !== i$3.elevationType ? e$1.hasElevatedBuckets = !0 : e$1.hasNonElevatedBuckets = !0, e$1.hasElevatedBuckets && e$1.hasNonElevatedBuckets)) break;
							}
						}
					} else e$1.hasNonElevatedBuckets = !0;
				},
				model: function(e$1, t$1, i$1) {
					const o$1 = t$1.getSource();
					if (!o$1.loaded()) return;
					if ("vector" === o$1.type || "geojson" === o$1.type) return void (i$1.modelManager && i$1.modelManager.upload(i$1, Jn(i$1, e$1)));
					if ("batched-model" === o$1.type) return;
					if ("model" !== o$1.type) return;
					const s$1 = o$1.getModels();
					for (const e$2 of s$1) e$2.upload(i$1.context);
				},
				raster: function(e$1, t$1, i$1) {
					const o$1 = t$1.getSource();
					if (!(o$1 instanceof pt && o$1.loaded())) return;
					const s$1 = e$1.sourceLayer || o$1.rasterLayerIds && o$1.rasterLayerIds[0];
					if (!s$1) return;
					const r$1 = e$1.paint.get("raster-array-band") || o$1.getInitialBand(s$1);
					if (null == r$1) return;
					const n$1 = t$1.getIds().map(((e$2) => t$1.getTileByID(e$2)));
					for (const t$2 of n$1) t$2.updateNeeded(e$1.id, r$1) && o$1.prepareTile(t$2, s$1, e$1.id, r$1);
				},
				"raster-particle": function(e$1, t$1, i$1) {
					const o$1 = t$1.getSource();
					if (!(o$1 instanceof pt && o$1.loaded())) return;
					const s$1 = e$1.sourceLayer || o$1.rasterLayerIds && o$1.rasterLayerIds[0];
					if (!s$1) return;
					const r$1 = e$1.paint.get("raster-particle-array-band") || o$1.getInitialBand(s$1);
					if (null == r$1) return;
					const n$1 = t$1.getIds().map(((e$2) => t$1.getTileByID(e$2)));
					for (const t$2 of n$1) t$2.updateNeeded(e$1.id, r$1) && o$1.prepareTile(t$2, s$1, e$1.id, r$1);
				}
			}, Aa = { fill: ln }, La = { fill: function(e$1, t$1, i$1, o$1) {
				if (!i$1.layout || "none" === i$1.layout.get("fill-elevation-reference") || 0 === i$1.paint.get("fill-opacity").constantOr(1)) return;
				const s$1 = e$1.context.gl, r$1 = new Xi(s$1.LEQUAL, Xi.ReadOnly, e$1.depthRangeFor3D), n$1 = new Ki({
					func: s$1.ALWAYS,
					mask: 255
				}, 255, 255, s$1.KEEP, s$1.KEEP, s$1.REPLACE), a$1 = e$1.transform.getFreeCameraOptions().position, l$1 = e$1.getOrCreateProgram("elevatedStructuresDepthReconstruct");
				for (const c$1 of o$1) {
					const o$2 = t$1.getTile(c$1), h$1 = o$2.getBucket(i$1);
					if (!h$1) continue;
					const d$1 = h$1.elevatedStructures;
					if (!d$1 || 0 === d$1.depthSegments.segments[0].primitiveLength) continue;
					const u$1 = an(c$1.toUnwrapped(), a$1), p$1 = Tr(e$1.translatePosMatrix(c$1.projMatrix, o$2, i$1.paint.get("fill-translate"), i$1.paint.get("fill-translate-anchor")), u$1, 0, 1, 0);
					l$1.draw(e$1, s$1.TRIANGLES, r$1, n$1, $i.disabled, eo.disabled, p$1, i$1.id, d$1.vertexBuffer, d$1.indexBuffer, d$1.depthSegments, i$1.paint, e$1.transform.zoom);
				}
			} };
			class Da {
				constructor(t$1, i$1, o$1, s$1, r$1) {
					this.context = new Kr(t$1, i$1), this.transform = o$1, this._tileTextures = {}, this.frameCopies = [], this.loadTimeStamps = [], this._timeStamp = e.o.now(), this._averageFPS = 0, this._fpsHistory = [], this._dt = 0, this._debugParams = {
						forceEnablePrecipitation: !1,
						showTerrainProxyTiles: !1,
						fpsWindow: 30,
						continousRedraw: !1,
						enabledLayers: {}
					};
					const n$1 = [
						"fill",
						"line",
						"symbol",
						"circle",
						"heatmap",
						"fill-extrusion",
						"building",
						"raster",
						"raster-particle",
						"hillshade",
						"model",
						"background",
						"sky"
					];
					for (const e$1 of n$1) this._debugParams.enabledLayers[e$1] = !0;
					for (const e$1 of n$1);
					this.occlusionParams = new pa(), this.setup(), this.numSublayers = Ft.maxUnderzooming + Ft.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.deferredRenderGpuTimeQueries = [], this.gpuTimers = {}, this.frameCounter = 0, this._backgroundTiles = {}, this.conflationActive = !1, this.replacementSource = new e.eP(), this.longestCutoffRange = 0, this.minCutoffZoom = 0, this._fogVisible = !1, this._cachedTileFogOpacities = {}, this._shadowRenderer = new fo(this), this._wireframeDebugCache = new _a(), this.renderDefaultNorthPole = !0, this.renderDefaultSouthPole = !0, this.layersWithOcclusionOpacity = [];
					const a$1 = new e.q({
						width: 1,
						height: 1
					}, Uint8Array.of(0, 0, 0, 0));
					this.emptyDepthTexture = new e.T(this.context, a$1, t$1.RGBA8), this._clippingActiveLastFrame = !1, this.scaleFactor = s$1, this.worldview = r$1, this._forceEmissiveMode = !1, this.emissiveMode = "constant";
				}
				updateTerrain(e$1, t$1) {
					const i$1 = !!e$1 && !!e$1.terrain && this.transform.projection.supportsTerrain;
					if (!(i$1 || this._terrain && this._terrain.enabled)) return;
					this._terrain || (this._terrain = new nr(this, e$1));
					const o$1 = this._terrain;
					this.transform.elevation = i$1 ? o$1 : null, o$1.update(e$1, this.transform, t$1), this.transform.elevation && !o$1.enabled && (this.transform.elevation = null);
				}
				_updateFog(e$1) {
					const t$1 = e$1.fog;
					if (!t$1 || "globe" === this.transform.projection.name || t$1.getOpacity(this.transform.pitch) < 1 || t$1.properties.get("horizon-blend") < .03) return void (this.transform.fogCullDistSq = null);
					const [i$1, o$1] = t$1.getFovAdjustedRange(this.transform._fov);
					if (i$1 > o$1) return void (this.transform.fogCullDistSq = null);
					const s$1 = i$1 + .78 * (o$1 - i$1);
					this.transform.fogCullDistSq = s$1 * s$1;
				}
				get terrain() {
					return this.transform._terrainEnabled() && this._terrain && this._terrain.enabled || this._forceTerrainMode ? this._terrain : null;
				}
				get forceTerrainMode() {
					return this._forceTerrainMode;
				}
				set forceTerrainMode(e$1) {
					e$1 && !this._terrain && (this._terrain = new nr(this, this.style)), this._forceTerrainMode = e$1;
				}
				get shadowRenderer() {
					return this._shadowRenderer && this._shadowRenderer.enabled ? this._shadowRenderer : null;
				}
				get wireframeDebugCache() {
					return this._wireframeDebugCache;
				}
				resize(t$1, i$1) {
					if (this.width = t$1 * e.o.devicePixelRatio, this.height = i$1 * e.o.devicePixelRatio, this.context.viewport.set([
						0,
						0,
						this.width,
						this.height
					]), this.style) for (const e$1 of this.style.order) this.style._mergedLayers[e$1].resize();
				}
				setup() {
					const t$1 = this.context, i$1 = new e.bd();
					i$1.emplaceBack(0, 0), i$1.emplaceBack(e.al, 0), i$1.emplaceBack(0, e.al), i$1.emplaceBack(e.al, e.al), this.tileExtentBuffer = t$1.createVertexBuffer(i$1, e.bf.members), this.tileExtentSegments = e.bg.simpleSegment(0, 0, 4, 2);
					const o$1 = new e.bd();
					o$1.emplaceBack(0, 0), o$1.emplaceBack(e.al, 0), o$1.emplaceBack(0, e.al), o$1.emplaceBack(e.al, e.al), this.debugBuffer = t$1.createVertexBuffer(o$1, e.bf.members), this.debugSegments = e.bg.simpleSegment(0, 0, 4, 5);
					const s$1 = new e.bd();
					s$1.emplaceBack(-1, -1), s$1.emplaceBack(1, -1), s$1.emplaceBack(-1, 1), s$1.emplaceBack(1, 1), this.viewportBuffer = t$1.createVertexBuffer(s$1, e.bf.members), this.viewportSegments = e.bg.simpleSegment(0, 0, 4, 2);
					const r$1 = new e.b1();
					r$1.emplaceBack(0, 0, 0, 0), r$1.emplaceBack(e.al, 0, e.al, 0), r$1.emplaceBack(0, e.al, 0, e.al), r$1.emplaceBack(e.al, e.al, e.al, e.al), this.mercatorBoundsBuffer = t$1.createVertexBuffer(r$1, e.bi.members), this.mercatorBoundsSegments = e.bg.simpleSegment(0, 0, 4, 2);
					const n$1 = new e.b0();
					n$1.emplaceBack(0, 1, 2), n$1.emplaceBack(2, 1, 3), this.quadTriangleIndexBuffer = t$1.createIndexBuffer(n$1);
					const a$1 = new e.be();
					for (const e$1 of [
						0,
						1,
						3,
						2,
						0
					]) a$1.emplaceBack(e$1);
					this.debugIndexBuffer = t$1.createIndexBuffer(a$1), this.emptyTexture = new e.T(t$1, new e.q({
						width: 1,
						height: 1
					}, Uint8Array.of(0, 0, 0, 0)), t$1.gl.RGBA8), this.identityMat = e.bC();
					const l$1 = this.context.gl;
					this.stencilClearMode = new Ki({
						func: l$1.ALWAYS,
						mask: 0
					}, 0, 255, l$1.ZERO, l$1.ZERO, l$1.ZERO), this.loadTimeStamps.push(performance.now());
				}
				getMercatorTileBoundsBuffers() {
					return {
						tileBoundsBuffer: this.mercatorBoundsBuffer,
						tileBoundsIndexBuffer: this.quadTriangleIndexBuffer,
						tileBoundsSegments: this.mercatorBoundsSegments
					};
				}
				getTileBoundsBuffers(e$1) {
					return e$1._makeTileBoundsBuffers(this.context, this.transform.projection), e$1._tileBoundsBuffer ? {
						tileBoundsBuffer: e$1._tileBoundsBuffer,
						tileBoundsIndexBuffer: e$1._tileBoundsIndexBuffer,
						tileBoundsSegments: e$1._tileBoundsSegments
					} : this.getMercatorTileBoundsBuffers();
				}
				clearStencil() {
					const e$1 = this.context.gl;
					this.nextStencilID = 1, this.currentStencilSource = void 0, this._tileClippingMaskIDs = {}, this.getOrCreateProgram("clippingMask").draw(this, e$1.TRIANGLES, Xi.disabled, this.stencilClearMode, $i.disabled, eo.disabled, tr(this.identityMat), "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);
				}
				resetStencilClippingMasks() {
					this.terrain || (this.currentStencilSource = void 0, this._tileClippingMaskIDs = {});
				}
				_renderTileClippingMasks(e$1, t$1, i$1) {
					if (!t$1 || this.currentStencilSource === t$1.id || !e$1.isTileClipped() || !i$1 || 0 === i$1.length) return;
					if (this._tileClippingMaskIDs && !this.terrain) {
						let e$2 = !1;
						for (const t$2 of i$1) if (void 0 === this._tileClippingMaskIDs[t$2.key]) {
							e$2 = !0;
							break;
						}
						if (!e$2) return;
					}
					this.currentStencilSource = t$1.id;
					const o$1 = this.context, s$1 = o$1.gl;
					this.nextStencilID + i$1.length > 256 && this.clearStencil(), o$1.setColorMode($i.disabled), o$1.setDepthMode(Xi.disabled);
					const r$1 = this.getOrCreateProgram("clippingMask");
					this._tileClippingMaskIDs = {};
					for (const e$2 of i$1) {
						const i$2 = t$1.getTile(e$2), o$2 = this._tileClippingMaskIDs[e$2.key] = this.nextStencilID++, { tileBoundsBuffer: n$1, tileBoundsIndexBuffer: a$1, tileBoundsSegments: l$1 } = this.getTileBoundsBuffers(i$2);
						r$1.draw(this, s$1.TRIANGLES, Xi.disabled, new Ki({
							func: s$1.ALWAYS,
							mask: 0
						}, o$2, 255, s$1.KEEP, s$1.KEEP, s$1.REPLACE), $i.disabled, eo.disabled, tr(e$2.projMatrix), "$clipping", n$1, a$1, l$1);
					}
				}
				stencilModeFor3D() {
					this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
					const e$1 = this.nextStencilID++, t$1 = this.context.gl;
					return new Ki({
						func: t$1.NOTEQUAL,
						mask: 255
					}, e$1, 255, t$1.KEEP, t$1.KEEP, t$1.REPLACE);
				}
				stencilModeForClipping(e$1) {
					if (this.terrain) return this.terrain.stencilModeForRTTOverlap(e$1);
					const t$1 = this.context.gl;
					return new Ki({
						func: t$1.EQUAL,
						mask: 255
					}, this._tileClippingMaskIDs[e$1.key], 0, t$1.KEEP, t$1.KEEP, t$1.REPLACE);
				}
				stencilConfigForOverlap(e$1) {
					const t$1 = this.context.gl, i$1 = e$1.sort(((e$2, t$2) => t$2.overscaledZ - e$2.overscaledZ)), o$1 = i$1[i$1.length - 1].overscaledZ, s$1 = i$1[0].overscaledZ - o$1 + 1;
					if (s$1 > 1) {
						this.currentStencilSource = void 0, this.nextStencilID + s$1 > 256 && this.clearStencil();
						const e$2 = {};
						for (let i$2 = 0; i$2 < s$1; i$2++) e$2[i$2 + o$1] = new Ki({
							func: t$1.GEQUAL,
							mask: 255
						}, i$2 + this.nextStencilID, 255, t$1.KEEP, t$1.KEEP, t$1.REPLACE);
						return this.nextStencilID += s$1, [e$2, i$1];
					}
					return [{ [o$1]: Ki.disabled }, i$1];
				}
				colorModeForRenderPass() {
					const t$1 = this.context.gl;
					if (this._showOverdrawInspector) {
						const i$1 = 1 / 8;
						return new $i([
							t$1.CONSTANT_COLOR,
							t$1.ONE,
							t$1.CONSTANT_COLOR,
							t$1.ONE
						], new e.ao(i$1, i$1, i$1, 0), [
							!0,
							!0,
							!0,
							!0
						]);
					}
					return "opaque" === this.renderPass ? $i.unblended : $i.alphaBlended;
				}
				colorModeForDrapableLayerRenderPass(t$1) {
					const i$1 = this.context.gl;
					return (() => this.style && this.style.enable3dLights() && this.terrain && this.terrain.renderingToTexture)() && "translucent" === this.renderPass ? null != t$1 && "mrt-fallback" !== this.emissiveMode || "constant" === this.emissiveMode ? new $i([
						i$1.ONE,
						i$1.ONE_MINUS_SRC_ALPHA,
						i$1.CONSTANT_ALPHA,
						i$1.ONE_MINUS_SRC_ALPHA
					], new e.ao(0, 0, 0, null != t$1 ? t$1 : 0), [
						!0,
						!0,
						!0,
						!0
					]) : "dual-source-blending" === this.emissiveMode ? new $i([
						i$1.ONE,
						i$1.ONE_MINUS_SRC_ALPHA,
						this.context.extBlendFuncExtended.SRC1_ALPHA_WEBGL,
						i$1.ONE_MINUS_SRC_ALPHA
					], e.ao.transparent, [
						!0,
						!0,
						!0,
						!0
					]) : this.colorModeForRenderPass() : this.colorModeForRenderPass();
				}
				depthModeForSublayer(e$1, t$1, i$1, o$1 = !1) {
					if (this.depthOcclusion) return new Xi(this.context.gl.GREATER, Xi.ReadOnly, this.depthRangeFor3D);
					if (!this.opaquePassEnabledForLayer() && !o$1) return Xi.disabled;
					const s$1 = 1 - ((1 + this.currentLayer) * this.numSublayers + e$1) * this.depthEpsilon;
					return new Xi(i$1 || this.context.gl.LEQUAL, t$1, [s$1, s$1]);
				}
				opaquePassEnabledForLayer() {
					return this.currentLayer < this.opaquePassCutoff;
				}
				blitDepth() {
					const t$1 = this.context.gl, i$1 = Math.ceil(this.width), o$1 = Math.ceil(this.height), s$1 = this.context.bindFramebuffer.get(), r$1 = t$1.getParameter(t$1.TEXTURE_BINDING_2D);
					this.depthFBO && this.depthFBO.width === i$1 && this.depthFBO.height === o$1 || (this.depthFBO && (this.depthFBO.destroy(), this.depthFBO = void 0, this.depthTexture = void 0), 0 !== i$1 && 0 !== o$1 && (this.depthFBO = new Yr(this.context, i$1, o$1, 0, "texture"), this.depthTexture = new e.T(this.context, {
						width: i$1,
						height: o$1,
						data: null
					}, t$1.DEPTH24_STENCIL8), this.depthFBO.depthAttachment.set(this.depthTexture.texture))), this.context.bindFramebuffer.set(s$1), t$1.bindTexture(t$1.TEXTURE_2D, r$1), this.depthFBO && (t$1.bindFramebuffer(t$1.READ_FRAMEBUFFER, null), t$1.bindFramebuffer(t$1.DRAW_FRAMEBUFFER, this.depthFBO.framebuffer), t$1.blitFramebuffer(0, 0, i$1, o$1, 0, 0, i$1, o$1, t$1.DEPTH_BUFFER_BIT, t$1.NEAREST), t$1.bindFramebuffer(t$1.FRAMEBUFFER, this.context.bindFramebuffer.current));
				}
				updateAverageFPS() {
					this._fpsHistory.push(0 === this._dt ? 0 : 1e3 / this._dt), this._fpsHistory.length > this._debugParams.fpsWindow && this._fpsHistory.splice(0, this._fpsHistory.length - this._debugParams.fpsWindow), this._averageFPS = Math.round(this._fpsHistory.reduce(((e$1, t$1) => e$1 + t$1 / this._fpsHistory.length), 0));
				}
				render(t$1, i$1) {
					const o$1 = e.o.now();
					this._dt = o$1 - this._timeStamp, this._timeStamp = o$1, this._wireframeDebugCache.update(this.frameCounter), this._debugParams.continousRedraw = t$1.map.repaint, this.style = t$1, this.options = i$1;
					const s$1 = this.style._mergedLayers, r$1 = !(!this.terrain || !this.terrain.enabled), n$1 = () => this.style._getOrder(r$1).filter(((e$1) => {
						const t$2 = s$1[e$1];
						return !(t$2.type in this._debugParams.enabledLayers) || this._debugParams.enabledLayers[t$2.type];
					}));
					let a$1 = n$1(), l$1 = !1, c$1 = !1, h$1 = null, d$1 = 0, u$1 = !1;
					for (const e$1 of a$1) {
						const t$2 = s$1[e$1];
						"none" !== t$2.visibility && ("circle" === t$2.type ? l$1 = !0 : "building" === t$2.type ? (h$1 = t$2, ++d$1) : "symbol" === t$2.type && (t$2.hasOcclusionOpacityProperties ? c$1 = !0 : l$1 = !0));
					}
					this.updateEmissiveMode();
					let _$1 = a$1.map(((e$1) => s$1[e$1]));
					const p$1 = this.style._mergedSourceCaches;
					this.imageManager = t$1.imageManager, this.modelManager = t$1.modelManager, this.symbolFadeChange = t$1.placement.symbolFadeChange(e.o.now()), this.imageManager.beginFrame();
					for (const e$1 in p$1) {
						const t$2 = p$1[e$1];
						t$2.used && (t$2.prepare(this.context), t$2.getSource().usedInConflation && ++d$1);
					}
					let f$1 = !1;
					for (const e$1 of _$1) e$1.isHidden(this.transform.zoom) || ("clip" === e$1.type && (f$1 = !0), this.prepareLayer(e$1));
					const m$1 = {}, g$1 = {}, v$1 = {}, y$1 = {}, x$1 = {};
					for (const e$1 in p$1) {
						const t$2 = p$1[e$1];
						m$1[e$1] = t$2.getVisibleCoordinates(), g$1[e$1] = m$1[e$1].slice().reverse(), v$1[e$1] = t$2.getVisibleCoordinates(!0).reverse(), y$1[e$1] = t$2.getShadowCasterCoordinates(), x$1[e$1] = t$2.sortCoordinatesByDistance(m$1[e$1]);
					}
					const b$1 = (e$1) => {
						const t$2 = this.style.getLayerSourceCache(e$1);
						return t$2 && t$2.used ? t$2.getSource() : null;
					};
					if (d$1 || f$1 || this._clippingActiveLastFrame) {
						const t$2 = [], i$2 = [];
						let o$2 = 0;
						for (const e$1 of _$1) this.isSourceForClippingOrConflation(e$1, b$1(e$1)) && (t$2.push(e$1), i$2.push(o$2)), o$2++;
						if (t$2 && (f$1 || t$2.length > 1) || this._clippingActiveLastFrame) {
							f$1 = !1;
							const o$3 = [];
							for (let s$2 = 0; s$2 < t$2.length; s$2++) {
								const r$2 = t$2[s$2], n$2 = i$2[s$2], a$2 = this.style.getLayerSourceCache(r$2);
								if (!a$2 || !a$2.used || !a$2.getSource().usedInConflation && "clip" !== r$2.type && "building" !== r$2.type) continue;
								let l$2 = e.eQ, c$2 = e.b_.None;
								const h$2 = [];
								let d$2 = !0;
								if ("building" === r$2.type) l$2 = e.eS;
								else if ("clip" === r$2.type) {
									l$2 = n$2;
									for (const t$3 of r$2.layout.get("clip-layer-types")) c$2 |= "model" === t$3 ? e.b_.Model : "symbol" === t$3 ? e.b_.Symbol : e.b_.FillExtrusion;
									for (const e$1 of r$2.layout.get("clip-layer-scope")) h$2.push(e$1);
									r$2.isHidden(this.transform.zoom) ? d$2 = !1 : f$1 = !0;
								}
								d$2 && o$3.push({
									layer: r$2.fqid,
									cache: a$2,
									order: l$2,
									clipMask: c$2,
									clipScope: h$2
								});
							}
							this.replacementSource.setSources(o$3), u$1 = !0;
						}
					}
					this._clippingActiveLastFrame = f$1, u$1 || this.replacementSource.clear(), this.conflationActive = u$1, this.minCutoffZoom = 0, this.longestCutoffRange = 0, this.opaquePassCutoff = Infinity, this._lastOcclusionLayer = -1, this.layersWithOcclusionOpacity = [];
					for (let e$1 = 0; e$1 < _$1.length; e$1++) {
						const t$2 = _$1[e$1];
						if ("none" === t$2.visibility) continue;
						const i$2 = t$2.cutoffRange();
						if (this.longestCutoffRange = Math.max(i$2, this.longestCutoffRange), i$2 > 0) {
							const e$2 = b$1(t$2);
							e$2 && (this.minCutoffZoom = Math.max(e$2.minzoom, this.minCutoffZoom)), t$2.minzoom && (this.minCutoffZoom = Math.max(t$2.minzoom, this.minCutoffZoom));
						}
						t$2.is3D(r$1) && (this.opaquePassCutoff === Infinity && (this.opaquePassCutoff = e$1), this._lastOcclusionLayer = e$1);
					}
					const w$1 = this.style && this.style.fog;
					w$1 ? (this._fogVisible = 0 !== w$1.getOpacity(this.transform.pitch), this._fogVisible && "globe" !== this.transform.projection.name && (this._fogVisible = w$1.isVisibleOnFrustum(this.transform.cameraFrustum))) : this._fogVisible = !1, this._cachedTileFogOpacities = {}, this.terrain && (this.terrain.updateTileBinding(v$1), this.opaquePassCutoff = 0, a$1 = n$1(), _$1 = a$1.map(((e$1) => s$1[e$1])));
					const T$1 = this._shadowRenderer;
					if (T$1) {
						T$1.updateShadowParameters(this.transform, this.style.directionalLight);
						for (const e$1 in p$1) for (const t$2 of m$1[e$1]) {
							let e$2 = {
								min: 0,
								max: 0
							};
							this.terrain && (e$2 = this.terrain.getMinMaxForTile(t$2) || e$2), T$1.addShadowReceiver(t$2.toUnwrapped(), e$2.min, e$2.max);
						}
					}
					"globe" !== this.transform.projection.name || this.globeSharedBuffers || (this.globeSharedBuffers = new e.eR(this.context)), this.style.fog && this.transform.projection.supportsFog ? (this._atmosphere || (this._atmosphere = new Wn(this)), this._atmosphere.update(this)) : this._atmosphere && (this._atmosphere.destroy(), this._atmosphere = void 0);
					const E$1 = this._debugParams.forceEnablePrecipitation || !(!this.style || !this.style.snow), S$1 = this._debugParams.forceEnablePrecipitation || !(!this.style || !this.style.rain);
					if (E$1 && !this._snow && (this._snow = new Ia(this)), !E$1 && this._snow && (this._snow.destroy(), delete this._snow), S$1 && !this._rain && (this._rain = new Ea(this)), !S$1 && this._rain && (this._rain.destroy(), delete this._rain), this._snow && this._snow.update(this), this._rain && this._rain.update(this), h$1) {
						this.buildingTileBorderManager || (this.buildingTileBorderManager = new $n());
						const e$1 = this.style.getLayerSourceCache(h$1);
						this.buildingTileBorderManager.updateBorders(e$1, h$1);
					}
					if (!q.has(this.context.gl)) return;
					this.renderPass = "offscreen";
					for (const e$1 of _$1) {
						const i$2 = t$1.getLayerSourceCache(e$1);
						if (!e$1.hasOffscreenPass() || e$1.isHidden(this.transform.zoom)) continue;
						const o$2 = i$2 ? g$1[i$2.id] : void 0;
						("custom" === e$1.type || "raster" === e$1.type || "raster-particle" === e$1.type || e$1.isSky() || o$2 && o$2.length) && this.renderLayer(this, i$2, e$1, o$2);
					}
					this.depthRangeFor3D = [0, 1 - (_$1.length + 2) * this.numSublayers * this.depthEpsilon], this._shadowRenderer && (this.renderPass = "shadow", this._shadowRenderer.drawShadowPass(this.style, y$1)), this.context.bindFramebuffer.set(null), this.context.viewport.set([
						0,
						0,
						this.width,
						this.height
					]);
					const I$1 = "globe" === this.transform.projection.name || this.transform.isHorizonVisible(), C$1 = (() => {
						if (i$1.showOverdrawInspector) return e.ao.black;
						const t$2 = this.style.fog;
						if (t$2 && this.transform.projection.supportsFog) {
							const i$2 = this.style.getLut(t$2.scope);
							if (!I$1) {
								const o$2 = "none" === t$2.properties.get("color-use-theme"), s$2 = t$2.properties.get("color").toNonPremultipliedRenderColor(o$2 ? null : i$2).toArray01();
								return new e.ao(...s$2);
							}
							if (I$1) {
								const o$2 = "none" === t$2.properties.get("space-color-use-theme"), s$2 = t$2.properties.get("space-color").toNonPremultipliedRenderColor(o$2 ? null : i$2).toArray01();
								return new e.ao(...s$2);
							}
						}
						return e.ao.transparent;
					})();
					if (this.context.clear({
						color: C$1,
						depth: 1
					}), this.clearStencil(), this._showOverdrawInspector = i$1.showOverdrawInspector, this.renderPass = "opaque", this.style.fog && this.transform.projection.supportsFog && this._atmosphere && !this._showOverdrawInspector && I$1 && this._atmosphere.drawStars(this, this.style.fog), !this.terrain) for (this.currentLayer = a$1.length - 1; this.currentLayer >= 0; this.currentLayer--) {
						const e$1 = _$1[this.currentLayer], i$2 = t$1.getLayerSourceCache(e$1);
						if (e$1.isSky()) continue;
						const o$2 = i$2 ? (e$1.is3D(r$1) ? x$1 : g$1)[i$2.id] : void 0;
						this._renderTileClippingMasks(e$1, i$2, o$2), this.renderLayer(this, i$2, e$1, o$2);
					}
					if (this.style.fog && this.transform.projection.supportsFog && this._atmosphere && !this._showOverdrawInspector && I$1 && this._atmosphere.drawAtmosphereGlow(this, this.style.fog), this.renderPass = "sky", (!this._atmosphere || e.aj(this.transform.zoom) > 0) && ("globe" === this.transform.projection.name || this.transform.isHorizonVisible())) for (this.currentLayer = 0; this.currentLayer < a$1.length; this.currentLayer++) {
						const e$1 = _$1[this.currentLayer], i$2 = t$1.getLayerSourceCache(e$1);
						e$1.isSky() && this.renderLayer(this, i$2, e$1, i$2 ? g$1[i$2.id] : void 0);
					}
					function R$1(e$1, t$2) {
						let i$2;
						return t$2 && (i$2 = ("symbol" === e$1.type ? v$1 : e$1.is3D(r$1) ? x$1 : g$1)[t$2.id]), i$2;
					}
					if (this.renderPass = "translucent", "globe" === this.transform.projection.name) {
						for (this.renderElevatedRasterBackface = !0, this.currentLayer = 0; this.currentLayer < a$1.length;) {
							const e$1 = _$1[this.currentLayer];
							if ("raster" === e$1.type || "raster-particle" === e$1.type) {
								const i$2 = t$1.getLayerSourceCache(e$1);
								this.renderLayer(this, i$2, e$1, R$1(e$1, i$2));
							}
							++this.currentLayer;
						}
						this.renderElevatedRasterBackface = !1;
					}
					this.currentLayer = 0, this.firstLightBeamLayer = Number.MAX_SAFE_INTEGER;
					let A$1 = 0;
					T$1 && (A$1 = T$1.getShadowCastingLayerCount());
					let L$1 = !1, D$1 = -1;
					for (let e$1 = 0; e$1 < a$1.length; ++e$1) {
						const t$2 = _$1[e$1];
						t$2.isHidden(this.transform.zoom) || t$2.is3D(r$1) && (D$1 = e$1);
					}
					c$1 && -1 === D$1 && (l$1 = !0);
					let P$1 = !1;
					for (; this.currentLayer < a$1.length;) {
						const e$1 = _$1[this.currentLayer], i$2 = t$1.getLayerSourceCache(e$1);
						if (e$1.isSky()) ++this.currentLayer;
						else if (this.terrain && this.style.isLayerDraped(e$1)) {
							if (e$1.isHidden(this.transform.zoom)) {
								++this.currentLayer;
								continue;
							}
							this.currentLayer = this.terrain.renderBatch(this.currentLayer), this._lastOcclusionLayer = Math.max(this.currentLayer, this._lastOcclusionLayer);
						} else {
							if (!P$1 && e$1.is3D(r$1) && !r$1) {
								const e$2 = this.currentLayer, t$2 = (e$3) => {
									for (this.currentLayer = 0; this.currentLayer < _$1.length; this.currentLayer++) {
										const t$3 = _$1[this.currentLayer];
										if (Aa[t$3.type]) {
											const i$3 = this.style.getLayerSourceCache(t$3);
											Aa[t$3.type](this, i$3, t$3, R$1(t$3, i$3), e$3);
										}
									}
								};
								t$2("initialize"), t$2("reset"), this.currentLayer = e$2, P$1 = !0;
							}
							if (l$1 && !L$1 && this.terrain && !this.transform.isOrthographic && (L$1 = !0, this.blitDepth()), c$1 && -1 !== D$1 && this.currentLayer === D$1 + 1 && !this.transform.isOrthographic && this.blitDepth(), this.terrain || this._renderTileClippingMasks(e$1, i$2, i$2 ? m$1[i$2.id] : void 0), this.renderLayer(this, i$2, e$1, R$1(e$1, i$2)), !this.terrain && T$1 && A$1 > 0 && e$1.hasShadowPass() && 0 == --A$1) {
								{
									this.clearStencil(), this.resetStencilClippingMasks();
									const e$2 = this.currentLayer;
									for (this.currentLayer = 0; this.currentLayer < _$1.length; this.currentLayer++) {
										const e$3 = _$1[this.currentLayer];
										if (La[e$3.type]) {
											const t$2 = this.style.getLayerSourceCache(e$3);
											La[e$3.type](this, t$2, e$3, R$1(e$3, t$2));
										}
									}
									this.currentLayer = e$2;
								}
								if (T$1.drawGroundShadows(), this.firstLightBeamLayer <= this.currentLayer) {
									const e$2 = this.currentLayer;
									for (this.renderPass = "light-beam", this.currentLayer = this.firstLightBeamLayer; this.currentLayer <= e$2; this.currentLayer++) {
										const e$3 = _$1[this.currentLayer];
										if (!e$3.hasLightBeamPass()) continue;
										const i$3 = t$1.getLayerSourceCache(e$3);
										this.renderLayer(this, i$3, e$3, i$3 ? g$1[i$3.id] : void 0);
									}
									this.currentLayer = e$2, this.renderPass = "translucent";
								}
							}
							if (this.currentLayer >= this._lastOcclusionLayer && this.layersWithOcclusionOpacity.length > 0) {
								const e$2 = this.currentLayer;
								this.depthOcclusion = !0;
								for (const e$3 of this.layersWithOcclusionOpacity) {
									this.currentLayer = e$3;
									const i$3 = _$1[this.currentLayer], o$2 = t$1.getLayerSourceCache(i$3), s$2 = o$2 ? g$1[o$2.id] : void 0;
									this.terrain || this._renderTileClippingMasks(i$3, o$2, o$2 ? m$1[o$2.id] : void 0), this.renderLayer(this, o$2, i$3, s$2);
								}
								this.depthOcclusion = !1, this.currentLayer = e$2, this.renderPass = "translucent", this.layersWithOcclusionOpacity = [];
							}
							++this.currentLayer;
						}
					}
					if (this.terrain && this.terrain.postRender(), this._snow && this._snow.draw(this), this._rain && this._rain.draw(this), this.options.showTileBoundaries || this.options.showQueryGeometry || this.options.showTileAABBs) {
						let i$2 = null;
						_$1.forEach(((e$1) => {
							const o$2 = t$1.getLayerSourceCache(e$1);
							o$2 && !e$1.isHidden(this.transform.zoom) && o$2.getVisibleCoordinates().length && (!i$2 || i$2.getSource().maxzoom < o$2.getSource().maxzoom) && (i$2 = o$2);
						})), i$2 && this.options.showTileBoundaries && On(this, i$2, i$2.getVisibleCoordinates(), e.ao.red, !1, this.options.showParseStatus);
					}
					this.terrain && this._debugParams.showTerrainProxyTiles && On(this, this.terrain.proxySourceCache, this.terrain.proxyCoords, new e.ao(1, .8, .1, 1), !0, this.options.showParseStatus), this.options.showPadding && function(e$1) {
						const t$2 = e$1.transform.padding;
						Mn(e$1, e$1.transform.height - (t$2.top || 0), 3, Rn), Mn(e$1, t$2.bottom || 0, 3, An), Fn(e$1, t$2.left || 0, 3, Ln), Fn(e$1, e$1.transform.width - (t$2.right || 0), 3, Dn);
						const i$2 = e$1.transform.centerPoint;
						(function(e$2, t$3, i$3, o$2) {
							Bn(e$2, t$3 - 1, i$3 - 10, 2, 20, o$2), Bn(e$2, t$3 - 10, i$3 - 1, 20, 2, o$2);
						})(e$1, i$2.x, e$1.transform.height - i$2.y, Pn);
					}(this), this.context.setDefault(), this.frameCounter = (this.frameCounter + 1) % Number.MAX_SAFE_INTEGER, this.tileLoaded && this.options.speedIndexTiming && (this.loadTimeStamps.push(performance.now()), this.saveCanvasCopy()), u$1 || (this.conflationActive = !1);
				}
				prepareLayer(e$1) {
					this.gpuTimingStart(e$1);
					const { unsupportedLayers: t$1 } = this.transform.projection, i$1 = !t$1 || !t$1.includes(e$1.type);
					if (Ra[e$1.type] && (i$1 || this.terrain && "custom" === e$1.type)) {
						const t$2 = this.style.getLayerSourceCache(e$1);
						Ra[e$1.type](e$1, t$2, this);
					}
					this.gpuTimingEnd();
				}
				renderLayer(e$1, t$1, i$1, o$1) {
					i$1.isHidden(this.transform.zoom) || ("background" === i$1.type || "sky" === i$1.type || "custom" === i$1.type || "model" === i$1.type || "raster" === i$1.type || "raster-particle" === i$1.type || o$1 && o$1.length) && (this.id = i$1.id, this.gpuTimingStart(i$1), e$1.transform.projection.unsupportedLayers && e$1.transform.projection.unsupportedLayers.includes(i$1.type) && (!e$1.terrain || "custom" !== i$1.type) || "clip" === i$1.type || Ca[i$1.type](e$1, t$1, i$1, o$1, this.style.placement.variableOffsets, this.options.isInitialLoad), this.gpuTimingEnd());
				}
				gpuTimingStart(e$1) {
					if (!this.options.gpuTiming) return;
					const t$1 = this.context.extTimerQuery, i$1 = this.context.gl;
					let o$1 = this.gpuTimers[e$1.id];
					o$1 || (o$1 = this.gpuTimers[e$1.id] = {
						calls: 0,
						cpuTime: 0,
						query: i$1.createQuery()
					}), o$1.calls++, i$1.beginQuery(t$1.TIME_ELAPSED_EXT, o$1.query);
				}
				gpuTimingDeferredRenderStart() {
					if (this.options.gpuTimingDeferredRender) {
						const e$1 = this.context.extTimerQuery, t$1 = this.context.gl, i$1 = t$1.createQuery();
						this.deferredRenderGpuTimeQueries.push(i$1), t$1.beginQuery(e$1.TIME_ELAPSED_EXT, i$1);
					}
				}
				gpuTimingDeferredRenderEnd() {
					this.options.gpuTimingDeferredRender && this.context.gl.endQuery(this.context.extTimerQuery.TIME_ELAPSED_EXT);
				}
				gpuTimingEnd() {
					this.options.gpuTiming && this.context.gl.endQuery(this.context.extTimerQuery.TIME_ELAPSED_EXT);
				}
				collectGpuTimers() {
					const e$1 = this.gpuTimers;
					return this.gpuTimers = {}, e$1;
				}
				collectDeferredRenderGpuQueries() {
					const e$1 = this.deferredRenderGpuTimeQueries;
					return this.deferredRenderGpuTimeQueries = [], e$1;
				}
				queryGpuTimers(e$1) {
					const t$1 = {};
					for (const i$1 in e$1) {
						const o$1 = e$1[i$1], s$1 = this.context.extTimerQuery, r$1 = s$1.getQueryParameter(o$1.query, this.context.gl.QUERY_RESULT) / 1e6;
						s$1.deleteQueryEXT(o$1.query), t$1[i$1] = r$1;
					}
					return t$1;
				}
				queryGpuTimeDeferredRender(e$1) {
					if (!this.options.gpuTimingDeferredRender) return 0;
					const t$1 = this.context.gl;
					let i$1 = 0;
					for (const o$1 of e$1) i$1 += t$1.getQueryParameter(o$1, t$1.QUERY_RESULT) / 1e6, t$1.deleteQuery(o$1);
					return i$1;
				}
				translatePosMatrix(t$1, i$1, o$1, s$1, r$1) {
					if (!o$1[0] && !o$1[1]) return t$1;
					const n$1 = r$1 ? "map" === s$1 ? this.transform.angle : 0 : "viewport" === s$1 ? -this.transform.angle : 0;
					if (n$1) {
						const e$1 = Math.sin(n$1), t$2 = Math.cos(n$1);
						o$1 = [o$1[0] * t$2 - o$1[1] * e$1, o$1[0] * e$1 + o$1[1] * t$2];
					}
					const a$1 = [
						r$1 ? o$1[0] : e.ay(i$1, o$1[0], this.transform.zoom),
						r$1 ? o$1[1] : e.ay(i$1, o$1[1], this.transform.zoom),
						0
					], l$1 = new Float32Array(16);
					return e.br(l$1, t$1, a$1), l$1;
				}
				saveTileTexture(e$1) {
					if (e$1.context !== this.context) return;
					const t$1 = e$1.size[0], i$1 = this._tileTextures[t$1];
					i$1 ? i$1.push(e$1) : this._tileTextures[t$1] = [e$1];
				}
				getTileTexture(e$1) {
					const t$1 = this._tileTextures[e$1];
					return t$1 && t$1.length > 0 ? t$1.pop() : null;
				}
				terrainRenderModeElevated() {
					return this.style && !!this.style.getTerrain() && !!this.terrain && !this.terrain.renderingToTexture || this.forceTerrainMode;
				}
				linearFloatFilteringSupported() {
					return null != this.context.extTextureFloatLinear;
				}
				currentGlobalDefines(e$1, t$1, i$1) {
					const o$1 = void 0 === i$1 ? this.terrain && this.terrain.renderingToTexture : i$1, s$1 = [];
					return this.style && this.style.enable3dLights() && ("globeRaster" === e$1 || "terrainRaster" === e$1 ? (s$1.push("LIGHTING_3D_MODE"), s$1.push("LIGHTING_3D_ALPHA_EMISSIVENESS")) : o$1 || s$1.push("LIGHTING_3D_MODE")), "shadow" === this.renderPass && (this._shadowMapDebug || s$1.push("DEPTH_TEXTURE")), this.terrainRenderModeElevated() && (s$1.push("TERRAIN"), this.linearFloatFilteringSupported() && s$1.push("TERRAIN_DEM_FLOAT_FORMAT")), "globe" === this.transform.projection.name && s$1.push("GLOBE"), !this._fogVisible || o$1 || void 0 !== t$1 && !t$1 || s$1.push("FOG", "FOG_DITHERING"), o$1 && s$1.push("RENDER_TO_TEXTURE"), this._showOverdrawInspector && s$1.push("OVERDRAW_INSPECTOR"), s$1;
				}
				getOrCreateProgram(e$1, t$1) {
					this.cache = this.cache || {};
					const i$1 = t$1 && t$1.defines || [], o$1 = t$1 && t$1.config, s$1 = this.currentGlobalDefines(e$1, t$1 && t$1.overrideFog, t$1 && t$1.overrideRtt).concat(i$1), r$1 = hr.cacheKey(is[e$1], e$1, s$1, o$1);
					return this.cache[r$1] || (this.cache[r$1] = new hr(this.context, e$1, is[e$1], o$1, Zr[e$1], s$1)), this.cache[r$1];
				}
				setCustomLayerDefaults() {
					this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.frontFace.setDefault(), this.context.cullFaceSide.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();
				}
				setBaseState() {
					const e$1 = this.context.gl;
					this.context.cullFace.set(!1), this.context.viewport.set([
						0,
						0,
						this.width,
						this.height
					]), this.context.blendEquation.set(e$1.FUNC_ADD);
				}
				initDebugOverlayCanvas() {
					this.debugOverlayCanvas ?? (this.debugOverlayCanvas = document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new e.T(this.context, this.debugOverlayCanvas, this.context.gl.RGBA8));
				}
				destroy() {
					this._terrain && this._terrain.destroy(), this._atmosphere && (this._atmosphere.destroy(), this._atmosphere = void 0), this.globeSharedBuffers && this.globeSharedBuffers.destroy(), this.emptyTexture.destroy(), this.debugOverlayTexture && this.debugOverlayTexture.destroy(), this._wireframeDebugCache.destroy(), this.depthFBO && (this.depthFBO.destroy(), this.depthFBO = void 0, this.depthTexture = void 0), this.emptyDepthTexture && this.emptyDepthTexture.destroy();
				}
				prepareDrawTile() {
					this.terrain && this.terrain.prepareDrawTile();
				}
				uploadCommonLightUniforms(t$1, i$1) {
					if (this.style.enable3dLights()) {
						const o$1 = this.style.directionalLight, s$1 = this.style.ambientLight;
						if (o$1 && s$1) {
							const r$1 = ((t$2, i$2, o$2) => {
								const s$2 = t$2.properties.get("direction"), r$2 = "none" === t$2.properties.get("color-use-theme"), n$1 = t$2.properties.get("color").toNonPremultipliedRenderColor(r$2 ? null : o$2.getLut(t$2.scope)).toArray01(), a$1 = t$2.properties.get("intensity"), l$1 = "none" === i$2.properties.get("color-use-theme"), c$1 = i$2.properties.get("color").toNonPremultipliedRenderColor(l$1 ? null : o$2.getLut(i$2.scope)).toArray01(), h$1 = i$2.properties.get("intensity"), d$1 = [
									s$2.x,
									s$2.y,
									s$2.z
								], u$1 = e.dN(c$1, h$1), _$1 = e.dN(n$1, a$1);
								return {
									u_lighting_ambient_color: u$1,
									u_lighting_directional_dir: d$1,
									u_lighting_directional_color: _$1,
									u_ground_radiance: ar(d$1, _$1, u$1)
								};
							})(o$1, s$1, this.style);
							i$1.setLightsUniformValues(t$1, r$1);
						}
					}
				}
				uploadCommonUniforms(t$1, i$1, o$1, s$1, r$1) {
					if (this.uploadCommonLightUniforms(t$1, i$1), this.terrain && this.terrain.renderingToTexture) return;
					const n$1 = this.style.fog;
					if (n$1) {
						const r$2 = n$1.getOpacity(this.transform.pitch), a$1 = ((t$2, i$2, o$2, s$2, r$3, n$2, a$2, l$1, c$1, h$1, d$1, u$1) => {
							const _$1 = t$2.transform, p$1 = "none" === i$2.properties.get("color-use-theme"), f$1 = i$2.properties.get("color").toNonPremultipliedRenderColor(p$1 ? null : t$2.style.getLut(i$2.scope)).toArray01();
							f$1[3] = s$2;
							const m$1 = t$2.frameCounter / 1e3 % 1, [g$1, v$1] = i$2.properties.get("vertical-range");
							return {
								u_fog_matrix: o$2 ? _$1.calculateFogTileMatrix(o$2) : u$1 || t$2.identityMat,
								u_fog_range: i$2.getFovAdjustedRange(_$1._fov),
								u_fog_color: f$1,
								u_fog_horizon_blend: i$2.properties.get("horizon-blend"),
								u_fog_vertical_limit: [Math.min(g$1, v$1), v$1],
								u_fog_temporal_offset: m$1,
								u_frustum_tl: r$3,
								u_frustum_tr: n$2,
								u_frustum_br: a$2,
								u_frustum_bl: l$1,
								u_globe_pos: c$1,
								u_globe_radius: h$1,
								u_viewport: d$1,
								u_globe_transition: e.aj(_$1.zoom),
								u_is_globe: +("globe" === _$1.projection.name)
							};
						})(this, n$1, o$1, r$2, this.transform.frustumCorners.TL, this.transform.frustumCorners.TR, this.transform.frustumCorners.BR, this.transform.frustumCorners.BL, this.transform.globeCenterInViewSpace, this.transform.globeRadius, [this.transform.width * e.o.devicePixelRatio, this.transform.height * e.o.devicePixelRatio], s$1);
						i$1.setFogUniformValues(t$1, a$1);
					}
					r$1 && i$1.setCutoffUniformValues(t$1, r$1.uniformValues);
				}
				setTileLoadedFlag(e$1) {
					this.tileLoaded = e$1;
				}
				saveCanvasCopy() {
					const e$1 = this.canvasCopy();
					e$1 && (this.frameCopies.push(e$1), this.tileLoaded = !1);
				}
				canvasCopy() {
					const e$1 = this.context.gl, t$1 = e$1.createTexture();
					return e$1.bindTexture(e$1.TEXTURE_2D, t$1), e$1.copyTexImage2D(e$1.TEXTURE_2D, 0, e$1.RGBA, 0, 0, e$1.drawingBufferWidth, e$1.drawingBufferHeight, 0), t$1;
				}
				getCanvasCopiesAndTimestamps() {
					return {
						canvasCopies: this.frameCopies,
						timeStamps: this.loadTimeStamps
					};
				}
				averageElevationNeedsEasing() {
					if (!this.transform._elevation) return !1;
					const e$1 = this.style && this.style.fog;
					return !!e$1 && 0 !== e$1.getOpacity(this.transform.pitch);
				}
				getBackgroundTiles() {
					const e$1 = this._backgroundTiles, t$1 = this._backgroundTiles = {}, i$1 = this.transform.coveringTiles({ tileSize: 512 });
					for (const o$1 of i$1) t$1[o$1.key] = e$1[o$1.key] || new Pt(o$1, 512, this.transform.tileZoom, this, void 0, this.worldview);
					return t$1;
				}
				clearBackgroundTiles() {
					this._backgroundTiles = {};
				}
				isSourceForClippingOrConflation(e$1, t$1) {
					return !(!e$1.is3D(!(!this.terrain || !this.terrain.enabled)) || "clip" !== e$1.type && "building" !== e$1.type && (e$1.minzoom && e$1.minzoom > this.transform.zoom || (this.style._clipLayerPresent || "building" !== e$1.sourceLayer && "procedural_buildings" !== e$1.sourceLayer) && (!t$1 || "batched-model" !== t$1.type)));
				}
				isTileAffectedByFog(e$1) {
					if (!this.style || !this.style.fog) return !1;
					if ("globe" === this.transform.projection.name) return !0;
					let t$1 = this._cachedTileFogOpacities[e$1.key];
					return t$1 || (this._cachedTileFogOpacities[e$1.key] = t$1 = this.style.fog.getOpacityForTile(e$1)), t$1[0] >= He || t$1[1] >= He;
				}
				setupDepthForOcclusion(e$1, t$1, i$1) {
					const o$1 = this.context, s$1 = o$1.gl, r$1 = !!i$1;
					var n$1;
					i$1 || (i$1 = {
						u_dem: 2,
						u_dem_prev: 4,
						u_dem_tl: [0, 0],
						u_dem_tl_prev: [0, 0],
						u_dem_scale: 0,
						u_dem_scale_prev: 0,
						u_dem_size: 0,
						u_dem_lerp: 1,
						u_depth: 3,
						u_depth_size_inv: [0, 0],
						u_depth_range_unpack: [0, 1],
						u_occluder_half_size: 16,
						u_occlusion_depth_offset: -1e-4,
						u_exaggeration: 0
					}), o$1.activeTexture.set(s$1.TEXTURE3), e$1 && this.depthFBO && this.depthTexture ? (this.depthTexture.bind(s$1.NEAREST, s$1.CLAMP_TO_EDGE), i$1.u_depth_size_inv = [1 / this.depthFBO.width, 1 / this.depthFBO.height], i$1.u_depth_range_unpack = [2 / ((n$1 = this.depthRangeFor3D)[1] - n$1[0]), -1 - 2 * n$1[0] / (n$1[1] - n$1[0])], i$1.u_occluder_half_size = .5 * this.occlusionParams.occluderSize, i$1.u_occlusion_depth_offset = this.occlusionParams.depthOffset) : this.emptyDepthTexture.bind(s$1.NEAREST, s$1.CLAMP_TO_EDGE), o$1.activeTexture.set(s$1.TEXTURE0), r$1 || t$1.setTerrainUniformValues(o$1, i$1);
				}
				updateEmissiveMode() {
					if (this._forceEmissiveMode) return;
					this.emissiveMode = this.style.hasDataDrivenEmissiveStrength() ? this.context.extBlendFuncExtended ? "dual-source-blending" : "mrt-fallback" : "constant";
				}
			}
			function Pa(e$1, t$1) {
				let i$1 = !1, o$1 = null;
				const s$1 = () => {
					o$1 = null, i$1 && (e$1(), o$1 = setTimeout(s$1, t$1), i$1 = !1);
				};
				return () => (i$1 = !0, o$1 || s$1(), o$1);
			}
			class Oa {
				constructor(t$1) {
					this._hashName = t$1 && encodeURIComponent(t$1), e.aY([
						"_getCurrentHash",
						"_onHashChange",
						"_updateHash"
					], this), this._updateHash = Pa(this._updateHashUnthrottled.bind(this), 300);
				}
				addTo(e$1) {
					return this._map = e$1, window.addEventListener("hashchange", this._onHashChange, !1), e$1.on("moveend", this._updateHash), this;
				}
				remove() {
					return this._map ? (this._map.off("moveend", this._updateHash), window.removeEventListener("hashchange", this._onHashChange, !1), clearTimeout(this._updateHash()), this._map = void 0, this) : this;
				}
				getHashString() {
					const e$1 = this._map;
					if (!e$1) return "";
					const t$1 = za(e$1);
					if (this._hashName) {
						const e$2 = this._hashName;
						let i$1 = !1;
						const o$1 = location.hash.slice(1).split("&").map(((o$2) => {
							const s$1 = o$2.split("=")[0];
							return s$1 === e$2 ? (i$1 = !0, `${s$1}=${t$1}`) : o$2;
						})).filter(((e$3) => e$3));
						return i$1 || o$1.push(`${e$2}=${t$1}`), `#${o$1.join("&")}`;
					}
					return `#${t$1}`;
				}
				_getCurrentHash() {
					const e$1 = location.hash.replace("#", "");
					if (this._hashName) {
						let t$1;
						return e$1.split("&").map(((e$2) => e$2.split("="))).forEach(((e$2) => {
							e$2[0] === this._hashName && (t$1 = e$2);
						})), (t$1 && t$1[1] || "").split("/");
					}
					return e$1.split("/");
				}
				_onHashChange() {
					const e$1 = this._map;
					if (!e$1) return !1;
					const t$1 = this._getCurrentHash();
					if (t$1.length >= 3 && !t$1.some(((e$2) => isNaN(Number(e$2))))) {
						const i$1 = e$1.dragRotate.isEnabled() && e$1.touchZoomRotate.isEnabled() ? +(t$1[3] || 0) : e$1.getBearing();
						return e$1.jumpTo({
							center: [+t$1[2], +t$1[1]],
							zoom: +t$1[0],
							bearing: i$1,
							pitch: +(t$1[4] || 0)
						}), !0;
					}
					return !1;
				}
				_updateHashUnthrottled() {
					history.replaceState(history.state, "", location.href.replace(/(#.+)?$/, this.getHashString()));
				}
			}
			function za(e$1, t$1) {
				const i$1 = e$1.getCenter(), o$1 = Math.round(100 * e$1.getZoom()) / 100, s$1 = Math.ceil((o$1 * Math.LN2 + Math.log(512 / 360 / .5)) / Math.LN10), r$1 = Math.pow(10, s$1), n$1 = Math.round(i$1.lng * r$1) / r$1, a$1 = Math.round(i$1.lat * r$1) / r$1, l$1 = e$1.getBearing(), c$1 = e$1.getPitch();
				let h$1 = t$1 ? `/${n$1}/${a$1}/${o$1}` : `${o$1}/${a$1}/${n$1}`;
				return (l$1 || c$1) && (h$1 += "/" + Math.round(10 * l$1) / 10), c$1 && (h$1 += `/${Math.round(c$1)}`), h$1;
			}
			const Ma = {
				linearity: .3,
				easing: e.eT(0, 0, .3, 1)
			}, Fa = Object.assign({
				deceleration: 2500,
				maxSpeed: 1400
			}, Ma), Ba = Object.assign({
				deceleration: 20,
				maxSpeed: 1400
			}, Ma), ka = Object.assign({
				deceleration: 1e3,
				maxSpeed: 360
			}, Ma), Na = Object.assign({
				deceleration: 1e3,
				maxSpeed: 90
			}, Ma);
			class Ua {
				constructor(e$1) {
					this._map = e$1, this.clear();
				}
				clear() {
					this._inertiaBuffer = [];
				}
				record(t$1) {
					this._drainInertiaBuffer(), this._inertiaBuffer.push({
						time: e.o.now(),
						settings: t$1
					});
				}
				_drainInertiaBuffer() {
					const t$1 = this._inertiaBuffer, i$1 = e.o.now();
					for (; t$1.length > 0 && i$1 - t$1[0].time > 160;) t$1.shift();
				}
				_onMoveEnd(t$1) {
					if (this._map._prefersReducedMotion()) return;
					if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2) return;
					const i$1 = {
						zoom: 0,
						bearing: 0,
						pitch: 0,
						pan: new e.P(0, 0),
						pinchAround: void 0,
						around: void 0
					};
					for (const { settings: e$1 } of this._inertiaBuffer) i$1.zoom += e$1.zoomDelta || 0, i$1.bearing += e$1.bearingDelta || 0, i$1.pitch += e$1.pitchDelta || 0, e$1.panDelta && i$1.pan._add(e$1.panDelta), e$1.around && (i$1.around = e$1.around), e$1.pinchAround && (i$1.pinchAround = e$1.pinchAround);
					const o$1 = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time, s$1 = {};
					if (i$1.pan.mag()) {
						const e$1 = Ga(i$1.pan.mag(), o$1, Object.assign({}, Fa, t$1 || {}));
						s$1.offset = i$1.pan.mult(e$1.amount / i$1.pan.mag()), s$1.center = this._map.transform.center, ja(s$1, e$1);
					}
					if (i$1.zoom) {
						const e$1 = Ga(i$1.zoom, o$1, Ba);
						s$1.zoom = this._map.transform.zoom + e$1.amount, ja(s$1, e$1);
					}
					if (i$1.bearing) {
						const t$2 = Ga(i$1.bearing, o$1, ka);
						s$1.bearing = this._map.transform.bearing + e.aA(t$2.amount, -179, 179), ja(s$1, t$2);
					}
					if (i$1.pitch) {
						const e$1 = Ga(i$1.pitch, o$1, Na);
						s$1.pitch = this._map.transform.pitch + e$1.amount, ja(s$1, e$1);
					}
					if (s$1.zoom || s$1.bearing) {
						const e$1 = void 0 === i$1.pinchAround ? i$1.around : i$1.pinchAround;
						s$1.around = e$1 ? this._map.unproject(e$1) : this._map.getCenter();
					}
					return this.clear(), s$1.noMoveStart = !0, s$1;
				}
			}
			function ja(e$1, t$1) {
				(!e$1.duration || e$1.duration < t$1.duration) && (e$1.duration = t$1.duration, e$1.easing = t$1.easing);
			}
			function Ga(t$1, i$1, o$1) {
				const { maxSpeed: s$1, linearity: r$1, deceleration: n$1 } = o$1, a$1 = e.aA(t$1 * r$1 / (i$1 / 1e3), -s$1, s$1), l$1 = Math.abs(a$1) / (n$1 * r$1);
				return {
					easing: o$1.easing,
					duration: 1e3 * l$1,
					amount: a$1 * (l$1 / 2)
				};
			}
			class Va extends e.z {
				preventDefault() {
					this._defaultPrevented = !0;
				}
				get defaultPrevented() {
					return this._defaultPrevented;
				}
				constructor(e$1, t$1, i$1, o$1 = {}) {
					const s$1 = g(t$1.getCanvasContainer(), i$1), r$1 = t$1.unproject(s$1);
					super(e$1, Object.assign({
						point: s$1,
						lngLat: r$1,
						originalEvent: i$1
					}, o$1)), this._defaultPrevented = !1, this.target = t$1;
				}
			}
			class Ha extends e.z {
				preventDefault() {
					this._defaultPrevented = !0;
				}
				get defaultPrevented() {
					return this._defaultPrevented;
				}
				constructor(t$1, i$1, o$1) {
					const s$1 = "touchend" === t$1 ? o$1.changedTouches : o$1.touches, r$1 = v(i$1.getCanvasContainer(), s$1), n$1 = r$1.map(((e$1) => i$1.unproject(e$1))), a$1 = r$1.reduce(((e$1, t$2, i$2, o$2) => e$1.add(t$2.div(o$2.length))), new e.P(0, 0));
					super(t$1, {
						points: r$1,
						point: a$1,
						lngLats: n$1,
						lngLat: i$1.unproject(a$1),
						originalEvent: o$1
					}), this._defaultPrevented = !1;
				}
			}
			class qa extends e.z {
				preventDefault() {
					this._defaultPrevented = !0;
				}
				get defaultPrevented() {
					return this._defaultPrevented;
				}
				constructor(e$1, t$1) {
					super("wheel", { originalEvent: t$1 }), this._defaultPrevented = !1;
				}
			}
			class Za {
				constructor(e$1, t$1) {
					this._map = e$1, this._clickTolerance = t$1.clickTolerance;
				}
				reset() {
					this._mousedownPos = void 0;
				}
				wheel(e$1) {
					return this._firePreventable(new qa(this._map, e$1));
				}
				mousedown(e$1, t$1) {
					return this._mousedownPos = t$1, this._firePreventable(new Va(e$1.type, this._map, e$1));
				}
				mouseup(e$1) {
					this._map.fire(new Va(e$1.type, this._map, e$1));
				}
				preclick(e$1) {
					const t$1 = new MouseEvent("preclick", e$1);
					this._map.fire(new Va(t$1.type, this._map, t$1));
				}
				click(e$1, t$1) {
					this._mousedownPos && this._mousedownPos.dist(t$1) >= this._clickTolerance || (this.preclick(e$1), this._map.fire(new Va(e$1.type, this._map, e$1)));
				}
				dblclick(e$1) {
					return this._firePreventable(new Va(e$1.type, this._map, e$1));
				}
				mouseover(e$1) {
					this._map.fire(new Va(e$1.type, this._map, e$1));
				}
				mouseout(e$1) {
					this._map.fire(new Va(e$1.type, this._map, e$1));
				}
				touchstart(e$1) {
					return this._firePreventable(new Ha(e$1.type, this._map, e$1));
				}
				touchmove(e$1) {
					this._map.fire(new Ha(e$1.type, this._map, e$1));
				}
				touchend(e$1) {
					this._map.fire(new Ha(e$1.type, this._map, e$1));
				}
				touchcancel(e$1) {
					this._map.fire(new Ha(e$1.type, this._map, e$1));
				}
				_firePreventable(e$1) {
					if (this._map.fire(e$1), e$1.defaultPrevented) return {};
				}
				isEnabled() {
					return !0;
				}
				isActive() {
					return !1;
				}
				enable() {}
				disable() {}
			}
			class Wa {
				constructor(e$1) {
					this._map = e$1;
				}
				reset() {
					this._delayContextMenu = !1, this._contextMenuEvent = void 0;
				}
				mousemove(e$1) {
					this._map.fire(new Va(e$1.type, this._map, e$1));
				}
				mousedown() {
					this._delayContextMenu = !0;
				}
				mouseup() {
					this._delayContextMenu = !1, this._contextMenuEvent && (this._map.fire(new Va("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent);
				}
				contextmenu(e$1) {
					this._delayContextMenu ? this._contextMenuEvent = e$1 : this._map.fire(new Va(e$1.type, this._map, e$1)), this._map.listens("contextmenu") && e$1.preventDefault();
				}
				isEnabled() {
					return !0;
				}
				isActive() {
					return !1;
				}
				enable() {}
				disable() {}
			}
			class $a {
				constructor(e$1, t$1) {
					this._map = e$1, this._el = e$1.getCanvasContainer(), this._container = e$1.getContainer(), this._clickTolerance = t$1.clickTolerance || 1;
				}
				isEnabled() {
					return !!this._enabled;
				}
				isActive() {
					return !!this._active;
				}
				enable() {
					this.isEnabled() || (this._enabled = !0);
				}
				disable() {
					this.isEnabled() && (this._enabled = !1);
				}
				mousedown(e$1, t$1) {
					this.isEnabled() && e$1.shiftKey && 0 === e$1.button && (_(), this._startPos = this._lastPos = t$1, this._active = !0);
				}
				mousemoveWindow(e$1, t$1) {
					if (!this._active) return;
					const i$1 = t$1, o$1 = this._startPos, s$1 = this._lastPos;
					if (!o$1 || !s$1 || s$1.equals(i$1) || !this._box && i$1.dist(o$1) < this._clickTolerance) return;
					this._lastPos = i$1, this._box || (this._box = l("div", "mapboxgl-boxzoom", this._container), this._container.classList.add("mapboxgl-crosshair"), this._fireEvent("boxzoomstart", e$1));
					const r$1 = Math.min(o$1.x, i$1.x), n$1 = Math.max(o$1.x, i$1.x), a$1 = Math.min(o$1.y, i$1.y), c$1 = Math.max(o$1.y, i$1.y);
					this._map._requestDomTask((() => {
						this._box && (this._box.style.transform = `translate(${r$1}px,${a$1}px)`, this._box.style.width = n$1 - r$1 + "px", this._box.style.height = c$1 - a$1 + "px");
					}));
				}
				mouseupWindow(t$1, i$1) {
					if (!this._active) return;
					const o$1 = this._startPos, s$1 = i$1;
					if (o$1 && 0 === t$1.button) {
						if (this.reset(), m(), o$1.x !== s$1.x || o$1.y !== s$1.y) return this._map.fire(new e.z("boxzoomend", { originalEvent: t$1 })), { cameraAnimation: (e$1) => e$1.fitScreenCoordinates(o$1, s$1, this._map.getBearing(), { linear: !1 }) };
						this._fireEvent("boxzoomcancel", t$1);
					}
				}
				keydown(e$1) {
					this._active && 27 === e$1.keyCode && (this.reset(), this._fireEvent("boxzoomcancel", e$1));
				}
				blur() {
					this.reset();
				}
				reset() {
					this._active = !1, this._container.classList.remove("mapboxgl-crosshair"), this._box && (this._box.remove(), this._box = null), p(), delete this._startPos, delete this._lastPos;
				}
				_fireEvent(t$1, i$1) {
					return this._map.fire(new e.z(t$1, { originalEvent: i$1 }));
				}
			}
			function Xa(e$1, t$1) {
				const i$1 = {};
				for (let o$1 = 0; o$1 < e$1.length; o$1++) i$1[e$1[o$1].identifier] = t$1[o$1];
				return i$1;
			}
			class Ya {
				constructor(e$1) {
					this.reset(), this.numTouches = e$1.numTouches;
				}
				reset() {
					this.centroid = void 0, this.startTime = 0, this.touches = {}, this.aborted = !1;
				}
				touchstart(t$1, i$1, o$1) {
					(this.centroid || o$1.length > this.numTouches) && (this.aborted = !0), this.aborted || (0 === this.startTime && (this.startTime = t$1.timeStamp), o$1.length === this.numTouches && (this.centroid = function(t$2) {
						const i$2 = new e.P(0, 0);
						for (const e$1 of t$2) i$2._add(e$1);
						return i$2.div(t$2.length);
					}(i$1), this.touches = Xa(o$1, i$1)));
				}
				touchmove(e$1, t$1, i$1) {
					if (this.aborted || !this.centroid) return;
					const o$1 = Xa(i$1, t$1);
					for (const e$2 in this.touches) {
						const t$2 = o$1[e$2];
						(!t$2 || t$2.dist(this.touches[e$2]) > 30) && (this.aborted = !0);
					}
				}
				touchend(e$1, t$1, i$1) {
					if ((!this.centroid || e$1.timeStamp - this.startTime > 500) && (this.aborted = !0), 0 === i$1.length) {
						const e$2 = !this.aborted && this.centroid;
						if (this.reset(), e$2) return e$2;
					}
				}
			}
			class Ka {
				constructor(e$1) {
					this.singleTap = new Ya(e$1), this.numTaps = e$1.numTaps, this.reset();
				}
				reset() {
					this.lastTime = Infinity, this.lastTap = void 0, this.count = 0, this.singleTap.reset();
				}
				touchstart(e$1, t$1, i$1) {
					this.singleTap.touchstart(e$1, t$1, i$1);
				}
				touchmove(e$1, t$1, i$1) {
					this.singleTap.touchmove(e$1, t$1, i$1);
				}
				touchend(e$1, t$1, i$1) {
					const o$1 = this.singleTap.touchend(e$1, t$1, i$1);
					if (o$1) {
						const t$2 = e$1.timeStamp - this.lastTime < 500, i$2 = !this.lastTap || this.lastTap.dist(o$1) < 30;
						if (t$2 && i$2 || this.reset(), this.count++, this.lastTime = e$1.timeStamp, this.lastTap = o$1, this.count === this.numTaps) return this.reset(), o$1;
					}
				}
			}
			class Ja {
				constructor() {
					this._zoomIn = new Ka({
						numTouches: 1,
						numTaps: 2
					}), this._zoomOut = new Ka({
						numTouches: 2,
						numTaps: 1
					}), this.reset();
				}
				reset() {
					this._active = !1, this._zoomIn.reset(), this._zoomOut.reset();
				}
				touchstart(e$1, t$1, i$1) {
					this._zoomIn.touchstart(e$1, t$1, i$1), this._zoomOut.touchstart(e$1, t$1, i$1);
				}
				touchmove(e$1, t$1, i$1) {
					this._zoomIn.touchmove(e$1, t$1, i$1), this._zoomOut.touchmove(e$1, t$1, i$1);
				}
				touchend(e$1, t$1, i$1) {
					const o$1 = this._zoomIn.touchend(e$1, t$1, i$1), s$1 = this._zoomOut.touchend(e$1, t$1, i$1);
					return o$1 ? (this._active = !0, e$1.preventDefault(), setTimeout((() => this.reset()), 0), { cameraAnimation: (t$2) => t$2.easeTo({
						duration: 300,
						zoom: t$2.getZoom() + 1,
						around: t$2.unproject(o$1)
					}, { originalEvent: e$1 }) }) : s$1 ? (this._active = !0, e$1.preventDefault(), setTimeout((() => this.reset()), 0), { cameraAnimation: (t$2) => t$2.easeTo({
						duration: 300,
						zoom: t$2.getZoom() - 1,
						around: t$2.unproject(s$1)
					}, { originalEvent: e$1 }) }) : void 0;
				}
				touchcancel() {
					this.reset();
				}
				enable() {
					this._enabled = !0;
				}
				disable() {
					this._enabled = !1, this.reset();
				}
				isEnabled() {
					return this._enabled;
				}
				isActive() {
					return this._active;
				}
			}
			const Qa = {
				0: 1,
				2: 2
			}, el = {
				Control: "ctrlKey",
				Alt: "altKey",
				Shift: "shiftKey",
				Meta: "metaKey"
			};
			class tl {
				constructor(e$1) {
					this.reset(), this._clickTolerance = e$1.clickTolerance || 1;
				}
				blur() {
					this.reset();
				}
				reset() {
					this._active = !1, this._moved = !1, this._lastPoint = void 0, this._eventButton = void 0;
				}
				_correctButton(e$1, t$1) {
					return !1;
				}
				_move(e$1, t$1) {
					return {};
				}
				mousedown(e$1, t$1) {
					if (this._lastPoint) return;
					const i$1 = y(e$1);
					this._correctButton(e$1, i$1) && (this._lastPoint = t$1, this._eventButton = i$1);
				}
				mousemoveWindow(e$1, t$1) {
					const i$1 = this._lastPoint;
					if (i$1) {
						if (e$1.preventDefault(), null != this._eventButton && function(e$2, t$2) {
							const i$2 = Qa[t$2];
							return void 0 === e$2.buttons || (e$2.buttons & i$2) !== i$2;
						}(e$1, this._eventButton)) this.reset();
						else if (this._moved || !(t$1.dist(i$1) < this._clickTolerance)) return this._moved = !0, this._lastPoint = t$1, this._move(i$1, t$1);
					}
				}
				mouseupWindow(e$1) {
					this._lastPoint && y(e$1) === this._eventButton && (this._moved && m(), this.reset());
				}
				enable() {
					this._enabled = !0;
				}
				disable() {
					this._enabled = !1, this.reset();
				}
				isEnabled() {
					return this._enabled;
				}
				isActive() {
					return this._active;
				}
			}
			class il extends tl {
				mousedown(e$1, t$1) {
					super.mousedown(e$1, t$1), this._lastPoint && (this._active = !0);
				}
				_correctButton(e$1, t$1) {
					return 0 === t$1 && !e$1.ctrlKey;
				}
				_move(e$1, t$1) {
					return {
						around: t$1,
						panDelta: t$1.sub(e$1)
					};
				}
			}
			class ol extends tl {
				constructor(e$1) {
					super(e$1), this._pitchRotateKey = e$1.pitchRotateKey ? el[e$1.pitchRotateKey] : void 0;
				}
				_correctButton(e$1, t$1) {
					return this._pitchRotateKey ? 0 === t$1 && e$1[this._pitchRotateKey] : 0 === t$1 && e$1.ctrlKey || 2 === t$1;
				}
				_move(e$1, t$1) {
					const i$1 = .8 * (t$1.x - e$1.x);
					if (i$1) return this._active = !0, { bearingDelta: i$1 };
				}
				contextmenu(e$1) {
					this._pitchRotateKey || e$1.preventDefault();
				}
			}
			class sl extends tl {
				constructor(e$1) {
					super(e$1), this._pitchRotateKey = e$1.pitchRotateKey ? el[e$1.pitchRotateKey] : void 0;
				}
				_correctButton(e$1, t$1) {
					return this._pitchRotateKey ? 0 === t$1 && e$1[this._pitchRotateKey] : 0 === t$1 && e$1.ctrlKey || 2 === t$1;
				}
				_move(e$1, t$1) {
					const i$1 = -.5 * (t$1.y - e$1.y);
					if (i$1) return this._active = !0, { pitchDelta: i$1 };
				}
				contextmenu(e$1) {
					this._pitchRotateKey || e$1.preventDefault();
				}
			}
			class rl {
				constructor(t$1, i$1) {
					this._map = t$1, this._el = t$1.getCanvasContainer(), this._minTouches = 1, this._clickTolerance = i$1.clickTolerance || 1, this.reset(), e.aY(["_addTouchPanBlocker", "_showTouchPanBlockerAlert"], this);
				}
				reset() {
					this._active = !1, this._touches = {}, this._sum = new e.P(0, 0);
				}
				touchstart(e$1, t$1, i$1) {
					return this._calculateTransform(e$1, t$1, i$1);
				}
				touchmove(t$1, i$1, o$1) {
					if (this._active && !(o$1.length < this._minTouches)) {
						if (this._map._cooperativeGestures && !this._map.isMoving()) {
							if (1 === o$1.length && !e.eU()) return void this._showTouchPanBlockerAlert();
							"hidden" !== this._alertContainer.style.visibility && (this._alertContainer.style.visibility = "hidden", clearTimeout(this._alertTimer));
						}
						return t$1.cancelable && t$1.preventDefault(), this._calculateTransform(t$1, i$1, o$1);
					}
				}
				touchend(e$1, t$1, i$1) {
					this._calculateTransform(e$1, t$1, i$1), this._active && i$1.length < this._minTouches && this.reset();
				}
				touchcancel() {
					this.reset();
				}
				_calculateTransform(t$1, i$1, o$1) {
					o$1.length > 0 && (this._active = !0);
					const s$1 = Xa(o$1, i$1), r$1 = new e.P(0, 0), n$1 = new e.P(0, 0);
					let a$1 = 0;
					for (const e$1 in s$1) {
						const t$2 = s$1[e$1], i$2 = this._touches[e$1];
						i$2 && (r$1._add(t$2), n$1._add(t$2.sub(i$2)), a$1++, s$1[e$1] = t$2);
					}
					if (this._touches = s$1, a$1 < this._minTouches || !n$1.mag()) return;
					const l$1 = n$1.div(a$1);
					return this._sum._add(l$1), this._sum.mag() < this._clickTolerance ? void 0 : {
						around: r$1.div(a$1),
						panDelta: l$1
					};
				}
				enable() {
					this._enabled = !0, this._map._cooperativeGestures && (this._addTouchPanBlocker(), this._el.classList.add("mapboxgl-touch-pan-blocker-override", "mapboxgl-scrollable-page"));
				}
				disable() {
					this._enabled = !1, this._map._cooperativeGestures && (clearTimeout(this._alertTimer), this._alertContainer.remove(), this._el.classList.remove("mapboxgl-touch-pan-blocker-override", "mapboxgl-scrollable-page")), this.reset();
				}
				isEnabled() {
					return !!this._enabled;
				}
				isActive() {
					return !!this._active;
				}
				_addTouchPanBlocker() {
					this._map && !this._alertContainer && (this._alertContainer = l("div", "mapboxgl-touch-pan-blocker", this._map._container), this._alertContainer.textContent = this._map._getUIString("TouchPanBlocker.Message"), this._alertContainer.style.fontSize = `${Math.max(10, Math.min(24, Math.floor(.05 * this._el.clientWidth)))}px`);
				}
				_showTouchPanBlockerAlert() {
					this._alertContainer.style.visibility = "visible", this._alertContainer.classList.add("mapboxgl-touch-pan-blocker-show"), this._alertContainer.setAttribute("role", "alert"), clearTimeout(this._alertTimer), this._alertTimer = window.setTimeout((() => {
						this._alertContainer.classList.remove("mapboxgl-touch-pan-blocker-show"), this._alertContainer.removeAttribute("role");
					}), 500);
				}
			}
			class nl {
				constructor() {
					this.reset();
				}
				reset() {
					this._active = !1, this._firstTwoTouches = void 0;
				}
				_start(e$1) {}
				_move(e$1, t$1, i$1) {
					return {};
				}
				touchstart(e$1, t$1, i$1) {
					this._firstTwoTouches || i$1.length < 2 || (this._firstTwoTouches = [i$1[0].identifier, i$1[1].identifier], this._start([t$1[0], t$1[1]]));
				}
				touchmove(e$1, t$1, i$1) {
					const o$1 = this._firstTwoTouches;
					if (!o$1) return;
					e$1.preventDefault();
					const [s$1, r$1] = o$1, n$1 = al(i$1, t$1, s$1), a$1 = al(i$1, t$1, r$1);
					if (!n$1 || !a$1) return;
					const l$1 = this._aroundCenter ? null : n$1.add(a$1).div(2);
					return this._move([n$1, a$1], l$1, e$1);
				}
				touchend(e$1, t$1, i$1) {
					if (!this._firstTwoTouches) return;
					const [o$1, s$1] = this._firstTwoTouches, r$1 = al(i$1, t$1, o$1), n$1 = al(i$1, t$1, s$1);
					r$1 && n$1 || (this._active && m(), this.reset());
				}
				touchcancel() {
					this.reset();
				}
				enable(e$1) {
					this._enabled = !0, this._aroundCenter = !!e$1 && "center" === e$1.around;
				}
				disable() {
					this._enabled = !1, this.reset();
				}
				isEnabled() {
					return this._enabled;
				}
				isActive() {
					return this._active;
				}
			}
			function al(e$1, t$1, i$1) {
				for (let o$1 = 0; o$1 < e$1.length; o$1++) if (e$1[o$1].identifier === i$1) return t$1[o$1];
			}
			function ll(e$1, t$1) {
				return Math.log2(e$1 / t$1);
			}
			class cl extends nl {
				reset() {
					super.reset(), this._distance = 0, this._startDistance = 0;
				}
				_start(e$1) {
					this._startDistance = this._distance = e$1[0].dist(e$1[1]);
				}
				_move(e$1, t$1) {
					const i$1 = this._distance;
					if (this._distance = e$1[0].dist(e$1[1]), this._active || !(Math.abs(ll(this._distance, this._startDistance)) < .1)) return this._active = !0, {
						zoomDelta: ll(this._distance, i$1),
						pinchAround: t$1
					};
				}
			}
			function hl(e$1, t$1) {
				return 180 * e$1.angleWith(t$1) / Math.PI;
			}
			class dl extends nl {
				reset() {
					super.reset(), this._minDiameter = 0, this._startVector = void 0, this._vector = void 0;
				}
				_start(e$1) {
					this._startVector = this._vector = e$1[0].sub(e$1[1]), this._minDiameter = e$1[0].dist(e$1[1]);
				}
				_move(e$1, t$1) {
					const i$1 = this._vector;
					if (this._vector = e$1[0].sub(e$1[1]), i$1 && (this._active || !this._isBelowThreshold(this._vector))) return this._active = !0, {
						bearingDelta: hl(this._vector, i$1),
						pinchAround: t$1
					};
				}
				_isBelowThreshold(e$1) {
					this._minDiameter = Math.min(this._minDiameter, e$1.mag());
					const t$1 = 25 / (Math.PI * this._minDiameter) * 360, i$1 = this._startVector;
					if (!i$1) return !1;
					const o$1 = hl(e$1, i$1);
					return Math.abs(o$1) < t$1;
				}
			}
			function ul(e$1) {
				return Math.abs(e$1.y) > Math.abs(e$1.x);
			}
			class _l extends nl {
				constructor(e$1) {
					super(), this._map = e$1;
				}
				reset() {
					super.reset(), this._valid = void 0, this._firstMove = void 0, this._lastPoints = void 0;
				}
				_start(e$1) {
					this._lastPoints = e$1, ul(e$1[0].sub(e$1[1])) && (this._valid = !1);
				}
				_move(t$1, i$1, o$1) {
					const s$1 = this._lastPoints;
					if (!s$1) return;
					const r$1 = t$1[0].sub(s$1[0]), n$1 = t$1[1].sub(s$1[1]);
					return this._map._cooperativeGestures && !e.eU() && o$1.touches.length < 3 || (this._valid = this.gestureBeginsVertically(r$1, n$1, o$1.timeStamp), !this._valid) ? void 0 : (this._lastPoints = t$1, this._active = !0, { pitchDelta: (r$1.y + n$1.y) / 2 * -.5 });
				}
				gestureBeginsVertically(e$1, t$1, i$1) {
					if (void 0 !== this._valid) return this._valid;
					const o$1 = e$1.mag() >= 2, s$1 = t$1.mag() >= 2;
					if (!o$1 && !s$1) return;
					if (!o$1 || !s$1) return this._firstMove ??= i$1, i$1 - this._firstMove < 100 && void 0;
					const r$1 = e$1.y > 0 == t$1.y > 0;
					return ul(e$1) && ul(t$1) && r$1;
				}
			}
			const pl = {
				panStep: 100,
				bearingStep: 15,
				pitchStep: 10
			};
			class fl {
				constructor() {
					const e$1 = pl;
					this._panStep = e$1.panStep, this._bearingStep = e$1.bearingStep, this._pitchStep = e$1.pitchStep, this._rotationDisabled = !1;
				}
				blur() {
					this.reset();
				}
				reset() {
					this._active = !1;
				}
				keydown(e$1) {
					if (e$1.altKey || e$1.ctrlKey || e$1.metaKey) return;
					let t$1 = 0, i$1 = 0, o$1 = 0, s$1 = 0, r$1 = 0;
					switch (e$1.keyCode) {
						case 61:
						case 107:
						case 171:
						case 187:
							t$1 = 1;
							break;
						case 189:
						case 109:
						case 173:
							t$1 = -1;
							break;
						case 37:
							e$1.shiftKey ? i$1 = -1 : (e$1.preventDefault(), s$1 = -1);
							break;
						case 39:
							e$1.shiftKey ? i$1 = 1 : (e$1.preventDefault(), s$1 = 1);
							break;
						case 38:
							e$1.shiftKey ? o$1 = 1 : (e$1.preventDefault(), r$1 = -1);
							break;
						case 40:
							e$1.shiftKey ? o$1 = -1 : (e$1.preventDefault(), r$1 = 1);
							break;
						default: return;
					}
					return this._rotationDisabled && (i$1 = 0, o$1 = 0), { cameraAnimation: (n$1) => {
						const a$1 = n$1.getZoom();
						n$1.easeTo({
							duration: 300,
							easeId: "keyboardHandler",
							easing: ml,
							zoom: t$1 ? Math.round(a$1) + t$1 * (e$1.shiftKey ? 2 : 1) : a$1,
							bearing: n$1.getBearing() + i$1 * this._bearingStep,
							pitch: n$1.getPitch() + o$1 * this._pitchStep,
							offset: [-s$1 * this._panStep, -r$1 * this._panStep],
							center: n$1.getCenter()
						}, { originalEvent: e$1 });
					} };
				}
				enable() {
					this._enabled = !0;
				}
				disable() {
					this._enabled = !1, this.reset();
				}
				isEnabled() {
					return this._enabled;
				}
				isActive() {
					return this._active;
				}
				disableRotation() {
					this._rotationDisabled = !0;
				}
				enableRotation() {
					this._rotationDisabled = !1;
				}
			}
			function ml(e$1) {
				return e$1 * (2 - e$1);
			}
			const gl = 4.000244140625, vl = 1 / 450;
			class yl {
				constructor(t$1, i$1) {
					this._map = t$1, this._el = t$1.getCanvasContainer(), this._handler = i$1, this._delta = 0, this._lastDelta = 0, this._defaultZoomRate = .01, this._wheelZoomRate = vl, e.aY([
						"_onTimeout",
						"_addScrollZoomBlocker",
						"_showBlockerAlert"
					], this);
				}
				setZoomRate(e$1) {
					this._defaultZoomRate = e$1;
				}
				setWheelZoomRate(e$1) {
					this._wheelZoomRate = e$1;
				}
				isEnabled() {
					return !!this._enabled;
				}
				isActive() {
					return this._active || void 0 !== this._finishTimeout;
				}
				isZooming() {
					return !!this._zooming;
				}
				enable(e$1) {
					this.isEnabled() || (this._enabled = !0, this._aroundCenter = !!e$1 && "center" === e$1.around, this._map._cooperativeGestures && this._addScrollZoomBlocker());
				}
				disable() {
					this.isEnabled() && (this._enabled = !1, this._map._cooperativeGestures && (clearTimeout(this._alertTimer), this._alertContainer.remove()));
				}
				wheel(t$1) {
					if (!this.isEnabled()) return;
					if (this._map._cooperativeGestures) {
						if (!(t$1.ctrlKey || t$1.metaKey || this.isZooming() || e.eU())) return void this._showBlockerAlert();
						"hidden" !== this._alertContainer.style.visibility && (this._alertContainer.style.visibility = "hidden", clearTimeout(this._alertTimer));
					}
					let i$1 = t$1.deltaMode === WheelEvent.DOM_DELTA_LINE ? 40 * t$1.deltaY : t$1.deltaY;
					const o$1 = e.o.now(), s$1 = o$1 - (this._lastWheelEventTime || 0);
					this._lastWheelEventTime = o$1, 0 !== i$1 && i$1 % gl == 0 ? this._type = "wheel" : 0 !== i$1 && Math.abs(i$1) < 4 ? this._type = "trackpad" : s$1 > 400 ? (this._type = null, this._lastValue = i$1, this._timeout = window.setTimeout(this._onTimeout, 40, t$1)) : this._type || (this._type = Math.abs(s$1 * i$1) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, i$1 += this._lastValue)), t$1.shiftKey && i$1 && (i$1 /= 4), this._type && (this._lastWheelEvent = t$1, this._delta -= i$1, this._active || this._start(t$1)), t$1.preventDefault();
				}
				_onTimeout(e$1) {
					this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(e$1);
				}
				_start(e$1) {
					if (!this._delta) return;
					this._frameId && (this._frameId = null), this._active = !0, this.isZooming() || (this._zooming = !0), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
					const t$1 = g(this._el, e$1);
					this._aroundPoint = this._aroundCenter ? this._map.transform.centerPoint : t$1, this._aroundCoord = this._map.transform.pointCoordinate3D(this._aroundPoint), this._targetZoom = void 0, this._frameId || (this._frameId = !0, this._handler._triggerRenderFrame());
				}
				renderFrame() {
					if (!this._frameId) return;
					if (this._frameId = null, !this.isActive()) return;
					const t$1 = this._map.transform;
					"wheel" === this._type && t$1.projection.wrap && (t$1._center.lng >= 180 || t$1._center.lng <= -180) && (this._prevEase = null, this._easing = null, this._lastWheelEvent = null, this._lastWheelEventTime = 0);
					const i$1 = () => t$1._terrainEnabled() && this._aroundCoord ? t$1.computeZoomRelativeTo(this._aroundCoord) : t$1.zoom;
					if (0 !== this._delta) {
						const e$1 = "wheel" === this._type && Math.abs(this._delta) > gl ? this._wheelZoomRate : this._defaultZoomRate;
						let o$2 = 2 / (1 + Math.exp(-Math.abs(this._delta * e$1)));
						this._delta < 0 && 0 !== o$2 && (o$2 = 1 / o$2);
						const s$2 = i$1(), r$2 = Math.pow(2, s$2), n$2 = "number" == typeof this._targetZoom ? t$1.zoomScale(this._targetZoom) : r$2;
						this._targetZoom = Math.min(t$1.maxZoom, Math.max(t$1.minZoom, t$1.scaleZoom(n$2 * o$2))), "wheel" === this._type && (this._startZoom = s$2, this._easing = this._smoothOutEasing(200)), this._lastDelta = this._delta, this._delta = 0;
					}
					const o$1 = "number" == typeof this._targetZoom ? this._targetZoom : i$1(), s$1 = this._startZoom, r$1 = this._easing;
					let n$1, a$1 = !1;
					if ("wheel" === this._type && s$1 && r$1) {
						const t$2 = Math.min((e.o.now() - this._lastWheelEventTime) / 200, 1), i$2 = r$1(t$2);
						n$1 = e.ak(s$1, o$1, i$2), t$2 < 1 ? this._frameId || (this._frameId = !0) : a$1 = !0;
					} else n$1 = o$1, a$1 = !0;
					this._active = !0, a$1 && (this._active = !1, this._finishTimeout = window.setTimeout((() => {
						this._zooming = !1, this._handler._triggerRenderFrame(), delete this._targetZoom, delete this._finishTimeout;
					}), 200));
					let l$1 = n$1 - i$1();
					return l$1 * this._lastDelta < 0 && (l$1 = 0), {
						noInertia: !0,
						needsRenderFrame: !a$1,
						zoomDelta: l$1,
						around: this._aroundPoint,
						aroundCoord: this._aroundCoord,
						originalEvent: this._lastWheelEvent
					};
				}
				_smoothOutEasing(t$1) {
					let i$1 = e.eV;
					if (this._prevEase) {
						const t$2 = this._prevEase, o$1 = (e.o.now() - t$2.start) / t$2.duration, s$1 = t$2.easing(o$1 + .01) - t$2.easing(o$1), r$1 = .27 / Math.sqrt(s$1 * s$1 + 1e-4) * .01, n$1 = Math.sqrt(.0729 - r$1 * r$1);
						i$1 = e.eT(r$1, n$1, .25, 1);
					}
					return this._prevEase = {
						start: e.o.now(),
						duration: t$1,
						easing: i$1
					}, i$1;
				}
				blur() {
					this.reset();
				}
				reset() {
					this._active = !1;
				}
				_addScrollZoomBlocker() {
					this._map && !this._alertContainer && (this._alertContainer = l("div", "mapboxgl-scroll-zoom-blocker", this._map._container), this._alertContainer.textContent = /(Mac|iPad)/i.test(navigator.userAgent) ? this._map._getUIString("ScrollZoomBlocker.CmdMessage") : this._map._getUIString("ScrollZoomBlocker.CtrlMessage"), this._alertContainer.style.fontSize = `${Math.max(10, Math.min(24, Math.floor(.05 * this._el.clientWidth)))}px`);
				}
				_showBlockerAlert() {
					this._alertContainer.style.visibility = "visible", this._alertContainer.classList.add("mapboxgl-scroll-zoom-blocker-show"), this._alertContainer.setAttribute("role", "alert"), clearTimeout(this._alertTimer), this._alertTimer = window.setTimeout((() => {
						this._alertContainer.classList.remove("mapboxgl-scroll-zoom-blocker-show"), this._alertContainer.removeAttribute("role");
					}), 200);
				}
			}
			class xl {
				constructor(e$1, t$1) {
					this._clickZoom = e$1, this._tapZoom = t$1;
				}
				enable() {
					this._clickZoom.enable(), this._tapZoom.enable();
				}
				disable() {
					this._clickZoom.disable(), this._tapZoom.disable();
				}
				isEnabled() {
					return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
				}
				isActive() {
					return this._clickZoom.isActive() || this._tapZoom.isActive();
				}
			}
			class bl {
				constructor() {
					this.reset();
				}
				reset() {
					this._active = !1;
				}
				blur() {
					this.reset();
				}
				dblclick(e$1, t$1) {
					return e$1.preventDefault(), { cameraAnimation: (i$1) => {
						i$1.easeTo({
							duration: 300,
							zoom: i$1.getZoom() + (e$1.shiftKey ? -1 : 1),
							around: i$1.unproject(t$1)
						}, { originalEvent: e$1 });
					} };
				}
				enable() {
					this._enabled = !0;
				}
				disable() {
					this._enabled = !1, this.reset();
				}
				isEnabled() {
					return this._enabled;
				}
				isActive() {
					return this._active;
				}
			}
			class wl {
				constructor() {
					this._tap = new Ka({
						numTouches: 1,
						numTaps: 1
					}), this.reset();
				}
				reset() {
					this._active = !1, this._swipePoint = void 0, this._swipeTouch = 0, this._tapTime = 0, this._tap.reset();
				}
				touchstart(e$1, t$1, i$1) {
					this._swipePoint || (this._tapTime && e$1.timeStamp - this._tapTime > 500 && this.reset(), this._tapTime ? i$1.length > 0 && (this._swipePoint = t$1[0], this._swipeTouch = i$1[0].identifier) : this._tap.touchstart(e$1, t$1, i$1));
				}
				touchmove(e$1, t$1, i$1) {
					if (this._tapTime) {
						if (this._swipePoint) {
							if (i$1[0].identifier !== this._swipeTouch) return;
							const o$1 = t$1[0], s$1 = o$1.y - this._swipePoint.y;
							return this._swipePoint = o$1, e$1.preventDefault(), this._active = !0, { zoomDelta: s$1 / 128 };
						}
					} else this._tap.touchmove(e$1, t$1, i$1);
				}
				touchend(e$1, t$1, i$1) {
					this._tapTime ? this._swipePoint && 0 === i$1.length && this.reset() : this._tap.touchend(e$1, t$1, i$1) && (this._tapTime = e$1.timeStamp);
				}
				touchcancel() {
					this.reset();
				}
				enable() {
					this._enabled = !0;
				}
				disable() {
					this._enabled = !1, this.reset();
				}
				isEnabled() {
					return this._enabled;
				}
				isActive() {
					return this._active;
				}
			}
			class Tl {
				constructor(e$1, t$1, i$1) {
					this._el = e$1, this._mousePan = t$1, this._touchPan = i$1;
				}
				enable(e$1) {
					this._inertiaOptions = e$1 || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("mapboxgl-touch-drag-pan");
				}
				disable() {
					this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("mapboxgl-touch-drag-pan");
				}
				isEnabled() {
					return this._mousePan.isEnabled() && this._touchPan.isEnabled();
				}
				isActive() {
					return this._mousePan.isActive() || this._touchPan.isActive();
				}
			}
			class El {
				constructor(e$1, t$1, i$1) {
					this._pitchWithRotate = e$1.pitchWithRotate, this._mouseRotate = t$1, this._mousePitch = i$1;
				}
				enable() {
					this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable();
				}
				disable() {
					this._mouseRotate.disable(), this._mousePitch.disable();
				}
				isEnabled() {
					return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled());
				}
				isActive() {
					return this._mouseRotate.isActive() || this._mousePitch.isActive();
				}
			}
			class Sl {
				constructor(e$1, t$1, i$1, o$1) {
					this._el = e$1, this._touchZoom = t$1, this._touchRotate = i$1, this._tapDragZoom = o$1, this._rotationDisabled = !1, this._enabled = !0;
				}
				enable(e$1) {
					this._touchZoom.enable(e$1), this._rotationDisabled || this._touchRotate.enable(e$1), this._tapDragZoom.enable(), this._el.classList.add("mapboxgl-touch-zoom-rotate");
				}
				disable() {
					this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("mapboxgl-touch-zoom-rotate");
				}
				isEnabled() {
					return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();
				}
				isActive() {
					return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();
				}
				disableRotation() {
					this._rotationDisabled = !0, this._touchRotate.disable();
				}
				enableRotation() {
					this._rotationDisabled = !1, this._touchZoom.isEnabled() && this._touchRotate.enable();
				}
			}
			const Il = (e$1) => e$1.zoom || e$1.drag || e$1.pitch || e$1.rotate;
			class Cl extends e.z {}
			class Rl {
				constructor() {
					this.constants = [
						1,
						1,
						.01
					], this.radius = 0;
				}
				setup(t$1, i$1) {
					const o$1 = e.av([], i$1, t$1);
					this.radius = e.ag(o$1[2] < 0 ? e.eX([], o$1, this.constants) : [
						o$1[0],
						o$1[1],
						0
					]);
				}
				projectRay(t$1) {
					e.eX(t$1, t$1, this.constants), e.aw(t$1, t$1), e.eY(t$1, t$1, this.constants);
					const i$1 = e.c5([], t$1, this.radius);
					if (i$1[2] > 0) {
						const t$2 = e.c5([], [
							0,
							0,
							1
						], e.bJ(i$1, [
							0,
							0,
							1
						])), o$1 = e.c5([], e.aw([], [
							i$1[0],
							i$1[1],
							0
						]), this.radius), s$1 = e.d8([], i$1, e.c5([], e.av([], e.d8([], o$1, t$2), i$1), 2));
						i$1[0] = s$1[0], i$1[1] = s$1[1];
					}
					return i$1;
				}
			}
			function Al(e$1) {
				return e$1.panDelta && e$1.panDelta.mag() || e$1.zoomDelta || e$1.bearingDelta || e$1.pitchDelta;
			}
			class Ll {
				constructor(t$1, i$1) {
					this._map = t$1, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new Ua(t$1), this._bearingSnap = i$1.bearingSnap, this._previousActiveHandlers = {}, this._trackingEllipsoid = new Rl(), this._dragOrigin = null, this._eventsInProgress = {}, this._addDefaultHandlers(i$1), e.aY(["handleEvent", "handleWindowEvent"], this);
					const o$1 = this._el;
					this._listeners = [
						[
							o$1,
							"touchstart",
							{ passive: !0 }
						],
						[
							o$1,
							"touchmove",
							{ passive: !1 }
						],
						[
							o$1,
							"touchend",
							void 0
						],
						[
							o$1,
							"touchcancel",
							void 0
						],
						[
							o$1,
							"mousedown",
							void 0
						],
						[
							o$1,
							"mousemove",
							void 0
						],
						[
							o$1,
							"mouseup",
							void 0
						],
						[
							document,
							"mousemove",
							{ capture: !0 }
						],
						[
							document,
							"mouseup",
							void 0
						],
						[
							o$1,
							"mouseover",
							void 0
						],
						[
							o$1,
							"mouseout",
							void 0
						],
						[
							o$1,
							"dblclick",
							void 0
						],
						[
							o$1,
							"click",
							void 0
						],
						[
							o$1,
							"keydown",
							{ capture: !1 }
						],
						[
							o$1,
							"keyup",
							void 0
						],
						[
							o$1,
							"wheel",
							{ passive: !1 }
						],
						[
							o$1,
							"contextmenu",
							void 0
						],
						[
							window,
							"blur",
							void 0
						]
					];
					for (const [e$1, t$2, i$2] of this._listeners) {
						const o$2 = e$1 === document ? this.handleWindowEvent : this.handleEvent;
						e$1.addEventListener(t$2, o$2, i$2);
					}
				}
				destroy() {
					for (const [e$1, t$1, i$1] of this._listeners) {
						const o$1 = e$1 === document ? this.handleWindowEvent : this.handleEvent;
						e$1.removeEventListener(t$1, o$1, i$1);
					}
				}
				_addDefaultHandlers(e$1) {
					const t$1 = this._map, i$1 = t$1.getCanvasContainer();
					this._add("mapEvent", new Za(t$1, e$1));
					const o$1 = t$1.boxZoom = new $a(t$1, e$1);
					this._add("boxZoom", o$1);
					const s$1 = new Ja(), r$1 = new bl();
					t$1.doubleClickZoom = new xl(r$1, s$1), this._add("tapZoom", s$1), this._add("clickZoom", r$1);
					const n$1 = new wl();
					this._add("tapDragZoom", n$1);
					const a$1 = t$1.touchPitch = new _l(t$1);
					this._add("touchPitch", a$1);
					const l$1 = new ol(e$1), c$1 = new sl(e$1);
					t$1.dragRotate = new El(e$1, l$1, c$1), this._add("mouseRotate", l$1, ["mousePitch"]), this._add("mousePitch", c$1, ["mouseRotate"]);
					const h$1 = new il(e$1), d$1 = new rl(t$1, e$1);
					t$1.dragPan = new Tl(i$1, h$1, d$1), this._add("mousePan", h$1), this._add("touchPan", d$1, ["touchZoom", "touchRotate"]);
					const u$1 = new dl(), _$1 = new cl();
					t$1.touchZoomRotate = new Sl(i$1, _$1, u$1, n$1), this._add("touchRotate", u$1, ["touchPan", "touchZoom"]), this._add("touchZoom", _$1, ["touchPan", "touchRotate"]), this._add("blockableMapEvent", new Wa(t$1));
					const p$1 = t$1.scrollZoom = new yl(t$1, this);
					this._add("scrollZoom", p$1, ["mousePan"]);
					const f$1 = t$1.keyboard = new fl();
					this._add("keyboard", f$1);
					for (const i$2 of [
						"boxZoom",
						"doubleClickZoom",
						"tapDragZoom",
						"touchPitch",
						"dragRotate",
						"dragPan",
						"touchZoomRotate",
						"scrollZoom",
						"keyboard"
					]) e$1.interactive && e$1[i$2] && t$1[i$2].enable(e$1[i$2]);
				}
				_add(e$1, t$1, i$1) {
					this._handlers.push({
						handlerName: e$1,
						handler: t$1,
						allowed: i$1
					}), this._handlersById[e$1] = t$1;
				}
				stop(e$1) {
					if (!this._updatingCamera) {
						for (const { handler: e$2 } of this._handlers) e$2.reset();
						this._inertia.clear(), this._fireEvents({}, {}, e$1), this._changes = [], this._originalZoom = void 0;
					}
				}
				isActive() {
					for (const { handler: e$1 } of this._handlers) if (e$1.isActive()) return !0;
					return !1;
				}
				isZooming() {
					return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();
				}
				isRotating() {
					return !!this._eventsInProgress.rotate;
				}
				isMoving() {
					return !!Il(this._eventsInProgress) || this.isZooming();
				}
				_isDragging() {
					return !!this._eventsInProgress.drag;
				}
				_blockedByActive(e$1, t$1, i$1) {
					for (const o$1 in e$1) if (o$1 !== i$1 && (!t$1 || t$1.indexOf(o$1) < 0)) return !0;
					return !1;
				}
				handleWindowEvent(e$1) {
					this.handleEvent(e$1, `${e$1.type}Window`);
				}
				_getMapTouches(e$1) {
					const t$1 = [];
					for (const i$1 of e$1) this._el.contains(i$1.target) && t$1.push(i$1);
					return t$1;
				}
				handleEvent(e$1, t$1) {
					this._updatingCamera = !0;
					const i$1 = "renderFrame" === e$1.type, o$1 = i$1 ? void 0 : e$1, s$1 = { needsRenderFrame: !1 }, r$1 = {}, n$1 = {}, a$1 = e$1.touches ? this._getMapTouches(e$1.touches) : void 0, l$1 = a$1 ? v(this._el, a$1) : i$1 ? void 0 : g(this._el, e$1);
					for (const { handlerName: i$2, handler: c$2, allowed: h$2 } of this._handlers) {
						if (!c$2.isEnabled()) continue;
						let d$1;
						this._blockedByActive(n$1, h$2, i$2) ? c$2.reset() : c$2[t$1 || e$1.type] && (d$1 = c$2[t$1 || e$1.type](e$1, l$1, a$1), this.mergeHandlerResult(s$1, r$1, d$1, i$2, o$1), d$1 && d$1.needsRenderFrame && this._triggerRenderFrame()), (d$1 || c$2.isActive()) && (n$1[i$2] = c$2);
					}
					const c$1 = {};
					for (const e$2 in this._previousActiveHandlers) n$1[e$2] || (c$1[e$2] = o$1);
					this._previousActiveHandlers = n$1, (Object.keys(c$1).length || Al(s$1)) && (this._changes.push([
						s$1,
						r$1,
						c$1
					]), this._triggerRenderFrame()), (Object.keys(n$1).length || Al(s$1)) && this._map._stop(!0), this._updatingCamera = !1;
					const { cameraAnimation: h$1 } = s$1;
					h$1 && (this._inertia.clear(), this._fireEvents({}, {}, !0), this._changes = [], h$1(this._map));
				}
				mergeHandlerResult(e$1, t$1, i$1, o$1, s$1) {
					if (!i$1) return;
					Object.assign(e$1, i$1);
					const r$1 = {
						handlerName: o$1,
						originalEvent: i$1.originalEvent || s$1
					};
					void 0 !== i$1.zoomDelta && (t$1.zoom = r$1), void 0 !== i$1.panDelta && (t$1.drag = r$1), void 0 !== i$1.pitchDelta && (t$1.pitch = r$1), void 0 !== i$1.bearingDelta && (t$1.rotate = r$1);
				}
				_applyChanges() {
					const t$1 = {}, i$1 = {}, o$1 = {};
					for (const [s$1, r$1, n$1] of this._changes) s$1.panDelta && (t$1.panDelta = (t$1.panDelta || new e.P(0, 0))._add(s$1.panDelta)), s$1.zoomDelta && (t$1.zoomDelta = (t$1.zoomDelta || 0) + s$1.zoomDelta), s$1.bearingDelta && (t$1.bearingDelta = (t$1.bearingDelta || 0) + s$1.bearingDelta), s$1.pitchDelta && (t$1.pitchDelta = (t$1.pitchDelta || 0) + s$1.pitchDelta), void 0 !== s$1.around && (t$1.around = s$1.around), void 0 !== s$1.aroundCoord && (t$1.aroundCoord = s$1.aroundCoord), void 0 !== s$1.pinchAround && (t$1.pinchAround = s$1.pinchAround), s$1.noInertia && (t$1.noInertia = s$1.noInertia), Object.assign(i$1, r$1), Object.assign(o$1, n$1);
					this._updateMapTransform(t$1, i$1, o$1), this._changes = [];
				}
				_updateMapTransform(t$1, i$1, o$1) {
					const s$1 = this._map, r$1 = s$1.transform, n$1 = (e$1) => [
						e$1.x,
						e$1.y,
						e$1.z
					];
					if (((e$1) => {
						const t$2 = this._eventsInProgress.drag;
						return t$2 && !this._handlersById[t$2.handlerName].isActive();
					})() && !Al(t$1)) {
						const e$1 = r$1.zoom;
						r$1.cameraElevationReference = "sea", null != this._originalZoom && r$1._orthographicProjectionAtLowPitch && "globe" !== r$1.projection.name && 0 === r$1.pitch ? (r$1.cameraElevationReference = "ground", r$1.zoom = this._originalZoom) : (r$1.recenterOnTerrain(), r$1.cameraElevationReference = "ground"), e$1 !== r$1.zoom && this._map._update(!0);
					}
					if (r$1._isCameraConstrained && s$1._stop(!0), !Al(t$1)) return void this._fireEvents(i$1, o$1, !0);
					let { panDelta: a$1, zoomDelta: l$1, bearingDelta: c$1, pitchDelta: h$1, around: d$1, aroundCoord: u$1, pinchAround: _$1 } = t$1;
					r$1._isCameraConstrained && (l$1 > 0 && (l$1 = 0), r$1._isCameraConstrained = !1), void 0 !== _$1 && (d$1 = _$1), (l$1 || ((e$1) => i$1[e$1] && !this._eventsInProgress[e$1])("drag")) && d$1 && (this._dragOrigin = n$1(r$1.pointCoordinate3D(d$1)), this._originalZoom = r$1.zoom, this._trackingEllipsoid.setup(r$1._camera.position, this._dragOrigin)), r$1.cameraElevationReference = "sea", s$1._stop(!0), d$1 = d$1 || s$1.transform.centerPoint, c$1 && (r$1.bearing += c$1), h$1 && (r$1.pitch += h$1), r$1._updateCameraState();
					const p$1 = [
						0,
						0,
						0
					];
					if (a$1) if ("mercator" === r$1.projection.name) {
						const e$1 = this._trackingEllipsoid.projectRay(r$1.screenPointToMercatorRay(d$1).dir), t$2 = this._trackingEllipsoid.projectRay(r$1.screenPointToMercatorRay(d$1.sub(a$1)).dir);
						p$1[0] = t$2[0] - e$1[0], p$1[1] = t$2[1] - e$1[1];
					} else {
						const t$2 = r$1.pointCoordinate(d$1);
						if ("globe" === r$1.projection.name) {
							a$1 = a$1.rotate(-r$1.angle);
							const i$2 = r$1._pixelsPerMercatorPixel / r$1.worldSize;
							p$1[0] = -a$1.x * e.eW(e.a$(t$2.y)) * i$2, p$1[1] = -a$1.y * e.eW(r$1.center.lat) * i$2;
						} else {
							const e$1 = r$1.pointCoordinate(d$1.sub(a$1));
							t$2 && e$1 && (p$1[0] = e$1.x - t$2.x, p$1[1] = e$1.y - t$2.y);
						}
					}
					const f$1 = r$1.zoom, m$1 = [
						0,
						0,
						0
					];
					if (l$1) {
						const t$2 = n$1(u$1 || r$1.pointCoordinate3D(d$1)), i$2 = { dir: e.aw([], e.av([], t$2, r$1._camera.position)) };
						if (i$2.dir[2] < 0) {
							const o$2 = r$1.zoomDeltaToMovement(t$2, l$1);
							e.c5(m$1, i$2.dir, o$2);
						}
					}
					const g$1 = e.d8(p$1, p$1, m$1);
					r$1._translateCameraConstrained(g$1), l$1 && Math.abs(r$1.zoom - f$1) > 1e-4 && r$1.recenterOnTerrain(), r$1.cameraElevationReference = "ground", this._map._update(), t$1.noInertia || this._inertia.record(t$1), this._fireEvents(i$1, o$1, !0);
				}
				_fireEvents(t$1, i$1, o$1) {
					const s$1 = Il(this._eventsInProgress), r$1 = Il(t$1), n$1 = {};
					for (const e$1 in t$1) {
						const { originalEvent: i$2 } = t$1[e$1];
						this._eventsInProgress[e$1] || (n$1[`${e$1}start`] = i$2), this._eventsInProgress[e$1] = t$1[e$1];
					}
					!s$1 && r$1 && this._fireEvent("movestart", r$1.originalEvent);
					for (const e$1 in n$1) this._fireEvent(e$1, n$1[e$1]);
					r$1 && this._fireEvent("move", r$1.originalEvent);
					for (const e$1 in t$1) {
						const { originalEvent: i$2 } = t$1[e$1];
						this._fireEvent(e$1, i$2);
					}
					const a$1 = {};
					let l$1;
					for (const e$1 in this._eventsInProgress) {
						const { handlerName: t$2, originalEvent: o$2 } = this._eventsInProgress[e$1];
						this._handlersById[t$2].isActive() || (delete this._eventsInProgress[e$1], l$1 = i$1[t$2] || o$2, a$1[`${e$1}end`] = l$1);
					}
					for (const e$1 in a$1) this._fireEvent(e$1, a$1[e$1]);
					const c$1 = Il(this._eventsInProgress);
					if (o$1 && (s$1 || r$1) && !c$1) {
						this._updatingCamera = !0;
						const t$2 = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions), i$2 = (e$1) => 0 !== e$1 && -this._bearingSnap < e$1 && e$1 < this._bearingSnap;
						t$2 ? (i$2(t$2.bearing || this._map.getBearing()) && (t$2.bearing = 0), this._map.easeTo(t$2, { originalEvent: l$1 })) : (this._map.fire(new e.z("moveend", { originalEvent: l$1 })), i$2(this._map.getBearing()) && this._map.resetNorth()), this._updatingCamera = !1;
					}
				}
				_fireEvent(t$1, i$1) {
					this._map.fire(new e.z(t$1, i$1 ? { originalEvent: i$1 } : {}));
				}
				_requestFrame() {
					return this._map.triggerRepaint(), this._map._renderTaskQueue.add(((e$1) => {
						this._frameId = void 0, this.handleEvent(new Cl("renderFrame", { timeStamp: e$1 })), this._applyChanges();
					}));
				}
				_triggerRenderFrame() {
					void 0 === this._frameId && (this._frameId = this._requestFrame());
				}
			}
			const Dl = "map.setFreeCameraOptions(...) and map.getFreeCameraOptions() are not yet supported for non-mercator projections.";
			class Pl extends e.E {
				constructor(t$1, i$1) {
					super(), this._moving = !1, this._zooming = !1, this.transform = t$1, this._bearingSnap = i$1.bearingSnap, this._respectPrefersReducedMotion = !1 !== i$1.respectPrefersReducedMotion, e.aY(["_renderFrameCallback"], this);
				}
				getCenter() {
					return new e.aT(this.transform.center.lng, this.transform.center.lat);
				}
				setCenter(e$1, t$1) {
					return this.jumpTo({ center: e$1 }, t$1);
				}
				panBy(t$1, i$1, o$1) {
					return t$1 = e.P.convert(t$1).mult(-1), this.panTo(this.transform.center, Object.assign({ offset: t$1 }, i$1), o$1);
				}
				panTo(e$1, t$1, i$1) {
					return this.easeTo(Object.assign({ center: e$1 }, t$1), i$1);
				}
				getZoom() {
					return this.transform.zoom;
				}
				setZoom(e$1, t$1) {
					return this.jumpTo({ zoom: e$1 }, t$1), this;
				}
				zoomTo(e$1, t$1, i$1) {
					return this.easeTo(Object.assign({ zoom: e$1 }, t$1), i$1);
				}
				zoomIn(e$1, t$1) {
					return this.zoomTo(this.getZoom() + 1, e$1, t$1), this;
				}
				zoomOut(e$1, t$1) {
					return this.zoomTo(this.getZoom() - 1, e$1, t$1), this;
				}
				getBearing() {
					return this.transform.bearing;
				}
				setBearing(e$1, t$1) {
					return this.jumpTo({ bearing: e$1 }, t$1), this;
				}
				getPadding() {
					return this.transform.padding;
				}
				setPadding(e$1, t$1) {
					return this.jumpTo({ padding: e$1 }, t$1), this;
				}
				rotateTo(e$1, t$1, i$1) {
					return this.easeTo(Object.assign({ bearing: e$1 }, t$1), i$1);
				}
				resetNorth(e$1, t$1) {
					return this.rotateTo(0, Object.assign({ duration: 1e3 }, e$1), t$1), this;
				}
				resetNorthPitch(e$1, t$1) {
					return this.easeTo(Object.assign({
						bearing: 0,
						pitch: 0,
						duration: 1e3
					}, e$1), t$1), this;
				}
				snapToNorth(e$1, t$1) {
					return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(e$1, t$1) : this;
				}
				getPitch() {
					return this.transform.pitch;
				}
				setPitch(e$1, t$1) {
					return this.jumpTo({ pitch: e$1 }, t$1), this;
				}
				cameraForBounds(t$1, i$1) {
					t$1 = e.aI.convert(t$1);
					const o$1 = i$1 && i$1.bearing || 0, s$1 = i$1 && i$1.pitch || 0, r$1 = t$1.getNorthWest(), n$1 = t$1.getSouthEast();
					return this._cameraForBounds(this.transform, r$1, n$1, o$1, s$1, i$1);
				}
				_extendPadding(e$1) {
					const t$1 = {
						top: 0,
						right: 0,
						bottom: 0,
						left: 0
					};
					return null == e$1 ? Object.assign({}, t$1, this.transform.padding) : "number" == typeof e$1 ? {
						top: e$1,
						bottom: e$1,
						right: e$1,
						left: e$1
					} : Object.assign({}, t$1, e$1);
				}
				_extendCameraOptions(e$1) {
					return (e$1 = Object.assign({
						offset: [0, 0],
						maxZoom: this.transform.maxZoom
					}, e$1)).padding = this._extendPadding(e$1.padding), e$1;
				}
				_minimumAABBFrustumDistance(e$1, t$1) {
					const i$1 = t$1.max[0] - t$1.min[0], o$1 = t$1.max[1] - t$1.min[1];
					return i$1 / o$1 > e$1.aspect ? i$1 / (2 * Math.tan(.5 * e$1.fovX) * e$1.aspect) : o$1 / (2 * Math.tan(.5 * e$1.fovY) * e$1.aspect);
				}
				_cameraForBoundsOnGlobe(t$1, i$1, o$1, s$1, r$1, n$1) {
					const a$1 = t$1.clone(), l$1 = this._extendCameraOptions(n$1);
					a$1.bearing = s$1, a$1.pitch = r$1;
					const c$1 = e.aT.convert(i$1), h$1 = e.aT.convert(o$1), d$1 = .5 * (c$1.lat + h$1.lat), u$1 = .5 * (c$1.lng + h$1.lng), _$1 = e.eZ(d$1, u$1), p$1 = e.aw([], _$1), f$1 = e.aw([], e.bI([], p$1, [
						0,
						1,
						0
					])), m$1 = e.bI([], f$1, p$1), g$1 = [
						f$1[0],
						f$1[1],
						f$1[2],
						0,
						m$1[0],
						m$1[1],
						m$1[2],
						0,
						p$1[0],
						p$1[1],
						p$1[2],
						0,
						0,
						0,
						0,
						1
					], v$1 = [
						_$1,
						e.eZ(c$1.lat, c$1.lng),
						e.eZ(h$1.lat, c$1.lng),
						e.eZ(h$1.lat, h$1.lng),
						e.eZ(c$1.lat, h$1.lng),
						e.eZ(d$1, c$1.lng),
						e.eZ(d$1, h$1.lng),
						e.eZ(c$1.lat, u$1),
						e.eZ(h$1.lat, u$1)
					];
					let y$1 = e.d9.fromPoints(v$1.map(((t$2) => [
						e.bJ(f$1, t$2),
						e.bJ(m$1, t$2),
						e.bJ(p$1, t$2)
					])));
					const x$1 = e.af([], y$1.center, g$1);
					0 === e.e_(x$1) && e.e$(x$1, 0, 0, 1), e.aw(x$1, x$1), e.c5(x$1, x$1, e.aD), a$1.center = e.f0(x$1);
					const b$1 = a$1.getWorldToCameraMatrix(), w$1 = e.bl(new Float64Array(16), b$1);
					y$1 = e.d9.applyTransform(y$1, e.aB([], b$1, g$1));
					const T$1 = this._extendAABB(y$1, a$1, l$1, s$1);
					if (!T$1) return void e.w("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
					y$1 = T$1, e.af(x$1, x$1, b$1);
					const E$1 = .5 * (y$1.max[2] - y$1.min[2]), S$1 = this._minimumAABBFrustumDistance(a$1, y$1), I$1 = e.c5([], [
						0,
						0,
						1
					], E$1), C$1 = e.d8(I$1, x$1, I$1), R$1 = S$1 + (0 === a$1.pitch ? 0 : e.bG(x$1, C$1)), A$1 = a$1.globeCenterInViewSpace, L$1 = e.av([], x$1, [
						A$1[0],
						A$1[1],
						A$1[2]
					]);
					e.aw(L$1, L$1), e.c5(L$1, L$1, R$1);
					const D$1 = e.d8([], x$1, L$1);
					e.af(D$1, D$1, w$1);
					const P$1 = e.eM / e.aD, O$1 = e.ag(D$1), z$1 = e.cf(Math.max(O$1 * P$1 - e.eM, Number.EPSILON), 0), M$1 = Math.min(a$1.zoomFromMercatorZAdjusted(z$1), l$1.maxZoom);
					return M$1 > .5 * (e.c_ + e.cL) ? (a$1.setProjection({ name: "mercator" }), a$1.zoom = M$1, this._cameraForBounds(a$1, i$1, o$1, s$1, r$1, n$1)) : {
						center: a$1.center,
						zoom: M$1,
						bearing: s$1,
						pitch: r$1
					};
				}
				_extendAABB(t$1, i$1, o$1, s$1) {
					const r$1 = .5 * ((o$1.padding.left || 0) + (o$1.padding.right || 0)), n$1 = .5 * ((o$1.padding.top || 0) + (o$1.padding.bottom || 0)), a$1 = n$1, l$1 = r$1, c$1 = r$1, h$1 = n$1, d$1 = i$1.width - (l$1 + c$1), u$1 = i$1.height - (a$1 + h$1), _$1 = e.av([], t$1.max, t$1.min), p$1 = Math.min(d$1 / _$1[0], u$1 / _$1[1]), f$1 = Math.min(i$1.scaleZoom(i$1.scale * p$1), o$1.maxZoom);
					if (isNaN(f$1)) return null;
					const m$1 = i$1.scale / i$1.zoomScale(f$1), g$1 = new e.d9([
						t$1.min[0] - l$1 * m$1,
						t$1.min[1] - h$1 * m$1,
						t$1.min[2]
					], [
						t$1.max[0] + c$1 * m$1,
						t$1.max[1] + a$1 * m$1,
						t$1.max[2]
					]), v$1 = ("number" == typeof o$1.offset.x && "number" == typeof o$1.offset.y ? new e.P(o$1.offset.x, o$1.offset.y) : e.P.convert(o$1.offset)).rotate(-e.an(s$1));
					return g$1.center[0] -= v$1.x * m$1, g$1.center[1] += v$1.y * m$1, g$1;
				}
				queryTerrainElevation(t$1, i$1) {
					const o$1 = this.transform.elevation;
					return o$1 ? (i$1 = Object.assign({}, { exaggerated: !0 }, i$1), o$1.getAtPoint(e.ae.fromLngLat(t$1), null, i$1.exaggerated)) : null;
				}
				_cameraForBounds(t$1, i$1, o$1, s$1, r$1, n$1) {
					if ("globe" === t$1.projection.name) return this._cameraForBoundsOnGlobe(t$1, i$1, o$1, s$1, r$1, n$1);
					const a$1 = t$1.clone(), l$1 = this._extendCameraOptions(n$1);
					a$1.bearing = s$1, a$1.pitch = r$1;
					const c$1 = e.aT.convert(i$1), h$1 = e.aT.convert(o$1), d$1 = new e.aT(c$1.lng, h$1.lat), u$1 = new e.aT(h$1.lng, c$1.lat), _$1 = a$1.project(c$1), p$1 = a$1.project(h$1), f$1 = this.queryTerrainElevation(c$1), m$1 = this.queryTerrainElevation(h$1), g$1 = this.queryTerrainElevation(d$1), v$1 = this.queryTerrainElevation(u$1), y$1 = [[
						_$1.x,
						_$1.y,
						Math.min(f$1 || 0, m$1 || 0, g$1 || 0, v$1 || 0)
					], [
						p$1.x,
						p$1.y,
						Math.max(f$1 || 0, m$1 || 0, g$1 || 0, v$1 || 0)
					]];
					let x$1 = e.d9.fromPoints(y$1);
					const b$1 = a$1.getWorldToCameraMatrix(), w$1 = e.bl(new Float64Array(16), b$1);
					x$1 = e.d9.applyTransform(x$1, b$1);
					const T$1 = this._extendAABB(x$1, a$1, l$1, s$1);
					if (!T$1) return void e.w("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
					x$1 = T$1;
					const E$1 = .5 * e.av([], x$1.max, x$1.min)[2], S$1 = this._minimumAABBFrustumDistance(a$1, x$1), I$1 = [
						0,
						0,
						1,
						0
					];
					e.aC(I$1, I$1, b$1), e.f1(I$1, I$1);
					const C$1 = e.c5([], I$1, S$1 + E$1), R$1 = e.d8([], x$1.center, C$1);
					e.af(x$1.center, x$1.center, w$1), e.af(R$1, R$1, w$1);
					const A$1 = a$1.unproject(new e.P(x$1.center[0], x$1.center[1])), L$1 = e.f2(a$1.projection, A$1), D$1 = Math.pow(2, L$1), P$1 = Math.min(a$1._zoomFromMercatorZ(R$1[2] * a$1.pixelsPerMeter * D$1 / a$1.worldSize), l$1.maxZoom);
					return a$1.mercatorFromTransition && P$1 < .5 * (e.c_ + e.cL) ? (a$1.setProjection({ name: "globe" }), a$1.zoom = P$1, this._cameraForBounds(a$1, i$1, o$1, s$1, r$1, n$1)) : {
						center: A$1,
						zoom: P$1,
						bearing: s$1,
						pitch: r$1
					};
				}
				fitBounds(e$1, t$1, i$1) {
					const o$1 = this.cameraForBounds(e$1, t$1);
					return this._fitInternal(o$1, t$1, i$1);
				}
				fitScreenCoordinates(t$1, i$1, o$1, s$1, r$1) {
					const n$1 = e.P.convert(t$1), a$1 = e.P.convert(i$1), l$1 = new e.P(Math.min(n$1.x, a$1.x), Math.min(n$1.y, a$1.y)), c$1 = new e.P(Math.max(n$1.x, a$1.x), Math.max(n$1.y, a$1.y));
					if ("mercator" === this.transform.projection.name && this.transform.anyCornerOffEdge(n$1, a$1)) return this;
					const h$1 = this.transform.pointLocation3D(l$1), d$1 = this.transform.pointLocation3D(c$1), u$1 = this.transform.pointLocation3D(new e.P(l$1.x, c$1.y)), _$1 = this.transform.pointLocation3D(new e.P(c$1.x, l$1.y)), p$1 = [Math.min(h$1.lng, d$1.lng, u$1.lng, _$1.lng), Math.min(h$1.lat, d$1.lat, u$1.lat, _$1.lat)], f$1 = [Math.max(h$1.lng, d$1.lng, u$1.lng, _$1.lng), Math.max(h$1.lat, d$1.lat, u$1.lat, _$1.lat)], m$1 = s$1 && s$1.pitch ? s$1.pitch : this.getPitch(), g$1 = this._cameraForBounds(this.transform, p$1, f$1, o$1, m$1, s$1);
					return this._fitInternal(g$1, s$1, r$1);
				}
				_fitInternal(e$1, t$1, i$1) {
					return e$1 ? (t$1 = Object.assign(e$1, t$1)).linear ? this.easeTo(t$1, i$1) : this.flyTo(t$1, i$1) : this;
				}
				jumpTo(t$1, i$1) {
					this.stop();
					const o$1 = t$1.preloadOnly ? this.transform.clone() : this.transform;
					let s$1 = !1, r$1 = !1, n$1 = !1;
					"zoom" in t$1 && o$1.zoom !== +t$1.zoom && (s$1 = !0, o$1.zoom = +t$1.zoom), void 0 !== t$1.center && (o$1.center = e.aT.convert(t$1.center)), "bearing" in t$1 && o$1.bearing !== +t$1.bearing && (r$1 = !0, o$1.bearing = +t$1.bearing), "pitch" in t$1 && o$1.pitch !== +t$1.pitch && (n$1 = !0, o$1.pitch = +t$1.pitch);
					const a$1 = "number" == typeof t$1.padding ? this._extendPadding(t$1.padding) : t$1.padding;
					if (null != t$1.padding && !o$1.isPaddingEqual(a$1)) if (!1 === t$1.retainPadding) {
						const e$1 = o$1.clone();
						e$1.padding = a$1, o$1.setLocationAtPoint(o$1.center, e$1.centerPoint);
					} else o$1.padding = a$1;
					return t$1.preloadOnly ? (this._preloadTiles(o$1), this) : (this.fire(new e.z("movestart", i$1)).fire(new e.z("move", i$1)), s$1 && this.fire(new e.z("zoomstart", i$1)).fire(new e.z("zoom", i$1)).fire(new e.z("zoomend", i$1)), r$1 && this.fire(new e.z("rotatestart", i$1)).fire(new e.z("rotate", i$1)).fire(new e.z("rotateend", i$1)), n$1 && this.fire(new e.z("pitchstart", i$1)).fire(new e.z("pitch", i$1)).fire(new e.z("pitchend", i$1)), this.fire(new e.z("moveend", i$1)));
				}
				getFreeCameraOptions() {
					return this.transform.projection.supportsFreeCamera || e.w(Dl), this.transform.getFreeCameraOptions();
				}
				setFreeCameraOptions(t$1, i$1) {
					const o$1 = this.transform;
					if (!o$1.projection.supportsFreeCamera) return e.w(Dl), this;
					this.stop();
					const s$1 = o$1.zoom, r$1 = o$1.pitch, n$1 = o$1.bearing;
					o$1.setFreeCameraOptions(t$1);
					const a$1 = s$1 !== o$1.zoom, l$1 = r$1 !== o$1.pitch, c$1 = n$1 !== o$1.bearing;
					return this.fire(new e.z("movestart", i$1)).fire(new e.z("move", i$1)), a$1 && this.fire(new e.z("zoomstart", i$1)).fire(new e.z("zoom", i$1)).fire(new e.z("zoomend", i$1)), c$1 && this.fire(new e.z("rotatestart", i$1)).fire(new e.z("rotate", i$1)).fire(new e.z("rotateend", i$1)), l$1 && this.fire(new e.z("pitchstart", i$1)).fire(new e.z("pitch", i$1)).fire(new e.z("pitchend", i$1)), this.fire(new e.z("moveend", i$1)), this;
				}
				easeTo(t$1, i$1) {
					this._stop(!1, t$1.easeId), (!1 === (t$1 = Object.assign({
						offset: [0, 0],
						duration: 500,
						easing: e.eV
					}, t$1)).animate || this._prefersReducedMotion(t$1)) && (t$1.duration = 0);
					const o$1 = this.transform, s$1 = this.getZoom(), r$1 = this.getBearing(), n$1 = this.getPitch(), a$1 = this.getPadding(), l$1 = "zoom" in t$1 ? +t$1.zoom : s$1, c$1 = "bearing" in t$1 ? this._normalizeBearing(t$1.bearing, r$1) : r$1, h$1 = "pitch" in t$1 ? +t$1.pitch : n$1, d$1 = this._extendPadding(t$1.padding), u$1 = e.P.convert(t$1.offset);
					let _$1, p$1, f$1;
					if ("globe" === o$1.projection.name) {
						const i$2 = e.ae.fromLngLat(o$1.center), s$2 = u$1.rotate(-o$1.angle);
						i$2.x += s$2.x / o$1.worldSize, i$2.y += s$2.y / o$1.worldSize;
						const r$2 = i$2.toLngLat(), n$2 = e.aT.convert(t$1.center || r$2);
						this._normalizeCenter(n$2), _$1 = o$1.centerPoint.add(s$2), p$1 = new e.P(i$2.x, i$2.y).mult(o$1.worldSize), f$1 = new e.P(e.aF(n$2.lng), e.aJ(n$2.lat)).mult(o$1.worldSize).sub(p$1);
					} else {
						_$1 = o$1.centerPoint.add(u$1);
						const i$2 = o$1.pointLocation(_$1), s$2 = e.aT.convert(t$1.center || i$2);
						this._normalizeCenter(s$2), p$1 = o$1.project(i$2), f$1 = o$1.project(s$2).sub(p$1);
					}
					const m$1 = o$1.zoomScale(l$1 - s$1);
					let g$1, v$1;
					t$1.around && (g$1 = e.aT.convert(t$1.around), v$1 = o$1.locationPoint(g$1));
					const y$1 = this._zooming || l$1 !== s$1, x$1 = this._rotating || r$1 !== c$1, b$1 = this._pitching || h$1 !== n$1, w$1 = !o$1.isPaddingEqual(d$1), T$1 = !1 === t$1.retainPadding ? o$1.clone() : o$1, E$1 = (o$2) => (E$2) => {
						if (y$1 && (o$2.zoom = e.ak(s$1, l$1, E$2)), x$1 && (o$2.bearing = e.ak(r$1, c$1, E$2)), b$1 && (o$2.pitch = e.ak(n$1, h$1, E$2)), w$1 && (T$1.interpolatePadding(a$1, d$1, E$2), _$1 = T$1.centerPoint.add(u$1)), g$1) o$2.setLocationAtPoint(g$1, v$1);
						else {
							const e$1 = o$2.zoomScale(o$2.zoom - s$1), t$2 = l$1 > s$1 ? Math.min(2, m$1) : Math.max(.5, m$1), i$2 = Math.pow(t$2, 1 - E$2), r$2 = o$2.unproject(p$1.add(f$1.mult(E$2 * i$2)).mult(e$1));
							o$2.setLocationAtPoint(o$2.renderWorldCopies ? r$2.wrap() : r$2, _$1);
						}
						return t$1.preloadOnly || this._fireMoveEvents(i$1), o$2;
					};
					if (t$1.preloadOnly) {
						const e$1 = this._emulate(E$1, t$1.duration, o$1);
						return this._preloadTiles(e$1), this;
					}
					const S$1 = {
						moving: this._moving,
						zooming: this._zooming,
						rotating: this._rotating,
						pitching: this._pitching
					};
					return this._zooming = y$1, this._rotating = x$1, this._pitching = b$1, this._padding = w$1, this._easeId = t$1.easeId, this._prepareEase(i$1, t$1.noMoveStart, S$1), this._ease(E$1(o$1), ((e$1) => {
						"sea" === o$1.cameraElevationReference && o$1.recenterOnTerrain(), this._afterEase(i$1, e$1);
					}), t$1), this;
				}
				_prepareEase(t$1, i$1, o$1 = {}) {
					this._moving = !0, this.transform.cameraElevationReference = "sea", this.transform._orthographicProjectionAtLowPitch && 0 === this.transform.pitch && "globe" !== this.transform.projection.name && (this.transform.cameraElevationReference = "ground"), i$1 || o$1.moving || this.fire(new e.z("movestart", t$1)), this._zooming && !o$1.zooming && this.fire(new e.z("zoomstart", t$1)), this._rotating && !o$1.rotating && this.fire(new e.z("rotatestart", t$1)), this._pitching && !o$1.pitching && this.fire(new e.z("pitchstart", t$1));
				}
				_fireMoveEvents(t$1) {
					this.fire(new e.z("move", t$1)), this._zooming && this.fire(new e.z("zoom", t$1)), this._rotating && this.fire(new e.z("rotate", t$1)), this._pitching && this.fire(new e.z("pitch", t$1));
				}
				_afterEase(t$1, i$1) {
					if (this._easeId && i$1 && this._easeId === i$1) return;
					this._easeId = void 0, this.transform.cameraElevationReference = "ground";
					const o$1 = this._zooming, s$1 = this._rotating, r$1 = this._pitching;
					this._moving = !1, this._zooming = !1, this._rotating = !1, this._pitching = !1, this._padding = !1, o$1 && this.fire(new e.z("zoomend", t$1)), s$1 && this.fire(new e.z("rotateend", t$1)), r$1 && this.fire(new e.z("pitchend", t$1)), this.fire(new e.z("moveend", t$1));
				}
				flyTo(t$1, i$1) {
					if (this._prefersReducedMotion(t$1)) {
						const o$2 = e.aH(t$1, [
							"center",
							"zoom",
							"bearing",
							"pitch",
							"around",
							"padding",
							"retainPadding"
						]);
						return this.jumpTo(o$2, i$1);
					}
					this.stop(), t$1 = Object.assign({
						offset: [0, 0],
						speed: 1.2,
						curve: 1.42,
						easing: e.eV
					}, t$1);
					const o$1 = this.transform, s$1 = this.getZoom(), r$1 = this.getBearing(), n$1 = this.getPitch(), a$1 = this.getPadding(), l$1 = "zoom" in t$1 ? e.aA(+t$1.zoom, o$1.minZoom, o$1.maxZoom) : s$1, c$1 = "bearing" in t$1 ? this._normalizeBearing(t$1.bearing, r$1) : r$1, h$1 = "pitch" in t$1 ? +t$1.pitch : n$1, d$1 = this._extendPadding(t$1.padding), u$1 = o$1.zoomScale(l$1 - s$1), _$1 = e.P.convert(t$1.offset);
					let p$1 = o$1.centerPoint.add(_$1);
					const f$1 = o$1.pointLocation(p$1), m$1 = e.aT.convert(t$1.center || f$1);
					this._normalizeCenter(m$1);
					const g$1 = o$1.project(f$1), v$1 = o$1.project(m$1).sub(g$1);
					let y$1 = t$1.curve;
					const x$1 = Math.max(o$1.width, o$1.height), b$1 = x$1 / u$1, w$1 = v$1.mag();
					if ("minZoom" in t$1) {
						const i$2 = e.aA(Math.min(t$1.minZoom, s$1, l$1), o$1.minZoom, o$1.maxZoom), r$2 = x$1 / o$1.zoomScale(i$2 - s$1);
						y$1 = Math.sqrt(r$2 / w$1 * 2);
					}
					const T$1 = y$1 * y$1;
					function E$1(e$1) {
						const t$2 = (b$1 * b$1 - x$1 * x$1 + (e$1 ? -1 : 1) * T$1 * T$1 * w$1 * w$1) / (2 * (e$1 ? b$1 : x$1) * T$1 * w$1);
						return Math.log(Math.sqrt(t$2 * t$2 + 1) - t$2);
					}
					function S$1(e$1) {
						return (Math.exp(e$1) - Math.exp(-e$1)) / 2;
					}
					function I$1(e$1) {
						return (Math.exp(e$1) + Math.exp(-e$1)) / 2;
					}
					const C$1 = E$1(0);
					let R$1 = function(e$1) {
						return I$1(C$1) / I$1(C$1 + y$1 * e$1);
					}, A$1 = function(e$1) {
						return x$1 * ((I$1(C$1) * (S$1(t$2 = C$1 + y$1 * e$1) / I$1(t$2)) - S$1(C$1)) / T$1) / w$1;
						var t$2;
					}, L$1 = (E$1(1) - C$1) / y$1;
					if (Math.abs(w$1) < 1e-6 || !isFinite(L$1)) {
						if (Math.abs(x$1 - b$1) < 1e-6) return this.easeTo(t$1, i$1);
						const e$1 = b$1 < x$1 ? -1 : 1;
						L$1 = Math.abs(Math.log(b$1 / x$1)) / y$1, A$1 = function() {
							return 0;
						}, R$1 = function(t$2) {
							return Math.exp(e$1 * y$1 * t$2);
						};
					}
					t$1.duration = "duration" in t$1 ? +t$1.duration : 1e3 * L$1 / ("screenSpeed" in t$1 ? +t$1.screenSpeed / y$1 : +t$1.speed), t$1.maxDuration && t$1.duration > t$1.maxDuration && (t$1.duration = 0);
					const D$1 = r$1 !== c$1, P$1 = h$1 !== n$1, O$1 = !o$1.isPaddingEqual(d$1), z$1 = !1 === t$1.retainPadding ? o$1.clone() : o$1, M$1 = (o$2) => (u$2) => {
						const f$2 = u$2 * L$1, y$2 = 1 / R$1(f$2);
						o$2.zoom = 1 === u$2 ? l$1 : s$1 + o$2.scaleZoom(y$2), D$1 && (o$2.bearing = e.ak(r$1, c$1, u$2)), P$1 && (o$2.pitch = e.ak(n$1, h$1, u$2)), O$1 && (z$1.interpolatePadding(a$1, d$1, u$2), p$1 = z$1.centerPoint.add(_$1));
						const x$2 = 1 === u$2 ? m$1 : o$2.unproject(g$1.add(v$1.mult(A$1(f$2))).mult(y$2));
						return o$2.setLocationAtPoint(o$2.renderWorldCopies ? x$2.wrap() : x$2, p$1), o$2._updateCameraOnTerrain(), t$1.preloadOnly || this._fireMoveEvents(i$1), o$2;
					};
					if (t$1.preloadOnly) {
						const e$1 = this._emulate(M$1, t$1.duration, o$1);
						return this._preloadTiles(e$1), this;
					}
					return this._zooming = !0, this._rotating = D$1, this._pitching = P$1, this._padding = O$1, this._prepareEase(i$1, !1), this._ease(M$1(o$1), (() => this._afterEase(i$1)), t$1), this;
				}
				isEasing() {
					return !!this._easeFrameId;
				}
				stop() {
					return this._stop();
				}
				_requestRenderFrame(e$1) {}
				_cancelRenderFrame(e$1) {}
				_stop(e$1, t$1) {
					if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), this._easeFrameId = void 0, this._onEaseFrame = void 0), this._onEaseEnd) {
						const e$2 = this._onEaseEnd;
						this._onEaseEnd = void 0, e$2.call(this, t$1);
					}
					if (!e$1) {
						const e$2 = this.handlers;
						e$2 && e$2.stop(!1);
					}
					return this;
				}
				_ease(t$1, i$1, o$1) {
					!1 === o$1.animate || 0 === o$1.duration ? (t$1(1), i$1()) : (this._easeStart = e.o.now(), this._easeOptions = o$1, this._onEaseFrame = t$1, this._onEaseEnd = i$1, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));
				}
				_renderFrameCallback() {
					const t$1 = Math.min((e.o.now() - this._easeStart) / this._easeOptions.duration, 1), i$1 = this._onEaseFrame;
					i$1 && i$1(this._easeOptions.easing(t$1)), t$1 < 1 ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();
				}
				_normalizeBearing(t$1, i$1) {
					t$1 = e.bT(t$1, -180, 180);
					const o$1 = Math.abs(t$1 - i$1);
					return Math.abs(t$1 - 360 - i$1) < o$1 && (t$1 -= 360), Math.abs(t$1 + 360 - i$1) < o$1 && (t$1 += 360), t$1;
				}
				_normalizeCenter(e$1) {
					const t$1 = this.transform;
					if (t$1.maxBounds) return;
					if ("globe" !== t$1.projection.name && !t$1.renderWorldCopies) return;
					const i$1 = e$1.lng - t$1.center.lng;
					e$1.lng += i$1 > 180 ? -360 : i$1 < -180 ? 360 : 0;
				}
				_prefersReducedMotion(t$1) {
					return this._respectPrefersReducedMotion && e.o.prefersReducedMotion && !(t$1 && t$1.essential);
				}
				_emulate(e$1, t$1, i$1) {
					const o$1 = Math.ceil(15 * t$1 / 1e3), s$1 = [], r$1 = e$1(i$1.clone());
					for (let e$2 = 0; e$2 <= o$1; e$2++) {
						const t$2 = r$1(e$2 / o$1);
						s$1.push(t$2.clone());
					}
					return s$1;
				}
				_preloadTiles(e$1, t$1) {}
			}
			class Ol {
				constructor(t$1 = {}) {
					this.options = t$1, e.aY([
						"_toggleAttribution",
						"_updateEditLink",
						"_updateData",
						"_updateCompact"
					], this);
				}
				getDefaultPosition() {
					return "bottom-right";
				}
				onAdd(e$1) {
					const t$1 = this.options && this.options.compact, i$1 = e$1._getUIString("AttributionControl.ToggleAttribution");
					this._map = e$1, this._container = l("div", "mapboxgl-ctrl mapboxgl-ctrl-attrib"), this._compactButton = l("button", "mapboxgl-ctrl-attrib-button", this._container), this._compactButton.type = "button", this._compactButton.addEventListener("click", this._toggleAttribution), this._compactButton.setAttribute("aria-label", i$1);
					const o$1 = l("span", "mapboxgl-ctrl-icon", this._compactButton);
					return o$1.setAttribute("aria-hidden", "true"), o$1.setAttribute("title", i$1), this._innerContainer = l("div", "mapboxgl-ctrl-attrib-inner", this._container), t$1 && this._container.classList.add("mapboxgl-compact"), this._updateAttributions(), this._updateEditLink(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("moveend", this._updateEditLink), void 0 === t$1 && (this._map.on("resize", this._updateCompact), this._updateCompact()), this._container;
				}
				onRemove() {
					this._container.remove(), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("moveend", this._updateEditLink), this._map.off("resize", this._updateCompact), this._map = void 0, this._attribHTML = void 0;
				}
				_toggleAttribution() {
					this._container.classList.contains("mapboxgl-compact-show") ? (this._container.classList.remove("mapboxgl-compact-show"), this._compactButton.setAttribute("aria-expanded", "false")) : (this._container.classList.add("mapboxgl-compact-show"), this._compactButton.setAttribute("aria-expanded", "true"));
				}
				_updateEditLink() {
					let t$1 = this._editLink;
					t$1 || (t$1 = this._editLink = this._container.querySelector(".mapbox-improve-map"));
					const i$1 = [
						{
							key: "owner",
							value: this.styleOwner
						},
						{
							key: "id",
							value: this.styleId
						},
						{
							key: "access_token",
							value: this._map._requestManager._customAccessToken || e.e.ACCESS_TOKEN
						}
					];
					if (t$1) {
						const o$1 = i$1.reduce(((e$1, t$2, o$2) => (t$2.value && (e$1 += `${t$2.key}=${t$2.value}${o$2 < i$1.length - 1 ? "&" : ""}`), e$1)), "?");
						t$1.href = `${e.e.FEEDBACK_URL}/${o$1}#${za(this._map, !0)}`, t$1.rel = "noopener nofollow";
					}
				}
				_updateData(e$1) {
					!e$1 || ("source" !== e$1.dataType || "metadata" !== e$1.sourceDataType && "visibility" !== e$1.sourceDataType) && "style" !== e$1.dataType || (this._updateAttributions(), this._updateEditLink());
				}
				_updateAttributions() {
					if (!this._map.style) return;
					let e$1 = [];
					if (this._map.style.stylesheet) {
						const e$2 = this._map.style.stylesheet;
						this.styleOwner = e$2.owner, this.styleId = e$2.id;
					}
					const t$1 = this._map.style._mergedSourceCaches;
					for (const i$2 in t$1) {
						const o$1 = t$1[i$2];
						if (o$1.used) {
							const t$2 = o$1.getSource();
							t$2.attribution && e$1.indexOf(t$2.attribution) < 0 && e$1.push(t$2.attribution);
						}
					}
					e$1.sort(((e$2, t$2) => e$2.length - t$2.length)), e$1 = e$1.filter(((t$2, i$2) => {
						for (let o$1 = i$2 + 1; o$1 < e$1.length; o$1++) if (e$1[o$1].indexOf(t$2) >= 0) return !1;
						return !0;
					})), this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? e$1 = [...this.options.customAttribution, ...e$1] : e$1.unshift(this.options.customAttribution));
					const i$1 = e$1.map(((e$2) => function(e$3) {
						const t$2 = new DOMParser().parseFromString(e$3, "text/html");
						return Array.from(t$2.body.querySelectorAll("*")).forEach(((e$4) => {
							const i$2 = e$4.textContent || "";
							if ("A" !== e$4.tagName) return void e$4.replaceWith(t$2.createTextNode(i$2));
							const o$1 = e$4.getAttribute("href");
							if (!o$1 || !/^(https?:|mailto:)/i.test(o$1)) return void e$4.replaceWith(t$2.createTextNode(i$2));
							const s$1 = t$2.createElement("a");
							s$1.href = o$1, s$1.textContent = i$2, s$1.rel = "noopener nofollow";
							const r$1 = e$4.getAttribute("class");
							r$1 && (s$1.className = r$1), e$4.replaceWith(s$1);
						})), t$2.body.innerHTML;
					}(e$2))).join(" | ");
					i$1 !== this._attribHTML && (this._attribHTML = i$1, e$1.length ? (this._innerContainer.innerHTML = i$1, this._container.classList.remove("mapboxgl-attrib-empty")) : this._container.classList.add("mapboxgl-attrib-empty"), this._editLink = null);
				}
				_updateCompact() {
					this._map.getCanvasContainer().offsetWidth <= 640 ? this._container.classList.add("mapboxgl-compact") : this._container.classList.remove("mapboxgl-compact", "mapboxgl-compact-show");
				}
			}
			class zl {
				constructor() {
					e.aY(["_updateLogo", "_updateCompact"], this);
				}
				onAdd(e$1) {
					this._map = e$1, this._container = l("div", "mapboxgl-ctrl");
					const t$1 = l("a", "mapboxgl-ctrl-logo");
					return t$1.target = "_blank", t$1.rel = "noopener nofollow", t$1.href = "https://www.mapbox.com/", t$1.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), t$1.setAttribute("rel", "noopener nofollow"), this._container.appendChild(t$1), this._container.style.display = "none", this._map.on("sourcedata", this._updateLogo), this._updateLogo(), this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;
				}
				onRemove() {
					this._container.remove(), this._map.off("sourcedata", this._updateLogo), this._map.off("resize", this._updateCompact);
				}
				getDefaultPosition() {
					return "bottom-left";
				}
				_updateLogo(e$1) {
					e$1 && "metadata" !== e$1.sourceDataType || (this._container.style.display = this._logoRequired() ? "block" : "none");
				}
				_logoRequired() {
					if (!this._map.style) return !0;
					const e$1 = this._map.style._sourceCaches;
					if (0 === Object.entries(e$1).length) return !0;
					for (const t$1 in e$1) {
						const i$1 = e$1[t$1].getSource();
						if (i$1.hasOwnProperty("mapbox_logo") && !i$1.mapbox_logo) return !1;
					}
					return !0;
				}
				_updateCompact() {
					const e$1 = this._container.children;
					if (e$1.length) {
						const t$1 = e$1[0];
						this._map.getCanvasContainer().offsetWidth < 250 ? t$1.classList.add("mapboxgl-compact") : t$1.classList.remove("mapboxgl-compact");
					}
				}
			}
			class Ml {
				constructor() {
					e.aY(["_onIndoorUpdate"], this);
				}
				onAdd(e$1) {
					return this._map = e$1, this._container = l("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._map.indoor.on("selector-update", ((e$2) => this._onIndoorUpdate(e$2))), this._container;
				}
				_createButton(e$1, t$1) {
					const i$1 = l("button", e$1, this._container);
					return i$1.type = "button", i$1.addEventListener("click", t$1), i$1;
				}
				_createSeparator() {
					return l("div", "mapboxgl-ctrl-separator", this._container);
				}
				_setButtonTitle(e$1, t$1) {
					this._map && (e$1.setAttribute("aria-label", t$1), e$1.textContent = t$1);
				}
				onRemove() {
					this._container && this._container.remove(), this._map && this._map.indoor && (this._map.indoor.off("selector-update", this._onIndoorUpdate), this._map = null);
				}
				getDefaultPosition() {
					return "right";
				}
				_onIndoorUpdate(e$1) {
					if (!e$1 || !e$1.floors) return this._model = e$1, void (this._container.style.display = "none");
					const t$1 = this._model;
					this._model = e$1, this._container.style.display = "inline-block", this._container.style.borderRadius = "8px", t$1 && Array.from(this._container.children).forEach(((e$2) => e$2.remove())), e$1.floors.length > 0 && (this.addBuildingsToggleButton(), this.addCurrentFloors(e$1.floors, e$1.activeFloorsVisible), this._updateBuildingsButtonState());
				}
				addBuildingsToggleButton() {
					const e$1 = this._createButton("mapboxgl-ctrl-buildings-toggle", (() => {
						const e$2 = this._map;
						this._model && e$2 && e$2._setIndoorActiveFloorsVisibility(!this._model.activeFloorsVisible);
					}));
					l("span", "mapboxgl-ctrl-icon", e$1).setAttribute("aria-hidden", "true"), e$1.classList.add("mapboxgl-ctrl-level-button", "mapboxgl-ctrl-buildings-toggle"), this._model && !this._model.activeFloorsVisible && e$1.classList.add("mapboxgl-ctrl-level-button-selected"), this._container.append(e$1), this._createSeparator();
				}
				_updateBuildingsButtonState() {
					const e$1 = this._container.querySelector(".mapboxgl-ctrl-buildings-toggle");
					e$1 && this._model && (this._model.activeFloorsVisible ? e$1.classList.remove("mapboxgl-ctrl-level-button-selected") : e$1.classList.add("mapboxgl-ctrl-level-button-selected"));
				}
				addCurrentFloors(e$1, t$1) {
					for (let i$1 = 0; i$1 < e$1.length; i$1++) {
						const o$1 = e$1[i$1], s$1 = this._createButton("mapboxgl-ctrl-level-button", (() => {
							this._map._selectIndoorFloor(o$1.id);
						}));
						this._setButtonTitle(s$1, o$1.zIndex.toString()), this._model && o$1.id === this._model.selectedFloorId && t$1 && s$1.classList.add("mapboxgl-ctrl-level-button-selected"), this._container.append(s$1), i$1 < e$1.length - 1 && this._createSeparator();
					}
				}
			}
			class Fl {
				constructor() {
					this._queue = [], this._id = 0, this._cleared = !1, this._currentlyRunning = !1;
				}
				add(e$1) {
					const t$1 = ++this._id;
					return this._queue.push({
						callback: e$1,
						id: t$1,
						cancelled: !1
					}), t$1;
				}
				remove(e$1) {
					const t$1 = this._currentlyRunning, i$1 = t$1 ? this._queue.concat(t$1) : this._queue;
					for (const t$2 of i$1) if (t$2.id === e$1) return void (t$2.cancelled = !0);
				}
				run(e$1 = 0) {
					const t$1 = this._currentlyRunning = this._queue;
					this._queue = [];
					for (const i$1 of t$1) if (!i$1.cancelled && (i$1.callback(e$1), this._cleared)) break;
					this._cleared = !1, this._currentlyRunning = !1;
				}
				clear() {
					this._currentlyRunning && (this._cleared = !0), this._queue = [];
				}
			}
			class Bl {
				constructor(e$1) {
					this.jumpTo(e$1);
				}
				getValue(t$1) {
					if (t$1 <= this._startTime) return this._start;
					if (t$1 >= this._endTime) return this._end;
					const i$1 = e.dD((t$1 - this._startTime) / (this._endTime - this._startTime));
					return this._start * (1 - i$1) + this._end * i$1;
				}
				isEasing(e$1) {
					return e$1 >= this._startTime && e$1 <= this._endTime;
				}
				jumpTo(e$1) {
					this._startTime = -Infinity, this._endTime = -Infinity, this._start = e$1, this._end = e$1;
				}
				easeTo(e$1, t$1, i$1) {
					this._start = this.getValue(t$1), this._end = e$1, this._startTime = t$1, this._endTime = t$1 + i$1;
				}
			}
			const kl = {
				"AttributionControl.ToggleAttribution": "Toggle attribution",
				"FullscreenControl.Enter": "Enter fullscreen",
				"FullscreenControl.Exit": "Exit fullscreen",
				"GeolocateControl.FindMyLocation": "Find my location",
				"GeolocateControl.LocationNotAvailable": "Location not available",
				"LogoControl.Title": "Mapbox homepage",
				"Map.Title": "Map",
				"NavigationControl.ResetBearing": "Reset bearing to north",
				"NavigationControl.ZoomIn": "Zoom in",
				"NavigationControl.ZoomOut": "Zoom out",
				"ScrollZoomBlocker.CtrlMessage": "Use ctrl + scroll to zoom the map",
				"ScrollZoomBlocker.CmdMessage": "Use  + scroll to zoom the map",
				"TouchPanBlocker.Message": "Use two fingers to move the map"
			};
			class Nl extends e.z {
				constructor(e$1, t$1, i$1, o$1) {
					const { point: s$1, lngLat: r$1, originalEvent: n$1, target: a$1 } = e$1;
					super(e$1.type, {
						point: s$1,
						lngLat: r$1,
						originalEvent: n$1,
						target: a$1
					}), this.preventDefault = () => {
						e$1.preventDefault();
					}, this.id = t$1, this.interaction = i$1, this.feature = o$1;
				}
			}
			class Ul {
				constructor(e$1) {
					this.map = e$1, this.interactionsByType = /* @__PURE__ */ new Map(), this.delegatedInteractions = /* @__PURE__ */ new Map(), this.typeById = /* @__PURE__ */ new Map(), this.filters = /* @__PURE__ */ new Map(), this.handleType = this.handleType.bind(this), this.handleMove = this.handleMove.bind(this), this.handleOut = this.handleOut.bind(this), this.hoveredFeatures = /* @__PURE__ */ new Map(), this.prevHoveredFeatures = /* @__PURE__ */ new Map();
				}
				add(t$1, i$1) {
					if (this.typeById.has(t$1)) throw new Error(`Interaction id "${t$1}" already exists.`);
					const o$1 = i$1.filter;
					let s$1 = i$1.type;
					o$1 && this.filters.set(t$1, e.b6(o$1)), "mouseover" === s$1 && (s$1 = "mouseenter"), "mouseout" === s$1 && (s$1 = "mouseleave");
					const r$1 = this.interactionsByType.get(s$1) || /* @__PURE__ */ new Map();
					"mouseenter" === s$1 || "mouseleave" === s$1 ? (0 === this.delegatedInteractions.size && (this.map.on("mousemove", this.handleMove), this.map.on("mouseout", this.handleOut)), this.delegatedInteractions.set(t$1, i$1)) : 0 === r$1.size && this.map.on(s$1, this.handleType), 0 === r$1.size && this.interactionsByType.set(s$1, r$1), r$1.set(t$1, i$1), this.typeById.set(t$1, s$1);
				}
				get(e$1) {
					const t$1 = this.typeById.get(e$1);
					if (!t$1) return;
					const i$1 = this.interactionsByType.get(t$1);
					return i$1 ? i$1.get(e$1) : void 0;
				}
				remove(e$1) {
					const t$1 = this.typeById.get(e$1);
					if (!t$1) return;
					this.typeById.delete(e$1), this.filters.delete(e$1);
					const i$1 = this.interactionsByType.get(t$1);
					i$1 && (i$1.delete(e$1), "mouseenter" === t$1 || "mouseleave" === t$1 ? (this.delegatedInteractions.delete(e$1), 0 === this.delegatedInteractions.size && (this.map.off("mousemove", this.handleMove), this.map.off("mouseout", this.handleOut))) : 0 === i$1.size && this.map.off(t$1, this.handleType));
				}
				queryTargets(e$1, t$1) {
					const i$1 = [];
					for (const [e$2, o$1] of t$1) o$1.target && i$1.push({
						targetId: e$2,
						target: o$1.target,
						filter: this.filters.get(e$2)
					});
					return this.map.style.queryRenderedTargets(e$1, i$1, this.map.transform);
				}
				handleMove(e$1) {
					this.prevHoveredFeatures = this.hoveredFeatures, this.hoveredFeatures = /* @__PURE__ */ new Map();
					const t$1 = this.queryTargets(e$1.point, Array.from(this.delegatedInteractions).reverse());
					t$1.length && (e$1.type = "mouseenter", this.handleType(e$1, t$1));
					const i$1 = /* @__PURE__ */ new Map();
					for (const [e$2, { feature: t$2 }] of this.prevHoveredFeatures) this.hoveredFeatures.has(e$2) || i$1.set(t$2.id, t$2);
					i$1.size && (e$1.type = "mouseleave", this.handleType(e$1, Array.from(i$1.values())));
				}
				handleOut(e$1) {
					const t$1 = Array.from(this.hoveredFeatures.values()).map((({ feature: e$2 }) => e$2));
					t$1.length && (e$1.type = "mouseleave", this.handleType(e$1, t$1)), this.hoveredFeatures.clear();
				}
				handleType(t$1, i$1) {
					const o$1 = "mouseenter" === t$1.type;
					if (o$1 && !this.interactionsByType.has(t$1.type)) return void e.w("mouseenter interaction required for mouseleave to work.");
					const s$1 = Array.from(this.interactionsByType.get(t$1.type)).reverse(), r$1 = !!i$1;
					i$1 = i$1 || this.queryTargets(t$1.point, s$1);
					let n$1 = !1;
					const a$1 = /* @__PURE__ */ new Set();
					for (const l$1 of i$1) {
						for (const [i$2, c$1] of s$1) {
							if (!c$1.target) continue;
							const s$2 = l$1.variants ? l$1.variants[i$2] : null;
							if (s$2) {
								for (const h$1 of s$2) {
									if (vt(h$1, l$1, a$1, i$2)) continue;
									const s$3 = new e.dx(l$1, h$1), d$1 = gt(h$1, l$1, i$2);
									r$1 && void 0 !== s$3.id && (s$3.state = this.map.getFeatureState(s$3));
									const u$1 = o$1 ? this.prevHoveredFeatures.get(d$1) : null, _$1 = new Nl(t$1, i$2, c$1, s$3), p$1 = u$1 ? u$1.stop : c$1.handler(_$1);
									if (o$1 && this.hoveredFeatures.set(d$1, {
										feature: l$1,
										stop: p$1
									}), !1 !== p$1) {
										n$1 = !0;
										break;
									}
								}
								if (n$1) break;
							}
						}
						if (n$1) break;
					}
					if (!n$1) for (const [e$1, i$2] of s$1) {
						const { handler: o$2, target: s$2 } = i$2;
						if (!s$2 && !1 !== o$2(new Nl(t$1, e$1, i$2, null))) break;
					}
				}
			}
			function jl(t$1, i$1) {
				if (Array.isArray(t$1) && Array.isArray(i$1)) {
					const e$1 = new Set(t$1), o$1 = new Set(i$1);
					return e$1.size === o$1.size && t$1.every(((e$2) => o$1.has(e$2)));
				}
				return e.by(t$1, i$1);
			}
			const Gl = {
				center: [0, 0],
				zoom: 0,
				bearing: 0,
				pitch: 0,
				minZoom: -2,
				maxZoom: 22,
				minPitch: 0,
				maxPitch: 85,
				interactive: !0,
				scrollZoom: !0,
				boxZoom: !0,
				dragRotate: !0,
				dragPan: !0,
				keyboard: !0,
				doubleClickZoom: !0,
				touchZoomRotate: !0,
				touchPitch: !0,
				cooperativeGestures: !1,
				performanceMetricsCollection: !0,
				bearingSnap: 7,
				clickTolerance: 3,
				pitchWithRotate: !0,
				hash: !1,
				attributionControl: !0,
				antialias: !1,
				failIfMajorPerformanceCaveat: !1,
				preserveDrawingBuffer: !1,
				trackResize: !0,
				renderWorldCopies: !0,
				refreshExpiredTiles: !0,
				minTileCacheSize: null,
				maxTileCacheSize: null,
				localIdeographFontFamily: "sans-serif",
				localFontFamily: null,
				transformRequest: null,
				accessToken: null,
				fadeDuration: 300,
				respectPrefersReducedMotion: !0,
				crossSourceCollisions: !0,
				collectResourceTiming: !1,
				testMode: !1,
				precompilePrograms: !0,
				scaleFactor: 1,
				spriteFormat: "auto"
			}, Vl = {
				showCompass: !0,
				showZoom: !0,
				visualizePitch: !1
			};
			class Hl {
				constructor(t$1, i$1, o$1 = !1) {
					this._clickTolerance = 10, this.element = i$1, this.mouseRotate = new ol({ clickTolerance: t$1.dragRotate._mouseRotate._clickTolerance }), this.map = t$1, o$1 && (this.mousePitch = new sl({ clickTolerance: t$1.dragRotate._mousePitch._clickTolerance })), e.aY([
						"mousedown",
						"mousemove",
						"mouseup",
						"touchstart",
						"touchmove",
						"touchend",
						"reset"
					], this), i$1.addEventListener("mousedown", this.mousedown), i$1.addEventListener("touchstart", this.touchstart, { passive: !1 }), i$1.addEventListener("touchmove", this.touchmove), i$1.addEventListener("touchend", this.touchend), i$1.addEventListener("touchcancel", this.reset);
				}
				down(e$1, t$1) {
					this.mouseRotate.mousedown(e$1, t$1), this.mousePitch && this.mousePitch.mousedown(e$1, t$1), _();
				}
				move(e$1, t$1) {
					const i$1 = this.map, o$1 = this.mouseRotate.mousemoveWindow(e$1, t$1), s$1 = o$1 && o$1.bearingDelta;
					if (s$1 && i$1.setBearing(i$1.getBearing() + s$1), this.mousePitch) {
						const o$2 = this.mousePitch.mousemoveWindow(e$1, t$1), s$2 = o$2 && o$2.pitchDelta;
						s$2 && i$1.setPitch(i$1.getPitch() + s$2);
					}
				}
				off() {
					const e$1 = this.element;
					e$1.removeEventListener("mousedown", this.mousedown), e$1.removeEventListener("touchstart", this.touchstart), e$1.removeEventListener("touchmove", this.touchmove), e$1.removeEventListener("touchend", this.touchend), e$1.removeEventListener("touchcancel", this.reset), this.offTemp();
				}
				offTemp() {
					p(), window.removeEventListener("mousemove", this.mousemove), window.removeEventListener("mouseup", this.mouseup);
				}
				mousedown(e$1) {
					this.down(Object.assign({}, e$1, {
						ctrlKey: !0,
						preventDefault: () => e$1.preventDefault()
					}), g(this.element, e$1)), window.addEventListener("mousemove", this.mousemove), window.addEventListener("mouseup", this.mouseup);
				}
				mousemove(e$1) {
					this.move(e$1, g(this.element, e$1));
				}
				mouseup(e$1) {
					this.mouseRotate.mouseupWindow(e$1), this.mousePitch && this.mousePitch.mouseupWindow(e$1), this.offTemp();
				}
				touchstart(e$1) {
					1 !== e$1.targetTouches.length ? this.reset() : (this._startPos = this._lastPos = v(this.element, e$1.targetTouches)[0], this.down({
						type: "mousedown",
						button: 0,
						ctrlKey: !0,
						preventDefault: () => e$1.preventDefault()
					}, this._startPos));
				}
				touchmove(e$1) {
					1 !== e$1.targetTouches.length ? this.reset() : (this._lastPos = v(this.element, e$1.targetTouches)[0], this.move({ preventDefault: () => e$1.preventDefault() }, this._lastPos));
				}
				touchend(e$1) {
					0 === e$1.targetTouches.length && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), this.reset();
				}
				reset() {
					this.mouseRotate.reset(), this.mousePitch && this.mousePitch.reset(), delete this._startPos, delete this._lastPos, this.offTemp();
				}
			}
			function ql(t$1, i$1, o$1) {
				if (t$1 = new e.aT(t$1.lng, t$1.lat), i$1) {
					const s$1 = new e.aT(t$1.lng - 360, t$1.lat), r$1 = new e.aT(t$1.lng + 360, t$1.lat), n$1 = 360 * Math.ceil(Math.abs(t$1.lng - o$1.center.lng) / 360), a$1 = o$1.locationPoint3D(t$1).distSqr(i$1), l$1 = i$1.x < 0 || i$1.y < 0 || i$1.x > o$1.width || i$1.y > o$1.height;
					o$1.locationPoint3D(s$1).distSqr(i$1) < a$1 && (l$1 || Math.abs(s$1.lng - o$1.center.lng) < n$1) ? t$1 = s$1 : o$1.locationPoint3D(r$1).distSqr(i$1) < a$1 && (l$1 || Math.abs(r$1.lng - o$1.center.lng) < n$1) && (t$1 = r$1);
				}
				for (; Math.abs(t$1.lng - o$1.center.lng) > 180;) {
					const e$1 = o$1.locationPoint3D(t$1);
					if (e$1.x >= 0 && e$1.y >= 0 && e$1.x <= o$1.width && e$1.y <= o$1.height) break;
					t$1.lng > o$1.center.lng ? t$1.lng -= 360 : t$1.lng += 360;
				}
				return t$1;
			}
			const Zl = {
				center: "translate(-50%,-50%)",
				top: "translate(-50%,0)",
				"top-left": "translate(0,0)",
				"top-right": "translate(-100%,0)",
				bottom: "translate(-50%,-100%)",
				"bottom-left": "translate(0,-100%)",
				"bottom-right": "translate(-100%,-100%)",
				left: "translate(0,-50%)",
				right: "translate(-100%,-50%)"
			}, Wl = {
				rotation: 0,
				rotationAlignment: "auto",
				pitchAlignment: "auto",
				occludedOpacity: .2,
				altitude: 0
			};
			class $l extends e.E {
				constructor(t$1, i$1) {
					super(), (t$1 instanceof HTMLElement || i$1) && (t$1 = Object.assign({ element: t$1 }, i$1)), e.aY([
						"_update",
						"_onMove",
						"_onUp",
						"_addDragHandler",
						"_onMapClick",
						"_onKeyPress",
						"_clearFadeTimer"
					], this);
					const { anchor: o$1 = "center", color: s$1 = "#3FB1CE", scale: r$1 = 1, draggable: n$1 = !1, clickTolerance: a$1 = 0, rotation: l$1 = Wl.rotation, rotationAlignment: c$1 = Wl.rotationAlignment, pitchAlignment: h$1 = Wl.pitchAlignment, occludedOpacity: d$1 = Wl.occludedOpacity, altitude: u$1 = Wl.altitude } = t$1 || {};
					this._anchor = o$1, this._color = s$1, this._scale = r$1, this._draggable = n$1, this._clickTolerance = a$1, this._rotation = l$1, this._rotationAlignment = c$1, this._pitchAlignment = h$1, this._occludedOpacity = d$1, this._altitude = u$1, this._state = "inactive", this._isDragging = !1, this._updateMoving = () => this._update(!0), t$1 && t$1.element ? (this._element = t$1.element, this._offset = e.P.convert(t$1 && t$1.offset || [0, 0])) : (this._defaultMarker = !0, this._element = this._createDefaultMarker(), this._offset = e.P.convert(t$1 && t$1.offset || [0, -14])), this._element.hasAttribute("aria-label") || this._element.setAttribute("aria-label", "Map marker"), this._element.hasAttribute("role") || this._element.setAttribute("role", "img"), this._element.classList.add("mapboxgl-marker"), this._element.addEventListener("dragstart", ((e$1) => {
						e$1.preventDefault();
					})), this._element.addEventListener("mousedown", ((e$1) => {
						e$1.preventDefault();
					}));
					const _$1 = this._element.classList;
					for (const e$1 in Zl) _$1.remove(`mapboxgl-marker-anchor-${e$1}`);
					_$1.add(`mapboxgl-marker-anchor-${this._anchor}`);
					const p$1 = t$1 && t$1.className ? t$1.className.trim().split(/\s+/) : [];
					_$1.add(...p$1), this._popup = null;
				}
				_createDefaultMarker() {
					const e$1 = l("div"), t$1 = c("svg", {
						display: "block",
						height: 41 * this._scale + "px",
						width: 27 * this._scale + "px",
						viewBox: "0 0 27 41"
					}, e$1);
					if (0 === this._altitude) {
						const e$2 = c("radialGradient", { id: "shadowGradient" }, c("defs", {}, t$1));
						c("stop", {
							offset: "10%",
							"stop-opacity": .4
						}, e$2), c("stop", {
							offset: "100%",
							"stop-opacity": .05
						}, e$2), c("ellipse", {
							cx: 13.5,
							cy: 34.8,
							rx: 10.5,
							ry: 5.25,
							fill: "url(#shadowGradient)"
						}, t$1);
					}
					return c("path", {
						fill: this._color,
						d: "M27,13.5C27,19.07 20.25,27 14.75,34.5C14.02,35.5 12.98,35.5 12.25,34.5C6.75,27 0,19.22 0,13.5C0,6.04 6.04,0 13.5,0C20.96,0 27,6.04 27,13.5Z"
					}, t$1), c("path", {
						opacity: .25,
						d: "M13.5,0C6.04,0 0,6.04 0,13.5C0,19.22 6.75,27 12.25,34.5C13,35.52 14.02,35.5 14.75,34.5C20.25,27 27,19.07 27,13.5C27,6.04 20.96,0 13.5,0ZM13.5,1C20.42,1 26,6.58 26,13.5C26,15.9 24.5,19.18 22.22,22.74C19.95,26.3 16.71,30.14 13.94,33.91C13.74,34.18 13.61,34.32 13.5,34.44C13.39,34.32 13.26,34.18 13.06,33.91C10.28,30.13 7.41,26.31 5.02,22.77C2.62,19.23 1,15.95 1,13.5C1,6.58 6.58,1 13.5,1Z"
					}, t$1), c("circle", {
						fill: "white",
						cx: 13.5,
						cy: 13.5,
						r: 5.5
					}, t$1), e$1;
				}
				addTo(e$1) {
					return e$1 === this._map || (this.remove(), this._map = e$1, e$1.getCanvasContainer().appendChild(this._element), e$1.on("move", this._updateMoving), e$1.on("moveend", this._update), e$1.on("remove", this._clearFadeTimer), e$1._addMarker(this), this.setDraggable(this._draggable), this._update(), e$1.on("click", this._onMapClick)), this;
				}
				remove() {
					const e$1 = this._map;
					return e$1 && (e$1.off("click", this._onMapClick), e$1.off("move", this._updateMoving), e$1.off("moveend", this._update), e$1.off("mousedown", this._addDragHandler), e$1.off("touchstart", this._addDragHandler), e$1.off("mouseup", this._onUp), e$1.off("touchend", this._onUp), e$1.off("mousemove", this._onMove), e$1.off("touchmove", this._onMove), e$1.off("remove", this._clearFadeTimer), e$1._removeMarker(this), this._map = void 0), this._clearFadeTimer(), this._element.remove(), this._popup && this._popup.remove(), this;
				}
				getLngLat() {
					return this._lngLat;
				}
				setLngLat(t$1) {
					return this._lngLat = e.aT.convert(t$1), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(!0), this;
				}
				setAltitude(e$1) {
					return e$1 === this._altitude || (this._defaultMarker && (0 === this._altitude && 0 !== e$1 || 0 !== this._altitude && 0 === e$1) && (this._element = this._createDefaultMarker()), this._altitude = e$1 || Wl.altitude, this._update()), this;
				}
				getAltitude() {
					return this._altitude;
				}
				getElement() {
					return this._element;
				}
				setPopup(e$1) {
					if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeAttribute("role"), this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), e$1) {
						if (!("offset" in e$1.options)) {
							const t$1 = 38.1, i$1 = 13.5, o$1 = Math.sqrt(Math.pow(i$1, 2) / 2);
							e$1.options.offset = this._defaultMarker ? {
								top: [0, 0],
								"top-left": [0, 0],
								"top-right": [0, 0],
								bottom: [0, -t$1],
								"bottom-left": [o$1, -1 * (t$1 - i$1 + o$1)],
								"bottom-right": [-o$1, -1 * (t$1 - i$1 + o$1)],
								left: [i$1, -1 * (t$1 - i$1)],
								right: [-i$1, -1 * (t$1 - i$1)]
							} : this._offset;
						}
						this._popup = e$1, e$1._marker = this, e$1._altitude = this._altitude, this._lngLat && this._popup.setLngLat(this._lngLat), this._element.setAttribute("role", "button"), this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress), this._element.setAttribute("aria-expanded", "false");
					}
					return this;
				}
				_onKeyPress(e$1) {
					const t$1 = e$1.code, i$1 = e$1.charCode || e$1.keyCode;
					"Space" !== t$1 && "Enter" !== t$1 && 32 !== i$1 && 13 !== i$1 || this.togglePopup();
				}
				_onMapClick(e$1) {
					const t$1 = e$1.originalEvent.target, i$1 = this._element;
					this._popup && (t$1 === i$1 || i$1.contains(t$1)) && this.togglePopup();
				}
				getPopup() {
					return this._popup;
				}
				togglePopup() {
					const e$1 = this._popup;
					return e$1 ? (e$1.isOpen() ? (e$1.remove(), this._element.setAttribute("aria-expanded", "false")) : this._map && (e$1.addTo(this._map), this._element.setAttribute("aria-expanded", "true")), this) : this;
				}
				_behindTerrain() {
					const e$1 = this._map, t$1 = this._pos;
					if (!e$1 || !t$1) return !1;
					const i$1 = e$1.unproject(t$1, this._altitude), o$1 = e$1.getFreeCameraOptions();
					if (!o$1.position) return !1;
					const s$1 = o$1.position.toLngLat();
					return s$1.distanceTo(i$1) < .9 * s$1.distanceTo(this._lngLat);
				}
				_evaluateOpacity() {
					const t$1 = this._map;
					if (!t$1) return;
					const i$1 = this._pos;
					if (!i$1 || i$1.x < 0 || i$1.x > t$1.transform.width || i$1.y < 0 || i$1.y > t$1.transform.height) return void this._clearFadeTimer();
					const o$1 = t$1.unproject(i$1, this._altitude);
					let s$1;
					t$1._showingGlobe() && e.f5(t$1.transform, this._lngLat) ? s$1 = 0 : (s$1 = 1 - t$1._queryFogOpacity(o$1), t$1.transform._terrainEnabled() && t$1.getTerrain() && this._behindTerrain() && (s$1 *= this._occludedOpacity)), this._element.style.opacity = `${s$1}`, this._element.style.pointerEvents = s$1 > 0 ? "auto" : "none", this._popup && this._popup._setOpacity(s$1), this._fadeTimer = null;
				}
				_clearFadeTimer() {
					this._fadeTimer && (clearTimeout(this._fadeTimer), this._fadeTimer = null);
				}
				_updateDOM() {
					const e$1 = this._pos;
					if (!e$1 || !this._map) return;
					const t$1 = this._offset.mult(this._scale);
					this._element.style.transform = `\n            translate(${e$1.x}px,${e$1.y}px)\n            ${Zl[this._anchor]}\n            ${this._calculateXYTransform()} ${this._calculateZTransform()}\n            translate(${t$1.x}px,${t$1.y}px)\n        `;
				}
				_calculateXYTransform() {
					const t$1 = this._pos, i$1 = this._map, o$1 = this.getPitchAlignment();
					if (!i$1 || !t$1 || "map" !== o$1) return "";
					if (!i$1._showingGlobe()) {
						const e$1 = i$1.getPitch();
						return e$1 ? `rotateX(${e$1}deg)` : "";
					}
					const s$1 = e.cX(e.f6(i$1.transform, this._lngLat)), r$1 = t$1.sub(e.f7(i$1.transform)), n$1 = Math.abs(r$1.x) + Math.abs(r$1.y);
					if (0 === n$1) return "";
					const a$1 = s$1 / n$1;
					return `rotateX(${-r$1.y * a$1}deg) rotateY(${r$1.x * a$1}deg)`;
				}
				_calculateZTransform() {
					const t$1 = this._pos, i$1 = this._map;
					if (!i$1 || !t$1) return "";
					let o$1 = 0;
					const s$1 = this.getRotationAlignment();
					if ("map" === s$1) if (i$1._showingGlobe()) {
						const t$2 = i$1.project(new e.aT(this._lngLat.lng, this._lngLat.lat + .001), this._altitude), s$2 = i$1.project(new e.aT(this._lngLat.lng, this._lngLat.lat - .001), this._altitude).sub(t$2);
						o$1 = e.cX(Math.atan2(s$2.y, s$2.x)) - 90;
					} else o$1 = -i$1.getBearing();
					else if ("horizon" === s$1) {
						const s$2 = e.ah(4, 6, i$1.getZoom()), r$1 = e.f7(i$1.transform);
						r$1.y += s$2 * i$1.transform.height;
						const n$1 = t$1.sub(r$1), a$1 = e.cX(Math.atan2(n$1.y, n$1.x));
						o$1 = (a$1 > 90 ? a$1 - 270 : a$1 + 90) * (1 - s$2);
					}
					return o$1 += this._rotation, o$1 ? `rotateZ(${o$1}deg)` : "";
				}
				_update(e$1) {
					cancelAnimationFrame(this._updateFrameId);
					const t$1 = this._map;
					t$1 && (t$1.transform.renderWorldCopies && (this._lngLat = ql(this._lngLat, this._pos, t$1.transform)), this._pos = t$1.project(this._lngLat, this._altitude), !0 === e$1 ? this._updateFrameId = requestAnimationFrame((() => {
						this._element && this._pos && this._anchor && (this._pos = this._pos.round(), this._updateDOM());
					})) : this._pos = this._pos.round(), t$1._requestDomTask((() => {
						this._map && (this._element && this._pos && this._anchor && this._updateDOM(), (t$1._showingGlobe() || t$1.getTerrain() || t$1.getFog()) && !this._fadeTimer && (this._fadeTimer = window.setTimeout(this._evaluateOpacity.bind(this), 60)));
					})));
				}
				getOffset() {
					return this._offset;
				}
				setOffset(t$1) {
					return this._offset = e.P.convert(t$1), this._update(), this;
				}
				addClassName(e$1) {
					return this._element.classList.add(e$1), this;
				}
				removeClassName(e$1) {
					return this._element.classList.remove(e$1), this;
				}
				toggleClassName(e$1) {
					return this._element.classList.toggle(e$1);
				}
				_onMove(t$1) {
					const i$1 = this._map;
					if (!i$1) return;
					const o$1 = this._pointerdownPos, s$1 = this._positionDelta;
					if (o$1 && s$1) {
						if (!this._isDragging) {
							const e$1 = this._clickTolerance || i$1._clickTolerance;
							if (t$1.point.dist(o$1) < e$1) return;
							this._isDragging = !0;
						}
						this._pos = t$1.point.sub(s$1), this._lngLat = i$1.unproject(this._pos, this._altitude), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", "pending" === this._state && (this._state = "active", this.fire(new e.z("dragstart"))), this.fire(new e.z("drag"));
					}
				}
				_onUp() {
					this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = !1;
					const t$1 = this._map;
					t$1 && (t$1.off("mousemove", this._onMove), t$1.off("touchmove", this._onMove)), "active" === this._state && this.fire(new e.z("dragend")), this._state = "inactive";
				}
				_addDragHandler(e$1) {
					const t$1 = this._map, i$1 = this._pos;
					t$1 && i$1 && this._element.contains(e$1.originalEvent.target) && (e$1.preventDefault(), this._positionDelta = e$1.point.sub(i$1), this._pointerdownPos = e$1.point, this._state = "pending", t$1.on("mousemove", this._onMove), t$1.on("touchmove", this._onMove), t$1.once("mouseup", this._onUp), t$1.once("touchend", this._onUp));
				}
				setDraggable(e$1) {
					this._draggable = !!e$1;
					const t$1 = this._map;
					return t$1 && (e$1 ? (t$1.on("mousedown", this._addDragHandler), t$1.on("touchstart", this._addDragHandler)) : (t$1.off("mousedown", this._addDragHandler), t$1.off("touchstart", this._addDragHandler))), this;
				}
				isDraggable() {
					return this._draggable;
				}
				setRotation(e$1) {
					return this._rotation = e$1 || Wl.rotation, this._update(), this;
				}
				getRotation() {
					return this._rotation;
				}
				setRotationAlignment(e$1) {
					return this._rotationAlignment = e$1 || Wl.rotationAlignment, this._update(), this;
				}
				getRotationAlignment() {
					return "auto" === this._rotationAlignment || "horizon" === this._rotationAlignment && this._map && !this._map._showingGlobe() ? "viewport" : this._rotationAlignment;
				}
				setPitchAlignment(e$1) {
					return this._pitchAlignment = e$1 || Wl.pitchAlignment, this._update(), this;
				}
				getPitchAlignment() {
					return "auto" === this._pitchAlignment ? this.getRotationAlignment() : this._pitchAlignment;
				}
				setOccludedOpacity(e$1) {
					return this._occludedOpacity = e$1 || Wl.occludedOpacity, this._update(), this;
				}
				getOccludedOpacity() {
					return this._occludedOpacity;
				}
			}
			const Xl = {
				positionOptions: {
					enableHighAccuracy: !1,
					maximumAge: 0,
					timeout: 6e3
				},
				fitBoundsOptions: { maxZoom: 15 },
				trackUserLocation: !1,
				showAccuracyCircle: !0,
				showUserLocation: !0,
				showUserHeading: !1
			}, Yl = {
				maxWidth: 100,
				unit: "metric"
			}, Kl = {
				kilometer: "km",
				meter: "m",
				mile: "mi",
				foot: "ft",
				"nautical-mile": "nm"
			}, Jl = {
				closeButton: !0,
				closeOnClick: !0,
				focusAfterOpen: !0,
				className: "",
				maxWidth: "240px",
				altitude: 0
			}, Ql = [
				"a[href]",
				"[tabindex]:not([tabindex='-1'])",
				"[contenteditable]:not([contenteditable='false'])",
				"button:not([disabled])",
				"input:not([disabled])",
				"select:not([disabled])",
				"textarea:not([disabled])"
			].join(", ");
			function ec(t$1 = new e.P(0, 0), i$1 = "bottom") {
				if ("number" == typeof t$1) {
					const o$1 = Math.round(Math.sqrt(.5 * Math.pow(t$1, 2)));
					switch (i$1) {
						case "top": return new e.P(0, t$1);
						case "top-left": return new e.P(o$1, o$1);
						case "top-right": return new e.P(-o$1, o$1);
						case "bottom": return new e.P(0, -t$1);
						case "bottom-left": return new e.P(o$1, -o$1);
						case "bottom-right": return new e.P(-o$1, -o$1);
						case "left": return new e.P(t$1, 0);
						case "right": return new e.P(-t$1, 0);
					}
					return new e.P(0, 0);
				}
				return t$1 instanceof e.P || Array.isArray(t$1) ? e.P.convert(t$1) : e.P.convert(t$1[i$1] || [0, 0]);
			}
			return {
				version: t,
				supported: a.supported,
				setRTLTextPlugin: e.fb,
				getRTLTextPluginStatus: e.fa,
				Map: class extends Pl {
					constructor(t$1) {
						o.mark(i.create);
						const s$1 = t$1;
						if (null != (t$1 = Object.assign({}, Gl, t$1)).minZoom && null != t$1.maxZoom && t$1.minZoom > t$1.maxZoom) throw new Error("maxZoom must be greater than or equal to minZoom");
						if (null != t$1.minPitch && null != t$1.maxPitch && t$1.minPitch > t$1.maxPitch) throw new Error("maxPitch must be greater than or equal to minPitch");
						if (null != t$1.minPitch && t$1.minPitch < 0) throw new Error("minPitch must be greater than or equal to 0");
						if (null != t$1.maxPitch && t$1.maxPitch > 85) throw new Error("maxPitch must be less than or equal to 85");
						if (t$1.antialias && e.f3(window) && (t$1.antialias = !1, e.w("Antialiasing is disabled for this WebGL context to avoid browser bug: https://github.com/mapbox/mapbox-gl-js/issues/11609")), super(new co(t$1.minZoom, t$1.maxZoom, t$1.minPitch, t$1.maxPitch, t$1.renderWorldCopies, null, null), t$1), this._repaint = !!t$1.repaint, this._interactive = t$1.interactive, this._minTileCacheSize = t$1.minTileCacheSize, this._maxTileCacheSize = t$1.maxTileCacheSize, this._failIfMajorPerformanceCaveat = t$1.failIfMajorPerformanceCaveat, this._preserveDrawingBuffer = t$1.preserveDrawingBuffer, this._antialias = t$1.antialias, this._trackResize = t$1.trackResize, this._bearingSnap = t$1.bearingSnap, this._refreshExpiredTiles = t$1.refreshExpiredTiles, this._fadeDuration = t$1.fadeDuration, this._isInitialLoad = !0, this._crossSourceCollisions = t$1.crossSourceCollisions, this._collectResourceTiming = t$1.collectResourceTiming, this._language = this._parseLanguage(t$1.language), this._worldview = t$1.worldview, this._renderTaskQueue = new Fl(), this._domRenderTaskQueue = new Fl(), this._controls = [], this._markers = [], this._popups = [], this._mapId = e.b2(), this._locale = Object.assign({}, kl, t$1.locale), this._clickTolerance = t$1.clickTolerance, this._cooperativeGestures = t$1.cooperativeGestures, this._performanceMetricsCollection = t$1.performanceMetricsCollection, this._tessellationStep = t$1.tessellationStep, this._containerWidth = 0, this._containerHeight = 0, this._showParseStatus = !0, this._precompilePrograms = t$1.precompilePrograms, this._scaleFactorChanged = !1, this._averageElevationLastSampledAt = -Infinity, this._averageElevationExaggeration = 0, this._averageElevation = new Bl(0), this._interactionRange = [Infinity, -Infinity], this._visibilityHidden = 0, this._useExplicitProjection = !1, this._frameId = 0, this._scaleFactor = t$1.scaleFactor, this._requestManager = new T(t$1.transformRequest, t$1.accessToken, t$1.testMode), this._silenceAuthErrors = !!t$1.testMode, this._contextCreateOptions = t$1.contextCreateOptions ? Object.assign({}, t$1.contextCreateOptions) : {}, "string" == typeof t$1.container) {
							const e$1 = document.getElementById(t$1.container);
							if (!e$1) throw new Error(`Container '${t$1.container.toString()}' not found.`);
							this._container = e$1;
						} else {
							if (!(t$1.container instanceof HTMLElement)) throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
							this._container = t$1.container;
						}
						if (this._container.childNodes.length > 0 && e.w("The map container element should be empty, otherwise the map's interactivity will be negatively impacted. If you want to display a message when WebGL is not supported, use the Mapbox GL Supported plugin instead."), t$1.maxBounds && this.setMaxBounds(t$1.maxBounds), this._spriteFormat = t$1.spriteFormat, e.aY([
							"_onWindowOnline",
							"_onWindowResize",
							"_onVisibilityChange",
							"_onMapScroll",
							"_contextLost",
							"_contextRestored"
						], this), this._setupContainer(), this._setupPainter(), void 0 === this.painter) throw new Error("Failed to initialize WebGL.");
						if (this.on("move", (() => this._update(!1))), this.on("moveend", (() => this._update(!1))), this.on("zoom", (() => this._update(!0))), this._fullscreenchangeEvent = "onfullscreenchange" in document ? "fullscreenchange" : "webkitfullscreenchange", window.addEventListener("online", this._onWindowOnline, !1), window.addEventListener("resize", this._onWindowResize, !1), window.addEventListener("orientationchange", this._onWindowResize, !1), window.addEventListener(this._fullscreenchangeEvent, this._onWindowResize, !1), window.addEventListener("visibilitychange", this._onVisibilityChange, !1), this.handlers = new Ll(this, t$1), this._localFontFamily = t$1.localFontFamily, this._localIdeographFontFamily = t$1.localIdeographFontFamily, (t$1.style || !t$1.testMode) && this.setStyle(t$1.style || e.e.DEFAULT_STYLE, {
							config: t$1.config,
							localFontFamily: this._localFontFamily,
							localIdeographFontFamily: this._localIdeographFontFamily
						}), t$1.projection && this.setProjection(t$1.projection), t$1.hash && (this._hash = new Oa("string" == typeof t$1.hash && t$1.hash || void 0).addTo(this)), !this._hash || !this._hash._onHashChange()) {
							null == s$1.center && null == s$1.zoom || (this.transform._unmodified = !1), this.jumpTo({
								center: t$1.center,
								zoom: t$1.zoom,
								bearing: t$1.bearing,
								pitch: t$1.pitch
							});
							const e$1 = t$1.bounds;
							e$1 && (this.resize(), this.fitBounds(e$1, Object.assign({}, t$1.fitBoundsOptions, { duration: 0 })));
						}
						this.resize(), t$1.attributionControl && this.addControl(new Ol({ customAttribution: t$1.customAttribution })), this._logoControl = new zl(), this.addControl(this._logoControl, t$1.logoPosition), this.on("style.load", (() => {
							this.transform.unmodified && this.jumpTo(this.style.stylesheet), this._postStyleLoadEvent(), this._postStyleWithAppearanceEvent(), this._setupIndoor();
						})), this.on("data", ((t$2) => {
							this._update("style" === t$2.dataType), this.fire(new e.z(`${t$2.dataType}data`, t$2));
						})), this.on("dataloading", ((t$2) => {
							this.fire(new e.z(`${t$2.dataType}dataloading`, t$2));
						})), this._interactions = new Ul(this);
					}
					_getMapId() {
						return this._mapId;
					}
					addControl(t$1, i$1) {
						if (void 0 === i$1 && (i$1 = t$1.getDefaultPosition ? t$1.getDefaultPosition() : "top-right"), !t$1 || !t$1.onAdd) return this.fire(new e.y(/* @__PURE__ */ new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
						const o$1 = t$1.onAdd(this);
						this._controls.push(t$1);
						const s$1 = this._controlPositions[i$1];
						return -1 !== i$1.indexOf("bottom") ? s$1.insertBefore(o$1, s$1.firstChild) : s$1.appendChild(o$1), this;
					}
					removeControl(t$1) {
						if (!t$1 || !t$1.onRemove) return this.fire(new e.y(/* @__PURE__ */ new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
						const i$1 = this._controls.indexOf(t$1);
						return i$1 > -1 && this._controls.splice(i$1, 1), t$1.onRemove(this), this;
					}
					hasControl(e$1) {
						return this._controls.indexOf(e$1) > -1;
					}
					getContainer() {
						return this._container;
					}
					getCanvasContainer() {
						return this._canvasContainer;
					}
					getCanvas() {
						return this._canvas;
					}
					resize(t$1) {
						if (this._updateContainerDimensions(), this._containerWidth === this.transform.width && this._containerHeight === this.transform.height) return this;
						this._resizeCanvas(this._containerWidth, this._containerHeight), this.transform.resize(this._containerWidth, this._containerHeight), this.painter.resize(Math.ceil(this._containerWidth), Math.ceil(this._containerHeight));
						const i$1 = !this._moving;
						return i$1 && this.fire(new e.z("movestart", t$1)).fire(new e.z("move", t$1)), this.fire(new e.z("resize", t$1)), i$1 && this.fire(new e.z("moveend", t$1)), this;
					}
					getBounds() {
						return this.transform.getBounds();
					}
					getMaxBounds() {
						return this.transform.getMaxBounds() || null;
					}
					setMaxBounds(t$1) {
						return this.transform.setMaxBounds(e.aI.convert(t$1)), this._update();
					}
					setMinZoom(t$1) {
						if ((t$1 = t$1 ?? -2) >= -2 && t$1 <= this.transform.maxZoom) return this.transform.minZoom = t$1, this._update(), this.getZoom() < t$1 ? this.setZoom(t$1) : this.fire(new e.z("zoomstart")).fire(new e.z("zoom")).fire(new e.z("zoomend")), this;
						throw new Error("minZoom must be between -2 and the current maxZoom, inclusive");
					}
					getMinZoom() {
						return this.transform.minZoom;
					}
					setMaxZoom(t$1) {
						if ((t$1 = t$1 ?? 22) >= this.transform.minZoom) return this.transform.maxZoom = t$1, this._update(), this.getZoom() > t$1 ? this.setZoom(t$1) : this.fire(new e.z("zoomstart")).fire(new e.z("zoom")).fire(new e.z("zoomend")), this;
						throw new Error("maxZoom must be greater than the current minZoom");
					}
					getMaxZoom() {
						return this.transform.maxZoom;
					}
					setMinPitch(t$1) {
						if ((t$1 = t$1 ?? 0) < 0) throw new Error("minPitch must be greater than or equal to 0");
						if (t$1 >= 0 && t$1 <= this.transform.maxPitch) return this.transform.minPitch = t$1, this._update(), this.getPitch() < t$1 ? this.setPitch(t$1) : this.fire(new e.z("pitchstart")).fire(new e.z("pitch")).fire(new e.z("pitchend")), this;
						throw new Error("minPitch must be between 0 and the current maxPitch, inclusive");
					}
					getMinPitch() {
						return this.transform.minPitch;
					}
					setMaxPitch(t$1) {
						if ((t$1 = t$1 ?? 85) > 85) throw new Error("maxPitch must be less than or equal to 85");
						if (t$1 >= this.transform.minPitch) return this.transform.maxPitch = t$1, this._update(), this.getPitch() > t$1 ? this.setPitch(t$1) : this.fire(new e.z("pitchstart")).fire(new e.z("pitch")).fire(new e.z("pitchend")), this;
						throw new Error("maxPitch must be greater than or equal to minPitch");
					}
					getMaxPitch() {
						return this.transform.maxPitch;
					}
					getScaleFactor() {
						return this._scaleFactor;
					}
					setScaleFactor(e$1) {
						return this._scaleFactor = e$1, this.painter.scaleFactor = e$1, this._scaleFactorChanged = !0, this.style._updateFilteredLayers(((e$2) => "symbol" === e$2.type)), this._update(!0), this;
					}
					getRenderWorldCopies() {
						return this.transform.renderWorldCopies;
					}
					setRenderWorldCopies(e$1) {
						return this.transform.renderWorldCopies = e$1, this.transform.renderWorldCopies || this._forceMarkerAndPopupUpdate(!0), this._update();
					}
					getLanguage() {
						return this._language;
					}
					_parseLanguage(e$1) {
						return "auto" === e$1 ? navigator.language : Array.isArray(e$1) ? 0 === e$1.length ? void 0 : e$1.map(((e$2) => "auto" === e$2 ? navigator.language : e$2)) : e$1;
					}
					setLanguage(e$1) {
						const t$1 = this._parseLanguage(e$1);
						if (!this.style || t$1 === this._language) return this;
						this._language = t$1, this.style.reloadSources();
						for (const e$2 of this._controls) e$2._setLanguage && e$2._setLanguage(this._language);
						return this;
					}
					getWorldview() {
						return this._worldview;
					}
					setWorldview(e$1) {
						return this.style && e$1 !== this._worldview ? (this._worldview = e$1, this._styleDirty = !0, this.style.reloadSources(), this) : this;
					}
					getProjection() {
						return this.transform.mercatorFromTransition ? {
							name: "globe",
							center: [0, 0]
						} : this.transform.getProjection();
					}
					_showingGlobe() {
						return "globe" === this.transform.projection.name;
					}
					setProjection(e$1) {
						return this._lazyInitEmptyStyle(), e$1 ? "string" == typeof e$1 && (e$1 = { name: e$1 }) : e$1 = null, this._useExplicitProjection = !!e$1, this._prioritizeAndUpdateProjection(e$1, this.style.projection);
					}
					_updateProjectionTransition() {
						if ("globe" !== this.getProjection().name) return;
						const t$1 = this.transform, i$1 = t$1.projection.name;
						let o$1;
						"globe" === i$1 && t$1.zoom >= e.cL ? (t$1.setMercatorFromTransition(), o$1 = !0) : "mercator" === i$1 && t$1.zoom < e.cL && (t$1.setProjection({ name: "globe" }), o$1 = !0), o$1 && (this.style.applyProjectionUpdate(), this.style._forceSymbolLayerUpdate(), this._update(!0));
					}
					_prioritizeAndUpdateProjection(e$1, t$1) {
						return this._updateProjection(e$1 || t$1 || { name: "mercator" });
					}
					_updateProjection(t$1) {
						let i$1;
						const o$1 = this.transform.mercatorFromTransition;
						i$1 = "globe" === t$1.name && this.transform.zoom >= e.cL ? this.transform.setMercatorFromTransition() : this.transform.setProjection(t$1), this.style.applyProjectionUpdate();
						const s$1 = "mercator" === this.transform.getProjection().name && o$1 !== this.transform.mercatorFromTransition;
						return (i$1 || s$1) && (this.painter.clearBackgroundTiles(), this.style.clearSources(), this._update(!0), this._forceMarkerAndPopupUpdate(!0)), this;
					}
					project(t$1, i$1) {
						return this.transform.locationPoint3D(e.aT.convert(t$1), i$1);
					}
					unproject(t$1, i$1) {
						return this.transform.pointLocation3D(e.P.convert(t$1), i$1);
					}
					isMoving() {
						return this._moving || this.handlers && this.handlers.isMoving() || !1;
					}
					isZooming() {
						return this._zooming || this.handlers && this.handlers.isZooming() || !1;
					}
					isRotating() {
						return this._rotating || this.handlers && this.handlers.isRotating() || !1;
					}
					_isDragging() {
						return this.handlers && this.handlers._isDragging() || !1;
					}
					_createDelegatedListener(e$1, t$1, i$1) {
						const o$1 = (e$2) => {
							let i$2 = [];
							if (Array.isArray(t$1)) {
								const o$2 = t$1.filter(((e$3) => this.getLayer(e$3)));
								i$2 = o$2.length ? this.queryRenderedFeatures(e$2, { layers: o$2 }) : [];
							} else i$2 = this.queryRenderedFeatures(e$2, { target: t$1 });
							return i$2;
						};
						if ("mouseenter" === e$1 || "mouseover" === e$1) {
							let s$1 = !1;
							const r$1 = (t$2) => {
								const r$2 = o$1(t$2.point);
								r$2.length ? s$1 || (s$1 = !0, i$1.call(this, new Va(e$1, this, t$2.originalEvent, { features: r$2 }))) : s$1 = !1;
							};
							return {
								listener: i$1,
								targets: t$1,
								delegates: {
									mousemove: r$1,
									mouseout: () => {
										s$1 = !1;
									}
								}
							};
						}
						if ("mouseleave" === e$1 || "mouseout" === e$1) {
							let s$1 = !1;
							const r$1 = (t$2) => {
								o$1(t$2.point).length ? s$1 = !0 : s$1 && (s$1 = !1, i$1.call(this, new Va(e$1, this, t$2.originalEvent)));
							}, n$1 = (t$2) => {
								s$1 && (s$1 = !1, i$1.call(this, new Va(e$1, this, t$2.originalEvent)));
							};
							return {
								listener: i$1,
								targets: t$1,
								delegates: {
									mousemove: r$1,
									mouseout: n$1
								}
							};
						}
						{
							const s$1 = (e$2) => {
								const t$2 = o$1(e$2.point);
								t$2.length && (e$2.features = t$2, i$1.call(this, e$2), delete e$2.features);
							};
							return {
								listener: i$1,
								targets: t$1,
								delegates: { [e$1]: s$1 }
							};
						}
					}
					on(e$1, t$1, i$1) {
						if ("function" == typeof t$1 || void 0 === i$1) return super.on(e$1, t$1);
						if ("string" == typeof t$1 && (t$1 = [t$1]), !this._areTargetsValid(t$1)) return this;
						const o$1 = this._createDelegatedListener(e$1, t$1, i$1);
						this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[e$1] = this._delegatedListeners[e$1] || [], this._delegatedListeners[e$1].push(o$1);
						for (const e$2 in o$1.delegates) this.on(e$2, o$1.delegates[e$2]);
						return this;
					}
					once(e$1, t$1, i$1) {
						if ("function" == typeof t$1 || void 0 === i$1) return super.once(e$1, t$1);
						if ("string" == typeof t$1 && (t$1 = [t$1]), !this._areTargetsValid(t$1)) return this;
						const o$1 = this._createDelegatedListener(e$1, t$1, i$1);
						for (const e$2 in o$1.delegates) this.once(e$2, o$1.delegates[e$2]);
						return this;
					}
					off(e$1, t$1, i$1) {
						if ("function" == typeof t$1 || void 0 === i$1) return super.off(e$1, t$1);
						if ("string" == typeof t$1 && (t$1 = [t$1]), !this._areTargetsValid(t$1)) return this;
						const o$1 = this._delegatedListeners ? this._delegatedListeners[e$1] : void 0;
						return o$1 && ((e$2) => {
							for (let o$2 = 0; o$2 < e$2.length; o$2++) {
								const s$1 = e$2[o$2];
								if (s$1.listener === i$1 && jl(s$1.targets, t$1)) {
									for (const e$3 in s$1.delegates) this.off(e$3, s$1.delegates[e$3]);
									return e$2.splice(o$2, 1), this;
								}
							}
						})(o$1), this;
					}
					queryRenderedFeatures(t$1, i$1) {
						if (!this.style) return [];
						if (void 0 === t$1 || t$1 instanceof e.P || Array.isArray(t$1) || void 0 !== i$1 || (i$1 = t$1, t$1 = void 0), t$1 = t$1 || [[0, 0], [this.transform.width, this.transform.height]], !i$1) {
							const e$1 = this.style.queryRenderedFeatures(t$1, void 0, this.transform), i$2 = this.style.queryRenderedFeatureset(t$1, void 0, this.transform);
							return e$1.concat(i$2);
						}
						let o$1 = !0;
						if (i$1.target && (o$1 = this._isTargetValid(i$1.target), o$1 && !i$1.layers)) return this.style.queryRenderedFeatureset(t$1, i$1, this.transform);
						let s$1 = !0;
						if (i$1.layers && Array.isArray(i$1.layers)) {
							for (const e$1 of i$1.layers) if (!this._isValidId(e$1)) {
								s$1 = !1;
								break;
							}
							if (s$1 && !i$1.target) return this.style.queryRenderedFeatures(t$1, i$1, this.transform);
						}
						let r$1 = [];
						return s$1 && (r$1 = r$1.concat(this.style.queryRenderedFeatures(t$1, i$1, this.transform))), o$1 && (r$1 = r$1.concat(this.style.queryRenderedFeatureset(t$1, i$1, this.transform))), r$1;
					}
					querySourceFeatures(e$1, t$1) {
						return !e$1 || "string" == typeof e$1 && !this._isValidId(e$1) ? [] : this.style.querySourceFeatures(e$1, t$1);
					}
					queryRasterValue(e$1, t$1, i$1) {
						return this._isValidId(e$1) ? this.style.queryRasterValue(e$1, t$1, i$1) : Promise.resolve(null);
					}
					isPointOnSurface(t$1) {
						const { name: i$1 } = this.transform.projection;
						return "globe" !== i$1 && "mercator" !== i$1 && e.w(`${i$1} projection does not support isPointOnSurface, this API may behave unexpectedly.`), this.transform.isPointOnSurface(e.P.convert(t$1));
					}
					addInteraction(e$1, t$1) {
						return this._interactions.add(e$1, t$1), this;
					}
					removeInteraction(e$1) {
						return this._interactions.remove(e$1), this;
					}
					getCooperativeGestures() {
						return this._cooperativeGestures;
					}
					setCooperativeGestures(e$1) {
						return this._cooperativeGestures = e$1, this;
					}
					setStyle(t$1, i$1) {
						return i$1 = Object.assign({}, {
							localIdeographFontFamily: this._localIdeographFontFamily,
							localFontFamily: this._localFontFamily
						}, i$1), this.style && t$1 && !1 !== i$1.diff && i$1.localFontFamily === this._localFontFamily && i$1.localIdeographFontFamily === this._localIdeographFontFamily && !i$1.config ? (this.style._diffStyle(t$1, ((o$1, s$1) => {
							if (o$1) {
								const s$2 = "string" == typeof o$1 ? o$1 : o$1 instanceof Error ? o$1.message : o$1.error;
								e.w(`Unable to perform style diff: ${s$2}. Rebuilding the style from scratch.`), this._updateStyle(t$1, i$1);
							} else s$1 && this._update(!0);
						}), (() => this._postStyleLoadEvent())), this) : (this._localIdeographFontFamily = i$1.localIdeographFontFamily, this._localFontFamily = i$1.localFontFamily, this._updateStyle(t$1, i$1));
					}
					_getUIString(e$1) {
						const t$1 = this._locale[e$1];
						if (null == t$1) throw new Error(`Missing UI string '${e$1}'`);
						return t$1;
					}
					_updateStyle(e$1, t$1) {
						if (this.style && (this.style.setEventedParent(null), this.style._remove(), this.style = void 0), e$1) {
							const i$1 = Object.assign({}, t$1);
							t$1 && t$1.config && (i$1.initialConfig = t$1.config, delete i$1.config), this.style = new Po(this, i$1).load(e$1), this.style.setEventedParent(this, { style: this.style });
						}
						return this._updateTerrain(), this;
					}
					_lazyInitEmptyStyle() {
						this.style || (this.style = new Po(this, {}), this.style.setEventedParent(this, { style: this.style }), this.style.loadEmpty());
					}
					getStyle() {
						if (this.style) return this.style.serialize();
					}
					isStyleLoaded() {
						return this.style ? this.style.loaded() : (e.w("There is no style added to the map."), !1);
					}
					_isValidId(t$1) {
						return null == t$1 ? (this.fire(new e.y(/* @__PURE__ */ new Error("IDs can't be empty."))), !1) : !e.dr(t$1) || (this.fire(new e.y(/* @__PURE__ */ new Error(`IDs can't contain special symbols: "${t$1}".`))), !1);
					}
					_isTargetValid(e$1) {
						return "featuresetId" in e$1 ? this._isValidId("importId" in e$1 ? e$1.importId : e$1.featuresetId) : "layerId" in e$1 && this._isValidId(e$1.layerId);
					}
					_areTargetsValid(e$1) {
						if (Array.isArray(e$1)) {
							for (const t$1 of e$1) if (!this._isValidId(t$1)) return !1;
							return !0;
						}
						return this._isTargetValid(e$1);
					}
					addSource(e$1, t$1) {
						return this._isValidId(e$1) ? (this._lazyInitEmptyStyle(), this.style.addSource(e$1, t$1), this._update(!0)) : this;
					}
					isSourceLoaded(e$1) {
						return !!this._isValidId(e$1) && !!this.style && this.style._isSourceCacheLoaded(e$1);
					}
					areTilesLoaded() {
						return this.style.areTilesLoaded();
					}
					addSourceType(e$1, t$1, i$1) {
						this._lazyInitEmptyStyle(), this.style.addSourceType(e$1, t$1, i$1);
					}
					removeSource(e$1) {
						return this._isValidId(e$1) ? (this.style.removeSource(e$1), this._updateTerrain(), this._update(!0)) : this;
					}
					getSource(e$1) {
						return this._isValidId(e$1) ? this.style.getOwnSource(e$1) : null;
					}
					addImage(t$1, i$1, { pixelRatio: o$1 = 1, sdf: s$1 = !1, stretchX: r$1, stretchY: n$1, content: a$1 } = {}) {
						this._lazyInitEmptyStyle();
						const l$1 = e.I.from(t$1);
						if (i$1 instanceof HTMLImageElement || ImageBitmap && i$1 instanceof ImageBitmap) {
							const { width: t$2, height: c$1, data: h$1 } = e.o.getImageData(i$1);
							this.style.addImage(l$1, {
								data: new e.q({
									width: t$2,
									height: c$1
								}, h$1),
								pixelRatio: o$1,
								stretchX: r$1,
								stretchY: n$1,
								content: a$1,
								sdf: s$1,
								version: 0,
								usvg: !1
							});
						} else if (void 0 === i$1.width || void 0 === i$1.height) this.fire(new e.y(/* @__PURE__ */ new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
						else {
							const { width: c$1, height: h$1 } = i$1, d$1 = i$1;
							this.style.addImage(l$1, {
								data: new e.q({
									width: c$1,
									height: h$1
								}, new Uint8Array(d$1.data)),
								pixelRatio: o$1,
								stretchX: r$1,
								stretchY: n$1,
								content: a$1,
								sdf: s$1,
								usvg: !1,
								version: 0,
								userImage: d$1
							}), d$1.onAdd && d$1.onAdd(this, t$1);
						}
					}
					updateImage(t$1, i$1) {
						this._lazyInitEmptyStyle();
						const o$1 = e.I.from(t$1), s$1 = this.style.getImage(o$1);
						if (!s$1) return void this.fire(new e.y(/* @__PURE__ */ new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
						const { width: n$1, height: a$1, data: l$1 } = i$1 instanceof HTMLImageElement || ImageBitmap && i$1 instanceof ImageBitmap ? e.o.getImageData(i$1) : i$1;
						if (void 0 === n$1 || void 0 === a$1) return void this.fire(new e.y(/* @__PURE__ */ new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
						if (n$1 !== (s$1.usvg ? s$1.icon.usvg_tree.width : s$1.data.width) || a$1 !== (s$1.usvg ? s$1.icon.usvg_tree.height : s$1.data.height)) return void this.fire(new e.y(/* @__PURE__ */ new Error(`The width and height of the updated image (${n$1}, ${a$1})\n                must be that same as the previous version of the image\n                (${s$1.data.width}, ${s$1.data.height})`)));
						const c$1 = !(i$1 instanceof HTMLImageElement || ImageBitmap && i$1 instanceof ImageBitmap);
						let h$1 = !1;
						s$1.usvg ? (s$1.data = new e.q({
							width: n$1,
							height: a$1
						}, new Uint8Array(l$1)), s$1.usvg = !1, s$1.icon = void 0, h$1 = !0) : s$1.data.replace(l$1, c$1), this.style.updateImage(o$1, s$1, h$1);
					}
					hasImage(t$1) {
						return t$1 ? !!this.style && !!this.style.getImage(e.I.from(t$1)) : (this.fire(new e.y(/* @__PURE__ */ new Error("Missing required image id"))), !1);
					}
					removeImage(t$1) {
						this.style.removeImage(e.I.from(t$1));
					}
					loadImage(t$1, i$1) {
						e.n(this._requestManager.transformRequest(t$1, e.R.Image), ((t$2, o$1) => {
							i$1(t$2, o$1 instanceof HTMLImageElement ? e.o.getImageData(o$1) : o$1);
						}));
					}
					listImages() {
						return this.style.listImages().map(((e$1) => e$1.name));
					}
					addModel(e$1, t$1) {
						this._lazyInitEmptyStyle(), this.style.addModel(e$1, t$1);
					}
					hasModel(t$1) {
						return t$1 ? this.style.hasModel(t$1) : (this.fire(new e.y(/* @__PURE__ */ new Error("Missing required model id"))), !1);
					}
					removeModel(e$1) {
						this.style.removeModel(e$1);
					}
					listModels() {
						return this.style.listModels();
					}
					addLayer(e$1, t$1) {
						return this._isValidId(e$1.id) ? (this._lazyInitEmptyStyle(), this.style.addLayer(e$1, t$1), this._update(!0)) : this;
					}
					getSlot(e$1) {
						const t$1 = this.getLayer(e$1);
						return t$1 && t$1.slot || null;
					}
					setSlot(e$1, t$1) {
						return this.style.setSlot(e$1, t$1), this.style.mergeLayers(), this._update(!0);
					}
					addImport(t$1, i$1) {
						return this.style.addImport(t$1, i$1).catch(((t$2) => this.fire(new e.y(new Error("Failed to add import", t$2))))), this;
					}
					updateImport(e$1, t$1) {
						return "string" != typeof t$1 && t$1.id !== e$1 ? (this.removeImport(e$1), this.addImport(t$1)) : (this.style.updateImport(e$1, t$1), this._update(!0));
					}
					removeImport(e$1) {
						return this.style.removeImport(e$1), this;
					}
					moveImport(e$1, t$1) {
						return this.style.moveImport(e$1, t$1), this._update(!0);
					}
					moveLayer(e$1, t$1) {
						return this._isValidId(e$1) ? (this.style.moveLayer(e$1, t$1), this._update(!0)) : this;
					}
					removeLayer(e$1) {
						return this._isValidId(e$1) ? (this.style.removeLayer(e$1), this._update(!0)) : this;
					}
					getLayer(e$1) {
						if (!this._isValidId(e$1)) return null;
						const t$1 = this.style.getOwnLayer(e$1);
						return t$1 ? "custom" === t$1.type ? t$1.implementation : t$1.serialize() : void 0;
					}
					getSlots() {
						return this.style.getSlots();
					}
					setLayerZoomRange(e$1, t$1, i$1) {
						return this._isValidId(e$1) ? (this.style.setLayerZoomRange(e$1, t$1, i$1), this._update(!0)) : this;
					}
					setFilter(e$1, t$1, i$1 = {}) {
						return this._isValidId(e$1) ? (this.style.setFilter(e$1, t$1, i$1), this._update(!0)) : this;
					}
					getFilter(e$1) {
						return this._isValidId(e$1) ? this.style.getFilter(e$1) : null;
					}
					setPaintProperty(e$1, t$1, i$1, o$1 = {}) {
						return this._isValidId(e$1) ? (this.style.setPaintProperty(e$1, t$1, i$1, o$1), this._update(!0)) : this;
					}
					getPaintProperty(e$1, t$1) {
						return this._isValidId(e$1) ? this.style.getPaintProperty(e$1, t$1) : null;
					}
					setLayoutProperty(e$1, t$1, i$1, o$1 = {}) {
						return this._isValidId(e$1) ? (this.style.setLayoutProperty(e$1, t$1, i$1, o$1), this._update(!0)) : this;
					}
					getLayoutProperty(e$1, t$1) {
						return this._isValidId(e$1) ? this.style.getLayoutProperty(e$1, t$1) : null;
					}
					setLayerProperty(e$1, t$1, i$1, o$1 = {}) {
						return this._isValidId(e$1) ? ("appearances" === t$1 && this._postAddingAppearancesToStyleEvent(), this.style.setLayerProperty(e$1, t$1, i$1, o$1), this._update(!0)) : this;
					}
					getGlyphsUrl() {
						return this.style.getGlyphsUrl();
					}
					setGlyphsUrl(e$1) {
						return this.style.setGlyphsUrl(e$1), this._update(!0);
					}
					getSchema(e$1) {
						return this.style.getSchema(e$1);
					}
					setSchema(e$1, t$1) {
						return this.style.setSchema(e$1, t$1), this._update(!0);
					}
					getConfig(e$1) {
						return this.style.getConfig(e$1);
					}
					setConfig(e$1, t$1) {
						return this.style.setConfig(e$1, t$1), this._update(!0);
					}
					getConfigProperty(e$1, t$1) {
						return this.style.getConfigProperty(e$1, t$1);
					}
					setConfigProperty(e$1, t$1, i$1) {
						return this.style.setConfigProperty(e$1, t$1, i$1), this._update(!0);
					}
					getFeaturesetDescriptors(e$1) {
						return this.style.getFeaturesetDescriptors(e$1);
					}
					setLights(e$1) {
						if (this._lazyInitEmptyStyle(), e$1 && 1 === e$1.length && "flat" === e$1[0].type) {
							const t$1 = e$1[0];
							t$1.properties ? this.style.setFlatLight(t$1.properties, t$1.id, {}) : this.style.setFlatLight({}, "flat");
						} else this.style.setLights(e$1), this.painter.terrain && (this.painter.terrain.invalidateRenderCache = !0);
						return this._update(!0);
					}
					getLights() {
						const e$1 = this.style.getLights() || [];
						return 0 === e$1.length && e$1.push({
							id: this.style.light.id,
							type: "flat",
							properties: this.style.getFlatLight()
						}), e$1;
					}
					setLight(e$1, t$1 = {}) {
						return console.log("The `map.setLight` function is deprecated, prefer using `map.setLights` with `flat` light type instead."), this.setLights([{
							id: "flat",
							type: "flat",
							properties: e$1
						}]);
					}
					getLight() {
						return console.log("The `map.getLight` function is deprecated, prefer using `map.getLights` instead."), this.style.getFlatLight();
					}
					setTerrain(e$1) {
						return this._lazyInitEmptyStyle(), !e$1 && this.transform.projection.requiresDraping ? this.style.setTerrainForDraping() : this.style.setTerrain(e$1), this._averageElevationLastSampledAt = -Infinity, this._update(!0);
					}
					getTerrain() {
						return this.style ? this.style.getTerrain() : null;
					}
					setFog(e$1) {
						return this._lazyInitEmptyStyle(), this.style.setFog(e$1), this._update(!0);
					}
					getFog() {
						return this.style ? this.style.getFog() : null;
					}
					setSnow(e$1) {
						return this._lazyInitEmptyStyle(), this.style.setSnow(e$1), this._update(!0);
					}
					getSnow() {
						return this.style ? this.style.getSnow() : null;
					}
					setRain(e$1) {
						return this._lazyInitEmptyStyle(), this.style.setRain(e$1), this._update(!0);
					}
					getRain() {
						return this.style ? this.style.getRain() : null;
					}
					setColorTheme(e$1) {
						return this._lazyInitEmptyStyle(), this.style.setColorTheme(e$1), this._update(!0);
					}
					setImportColorTheme(e$1, t$1) {
						return this._lazyInitEmptyStyle(), this.style.setImportColorTheme(e$1, t$1), this._update(!0);
					}
					setCamera(e$1) {
						return this.style.setCamera(e$1), this._triggerCameraUpdate(e$1);
					}
					_triggerCameraUpdate(e$1) {
						return this._update(this.transform.setOrthographicProjectionAtLowPitch("orthographic" === e$1["camera-projection"]));
					}
					getCamera() {
						return this.style.camera;
					}
					_queryFogOpacity(t$1) {
						return this.style && this.style.fog ? this.style.fog.getOpacityAtLatLng(e.aT.convert(t$1), this.transform) : 0;
					}
					setFeatureState(e$1, t$1) {
						return e$1.source && !this._isValidId(e$1.source) ? this : (this.style.setFeatureState(e$1, t$1), this._update());
					}
					removeFeatureState(e$1, t$1) {
						return e$1.source && !this._isValidId(e$1.source) ? this : (this.style.removeFeatureState(e$1, t$1), this._update());
					}
					getFeatureState(e$1) {
						return e$1.source && !this._isValidId(e$1.source) ? null : this.style.getFeatureState(e$1);
					}
					_selectIndoorFloor(e$1) {
						this.indoor.selectFloor(e$1);
					}
					_setIndoorActiveFloorsVisibility(e$1) {
						this.indoor.setActiveFloorsVisibility(e$1);
					}
					_addIndoorControl() {
						this._indoorControl || (this._indoorControl = new Ml()), this.addControl(this._indoorControl, "right");
					}
					_removeIndoorControl() {
						this._indoorControl && this.removeControl(this._indoorControl);
					}
					_updateContainerDimensions() {
						if (!this._container) return;
						const e$1 = this._container.getBoundingClientRect().width || 400, t$1 = this._container.getBoundingClientRect().height || 300;
						let i$1, o$1, s$1, r$1 = this._container;
						for (; r$1 && (!o$1 || !s$1);) {
							const e$2 = window.getComputedStyle(r$1).transform;
							e$2 && "none" !== e$2 && (i$1 = e$2.match(/matrix.*\((.+)\)/)[1].split(", "), i$1[0] && "0" !== i$1[0] && "1" !== i$1[0] && (o$1 = i$1[0]), i$1[3] && "0" !== i$1[3] && "1" !== i$1[3] && (s$1 = i$1[3])), r$1 = r$1.parentElement;
						}
						this._containerWidth = o$1 ? Math.abs(e$1 / o$1) : e$1, this._containerHeight = s$1 ? Math.abs(t$1 / s$1) : t$1;
					}
					_detectMissingCSS() {
						"rgb(250, 128, 114)" !== window.getComputedStyle(this._missingCSSCanary).getPropertyValue("background-color") && e.w("This page appears to be missing CSS declarations for Mapbox GL JS, which may cause the map to display incorrectly. Please ensure your page includes mapbox-gl.css, as described in https://www.mapbox.com/mapbox-gl-js/api/.");
					}
					_setupIndoor() {
						this.style.isIndoorEnabled() && (this.indoor = new Oo(this.style), this.on("load", (() => {
							this._addIndoorControl(), this.indoor._updateUI(this.transform.zoom, this.transform.center, this.transform.getBounds()), this.on("move", (() => {
								this.indoor._updateUI(this.transform.zoom, this.transform.center, this.transform.getBounds());
							})), this.on("idle", (() => {
								this.indoor._updateUI(this.transform.zoom, this.transform.center, this.transform.getBounds());
							}));
						})));
					}
					_setupContainer() {
						const e$1 = this._container;
						e$1.classList.add("mapboxgl-map"), (this._missingCSSCanary = l("div", "mapboxgl-canary", e$1)).style.visibility = "hidden", this._detectMissingCSS();
						const t$1 = this._canvasContainer = l("div", "mapboxgl-canvas-container", e$1);
						this._canvas = l("canvas", "mapboxgl-canvas", t$1), this._interactive && (t$1.classList.add("mapboxgl-interactive"), this._canvas.setAttribute("tabindex", "0")), this._canvas.addEventListener("webglcontextlost", this._contextLost, !1), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.setAttribute("aria-label", this._getUIString("Map.Title")), this._canvas.setAttribute("role", "region"), this._updateContainerDimensions(), this._resizeCanvas(this._containerWidth, this._containerHeight);
						const i$1 = this._controlContainer = l("div", "mapboxgl-control-container", e$1), o$1 = this._controlPositions = {};
						[
							"top-left",
							"top",
							"top-right",
							"right",
							"bottom-right",
							"bottom",
							"bottom-left",
							"left"
						].forEach(((e$2) => {
							o$1[e$2] = l("div", `mapboxgl-ctrl-${e$2}`, i$1);
						})), this._container.addEventListener("scroll", this._onMapScroll, !1);
					}
					_resizeCanvas(t$1, i$1) {
						const o$1 = e.o.devicePixelRatio || 1;
						this._canvas.width = o$1 * Math.ceil(t$1), this._canvas.height = o$1 * Math.ceil(i$1), this._canvas.style.width = `${t$1}px`, this._canvas.style.height = `${i$1}px`;
					}
					_addMarker(e$1) {
						this._markers.push(e$1);
					}
					_removeMarker(e$1) {
						const t$1 = this._markers.indexOf(e$1);
						-1 !== t$1 && this._markers.splice(t$1, 1);
					}
					_addPopup(e$1) {
						this._popups.push(e$1);
					}
					_removePopup(e$1) {
						const t$1 = this._popups.indexOf(e$1);
						-1 !== t$1 && this._popups.splice(t$1, 1);
					}
					_setupPainter() {
						const t$1 = Object.assign({}, a.supported.webGLContextAttributes, {
							failIfMajorPerformanceCaveat: this._failIfMajorPerformanceCaveat,
							preserveDrawingBuffer: this._preserveDrawingBuffer,
							antialias: this._antialias || !1
						}), i$1 = this._canvas.getContext("webgl2", t$1);
						i$1 ? (Z(i$1, !0), this.painter = new Da(i$1, this._contextCreateOptions, this.transform, this._scaleFactor, this._worldview), this.on("data", ((e$1) => {
							"source" === e$1.dataType && this.painter.setTileLoadedFlag(!0);
						})), e.k.testSupport(i$1)) : this.fire(new e.y(/* @__PURE__ */ new Error("Failed to initialize WebGL")));
					}
					_contextLost(t$1) {
						t$1.preventDefault(), this._frame && (this._frame.cancel(), this._frame = null), this.fire(new e.z("webglcontextlost", { originalEvent: t$1 }));
					}
					_contextRestored(t$1) {
						this._setupPainter(), this.painter.resize(Math.ceil(this._containerWidth), Math.ceil(this._containerHeight)), this._updateTerrain(), this.style && (this.style.clearLayers(), this.style.imageManager.destroyAtlasTextures(), this.style.reloadModels(), this.style.clearSources()), this._update(), this.fire(new e.z("webglcontextrestored", { originalEvent: t$1 }));
					}
					_onMapScroll(e$1) {
						if (e$1.target === this._container) return this._container.scrollTop = 0, this._container.scrollLeft = 0, !1;
					}
					idle() {
						return !this.isMoving() && this.loaded();
					}
					loaded() {
						return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();
					}
					frameReady() {
						return this.loaded() && !this._placementDirty;
					}
					_update(e$1) {
						return this.style ? (this._styleDirty = this._styleDirty || e$1, this._sourcesDirty = !0, this.triggerRepaint(), this) : this;
					}
					_requestRenderFrame(e$1) {
						return this._update(), this._renderTaskQueue.add(e$1);
					}
					_cancelRenderFrame(e$1) {
						this._renderTaskQueue.remove(e$1);
					}
					_requestDomTask(e$1) {
						!this.loaded() || this.loaded() && !this.isMoving() ? e$1() : this._domRenderTaskQueue.add(e$1);
					}
					_render(t$1) {
						let s$1;
						this.fire(new e.z("renderstart")), ++this._frameId;
						const r$1 = this.painter.context.extTimerQuery, n$1 = e.o.now(), a$1 = this.painter.context.gl;
						if (this.listens("gpu-timing-frame") && (s$1 = a$1.createQuery(), a$1.beginQuery(r$1.TIME_ELAPSED_EXT, s$1)), this.painter.context.setDirty(), this.painter.setBaseState(), (this.isMoving() || this.isRotating() || this.isZooming()) && (this._interactionRange[0] = Math.min(this._interactionRange[0], performance.now()), this._interactionRange[1] = Math.max(this._interactionRange[1], performance.now())), this._renderTaskQueue.run(t$1), this._domRenderTaskQueue.run(t$1), this._removed) return;
						this._updateProjectionTransition();
						const l$1 = this._isInitialLoad ? 0 : this._fadeDuration;
						if (this.style && this._styleDirty) {
							this._styleDirty = !1;
							const t$2 = this.transform.zoom, i$1 = this.transform.pitch, o$1 = e.o.now(), s$2 = new e.ac(t$2, {
								now: o$1,
								fadeDuration: l$1,
								pitch: i$1,
								transition: this.style.transition,
								worldview: this._worldview
							});
							this.style.update(s$2);
						}
						this.style && this.style.hasFogTransition() && (this.style._markersNeedUpdate = !0, this._sourcesDirty = !0);
						let c$1 = !1;
						this.style && this._sourcesDirty ? (this._sourcesDirty = !1, this.painter._updateFog(this.style), this._updateTerrain(), c$1 = this._updateAverageElevation(n$1), this.style.updateSources(this.transform), this.style.updateImageProviders(), this.isMoving() || this._forceMarkerAndPopupUpdate()) : c$1 = this._updateAverageElevation(n$1);
						const h$1 = this.style && this.style._updatePlacement(this.painter, this.painter.transform, this.showCollisionBoxes, l$1, this._crossSourceCollisions, this.painter.replacementSource, this._scaleFactorChanged);
						if (this._scaleFactorChanged && (this._scaleFactorChanged = !1), h$1 && (this._placementDirty = h$1.needsRerender), this.style && this.painter.render(this.style, {
							showTileBoundaries: this.showTileBoundaries,
							showParseStatus: this.showParseStatus,
							wireframe: {
								terrain: this.showTerrainWireframe,
								layers2D: this.showLayers2DWireframe,
								layers3D: this.showLayers3DWireframe
							},
							showOverdrawInspector: this._showOverdrawInspector,
							showQueryGeometry: !!this._showQueryGeometry,
							showTileAABBs: this.showTileAABBs,
							rotating: this.isRotating(),
							zooming: this.isZooming(),
							moving: this.isMoving(),
							fadeDuration: l$1,
							isInitialLoad: this._isInitialLoad,
							showPadding: this.showPadding,
							gpuTiming: !!this.listens("gpu-timing-layer"),
							gpuTimingDeferredRender: !!this.listens("gpu-timing-deferred-render"),
							speedIndexTiming: this.speedIndexTiming
						}), this.fire(new e.z("render")), this.loaded() && !this._loaded && (this._loaded = !0, o.mark(i.load), this.fire(new e.z("load"))), this.style && this.style.hasTransitions() && (this._styleDirty = !0), this.style && (this.style.snow || this.style.rain) && (this._styleDirty = !0), this.style && this.style.imageManager.hasPatternsInFlight() && (this._styleDirty = !0), this.style && !this.style.modelManager.isLoaded() && (this._styleDirty = !0), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles(), s$1) {
							const t$2 = e.o.now() - n$1;
							a$1.endQuery(r$1.TIME_ELAPSED_EXT), setTimeout((() => {
								const i$1 = a$1.getQueryParameter(s$1, a$1.QUERY_RESULT) / 1e6;
								a$1.deleteQuery(s$1), this.fire(new e.z("gpu-timing-frame", {
									cpuTime: t$2,
									gpuTime: i$1
								}));
							}), 50);
						}
						if (this.listens("gpu-timing-layer")) {
							const t$2 = this.painter.collectGpuTimers();
							setTimeout((() => {
								const i$1 = this.painter.queryGpuTimers(t$2);
								this.fire(new e.z("gpu-timing-layer", { layerTimes: i$1 }));
							}), 50);
						}
						if (this.listens("gpu-timing-deferred-render")) {
							const t$2 = this.painter.collectDeferredRenderGpuQueries();
							setTimeout((() => {
								const i$1 = this.painter.queryGpuTimeDeferredRender(t$2);
								this.fire(new e.z("gpu-timing-deferred-render", { gpuTime: i$1 }));
							}), 50);
						}
						const d$1 = this._sourcesDirty || this._styleDirty || this._placementDirty || c$1;
						if (d$1 || this._repaint) this.triggerRepaint();
						else {
							const t$2 = this.idle();
							if (t$2 && (c$1 = this._updateAverageElevation(n$1, !0)), c$1) this.triggerRepaint();
							else if (this._triggerFrame(!1), t$2 && (this.fire(new e.z("idle")), this._isInitialLoad = !1, this.speedIndexTiming)) {
								const t$3 = this._calculateSpeedIndex();
								this.fire(new e.z("speedindexcompleted", { speedIndex: t$3 })), this.speedIndexTiming = !1;
							}
						}
						!this._loaded || this._fullyLoaded || d$1 || (this._fullyLoaded = !0, o.mark(i.fullLoad), this._performanceMetricsCollection && G(this._requestManager._customAccessToken, {
							width: this.painter.width,
							height: this.painter.height,
							interactionRange: this._interactionRange,
							visibilityHidden: this._visibilityHidden,
							terrainEnabled: !!this.painter.style.getTerrain(),
							fogEnabled: !!this.painter.style.getFog(),
							projection: this.getProjection().name,
							zoom: this.transform.zoom,
							renderer: this.painter.context.renderer,
							vendor: this.painter.context.vendor
						}), this._authenticate());
					}
					_forceMarkerAndPopupUpdate(e$1) {
						for (const t$1 of this._markers) e$1 && !this.getRenderWorldCopies() && (t$1._lngLat = t$1._lngLat.wrap()), t$1._update();
						for (const t$1 of this._popups) !e$1 || this.getRenderWorldCopies() || t$1._trackPointer || (t$1._lngLat = t$1._lngLat.wrap()), t$1._update();
					}
					_updateAverageElevation(e$1, t$1 = !1) {
						const i$1 = (e$2) => (this.transform.averageElevation = e$2, this._update(!1), !0);
						if (!this.painter.averageElevationNeedsEasing()) return 0 !== this.transform.averageElevation && i$1(0);
						const o$1 = this.transform.elevation && this.transform.elevation.exaggeration() !== this._averageElevationExaggeration;
						if (o$1 || (t$1 || e$1 - this._averageElevationLastSampledAt > 500) && !this._averageElevation.isEasing(e$1)) {
							const t$2 = this.transform.averageElevation;
							let s$1 = this.transform.sampleAverageElevation();
							null != this.transform.elevation && (this._averageElevationExaggeration = this.transform.elevation.exaggeration()), isNaN(s$1) ? s$1 = 0 : this._averageElevationLastSampledAt = e$1;
							const r$1 = Math.abs(t$2 - s$1);
							if (r$1 > 1) {
								if (this._isInitialLoad || o$1) return this._averageElevation.jumpTo(s$1), i$1(s$1);
								this._averageElevation.easeTo(s$1, e$1, 300);
							} else if (r$1 > 1e-4) return this._averageElevation.jumpTo(s$1), i$1(s$1);
						}
						return !!this._averageElevation.isEasing(e$1) && i$1(this._averageElevation.getValue(e$1));
					}
					_authenticate() {
						H(this._getMapId(), this._requestManager._skuToken, this._requestManager._customAccessToken, ((t$1) => {
							if (t$1 && (t$1.message === w || 401 === t$1.status)) {
								const t$2 = this.painter.context.gl;
								Z(t$2, !1), this._logoControl instanceof zl && this._logoControl._updateLogo(), t$2 && t$2.clear(t$2.DEPTH_BUFFER_BIT | t$2.COLOR_BUFFER_BIT | t$2.STENCIL_BUFFER_BIT), this._silenceAuthErrors || this.fire(new e.y(/* @__PURE__ */ new Error("A valid Mapbox access token is required to use Mapbox GL JS. To create an account or a new access token, visit https://account.mapbox.com/")));
							}
						})), z(this._getMapId(), this._requestManager._skuToken, this._requestManager._customAccessToken, (() => {}));
					}
					_postStyleLoadEvent() {
						this.style.globalId && F(this._requestManager._customAccessToken, {
							map: this,
							style: this.style.globalId,
							importedStyles: this.style.getImportGlobalIds()
						});
					}
					_postStyleWithAppearanceEvent() {
						this.style.globalId && this.style.hasAppearances() && k(this._requestManager._customAccessToken);
					}
					_postAddingAppearancesToStyleEvent() {
						U(this._requestManager._customAccessToken);
					}
					_updateTerrain() {
						const e$1 = this._isDragging();
						this.painter.updateTerrain(this.style, e$1);
					}
					_calculateSpeedIndex() {
						const e$1 = this.painter.canvasCopy(), t$1 = this.painter.getCanvasCopiesAndTimestamps();
						t$1.timeStamps.push(performance.now());
						const i$1 = this.painter.context.gl, o$1 = i$1.createFramebuffer();
						function s$1(e$2) {
							i$1.framebufferTexture2D(i$1.FRAMEBUFFER, i$1.COLOR_ATTACHMENT0, i$1.TEXTURE_2D, e$2, 0);
							const t$2 = new Uint8Array(i$1.drawingBufferWidth * i$1.drawingBufferHeight * 4);
							return i$1.readPixels(0, 0, i$1.drawingBufferWidth, i$1.drawingBufferHeight, i$1.RGBA, i$1.UNSIGNED_BYTE, t$2), t$2;
						}
						return i$1.bindFramebuffer(i$1.FRAMEBUFFER, o$1), this._canvasPixelComparison(s$1(e$1), t$1.canvasCopies.map(s$1), t$1.timeStamps);
					}
					_canvasPixelComparison(e$1, t$1, i$1) {
						let o$1 = i$1[1] - i$1[0];
						const s$1 = e$1.length / 4;
						for (let r$1 = 0; r$1 < t$1.length; r$1++) {
							const n$1 = t$1[r$1];
							let a$1 = 0;
							for (let t$2 = 0; t$2 < n$1.length; t$2 += 4) n$1[t$2] === e$1[t$2] && n$1[t$2 + 1] === e$1[t$2 + 1] && n$1[t$2 + 2] === e$1[t$2 + 2] && n$1[t$2 + 3] === e$1[t$2 + 3] && (a$1 += 1);
							o$1 += (i$1[r$1 + 2] - i$1[r$1 + 1]) * (1 - a$1 / s$1);
						}
						return o$1;
					}
					remove() {
						this._hash && this._hash.remove();
						for (const e$1 of this._controls) e$1.onRemove(this);
						this._controls = [], this._frame && (this._frame.cancel(), this._frame = null), this._renderTaskQueue.clear(), this._domRenderTaskQueue.clear(), this.style && this.style.destroy(), this.indoor && this.indoor.destroy(), this.painter.destroy(), this.handlers && this.handlers.destroy(), this.handlers = void 0, this.setStyle(null), window.removeEventListener("resize", this._onWindowResize, !1), window.removeEventListener("orientationchange", this._onWindowResize, !1), window.removeEventListener(this._fullscreenchangeEvent, this._onWindowResize, !1), window.removeEventListener("online", this._onWindowOnline, !1), window.removeEventListener("visibilitychange", this._onVisibilityChange, !1);
						const t$1 = this.painter.context.gl.getExtension("WEBGL_lose_context");
						t$1 && t$1.loseContext(), this._canvas.removeEventListener("webglcontextlost", this._contextLost, !1), this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, !1), this._canvasContainer.remove(), this._controlContainer.remove(), this._missingCSSCanary.remove(), this._canvas = void 0, this._canvasContainer = void 0, this._controlContainer = void 0, this._missingCSSCanary = void 0, this._container.classList.remove("mapboxgl-map"), this._container.removeEventListener("scroll", this._onMapScroll, !1), q.delete(this.painter.context.gl), V.remove(), O.remove(), this._removed = !0, this.fire(new e.z("remove"));
					}
					triggerRepaint() {
						this._triggerFrame(!0);
					}
					_triggerFrame(t$1) {
						this._renderNextFrame = this._renderNextFrame || t$1, this.style && !this._frame && (this._frame = e.o.frame(((e$1) => {
							const t$2 = !!this._renderNextFrame;
							this._frame = null, this._renderNextFrame = null, t$2 && this._render(e$1);
						})));
					}
					_preloadTiles(t$1) {
						const i$1 = this.style ? this.style.getSourceCaches() : [];
						return e.bw(i$1, ((e$1, i$2) => e$1._preloadTiles(t$1, i$2)), (() => {
							this.triggerRepaint();
						})), this;
					}
					_onWindowOnline() {
						this._update();
					}
					_onWindowResize(e$1) {
						this._trackResize && this.resize({ originalEvent: e$1 })._update();
					}
					_onVisibilityChange() {
						"hidden" === document.visibilityState && this._visibilityHidden++;
					}
					get showTileBoundaries() {
						return !!this._showTileBoundaries;
					}
					set showTileBoundaries(e$1) {
						this._showTileBoundaries !== e$1 && (this._showTileBoundaries = e$1, this._update());
					}
					get showParseStatus() {
						return !!this._showParseStatus;
					}
					set showParseStatus(e$1) {
						this._showParseStatus !== e$1 && (this._showParseStatus = e$1, this._update());
					}
					get showTerrainWireframe() {
						return !!this._showTerrainWireframe;
					}
					set showTerrainWireframe(e$1) {
						this._showTerrainWireframe !== e$1 && (this._showTerrainWireframe = e$1, this._update());
					}
					get showLayers2DWireframe() {
						return !!this._showLayers2DWireframe;
					}
					set showLayers2DWireframe(e$1) {
						this._showLayers2DWireframe !== e$1 && (this._showLayers2DWireframe = e$1, this._update());
					}
					get showLayers3DWireframe() {
						return !!this._showLayers3DWireframe;
					}
					set showLayers3DWireframe(e$1) {
						this._showLayers3DWireframe !== e$1 && (this._showLayers3DWireframe = e$1, this._update());
					}
					get speedIndexTiming() {
						return !!this._speedIndexTiming;
					}
					set speedIndexTiming(e$1) {
						this._speedIndexTiming !== e$1 && (this._speedIndexTiming = e$1, this._update());
					}
					get showPadding() {
						return !!this._showPadding;
					}
					set showPadding(e$1) {
						this._showPadding !== e$1 && (this._showPadding = e$1, this._update());
					}
					get showCollisionBoxes() {
						return !!this._showCollisionBoxes;
					}
					set showCollisionBoxes(e$1) {
						this._showCollisionBoxes !== e$1 && (this._showCollisionBoxes = e$1, this.style && e$1 ? this.style._generateCollisionBoxes() : this._update());
					}
					get showOverdrawInspector() {
						return !!this._showOverdrawInspector;
					}
					set showOverdrawInspector(e$1) {
						this._showOverdrawInspector !== e$1 && (this._showOverdrawInspector = e$1, this._update());
					}
					get repaint() {
						return !!this._repaint;
					}
					set repaint(e$1) {
						this._repaint !== e$1 && (this._repaint = e$1, this.triggerRepaint());
					}
					get vertices() {
						return !!this._vertices;
					}
					set vertices(e$1) {
						this._vertices = e$1, this._update();
					}
					get showTileAABBs() {
						return !!this._showTileAABBs;
					}
					set showTileAABBs(e$1) {
						this._showTileAABBs !== e$1 && (this._showTileAABBs = e$1, e$1 && this._update());
					}
					_setCacheLimits(t$1, i$1) {
						e.f4(t$1, i$1);
					}
					get version() {
						return t;
					}
				},
				NavigationControl: class {
					constructor(t$1 = {}) {
						this.options = Object.assign({}, Vl, t$1), this._container = l("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._container.addEventListener("contextmenu", ((e$1) => e$1.preventDefault())), this.options.showZoom && (e.aY(["_setButtonTitle", "_updateZoomButtons"], this), this._zoomInButton = this._createButton("mapboxgl-ctrl-zoom-in", ((e$1) => {
							this._map && this._map.zoomIn({}, { originalEvent: e$1 });
						})), l("span", "mapboxgl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"), this._zoomOutButton = this._createButton("mapboxgl-ctrl-zoom-out", ((e$1) => {
							this._map && this._map.zoomOut({}, { originalEvent: e$1 });
						})), l("span", "mapboxgl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")), this.options.showCompass && (e.aY(["_rotateCompassArrow"], this), this._compass = this._createButton("mapboxgl-ctrl-compass", ((e$1) => {
							const t$2 = this._map;
							t$2 && (this.options.visualizePitch ? t$2.resetNorthPitch({}, { originalEvent: e$1 }) : t$2.resetNorth({}, { originalEvent: e$1 }));
						})), this._compassIcon = l("span", "mapboxgl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", "true"));
					}
					_updateZoomButtons() {
						const e$1 = this._map;
						if (!e$1) return;
						const t$1 = e$1.getZoom(), i$1 = t$1 === e$1.getMaxZoom(), o$1 = t$1 === e$1.getMinZoom();
						this._zoomInButton.disabled = i$1, this._zoomOutButton.disabled = o$1, this._zoomInButton.setAttribute("aria-disabled", i$1.toString()), this._zoomOutButton.setAttribute("aria-disabled", o$1.toString());
					}
					_rotateCompassArrow() {
						const e$1 = this._map;
						if (!e$1) return;
						const t$1 = this.options.visualizePitch ? `scale(${1 / Math.pow(Math.cos(e$1.transform.pitch * (Math.PI / 180)), .5)}) rotateX(${e$1.transform.pitch}deg) rotateZ(${e$1.transform.angle * (180 / Math.PI)}deg)` : `rotate(${e$1.transform.angle * (180 / Math.PI)}deg)`;
						e$1._requestDomTask((() => {
							this._compassIcon && (this._compassIcon.style.transform = t$1);
						}));
					}
					onAdd(e$1) {
						return this._map = e$1, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), e$1.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && e$1.on("pitch", this._rotateCompassArrow), e$1.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new Hl(e$1, this._compass, this.options.visualizePitch)), this._container;
					}
					onRemove() {
						const e$1 = this._map;
						e$1 && (this._container.remove(), this.options.showZoom && e$1.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && e$1.off("pitch", this._rotateCompassArrow), e$1.off("rotate", this._rotateCompassArrow), this._handler && this._handler.off(), this._handler = void 0), this._map = void 0);
					}
					_createButton(e$1, t$1) {
						const i$1 = l("button", e$1, this._container);
						return i$1.type = "button", i$1.addEventListener("click", t$1), i$1;
					}
					_setButtonTitle(e$1, t$1) {
						if (!this._map) return;
						const i$1 = this._map._getUIString(`NavigationControl.${t$1}`);
						e$1.setAttribute("aria-label", i$1), e$1.firstElementChild && e$1.firstElementChild.setAttribute("title", i$1);
					}
				},
				GeolocateControl: class extends e.E {
					constructor(t$1 = {}) {
						super();
						const i$1 = navigator.geolocation;
						this.options = Object.assign({ geolocation: i$1 }, Xl, t$1), e.aY([
							"_onSuccess",
							"_onError",
							"_onZoom",
							"_finish",
							"_setupUI",
							"_updateCamera",
							"_updateMarker",
							"_updateMarkerRotation",
							"_onDeviceOrientation"
						], this), this._updateMarkerRotationThrottled = Pa(this._updateMarkerRotation, 20), this._numberOfWatches = 0;
					}
					onAdd(e$1) {
						return this._map = e$1, this._container = l("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._checkGeolocationSupport(this._setupUI), this._container;
					}
					onRemove() {
						void 0 !== this._geolocationWatchID && (this.options.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), this._container.remove(), this._map.off("zoom", this._onZoom), this._map = void 0, this._numberOfWatches = 0, this._noTimeout = !1;
					}
					_checkGeolocationSupport(e$1) {
						const t$1 = (t$2 = !!this.options.geolocation) => {
							this._supportsGeolocation = t$2, e$1(t$2);
						};
						void 0 !== this._supportsGeolocation ? e$1(this._supportsGeolocation) : void 0 !== navigator.permissions ? navigator.permissions.query({ name: "geolocation" }).then(((e$2) => t$1("denied" !== e$2.state))).catch((() => t$1())) : t$1();
					}
					_isOutOfMapMaxBounds(e$1) {
						const t$1 = this._map.getMaxBounds(), i$1 = e$1.coords;
						return !!t$1 && (i$1.longitude < t$1.getWest() || i$1.longitude > t$1.getEast() || i$1.latitude < t$1.getSouth() || i$1.latitude > t$1.getNorth());
					}
					_setErrorState() {
						switch (this._watchState) {
							case "WAITING_ACTIVE":
								this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");
								break;
							case "ACTIVE_LOCK":
								this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting");
								break;
							case "BACKGROUND": this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting");
						}
					}
					_onSuccess(t$1) {
						if (this._map) {
							if (this._isOutOfMapMaxBounds(t$1)) return this._setErrorState(), this.fire(new e.z("outofmaxbounds", t$1)), this._updateMarker(), void this._finish();
							if (this.options.trackUserLocation) switch (this._lastKnownPosition = t$1, this._watchState) {
								case "WAITING_ACTIVE":
								case "ACTIVE_LOCK":
								case "ACTIVE_ERROR":
									this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
									break;
								case "BACKGROUND":
								case "BACKGROUND_ERROR": this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background");
							}
							this.options.showUserLocation && "OFF" !== this._watchState && this._updateMarker(t$1), this.options.trackUserLocation && "ACTIVE_LOCK" !== this._watchState || this._updateCamera(t$1), this.options.showUserLocation && this._userLocationDotMarker.removeClassName("mapboxgl-user-location-dot-stale"), this.fire(new e.z("geolocate", Object.assign({
								coords: t$1.coords,
								timestamp: t$1.timestamp
							}, t$1.toJSON ? { toJSON: t$1.toJSON.bind(t$1) } : {}))), this._finish();
						}
					}
					_updateCamera(t$1) {
						const i$1 = new e.aT(t$1.coords.longitude, t$1.coords.latitude), o$1 = t$1.coords.accuracy, s$1 = this._map.getBearing(), r$1 = Object.assign({ bearing: s$1 }, this.options.fitBoundsOptions);
						this._map.fitBounds(i$1.toBounds(o$1), r$1, { geolocateSource: !0 });
					}
					_updateMarker(t$1) {
						if (t$1) {
							const i$1 = new e.aT(t$1.coords.longitude, t$1.coords.latitude);
							this._accuracyCircleMarker.setLngLat(i$1).addTo(this._map), this._userLocationDotMarker.setLngLat(i$1).addTo(this._map), this._accuracy = t$1.coords.accuracy, this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
						} else this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove();
					}
					_updateCircleRadius() {
						const t$1 = this._map.transform, i$1 = e.cf(1, t$1._center.lat) * t$1.worldSize, o$1 = Math.ceil(2 * this._accuracy * i$1);
						this._circleElement.style.width = `${o$1}px`, this._circleElement.style.height = `${o$1}px`;
					}
					_onZoom() {
						this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
					}
					_updateMarkerRotation() {
						this._userLocationDotMarker && "number" == typeof this._heading ? (this._userLocationDotMarker.setRotation(this._heading), this._userLocationDotMarker.addClassName("mapboxgl-user-location-show-heading")) : (this._userLocationDotMarker.removeClassName("mapboxgl-user-location-show-heading"), this._userLocationDotMarker.setRotation(0));
					}
					_onError(t$1) {
						if (this._map) {
							if (this.options.trackUserLocation) if (1 === t$1.code) {
								this._watchState = "OFF", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = !0;
								const e$1 = this._map._getUIString("GeolocateControl.LocationNotAvailable");
								this._geolocateButton.setAttribute("aria-label", e$1), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", e$1), void 0 !== this._geolocationWatchID && this._clearWatch();
							} else {
								if (3 === t$1.code && this._noTimeout) return;
								this._setErrorState();
							}
							"OFF" !== this._watchState && this.options.showUserLocation && this._userLocationDotMarker.addClassName("mapboxgl-user-location-dot-stale"), this.fire(new e.z("error", t$1)), this._finish();
						}
					}
					_finish() {
						this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0;
					}
					_setupUI(t$1) {
						if (void 0 !== this._map) {
							if (this._container.addEventListener("contextmenu", ((e$1) => e$1.preventDefault())), this._geolocateButton = l("button", "mapboxgl-ctrl-geolocate", this._container), l("span", "mapboxgl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"), this._geolocateButton.type = "button", !1 === t$1) {
								e.w("Geolocation support is not available so the GeolocateControl will be disabled.");
								const t$2 = this._map._getUIString("GeolocateControl.LocationNotAvailable");
								this._geolocateButton.disabled = !0, this._geolocateButton.setAttribute("aria-label", t$2), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", t$2);
							} else {
								const e$1 = this._map._getUIString("GeolocateControl.FindMyLocation");
								this._geolocateButton.setAttribute("aria-label", e$1), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", e$1);
							}
							this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = l("div", "mapboxgl-user-location"), this._dotElement.appendChild(l("div", "mapboxgl-user-location-dot")), this._dotElement.appendChild(l("div", "mapboxgl-user-location-heading")), this._userLocationDotMarker = new $l({
								element: this._dotElement,
								rotationAlignment: "map",
								pitchAlignment: "map"
							}), this._circleElement = l("div", "mapboxgl-user-location-accuracy-circle"), this._accuracyCircleMarker = new $l({
								element: this._circleElement,
								pitchAlignment: "map"
							}), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onZoom)), this._geolocateButton.addEventListener("click", this.trigger.bind(this)), this._setup = !0, this.options.trackUserLocation && this._map.on("movestart", ((t$2) => {
								t$2.geolocateSource || "ACTIVE_LOCK" !== this._watchState || t$2.originalEvent && "resize" === t$2.originalEvent.type || (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this.fire(new e.z("trackuserlocationend")));
							}));
						}
					}
					_onDeviceOrientation(e$1) {
						this._userLocationDotMarker && (e$1.webkitCompassHeading ? this._heading = e$1.webkitCompassHeading : !0 === e$1.absolute && (this._heading = -1 * e$1.alpha), this._updateMarkerRotationThrottled());
					}
					trigger() {
						if (!this._setup) return e.w("Geolocate control triggered before added to a map"), !1;
						if (this.options.trackUserLocation) {
							switch (this._watchState) {
								case "OFF":
									this._watchState = "WAITING_ACTIVE", this.fire(new e.z("trackuserlocationstart"));
									break;
								case "WAITING_ACTIVE":
								case "ACTIVE_LOCK":
								case "ACTIVE_ERROR":
								case "BACKGROUND_ERROR":
									this._numberOfWatches--, this._noTimeout = !1, this._watchState = "OFF", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this.fire(new e.z("trackuserlocationend"));
									break;
								case "BACKGROUND": this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new e.z("trackuserlocationstart"));
							}
							switch (this._watchState) {
								case "WAITING_ACTIVE":
									this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
									break;
								case "ACTIVE_LOCK":
									this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
									break;
								case "ACTIVE_ERROR":
									this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");
									break;
								case "BACKGROUND":
									this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background");
									break;
								case "BACKGROUND_ERROR": this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error");
							}
							if ("OFF" === this._watchState && void 0 !== this._geolocationWatchID) this._clearWatch();
							else if (void 0 === this._geolocationWatchID) {
								let e$1;
								this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), this._numberOfWatches++, this._numberOfWatches > 1 ? (e$1 = {
									maximumAge: 6e5,
									timeout: 0
								}, this._noTimeout = !0) : (e$1 = this.options.positionOptions, this._noTimeout = !1), this._geolocationWatchID = this.options.geolocation.watchPosition(this._onSuccess, this._onError, e$1), this.options.showUserHeading && this._addDeviceOrientationListener();
							}
						} else this.options.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = window.setTimeout(this._finish, 1e4);
						return !0;
					}
					_addDeviceOrientationListener() {
						const e$1 = () => {
							"ondeviceorientationabsolute" in window ? window.addEventListener("deviceorientationabsolute", this._onDeviceOrientation) : window.addEventListener("deviceorientation", this._onDeviceOrientation);
						};
						"undefined" != typeof DeviceMotionEvent && "function" == typeof DeviceMotionEvent.requestPermission ? DeviceOrientationEvent.requestPermission().then(((t$1) => {
							"granted" === t$1 && e$1();
						})).catch(console.error) : e$1();
					}
					_clearWatch() {
						this.options.geolocation.clearWatch(this._geolocationWatchID), window.removeEventListener("deviceorientation", this._onDeviceOrientation), window.removeEventListener("deviceorientationabsolute", this._onDeviceOrientation), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null);
					}
				},
				AttributionControl: Ol,
				ScaleControl: class {
					constructor(t$1 = {}) {
						this.options = Object.assign({}, Yl, t$1), e.aY([
							"_update",
							"_setScale",
							"setUnit"
						], this);
					}
					getDefaultPosition() {
						return "bottom-left";
					}
					_update() {
						const e$1 = this.options.maxWidth || 100, t$1 = this._map, i$1 = t$1._containerHeight / 2, o$1 = t$1._containerWidth / 2 - e$1 / 2, s$1 = t$1.unproject([o$1, i$1]), r$1 = t$1.unproject([o$1 + e$1, i$1]), n$1 = s$1.distanceTo(r$1);
						if ("imperial" === this.options.unit) {
							const t$2 = 3.2808 * n$1;
							t$2 > 5280 ? this._setScale(e$1, t$2 / 5280, "mile") : this._setScale(e$1, t$2, "foot");
						} else "nautical" === this.options.unit ? this._setScale(e$1, n$1 / 1852, "nautical-mile") : n$1 >= 1e3 ? this._setScale(e$1, n$1 / 1e3, "kilometer") : this._setScale(e$1, n$1, "meter");
					}
					_setScale(e$1, t$1, i$1) {
						this._map._requestDomTask((() => {
							const o$1 = function(e$2) {
								const t$2 = Math.pow(10, `${Math.floor(e$2)}`.length - 1);
								let i$2 = e$2 / t$2;
								return i$2 = i$2 >= 10 ? 10 : i$2 >= 5 ? 5 : i$2 >= 3 ? 3 : i$2 >= 2 ? 2 : i$2 >= 1 ? 1 : function(e$3) {
									const t$3 = Math.pow(10, Math.ceil(-Math.log(e$3) / Math.LN10));
									return Math.round(e$3 * t$3) / t$3;
								}(i$2), t$2 * i$2;
							}(t$1), s$1 = o$1 / t$1;
							this._container.innerHTML = "nautical-mile" !== i$1 ? new Intl.NumberFormat(this._language, {
								style: "unit",
								unitDisplay: "short",
								unit: i$1
							}).format(o$1) : `${o$1}&nbsp;${Kl[i$1]}`, this._container.style.width = e$1 * s$1 + "px";
						}));
					}
					onAdd(e$1) {
						return this._map = e$1, this._language = e$1.getLanguage(), this._container = l("div", "mapboxgl-ctrl mapboxgl-ctrl-scale", e$1.getContainer()), this._container.dir = "auto", this._map.on("move", this._update), this._update(), this._container;
					}
					onRemove() {
						this._container.remove(), this._map.off("move", this._update), this._map = void 0;
					}
					_setLanguage(e$1) {
						this._language = e$1, this._update();
					}
					setUnit(e$1) {
						this.options.unit = e$1, this._update();
					}
				},
				FullscreenControl: class {
					constructor(t$1 = {}) {
						this._fullscreen = !1, t$1 && t$1.container && (t$1.container instanceof HTMLElement ? this._container = t$1.container : e.w("Full screen control 'container' must be a DOM element.")), e.aY(["_onClickFullscreen", "_changeIcon"], this), "onfullscreenchange" in document ? this._fullscreenchange = "fullscreenchange" : "onwebkitfullscreenchange" in document && (this._fullscreenchange = "webkitfullscreenchange");
					}
					onAdd(t$1) {
						return this._map = t$1, this._container || (this._container = this._map.getContainer()), this._controlContainer = l("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._checkFullscreenSupport() ? this._setupUI() : (this._controlContainer.style.display = "none", e.w("This device does not support fullscreen mode.")), this._controlContainer;
					}
					onRemove() {
						this._controlContainer.remove(), this._map = null, document.removeEventListener(this._fullscreenchange, this._changeIcon);
					}
					_checkFullscreenSupport() {
						return !(!document.fullscreenEnabled && !document.webkitFullscreenEnabled);
					}
					_setupUI() {
						const e$1 = this._fullscreenButton = l("button", "mapboxgl-ctrl-fullscreen", this._controlContainer);
						l("span", "mapboxgl-ctrl-icon", e$1).setAttribute("aria-hidden", "true"), e$1.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), document.addEventListener(this._fullscreenchange, this._changeIcon);
					}
					_updateTitle() {
						const e$1 = this._getTitle();
						this._fullscreenButton.setAttribute("aria-label", e$1), this._fullscreenButton.firstElementChild && this._fullscreenButton.firstElementChild.setAttribute("title", e$1);
					}
					_getTitle() {
						return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter");
					}
					_isFullscreen() {
						return this._fullscreen;
					}
					_changeIcon() {
						(document.fullscreenElement || document.webkitFullscreenElement) === this._container !== this._fullscreen && (this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("mapboxgl-ctrl-shrink"), this._fullscreenButton.classList.toggle("mapboxgl-ctrl-fullscreen"), this._updateTitle());
					}
					_onClickFullscreen() {
						this._isFullscreen() ? document.exitFullscreen ? document.exitFullscreen() : document.webkitCancelFullScreen && document.webkitCancelFullScreen() : this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.webkitRequestFullscreen && this._container.webkitRequestFullscreen();
					}
				},
				IndoorControl: Ml,
				Popup: class extends e.E {
					constructor(t$1) {
						super(), this.options = Object.assign(Object.create(Jl), t$1), this._altitude = this.options.altitude, e.aY([
							"_update",
							"_onClose",
							"remove",
							"_onMouseEvent"
						], this), this._classList = new Set(t$1 && t$1.className ? t$1.className.trim().split(/\s+/) : []);
					}
					addTo(t$1) {
						return this._map && this.remove(), this._map = t$1, this.options.closeOnClick && t$1.on("preclick", this._onClose), this.options.closeOnMove && t$1.on("move", this._onClose), t$1.on("remove", this.remove), this._update(), t$1._addPopup(this), this._focusFirstElement(), this._trackPointer ? (t$1.on("mousemove", this._onMouseEvent), t$1.on("mouseup", this._onMouseEvent), t$1._canvasContainer.classList.add("mapboxgl-track-pointer")) : t$1.on("move", this._update), this.fire(new e.z("open")), this;
					}
					isOpen() {
						return !!this._map;
					}
					remove() {
						this._content && this._content.remove(), this._container && (this._container.remove(), this._container = void 0);
						const t$1 = this._map;
						return t$1 && (t$1.off("move", this._update), t$1.off("move", this._onClose), t$1.off("preclick", this._onClose), t$1.off("click", this._onClose), t$1.off("remove", this.remove), t$1.off("mousemove", this._onMouseEvent), t$1.off("mouseup", this._onMouseEvent), t$1.off("drag", this._onMouseEvent), t$1._canvasContainer && t$1._canvasContainer.classList.remove("mapboxgl-track-pointer"), t$1._removePopup(this), this._map = void 0), this.fire(new e.z("close")), this;
					}
					getLngLat() {
						return this._lngLat;
					}
					setLngLat(t$1) {
						this._lngLat = e.aT.convert(t$1), this._pos = null, this._trackPointer = !1, this._update();
						const i$1 = this._map;
						return i$1 && (i$1.on("move", this._update), i$1.off("mousemove", this._onMouseEvent), i$1._canvasContainer.classList.remove("mapboxgl-track-pointer")), this;
					}
					getAltitude() {
						return this._altitude;
					}
					setAltitude(e$1) {
						return this._altitude = e$1, this._update(), this;
					}
					trackPointer() {
						this._trackPointer = !0, this._pos = null, this._update();
						const e$1 = this._map;
						return e$1 && (e$1.off("move", this._update), e$1.on("mousemove", this._onMouseEvent), e$1.on("drag", this._onMouseEvent), e$1._canvasContainer.classList.add("mapboxgl-track-pointer")), this;
					}
					getElement() {
						return this._container;
					}
					setText(e$1) {
						return this.setDOMContent(document.createTextNode(e$1));
					}
					setHTML(e$1) {
						const t$1 = document.createDocumentFragment(), i$1 = document.createElement("body");
						let o$1;
						for (i$1.innerHTML = e$1; o$1 = i$1.firstChild, o$1;) t$1.appendChild(o$1);
						return this.setDOMContent(t$1);
					}
					getMaxWidth() {
						return this._container && this._container.style.maxWidth;
					}
					setMaxWidth(e$1) {
						return this.options.maxWidth = e$1, this._update(), this;
					}
					setDOMContent(e$1) {
						let t$1 = this._content;
						if (t$1) for (; t$1.hasChildNodes();) t$1.firstChild && t$1.removeChild(t$1.firstChild);
						else t$1 = this._content = l("div", "mapboxgl-popup-content", this._container || void 0);
						if (t$1.appendChild(e$1), this.options.closeButton) {
							const e$2 = this._closeButton = l("button", "mapboxgl-popup-close-button", t$1);
							e$2.type = "button", e$2.setAttribute("aria-label", "Close popup"), e$2.innerHTML = "<span aria-hidden=\"true\">&#215;</span>", e$2.addEventListener("click", this._onClose);
						}
						return this._update(), this._focusFirstElement(), this;
					}
					addClassName(e$1) {
						return this._classList.add(e$1), this._updateClassList(), this;
					}
					removeClassName(e$1) {
						return this._classList.delete(e$1), this._updateClassList(), this;
					}
					setOffset(e$1) {
						return this.options.offset = e$1, this._update(), this;
					}
					toggleClassName(e$1) {
						let t$1;
						return this._classList.delete(e$1) ? t$1 = !1 : (this._classList.add(e$1), t$1 = !0), this._updateClassList(), t$1;
					}
					_onMouseEvent(e$1) {
						this._update(e$1.point);
					}
					_getAnchor(e$1) {
						if (this.options.anchor) return this.options.anchor;
						const t$1 = this._map, i$1 = this._container, o$1 = this._pos;
						if (!t$1 || !i$1 || !o$1) return "bottom";
						const s$1 = i$1.offsetWidth, r$1 = i$1.offsetHeight, n$1 = o$1.x < s$1 / 2, a$1 = o$1.x > t$1.transform.width - s$1 / 2;
						if (o$1.y + e$1 < r$1) return n$1 ? "top-left" : a$1 ? "top-right" : "top";
						if (o$1.y > t$1.transform.height - r$1) {
							if (n$1) return "bottom-left";
							if (a$1) return "bottom-right";
						}
						return n$1 ? "left" : a$1 ? "right" : "bottom";
					}
					_updateClassList() {
						const e$1 = this._container;
						if (!e$1) return;
						const t$1 = [...this._classList];
						t$1.push("mapboxgl-popup"), this._anchor && t$1.push(`mapboxgl-popup-anchor-${this._anchor}`), this._trackPointer && t$1.push("mapboxgl-popup-track-pointer"), e$1.className = t$1.join(" ");
					}
					_update(t$1) {
						const i$1 = this._map, o$1 = this._content;
						if (!i$1 || !this._lngLat && !this._trackPointer || !o$1) return;
						let s$1 = this._container;
						if (s$1 || (s$1 = this._container = l("div", "mapboxgl-popup", i$1.getContainer()), this._tip = l("div", "mapboxgl-popup-tip", s$1), s$1.appendChild(o$1)), this.options.maxWidth && s$1.style.maxWidth !== this.options.maxWidth && (s$1.style.maxWidth = this.options.maxWidth), i$1.transform.renderWorldCopies && !this._trackPointer && (this._lngLat = ql(this._lngLat, this._pos, i$1.transform)), !this._trackPointer || t$1) {
							const o$2 = this._pos = this._trackPointer && t$1 instanceof e.P ? t$1 : i$1.project(this._lngLat, this._altitude), s$2 = ec(this.options.offset), r$1 = this._anchor = this._getAnchor(s$2.y), n$1 = ec(this.options.offset, r$1), a$1 = o$2.add(n$1).round();
							i$1._requestDomTask((() => {
								this._container && r$1 && (this._container.style.transform = `${Zl[r$1]} translate(${a$1.x}px,${a$1.y}px)`);
							}));
						}
						if (!this._marker && i$1._showingGlobe()) {
							const t$2 = e.f5(i$1.transform, this._lngLat) ? 0 : 1;
							this._setOpacity(t$2);
						}
						this._updateClassList();
					}
					_focusFirstElement() {
						if (!this.options.focusAfterOpen || !this._container) return;
						const e$1 = this._container.querySelector(Ql);
						e$1 && e$1.focus();
					}
					_onClose() {
						this.remove();
					}
					_setOpacity(e$1) {
						this._container && (this._container.style.opacity = `${e$1}`), this._content && (this._content.style.pointerEvents = e$1 ? "auto" : "none");
					}
				},
				Marker: $l,
				Style: Po,
				LngLat: e.aT,
				LngLatBounds: e.aI,
				Point: e.P,
				MercatorCoordinate: e.ae,
				FreeCameraOptions: so,
				Evented: e.E,
				config: e.e,
				prewarm: e.f9,
				clearPrewarmedResources: e.f8,
				get accessToken() {
					return e.e.ACCESS_TOKEN;
				},
				set accessToken(t$1) {
					e.e.ACCESS_TOKEN = t$1;
				},
				get baseApiUrl() {
					return e.e.API_URL;
				},
				set baseApiUrl(t$1) {
					e.e.API_URL = t$1;
				},
				get workerCount() {
					return e.fi.workerCount;
				},
				set workerCount(t$1) {
					e.fi.workerCount = t$1;
				},
				get maxParallelImageRequests() {
					return e.e.MAX_PARALLEL_IMAGE_REQUESTS;
				},
				set maxParallelImageRequests(t$1) {
					e.e.MAX_PARALLEL_IMAGE_REQUESTS = t$1;
				},
				clearStorage(t$1) {
					e.fh(t$1);
				},
				get workerUrl() {
					return e.fg.workerUrl;
				},
				set workerUrl(t$1) {
					e.fg.workerUrl = t$1;
				},
				get workerClass() {
					return e.fg.workerClass;
				},
				set workerClass(t$1) {
					e.fg.workerClass = t$1;
				},
				get workerParams() {
					return e.fg.workerParams;
				},
				set workerParams(t$1) {
					e.fg.workerParams = t$1;
				},
				get dracoUrl() {
					return e.ff();
				},
				set dracoUrl(t$1) {
					e.fe(t$1);
				},
				get meshoptUrl() {
					return e.fd();
				},
				set meshoptUrl(t$1) {
					e.fc(t$1);
				},
				setNow: e.o.setNow,
				restoreNow: e.o.restoreNow
			};
		}));
		return mapboxgl;
	}));
}) });

//#endregion
export default require_mapbox_gl();

//# sourceMappingURL=mapbox-gl.js.map